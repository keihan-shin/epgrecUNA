diff -urN a/epgrec/Smarty/Autoloader.php b/epgrec/Smarty/Autoloader.php
--- a/epgrec/Smarty/Autoloader.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/Autoloader.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,110 @@
+<?php
+/**
+ * Smarty Autoloader
+ *
+ * @package Smarty
+ */
+
+/**
+ * Smarty Autoloader
+ *
+ * @package Smarty
+ * @author  Uwe Tews
+ *             Usage:
+ *                  require_once '...path/Autoloader.php';
+ *                  Smarty_Autoloader::register();
+ *             or
+ *                  include '...path/bootstrap.php';
+ *
+ *                  $smarty = new Smarty();
+ */
+class Smarty_Autoloader
+{
+    /**
+     * Filepath to Smarty root
+     *
+     * @var string
+     */
+    public static $SMARTY_DIR = null;
+
+    /**
+     * Filepath to Smarty internal plugins
+     *
+     * @var string
+     */
+    public static $SMARTY_SYSPLUGINS_DIR = null;
+
+    /**
+     * Array with Smarty core classes and their filename
+     *
+     * @var array
+     */
+    public static $rootClasses = array('smarty' => 'Smarty.class.php', 'smartybc' => 'SmartyBC.class.php',);
+
+    /**
+     * Registers Smarty_Autoloader backward compatible to older installations.
+     *
+     * @param bool $prepend Whether to prepend the autoloader or not.
+     */
+    public static function registerBC($prepend = false)
+    {
+        /**
+         * register the class autoloader
+         */
+        if (!defined('SMARTY_SPL_AUTOLOAD')) {
+            define('SMARTY_SPL_AUTOLOAD', 0);
+        }
+        if (SMARTY_SPL_AUTOLOAD
+            && set_include_path(get_include_path() . PATH_SEPARATOR . SMARTY_SYSPLUGINS_DIR) !== false
+        ) {
+            $registeredAutoLoadFunctions = spl_autoload_functions();
+            if (!isset($registeredAutoLoadFunctions[ 'spl_autoload' ])) {
+                spl_autoload_register();
+            }
+        } else {
+            self::register($prepend);
+        }
+    }
+
+    /**
+     * Registers Smarty_Autoloader as an SPL autoloader.
+     *
+     * @param bool $prepend Whether to prepend the autoloader or not.
+     */
+    public static function register($prepend = false)
+    {
+        self::$SMARTY_DIR = defined('SMARTY_DIR') ? SMARTY_DIR : dirname(__FILE__) . DIRECTORY_SEPARATOR;
+        self::$SMARTY_SYSPLUGINS_DIR = defined('SMARTY_SYSPLUGINS_DIR') ? SMARTY_SYSPLUGINS_DIR :
+            self::$SMARTY_DIR . 'sysplugins' . DIRECTORY_SEPARATOR;
+        if (version_compare(PHP_VERSION, '5.3.0', '>=')) {
+            spl_autoload_register(array(__CLASS__, 'autoload'), true, $prepend);
+        } else {
+            spl_autoload_register(array(__CLASS__, 'autoload'));
+        }
+    }
+
+    /**
+     * Handles auto loading of classes.
+     *
+     * @param string $class A class name.
+     */
+    public static function autoload($class)
+    {
+        if ($class[ 0 ] !== 'S' || strpos($class, 'Smarty') !== 0) {
+            return;
+        }
+        $_class = strtolower($class);
+        if (isset(self::$rootClasses[ $_class ])) {
+            $file = self::$SMARTY_DIR . self::$rootClasses[ $_class ];
+            if (is_file($file)) {
+                include $file;
+            }
+        } else {
+            $file = self::$SMARTY_SYSPLUGINS_DIR . $_class . '.php';
+            if (is_file($file)) {
+                include $file;
+            }
+        }
+        return;
+    }
+}
diff -urN a/epgrec/Smarty/Config_File.class.php b/epgrec/Smarty/Config_File.class.php
--- a/epgrec/Smarty/Config_File.class.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/Config_File.class.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,393 +0,0 @@
-<?php
-
-/**
- * Config_File class.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * For questions, help, comments, discussion, etc., please join the
- * Smarty mailing list. Send a blank e-mail to
- * smarty-discussion-subscribe@googlegroups.com 
- *
- * @link http://www.smarty.net/
- * @version 2.6.25-dev
- * @copyright Copyright: 2001-2005 New Digital Group, Inc.
- * @author Andrei Zmievski <andrei@php.net>
- * @access public
- * @package Smarty
- */
-
-/* $Id$ */
-
-/**
- * Config file reading class
- * @package Smarty
- */
-class Config_File {
-    /**#@+
-     * Options
-     * @var boolean
-     */
-    /**
-     * Controls whether variables with the same name overwrite each other.
-     */
-    var $overwrite        =    true;
-
-    /**
-     * Controls whether config values of on/true/yes and off/false/no get
-     * converted to boolean values automatically.
-     */
-    var $booleanize        =    true;
-
-    /**
-     * Controls whether hidden config sections/vars are read from the file.
-     */
-    var $read_hidden     =    true;
-
-    /**
-     * Controls whether or not to fix mac or dos formatted newlines.
-     * If set to true, \r or \r\n will be changed to \n.
-     */
-    var $fix_newlines =    true;
-    /**#@-*/
-
-    /** @access private */
-    var $_config_path    = "";
-    var $_config_data    = array();
-    /**#@-*/
-
-    /**
-     * Constructs a new config file class.
-     *
-     * @param string $config_path (optional) path to the config files
-     */
-    public function __construct($config_path = NULL)
-    {
-        if (isset($config_path))
-            $this->set_path($config_path);
-    }
-
-
-    /**
-     * Set the path where configuration files can be found.
-     *
-     * @param string $config_path path to the config files
-     */
-    function set_path($config_path)
-    {
-        if (!empty($config_path)) {
-            if (!is_string($config_path) || !file_exists($config_path) || !is_dir($config_path)) {
-                $this->_trigger_error_msg("Bad config file path '$config_path'");
-                return;
-            }
-            if(substr($config_path, -1) != DIRECTORY_SEPARATOR) {
-                $config_path .= DIRECTORY_SEPARATOR;
-            }
-
-            $this->_config_path = $config_path;
-        }
-    }
-
-
-    /**
-     * Retrieves config info based on the file, section, and variable name.
-     *
-     * @param string $file_name config file to get info for
-     * @param string $section_name (optional) section to get info for
-     * @param string $var_name (optional) variable to get info for
-     * @return string|array a value or array of values
-     */
-    function get($file_name, $section_name = NULL, $var_name = NULL)
-    {
-        if (empty($file_name)) {
-            $this->_trigger_error_msg('Empty config file name');
-            return;
-        } else {
-            $file_name = $this->_config_path . $file_name;
-            if (!isset($this->_config_data[$file_name]))
-                $this->load_file($file_name, false);
-        }
-
-        if (!empty($var_name)) {
-            if (empty($section_name)) {
-                return $this->_config_data[$file_name]["vars"][$var_name];
-            } else {
-                if(isset($this->_config_data[$file_name]["sections"][$section_name]["vars"][$var_name]))
-                    return $this->_config_data[$file_name]["sections"][$section_name]["vars"][$var_name];
-                else
-                    return array();
-            }
-        } else {
-            if (empty($section_name)) {
-                return (array)$this->_config_data[$file_name]["vars"];
-            } else {
-                if(isset($this->_config_data[$file_name]["sections"][$section_name]["vars"]))
-                    return (array)$this->_config_data[$file_name]["sections"][$section_name]["vars"];
-                else
-                    return array();
-            }
-        }
-    }
-
-
-    /**
-     * Retrieves config info based on the key.
-     *
-     * @param $file_name string config key (filename/section/var)
-     * @return string|array same as get()
-     * @uses get() retrieves information from config file and returns it
-     */
-    function &get_key($config_key)
-    {
-        list($file_name, $section_name, $var_name) = explode('/', $config_key, 3);
-        $result = &$this->get($file_name, $section_name, $var_name);
-        return $result;
-    }
-
-    /**
-     * Get all loaded config file names.
-     *
-     * @return array an array of loaded config file names
-     */
-    function get_file_names()
-    {
-        return array_keys($this->_config_data);
-    }
-
-
-    /**
-     * Get all section names from a loaded file.
-     *
-     * @param string $file_name config file to get section names from
-     * @return array an array of section names from the specified file
-     */
-    function get_section_names($file_name)
-    {
-        $file_name = $this->_config_path . $file_name;
-        if (!isset($this->_config_data[$file_name])) {
-            $this->_trigger_error_msg("Unknown config file '$file_name'");
-            return;
-        }
-
-        return array_keys($this->_config_data[$file_name]["sections"]);
-    }
-
-
-    /**
-     * Get all global or section variable names.
-     *
-     * @param string $file_name config file to get info for
-     * @param string $section_name (optional) section to get info for
-     * @return array an array of variables names from the specified file/section
-     */
-    function get_var_names($file_name, $section = NULL)
-    {
-        if (empty($file_name)) {
-            $this->_trigger_error_msg('Empty config file name');
-            return;
-        } else if (!isset($this->_config_data[$file_name])) {
-            $this->_trigger_error_msg("Unknown config file '$file_name'");
-            return;
-        }
-
-        if (empty($section))
-            return array_keys($this->_config_data[$file_name]["vars"]);
-        else
-            return array_keys($this->_config_data[$file_name]["sections"][$section]["vars"]);
-    }
-
-
-    /**
-     * Clear loaded config data for a certain file or all files.
-     *
-     * @param string $file_name file to clear config data for
-     */
-    function clear($file_name = NULL)
-    {
-        if ($file_name === NULL)
-            $this->_config_data = array();
-        else if (isset($this->_config_data[$file_name]))
-            $this->_config_data[$file_name] = array();
-    }
-
-
-    /**
-     * Load a configuration file manually.
-     *
-     * @param string $file_name file name to load
-     * @param boolean $prepend_path whether current config path should be
-     *                              prepended to the filename
-     */
-    function load_file($file_name, $prepend_path = true)
-    {
-        if ($prepend_path && $this->_config_path != "")
-            $config_file = $this->_config_path . $file_name;
-        else
-            $config_file = $file_name;
-
-        ini_set('track_errors', true);
-        $fp = @fopen($config_file, "r");
-        if (!is_resource($fp)) {
-            $this->_trigger_error_msg("Could not open config file '$config_file'");
-            return false;
-        }
-
-        $contents = ($size = filesize($config_file)) ? fread($fp, $size) : '';
-        fclose($fp);
-
-        $this->_config_data[$config_file] = $this->parse_contents($contents);
-        return true;
-    }
-
-    /**
-     * Store the contents of a file manually.
-     *
-     * @param string $config_file file name of the related contents
-     * @param string $contents the file-contents to parse
-     */
-    function set_file_contents($config_file, $contents)
-    {
-        $this->_config_data[$config_file] = $this->parse_contents($contents);
-        return true;
-    }
-
-    /**
-     * parse the source of a configuration file manually.
-     *
-     * @param string $contents the file-contents to parse
-     */
-    function parse_contents($contents)
-    {
-        if($this->fix_newlines) {
-            // fix mac/dos formatted newlines
-            $contents = preg_replace('!\r\n?!', "\n", $contents);
-        }
-
-        $config_data = array();
-        $config_data['sections'] = array();
-        $config_data['vars'] = array();
-
-        /* reference to fill with data */
-        $vars =& $config_data['vars'];
-
-        /* parse file line by line */
-        preg_match_all('!^.*\r?\n?!m', $contents, $match);
-        $lines = $match[0];
-        for ($i=0, $count=count($lines); $i<$count; $i++) {
-            $line = $lines[$i];
-            if (empty($line)) continue;
-
-            if ( substr($line, 0, 1) == '[' && preg_match('!^\[(.*?)\]!', $line, $match) ) {
-                /* section found */
-                if (substr($match[1], 0, 1) == '.') {
-                    /* hidden section */
-                    if ($this->read_hidden) {
-                        $section_name = substr($match[1], 1);
-                    } else {
-                        /* break reference to $vars to ignore hidden section */
-                        unset($vars);
-                        $vars = array();
-                        continue;
-                    }
-                } else {                    
-                    $section_name = $match[1];
-                }
-                if (!isset($config_data['sections'][$section_name]))
-                    $config_data['sections'][$section_name] = array('vars' => array());
-                $vars =& $config_data['sections'][$section_name]['vars'];
-                continue;
-            }
-
-            if (preg_match('/^\s*(\.?\w+)\s*=\s*(.*)/s', $line, $match)) {
-                /* variable found */
-                $var_name = rtrim($match[1]);
-                if (strpos($match[2], '"""') === 0) {
-                    /* handle multiline-value */
-                    $lines[$i] = substr($match[2], 3);
-                    $var_value = '';
-                    while ($i<$count) {
-                        if (($pos = strpos($lines[$i], '"""')) === false) {
-                            $var_value .= $lines[$i++];
-                        } else {
-                            /* end of multiline-value */
-                            $var_value .= substr($lines[$i], 0, $pos);
-                            break;
-                        }
-                    }
-                    $booleanize = false;
-
-                } else {
-                    /* handle simple value */
-                    $var_value = preg_replace('/^([\'"])(.*)\1$/', '\2', rtrim($match[2]));
-                    $booleanize = $this->booleanize;
-
-                }
-                $this->_set_config_var($vars, $var_name, $var_value, $booleanize);
-            }
-            /* else unparsable line / means it is a comment / means ignore it */
-        }
-        return $config_data;
-    }
-
-    /**#@+ @access private */
-    /**
-     * @param array &$container
-     * @param string $var_name
-     * @param mixed $var_value
-     * @param boolean $booleanize determines whether $var_value is converted to
-     *                            to true/false
-     */
-    function _set_config_var(&$container, $var_name, $var_value, $booleanize)
-    {
-        if (substr($var_name, 0, 1) == '.') {
-            if (!$this->read_hidden)
-                return;
-            else
-                $var_name = substr($var_name, 1);
-        }
-
-        if (!preg_match("/^[a-zA-Z_]\w*$/", $var_name)) {
-            $this->_trigger_error_msg("Bad variable name '$var_name'");
-            return;
-        }
-
-        if ($booleanize) {
-            if (preg_match("/^(on|true|yes)$/i", $var_value))
-                $var_value = true;
-            else if (preg_match("/^(off|false|no)$/i", $var_value))
-                $var_value = false;
-        }
-
-        if (!isset($container[$var_name]) || $this->overwrite)
-            $container[$var_name] = $var_value;
-        else {
-            settype($container[$var_name], 'array');
-            $container[$var_name][] = $var_value;
-        }
-    }
-
-    /**
-     * @uses trigger_error() creates a PHP warning/error
-     * @param string $error_msg
-     * @param integer $error_type one of
-     */
-    function _trigger_error_msg($error_msg, $error_type = E_USER_WARNING)
-    {
-        trigger_error("Config_File error: $error_msg", $error_type);
-    }
-    /**#@-*/
-}
-
-?>
diff -urN a/epgrec/Smarty/Smarty.class.php b/epgrec/Smarty/Smarty.class.php
--- a/epgrec/Smarty/Smarty.class.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/Smarty.class.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,5 +1,4 @@
 <?php
-
 /**
  * Project:     Smarty: the PHP compiling template engine
  * File:        Smarty.class.php
@@ -7,7 +6,7 @@
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
+ * version 3.0 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -17,1946 +16,1409 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  * For questions, help, comments, discussion, etc., please join the
  * Smarty mailing list. Send a blank e-mail to
  * smarty-discussion-subscribe@googlegroups.com
  *
- * @link http://www.smarty.net/
- * @copyright 2001-2005 New Digital Group, Inc.
- * @author Monte Ohrt <monte at ohrt dot com>
- * @author Andrei Zmievski <andrei@php.net>
- * @package Smarty
- * @version 2.6.29
- */
-
-/* $Id$ */
-
-/**
- * DIR_SEP isn't used anymore, but third party apps might
+ * @link      http://www.smarty.net/
+ * @copyright 2018 New Digital Group, Inc.
+ * @copyright 2018 Uwe Tews
+ * @author    Monte Ohrt <monte at ohrt dot com>
+ * @author    Uwe Tews   <uwe dot tews at gmail dot com>
+ * @author    Rodney Rehm
+ * @package   Smarty
  */
-if(!defined('DIR_SEP')) {
-    define('DIR_SEP', DIRECTORY_SEPARATOR);
-}
-
 /**
  * set SMARTY_DIR to absolute path to Smarty library files.
- * if not defined, include_path will be used. Sets SMARTY_DIR only if user
- * application has not already defined it.
+ * Sets SMARTY_DIR only if user application has not already defined it.
  */
-
 if (!defined('SMARTY_DIR')) {
+    /**
+     *
+     */
     define('SMARTY_DIR', dirname(__FILE__) . DIRECTORY_SEPARATOR);
 }
-
-if (!defined('SMARTY_CORE_DIR')) {
-    define('SMARTY_CORE_DIR', SMARTY_DIR . 'internals' . DIRECTORY_SEPARATOR);
+/**
+ * set SMARTY_SYSPLUGINS_DIR to absolute path to Smarty internal plugins.
+ * Sets SMARTY_SYSPLUGINS_DIR only if user application has not already defined it.
+ */
+if (!defined('SMARTY_SYSPLUGINS_DIR')) {
+    /**
+     *
+     */
+    define('SMARTY_SYSPLUGINS_DIR', SMARTY_DIR . 'sysplugins' . DIRECTORY_SEPARATOR);
 }
-
-define('SMARTY_PHP_PASSTHRU',   0);
-define('SMARTY_PHP_QUOTE',      1);
-define('SMARTY_PHP_REMOVE',     2);
-define('SMARTY_PHP_ALLOW',      3);
+if (!defined('SMARTY_PLUGINS_DIR')) {
+    /**
+     *
+     */
+    define('SMARTY_PLUGINS_DIR', SMARTY_DIR . 'plugins' . DIRECTORY_SEPARATOR);
+}
+if (!defined('SMARTY_MBSTRING')) {
+    /**
+     *
+     */
+    define('SMARTY_MBSTRING', function_exists('mb_get_info'));
+}
+if (!defined('SMARTY_RESOURCE_CHAR_SET')) {
+    // UTF-8 can only be done properly when mbstring is available!
+    /**
+     * @deprecated in favor of Smarty::$_CHARSET
+     */
+    define('SMARTY_RESOURCE_CHAR_SET', SMARTY_MBSTRING ? 'UTF-8' : 'ISO-8859-1');
+}
+if (!defined('SMARTY_RESOURCE_DATE_FORMAT')) {
+    /**
+     * @deprecated in favor of Smarty::$_DATE_FORMAT
+     */
+    define('SMARTY_RESOURCE_DATE_FORMAT', '%b %e, %Y');
+}
+/**
+ * Load Smarty_Autoloader
+ */
+if (!class_exists('Smarty_Autoloader')) {
+    include dirname(__FILE__) . '/bootstrap.php';
+}
+/**
+ * Load always needed external class files
+ */
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_internal_data.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_internal_extension_handler.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_internal_templatebase.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_internal_template.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_resource.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_variable.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_template_source.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_template_resource_base.php';
+require_once SMARTY_SYSPLUGINS_DIR . 'smarty_internal_resource_file.php';
 
 /**
+ * This is the main Smarty class
+ *
  * @package Smarty
+ *
+ * The following methods will be dynamically loaded by the extension handler when they are called.
+ * They are located in a corresponding Smarty_Internal_Method_xxxx class
+ *
+ * @method int clearAllCache(int $exp_time = null, string $type = null)
+ * @method int clearCache(string $template_name, string $cache_id = null, string $compile_id = null, int $exp_time = null, string $type = null)
+ * @method int compileAllTemplates(string $extension = '.tpl', bool $force_compile = false, int $time_limit = 0, $max_errors = null)
+ * @method int compileAllConfig(string $extension = '.conf', bool $force_compile = false, int $time_limit = 0, $max_errors = null)
+ * @method int clearCompiledTemplate($resource_name = null, $compile_id = null, $exp_time = null)
  */
-class Smarty
+class Smarty extends Smarty_Internal_TemplateBase
 {
-    /**#@+
-     * Smarty Configuration Section
+    /**
+     * smarty version
      */
-
+    const SMARTY_VERSION = '3.1.47';
     /**
-     * The name of the directory where templates are located.
-     *
-     * @var string
+     * define variable scopes
      */
-    var $template_dir    =  'templates';
-
+    const SCOPE_LOCAL    = 1;
+    const SCOPE_PARENT   = 2;
+    const SCOPE_TPL_ROOT = 4;
+    const SCOPE_ROOT     = 8;
+    const SCOPE_SMARTY   = 16;
+    const SCOPE_GLOBAL   = 32;
     /**
-     * The directory where compiled templates are located.
-     *
-     * @var string
+     * define caching modes
+     */
+    const CACHING_OFF              = 0;
+    const CACHING_LIFETIME_CURRENT = 1;
+    const CACHING_LIFETIME_SAVED   = 2;
+    /**
+     * define constant for clearing cache files be saved expiration dates
+     */
+    const CLEAR_EXPIRED = -1;
+    /**
+     * define compile check modes
+     */
+    const COMPILECHECK_OFF       = 0;
+    const COMPILECHECK_ON        = 1;
+    const COMPILECHECK_CACHEMISS = 2;
+    /**
+     * define debug modes
+     */
+    const DEBUG_OFF        = 0;
+    const DEBUG_ON         = 1;
+    const DEBUG_INDIVIDUAL = 2;
+    /**
+     * modes for handling of "<?php ... ?>" tags in templates.
+     */
+    const PHP_PASSTHRU = 0; //-> print tags as plain text
+    const PHP_QUOTE    = 1; //-> escape tags as entities
+    const PHP_REMOVE   = 2; //-> escape tags as entities
+    const PHP_ALLOW    = 3; //-> escape tags as entities
+    /**
+     * filter types
+     */
+    const FILTER_POST     = 'post';
+    const FILTER_PRE      = 'pre';
+    const FILTER_OUTPUT   = 'output';
+    const FILTER_VARIABLE = 'variable';
+    /**
+     * plugin types
      */
-    var $compile_dir     =  'templates_c';
+    const PLUGIN_FUNCTION         = 'function';
+    const PLUGIN_BLOCK            = 'block';
+    const PLUGIN_COMPILER         = 'compiler';
+    const PLUGIN_MODIFIER         = 'modifier';
+    const PLUGIN_MODIFIERCOMPILER = 'modifiercompiler';
 
     /**
-     * The directory where config files are located.
-     *
-     * @var string
+     * assigned global tpl vars
      */
-    var $config_dir      =  'configs';
+    public static $global_tpl_vars = array();
 
     /**
-     * An array of directories searched for plugins.
-     *
-     * @var array
+     * Flag denoting if Multibyte String functions are available
      */
-    var $plugins_dir     =  array('plugins');
+    public static $_MBSTRING = SMARTY_MBSTRING;
 
     /**
-     * If debugging is enabled, a debug console window will display
-     * when the page loads (make sure your browser allows unrequested
-     * popup windows)
-     *
-     * @var boolean
+     * The character set to adhere to (e.g. "UTF-8")
      */
-    var $debugging       =  false;
+    public static $_CHARSET = SMARTY_RESOURCE_CHAR_SET;
 
     /**
-     * When set, smarty does uses this value as error_reporting-level.
-     *
-     * @var integer
+     * The date format to be used internally
+     * (accepts date() and strftime())
      */
-    var $error_reporting  =  null;
+    public static $_DATE_FORMAT = SMARTY_RESOURCE_DATE_FORMAT;
 
     /**
-     * This is the path to the debug console template. If not set,
-     * the default one will be used.
-     *
-     * @var string
+     * Flag denoting if PCRE should run in UTF-8 mode
      */
-    var $debug_tpl       =  '';
+    public static $_UTF8_MODIFIER = 'u';
 
     /**
-     * This determines if debugging is enable-able from the browser.
-     * <ul>
-     *  <li>NONE => no debugging control allowed</li>
-     *  <li>URL => enable debugging when SMARTY_DEBUG is found in the URL.</li>
-     * </ul>
-     * @link http://www.foo.dom/index.php?SMARTY_DEBUG
-     * @var string
+     * Flag denoting if operating system is windows
      */
-    var $debugging_ctrl  =  'NONE';
+    public static $_IS_WINDOWS = false;
 
     /**
-     * This tells Smarty whether to check for recompiling or not. Recompiling
-     * does not need to happen unless a template or config file is changed.
-     * Typically you enable this during development, and disable for
-     * production.
+     * auto literal on delimiters with whitespace
      *
      * @var boolean
      */
-    var $compile_check   =  true;
+    public $auto_literal = true;
 
     /**
-     * This forces templates to compile every time. Useful for development
-     * or debugging.
+     * display error on not assigned variables
      *
      * @var boolean
      */
-    var $force_compile   =  false;
+    public $error_unassigned = false;
 
     /**
-     * This enables template caching.
-     * <ul>
-     *  <li>0 = no caching</li>
-     *  <li>1 = use class cache_lifetime value</li>
-     *  <li>2 = use cache_lifetime in cache file</li>
-     * </ul>
-     * @var integer
+     * look up relative file path in include_path
+     *
+     * @var boolean
      */
-    var $caching         =  0;
+    public $use_include_path = false;
 
     /**
-     * The name of the directory for cache files.
+     * flag if template_dir is normalized
      *
-     * @var string
+     * @var bool
      */
-    var $cache_dir       =  'cache';
+    public $_templateDirNormalized = false;
 
     /**
-     * This is the number of seconds cached content will persist.
-     * <ul>
-     *  <li>0 = always regenerate cache</li>
-     *  <li>-1 = never expires</li>
-     * </ul>
+     * joined template directory string used in cache keys
      *
-     * @var integer
+     * @var string
      */
-    var $cache_lifetime  =  3600;
+    public $_joined_template_dir = null;
 
     /**
-     * Only used when $caching is enabled. If true, then If-Modified-Since headers
-     * are respected with cached content, and appropriate HTTP headers are sent.
-     * This way repeated hits to a cached page do not send the entire page to the
-     * client every time.
+     * flag if config_dir is normalized
      *
-     * @var boolean
+     * @var bool
      */
-    var $cache_modified_check = false;
+    public $_configDirNormalized = false;
 
     /**
-     * This determines how Smarty handles "<?php ... ?>" tags in templates.
-     * possible values:
-     * <ul>
-     *  <li>SMARTY_PHP_PASSTHRU -> print tags as plain text</li>
-     *  <li>SMARTY_PHP_QUOTE    -> escape tags as entities</li>
-     *  <li>SMARTY_PHP_REMOVE   -> remove php tags</li>
-     *  <li>SMARTY_PHP_ALLOW    -> execute php tags</li>
-     * </ul>
+     * joined config directory string used in cache keys
      *
-     * @var integer
+     * @var string
      */
-    var $php_handling    =  SMARTY_PHP_PASSTHRU;
+    public $_joined_config_dir = null;
 
     /**
-     * This enables template security. When enabled, many things are restricted
-     * in the templates that normally would go unchecked. This is useful when
-     * untrusted parties are editing templates and you want a reasonable level
-     * of security. (no direct execution of PHP in templates for example)
+     * default template handler
      *
-     * @var boolean
+     * @var callable
      */
-    var $security       =   false;
+    public $default_template_handler_func = null;
 
     /**
-     * This is the list of template directories that are considered secure. This
-     * is used only if {@link $security} is enabled. One directory per array
-     * element.  {@link $template_dir} is in this list implicitly.
+     * default config handler
      *
-     * @var array
+     * @var callable
      */
-    var $secure_dir     =   array();
+    public $default_config_handler_func = null;
 
     /**
-     * These are the security settings for Smarty. They are used only when
-     * {@link $security} is enabled.
+     * default plugin handler
      *
-     * @var array
+     * @var callable
      */
-    var $security_settings  = array(
-                                    'PHP_HANDLING'    => false,
-                                    'IF_FUNCS'        => array('array', 'list',
-                                                               'isset', 'empty',
-                                                               'count', 'sizeof',
-                                                               'in_array', 'is_array',
-                                                               'true', 'false', 'null'),
-                                    'INCLUDE_ANY'     => false,
-                                    'PHP_TAGS'        => false,
-                                    'MODIFIER_FUNCS'  => array('count'),
-                                    'ALLOW_CONSTANTS'  => false,
-                                    'ALLOW_SUPER_GLOBALS' => true
-                                   );
+    public $default_plugin_handler_func = null;
 
     /**
-     * This is an array of directories where trusted php scripts reside.
-     * {@link $security} is disabled during their inclusion/execution.
+     * flag if template_dir is normalized
      *
-     * @var array
+     * @var bool
      */
-    var $trusted_dir        = array();
+    public $_compileDirNormalized = false;
 
     /**
-     * The left delimiter used for the template tags.
+     * flag if plugins_dir is normalized
      *
-     * @var string
+     * @var bool
      */
-    var $left_delimiter  =  '{';
+    public $_pluginsDirNormalized = false;
 
     /**
-     * The right delimiter used for the template tags.
+     * flag if template_dir is normalized
      *
-     * @var string
+     * @var bool
      */
-    var $right_delimiter =  '}';
+    public $_cacheDirNormalized = false;
 
     /**
-     * The order in which request variables are registered, similar to
-     * variables_order in php.ini E = Environment, G = GET, P = POST,
-     * C = Cookies, S = Server
+     * force template compiling?
      *
-     * @var string
+     * @var boolean
      */
-    var $request_vars_order    = 'EGPCS';
+    public $force_compile = false;
 
     /**
-     * Indicates wether $HTTP_*_VARS[] (request_use_auto_globals=false)
-     * are uses as request-vars or $_*[]-vars. note: if
-     * request_use_auto_globals is true, then $request_vars_order has
-     * no effect, but the php-ini-value "gpc_order"
+     * use sub dirs for compiled/cached files?
      *
      * @var boolean
      */
-    var $request_use_auto_globals      = true;
+    public $use_sub_dirs = false;
 
     /**
-     * Set this if you want different sets of compiled files for the same
-     * templates. This is useful for things like different languages.
-     * Instead of creating separate sets of templates per language, you
-     * set different compile_ids like 'en' and 'de'.
+     * allow ambiguous resources (that are made unique by the resource handler)
      *
-     * @var string
+     * @var boolean
      */
-    var $compile_id            = null;
+    public $allow_ambiguous_resources = false;
 
     /**
-     * This tells Smarty whether or not to use sub dirs in the cache/ and
-     * templates_c/ directories. sub directories better organized, but
-     * may not work well with PHP safe mode enabled.
+     * merge compiled includes
      *
      * @var boolean
-     *
      */
-    var $use_sub_dirs          = false;
+    public $merge_compiled_includes = false;
+
+    /*
+    * flag for behaviour when extends: resource  and {extends} tag are used simultaneous
+    *   if false disable execution of {extends} in templates called by extends resource.
+    *   (behaviour as versions < 3.1.28)
+    *
+    * @var boolean
+    */
+    public $extends_recursion = true;
 
     /**
-     * This is a list of the modifiers to apply to all template variables.
-     * Put each modifier in a separate array element in the order you want
-     * them applied. example: <code>array('escape:"htmlall"');</code>
+     * force cache file creation
      *
-     * @var array
+     * @var boolean
      */
-    var $default_modifiers        = array();
+    public $force_cache = false;
 
     /**
-     * This is the resource type to be used when not specified
-     * at the beginning of the resource path. examples:
-     * $smarty->display('file:index.tpl');
-     * $smarty->display('db:index.tpl');
-     * $smarty->display('index.tpl'); // will use default resource type
-     * {include file="file:index.tpl"}
-     * {include file="db:index.tpl"}
-     * {include file="index.tpl"} {* will use default resource type *}
+     * template left-delimiter
      *
-     * @var array
+     * @var string
      */
-    var $default_resource_type    = 'file';
+    public $left_delimiter = "{";
 
     /**
-     * The function used for cache file handling. If not set, built-in caching is used.
+     * template right-delimiter
      *
-     * @var null|string function name
+     * @var string
      */
-    var $cache_handler_func   = null;
+    public $right_delimiter = "}";
 
     /**
-     * This indicates which filters are automatically loaded into Smarty.
+     * array of strings which shall be treated as literal by compiler
      *
-     * @var array array of filter names
+     * @var array string
      */
-    var $autoload_filters = array();
+    public $literals = array();
 
-    /**#@+
-     * @var boolean
-     */
     /**
-     * This tells if config file vars of the same name overwrite each other or not.
-     * if disabled, same name variables are accumulated in an array.
+     * class name
+     * This should be instance of Smarty_Security.
+     *
+     * @var string
+     * @see Smarty_Security
      */
-    var $config_overwrite = true;
+    public $security_class = 'Smarty_Security';
 
     /**
-     * This tells whether or not to automatically booleanize config file variables.
-     * If enabled, then the strings "on", "true", and "yes" are treated as boolean
-     * true, and "off", "false" and "no" are treated as boolean false.
+     * implementation of security class
+     *
+     * @var Smarty_Security
      */
-    var $config_booleanize = true;
+    public $security_policy = null;
 
     /**
-     * This tells whether hidden sections [.foobar] are readable from the
-     * tempalates or not. Normally you would never allow this since that is
-     * the point behind hidden sections: the application can access them, but
-     * the templates cannot.
+     * controls handling of PHP-blocks
+     *
+     * @var integer
      */
-    var $config_read_hidden = false;
+    public $php_handling = self::PHP_PASSTHRU;
 
     /**
-     * This tells whether or not automatically fix newlines in config files.
-     * It basically converts \r (mac) or \r\n (dos) to \n
+     * controls if the php template file resource is allowed
+     *
+     * @var bool
      */
-    var $config_fix_newlines = true;
-    /**#@-*/
+    public $allow_php_templates = false;
 
     /**
-     * If a template cannot be found, this PHP function will be executed.
-     * Useful for creating templates on-the-fly or other special action.
+     * debug mode
+     * Setting this to true enables the debug-console.
      *
-     * @var string function name
+     * @var boolean
      */
-    var $default_template_handler_func = '';
+    public $debugging = false;
 
     /**
-     * The file that contains the compiler class. This can a full
-     * pathname, or relative to the php_include path.
+     * This determines if debugging is enable-able from the browser.
+     * <ul>
+     *  <li>NONE => no debugging control allowed</li>
+     *  <li>URL => enable debugging when SMARTY_DEBUG is found in the URL.</li>
+     * </ul>
      *
      * @var string
      */
-    var $compiler_file        =    'Smarty_Compiler.class.php';
+    public $debugging_ctrl = 'NONE';
 
     /**
-     * The class used for compiling templates.
+     * Name of debugging URL-param.
+     * Only used when $debugging_ctrl is set to 'URL'.
+     * The name of the URL-parameter that activates debugging.
      *
      * @var string
      */
-    var $compiler_class        =   'Smarty_Compiler';
+    public $smarty_debug_id = 'SMARTY_DEBUG';
 
     /**
-     * The class used to load config vars.
+     * Path of debug template.
      *
      * @var string
      */
-    var $config_class          =   'Config_File';
+    public $debug_tpl = null;
 
-/**#@+
- * END Smarty Configuration Section
- * There should be no need to touch anything below this line.
- * @access private
- */
     /**
-     * where assigned template vars are kept
+     * When set, smarty uses this value as error_reporting-level.
      *
-     * @var array
+     * @var int
      */
-    var $_tpl_vars             = array();
+    public $error_reporting = null;
 
     /**
-     * stores run-time $smarty.* vars
+     * Controls whether variables with the same name overwrite each other.
      *
-     * @var null|array
+     * @var boolean
      */
-    var $_smarty_vars          = null;
+    public $config_overwrite = true;
 
     /**
-     * keeps track of sections
+     * Controls whether config values of on/true/yes and off/false/no get converted to boolean.
      *
-     * @var array
+     * @var boolean
      */
-    var $_sections             = array();
+    public $config_booleanize = true;
 
     /**
-     * keeps track of foreach blocks
+     * Controls whether hidden config sections/vars are read from the file.
      *
-     * @var array
+     * @var boolean
      */
-    var $_foreach              = array();
+    public $config_read_hidden = false;
 
     /**
-     * keeps track of tag hierarchy
+     * locking concurrent compiles
      *
-     * @var array
+     * @var boolean
      */
-    var $_tag_stack            = array();
+    public $compile_locking = true;
 
     /**
-     * configuration object
+     * Controls whether cache resources should use locking mechanism
      *
-     * @var Config_file
+     * @var boolean
      */
-    var $_conf_obj             = null;
+    public $cache_locking = false;
 
     /**
-     * loaded configuration settings
+     * seconds to wait for acquiring a lock before ignoring the write lock
      *
-     * @var array
+     * @var float
      */
-    var $_config               = array(array('vars'  => array(), 'files' => array()));
+    public $locking_timeout = 10;
 
     /**
-     * md5 checksum of the string 'Smarty'
+     * resource type used if none given
+     * Must be an valid key of $registered_resources.
      *
      * @var string
      */
-    var $_smarty_md5           = 'f8d698aea36fcbead2b9d5359ffca76f';
+    public $default_resource_type = 'file';
 
     /**
-     * Smarty version number
+     * caching type
+     * Must be an element of $cache_resource_types.
      *
      * @var string
      */
-    var $_version              = '2.6.29';
+    public $caching_type = 'file';
 
     /**
-     * current template inclusion depth
+     * config type
      *
-     * @var integer
+     * @var string
      */
-    var $_inclusion_depth      = 0;
+    public $default_config_type = 'file';
 
     /**
-     * for different compiled templates
+     * check If-Modified-Since headers
      *
-     * @var string
+     * @var boolean
      */
-    var $_compile_id           = null;
+    public $cache_modified_check = false;
 
     /**
-     * text in URL to enable debug mode
+     * registered plugins
      *
-     * @var string
+     * @var array
      */
-    var $_smarty_debug_id      = 'SMARTY_DEBUG';
+    public $registered_plugins = array();
 
     /**
-     * debugging information for debug console
+     * registered objects
      *
      * @var array
      */
-    var $_smarty_debug_info    = array();
+    public $registered_objects = array();
 
     /**
-     * info that makes up a cache file
+     * registered classes
      *
      * @var array
      */
-    var $_cache_info           = array();
+    public $registered_classes = array();
 
     /**
-     * default file permissions
+     * registered filters
      *
-     * @var integer
+     * @var array
      */
-    var $_file_perms           = 0644;
+    public $registered_filters = array();
 
     /**
-     * default dir permissions
+     * registered resources
      *
-     * @var integer
+     * @var array
      */
-    var $_dir_perms               = 0771;
+    public $registered_resources = array();
 
     /**
-     * registered objects
+     * registered cache resources
      *
      * @var array
      */
-    var $_reg_objects           = array();
+    public $registered_cache_resources = array();
 
     /**
-     * table keeping track of plugins
+     * autoload filter
      *
      * @var array
      */
-    var $_plugins              = array(
-                                       'modifier'      => array(),
-                                       'function'      => array(),
-                                       'block'         => array(),
-                                       'compiler'      => array(),
-                                       'prefilter'     => array(),
-                                       'postfilter'    => array(),
-                                       'outputfilter'  => array(),
-                                       'resource'      => array(),
-                                       'insert'        => array());
-
+    public $autoload_filters = array();
 
     /**
-     * cache serials
+     * default modifier
      *
      * @var array
      */
-    var $_cache_serials = array();
+    public $default_modifiers = array();
 
     /**
-     * name of optional cache include file
+     * autoescape variable output
      *
-     * @var string
+     * @var boolean
      */
-    var $_cache_include = null;
+    public $escape_html = false;
 
     /**
-     * indicate if the current code is used in a compiled
-     * include
+     * start time for execution time calculation
      *
-     * @var string
+     * @var int
      */
-    var $_cache_including = false;
+    public $start_time = 0;
 
-    /**#@-*/
     /**
-     * The class constructor.
+     * required by the compiler for BC
+     *
+     * @var string
      */
-    public function __construct()
-    {
-      $this->assign('SCRIPT_NAME', isset($_SERVER['SCRIPT_NAME']) ? $_SERVER['SCRIPT_NAME']
-                    : @$GLOBALS['HTTP_SERVER_VARS']['SCRIPT_NAME']);
-    }
+    public $_current_file = null;
 
     /**
-     * assigns values to template variables
+     * internal flag to enable parser debugging
      *
-     * @param array|string $tpl_var the template variable name(s)
-     * @param mixed $value the value to assign
+     * @var bool
      */
-    function assign($tpl_var, $value = null)
-    {
-        if (is_array($tpl_var)){
-            foreach ($tpl_var as $key => $val) {
-                if ($key != '') {
-                    $this->_tpl_vars[$key] = $val;
-                }
-            }
-        } else {
-            if ($tpl_var != '')
-                $this->_tpl_vars[$tpl_var] = $value;
-        }
-    }
+    public $_parserdebug = false;
 
     /**
-     * assigns values to template variables by reference
+     * This object type (Smarty = 1, template = 2, data = 4)
      *
-     * @param string $tpl_var the template variable name
-     * @param mixed $value the referenced value to assign
+     * @var int
      */
-    function assign_by_ref($tpl_var, &$value)
-    {
-        if ($tpl_var != '')
-            $this->_tpl_vars[$tpl_var] = &$value;
-    }
+    public $_objType = 1;
 
     /**
-     * appends values to template variables
+     * Debug object
      *
-     * @param array|string $tpl_var the template variable name(s)
-     * @param mixed $value the value to append
+     * @var Smarty_Internal_Debug
      */
-    function append($tpl_var, $value=null, $merge=false)
-    {
-        if (is_array($tpl_var)) {
-            // $tpl_var is an array, ignore $value
-            foreach ($tpl_var as $_key => $_val) {
-                if ($_key != '') {
-                    if(!@is_array($this->_tpl_vars[$_key])) {
-                        settype($this->_tpl_vars[$_key],'array');
-                    }
-                    if($merge && is_array($_val)) {
-                        foreach($_val as $_mkey => $_mval) {
-                            $this->_tpl_vars[$_key][$_mkey] = $_mval;
-                        }
-                    } else {
-                        $this->_tpl_vars[$_key][] = $_val;
-                    }
-                }
-            }
-        } else {
-            if ($tpl_var != '' && isset($value)) {
-                if(!@is_array($this->_tpl_vars[$tpl_var])) {
-                    settype($this->_tpl_vars[$tpl_var],'array');
-                }
-                if($merge && is_array($value)) {
-                    foreach($value as $_mkey => $_mval) {
-                        $this->_tpl_vars[$tpl_var][$_mkey] = $_mval;
-                    }
-                } else {
-                    $this->_tpl_vars[$tpl_var][] = $value;
-                }
-            }
-        }
-    }
+    public $_debug = null;
 
     /**
-     * appends values to template variables by reference
+     * template directory
      *
-     * @param string $tpl_var the template variable name
-     * @param mixed $value the referenced value to append
+     * @var array
      */
-    function append_by_ref($tpl_var, &$value, $merge=false)
-    {
-        if ($tpl_var != '' && isset($value)) {
-            if(!@is_array($this->_tpl_vars[$tpl_var])) {
-             settype($this->_tpl_vars[$tpl_var],'array');
-            }
-            if ($merge && is_array($value)) {
-                foreach($value as $_key => $_val) {
-                    $this->_tpl_vars[$tpl_var][$_key] = &$value[$_key];
-                }
-            } else {
-                $this->_tpl_vars[$tpl_var][] = &$value;
-            }
-        }
-    }
-
+    protected $template_dir = array('./templates/');
 
     /**
-     * clear the given assigned template variable.
+     * flags for normalized template directory entries
      *
-     * @param string $tpl_var the template variable to clear
+     * @var array
      */
-    function clear_assign($tpl_var)
-    {
-        if (is_array($tpl_var))
-            foreach ($tpl_var as $curr_var)
-                unset($this->_tpl_vars[$curr_var]);
-        else
-            unset($this->_tpl_vars[$tpl_var]);
-    }
-
+    protected $_processedTemplateDir = array();
 
     /**
-     * Registers custom function to be used in templates
+     * config directory
      *
-     * @param string $function the name of the template function
-     * @param string $function_impl the name of the PHP function to register
+     * @var array
      */
-    function register_function($function, $function_impl, $cacheable=true, $cache_attrs=null)
-    {
-        $this->_plugins['function'][$function] =
-            array($function_impl, null, null, false, $cacheable, $cache_attrs);
+    protected $config_dir = array('./configs/');
 
-    }
+    /**
+     * flags for normalized template directory entries
+     *
+     * @var array
+     */
+    protected $_processedConfigDir = array();
 
     /**
-     * Unregisters custom function
+     * compile directory
      *
-     * @param string $function name of template function
+     * @var string
      */
-    function unregister_function($function)
-    {
-        unset($this->_plugins['function'][$function]);
-    }
+    protected $compile_dir = './templates_c/';
 
     /**
-     * Registers object to be used in templates
+     * plugins directory
      *
-     * @param string $object name of template object
-     * @param object &$object_impl the referenced PHP object to register
-     * @param null|array $allowed list of allowed methods (empty = all)
-     * @param boolean $smarty_args smarty argument format, else traditional
-     * @param null|array $block_functs list of methods that are block format
+     * @var array
      */
-    function register_object($object, &$object_impl, $allowed = array(), $smarty_args = true, $block_methods = array())
-    {
-        settype($allowed, 'array');
-        settype($smarty_args, 'boolean');
-        $this->_reg_objects[$object] =
-            array(&$object_impl, $allowed, $smarty_args, $block_methods);
-    }
+    protected $plugins_dir = array();
 
     /**
-     * Unregisters object
+     * cache directory
      *
-     * @param string $object name of template object
+     * @var string
      */
-    function unregister_object($object)
-    {
-        unset($this->_reg_objects[$object]);
-    }
+    protected $cache_dir = './cache/';
 
+    /**
+     * removed properties
+     *
+     * @var string[]
+     */
+    protected $obsoleteProperties = array(
+        'resource_caching', 'template_resource_caching', 'direct_access_security',
+        '_dir_perms', '_file_perms', 'plugin_search_order',
+        'inheritance_merge_compiled_includes', 'resource_cache_mode',
+    );
 
     /**
-     * Registers block function to be used in templates
+     * List of private properties which will call getter/setter on a direct access
      *
-     * @param string $block name of template block
-     * @param string $block_impl PHP function to register
+     * @var string[]
      */
-    function register_block($block, $block_impl, $cacheable=true, $cache_attrs=null)
+    protected $accessMap = array(
+        'template_dir' => 'TemplateDir', 'config_dir' => 'ConfigDir',
+        'plugins_dir'  => 'PluginsDir', 'compile_dir' => 'CompileDir',
+        'cache_dir'    => 'CacheDir',
+    );
+
+    /**
+     * Initialize new Smarty object
+     */
+    public function __construct()
     {
-        $this->_plugins['block'][$block] =
-            array($block_impl, null, null, false, $cacheable, $cache_attrs);
+        $this->_clearTemplateCache();
+        parent::__construct();
+        if (is_callable('mb_internal_encoding')) {
+            mb_internal_encoding(Smarty::$_CHARSET);
+        }
+        $this->start_time = microtime(true);
+        if (isset($_SERVER[ 'SCRIPT_NAME' ])) {
+            Smarty::$global_tpl_vars[ 'SCRIPT_NAME' ] = new Smarty_Variable($_SERVER[ 'SCRIPT_NAME' ]);
+        }
+        // Check if we're running on windows
+        Smarty::$_IS_WINDOWS = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN';
+        // let PCRE (preg_*) treat strings as ISO-8859-1 if we're not dealing with UTF-8
+        if (Smarty::$_CHARSET !== 'UTF-8') {
+            Smarty::$_UTF8_MODIFIER = '';
+        }
     }
 
     /**
-     * Unregisters block function
+     * Enable error handler to mute expected messages
      *
-     * @param string $block name of template function
+     * @return     boolean
+     * @deprecated
      */
-    function unregister_block($block)
+    public static function muteExpectedErrors()
     {
-        unset($this->_plugins['block'][$block]);
+        return Smarty_Internal_ErrorHandler::muteExpectedErrors();
     }
 
     /**
-     * Registers compiler function
+     * Disable error handler muting expected messages
      *
-     * @param string $function name of template function
-     * @param string $function_impl name of PHP function to register
+     * @deprecated
      */
-    function register_compiler_function($function, $function_impl, $cacheable=true)
+    public static function unmuteExpectedErrors()
     {
-        $this->_plugins['compiler'][$function] =
-            array($function_impl, null, null, false, $cacheable);
+        restore_error_handler();
     }
 
     /**
-     * Unregisters compiler function
+     * Check if a template resource exists
      *
-     * @param string $function name of template function
+     * @param string $resource_name template name
+     *
+     * @return bool status
+     * @throws \SmartyException
      */
-    function unregister_compiler_function($function)
+    public function templateExists($resource_name)
     {
-        unset($this->_plugins['compiler'][$function]);
+        // create source object
+        $source = Smarty_Template_Source::load(null, $this, $resource_name);
+        return $source->exists;
     }
 
     /**
-     * Registers modifier to be used in templates
+     * Loads security class and enables security
+     *
+     * @param string|Smarty_Security $security_class if a string is used, it must be class-name
      *
-     * @param string $modifier name of template modifier
-     * @param string $modifier_impl name of PHP function to register
+     * @return Smarty                 current Smarty instance for chaining
+     * @throws \SmartyException
      */
-    function register_modifier($modifier, $modifier_impl)
+    public function enableSecurity($security_class = null)
     {
-        $this->_plugins['modifier'][$modifier] =
-            array($modifier_impl, null, null, false);
+        Smarty_Security::enableSecurity($this, $security_class);
+        return $this;
     }
 
     /**
-     * Unregisters modifier
+     * Disable security
      *
-     * @param string $modifier name of template modifier
+     * @return Smarty current Smarty instance for chaining
      */
-    function unregister_modifier($modifier)
+    public function disableSecurity()
     {
-        unset($this->_plugins['modifier'][$modifier]);
+        $this->security_policy = null;
+        return $this;
     }
 
     /**
-     * Registers a resource to fetch a template
+     * Add template directory(s)
      *
-     * @param string $type name of resource
-     * @param array $functions array of functions to handle resource
+     * @param string|array $template_dir directory(s) of template sources
+     * @param string       $key          of the array element to assign the template dir to
+     * @param bool         $isConfig     true for config_dir
+     *
+     * @return Smarty          current Smarty instance for chaining
      */
-    function register_resource($type, $functions)
+    public function addTemplateDir($template_dir, $key = null, $isConfig = false)
     {
-        if (count($functions)==4) {
-            $this->_plugins['resource'][$type] =
-                array($functions, false);
-
-        } elseif (count($functions)==5) {
-            $this->_plugins['resource'][$type] =
-                array(array(array(&$functions[0], $functions[1])
-                            ,array(&$functions[0], $functions[2])
-                            ,array(&$functions[0], $functions[3])
-                            ,array(&$functions[0], $functions[4]))
-                      ,false);
-
+        if ($isConfig) {
+            $processed = &$this->_processedConfigDir;
+            $dir = &$this->config_dir;
+            $this->_configDirNormalized = false;
         } else {
-            $this->trigger_error("malformed function-list for '$type' in register_resource");
-
+            $processed = &$this->_processedTemplateDir;
+            $dir = &$this->template_dir;
+            $this->_templateDirNormalized = false;
+        }
+        if (is_array($template_dir)) {
+            foreach ($template_dir as $k => $v) {
+                if (is_int($k)) {
+                    // indexes are not merged but appended
+                    $dir[] = $v;
+                } else {
+                    // string indexes are overridden
+                    $dir[ $k ] = $v;
+                    unset($processed[ $key ]);
+                }
+            }
+        } else {
+            if ($key !== null) {
+                // override directory at specified index
+                $dir[ $key ] = $template_dir;
+                unset($processed[ $key ]);
+            } else {
+                // append new directory
+                $dir[] = $template_dir;
+            }
         }
+        return $this;
     }
 
     /**
-     * Unregisters a resource
+     * Get template directories
      *
-     * @param string $type name of resource
+     * @param mixed $index    index of directory to get, null to get all
+     * @param bool  $isConfig true for config_dir
+     *
+     * @return array|string list of template directories, or directory of $index
      */
-    function unregister_resource($type)
+    public function getTemplateDir($index = null, $isConfig = false)
     {
-        unset($this->_plugins['resource'][$type]);
+        if ($isConfig) {
+            $dir = &$this->config_dir;
+        } else {
+            $dir = &$this->template_dir;
+        }
+        if ($isConfig ? !$this->_configDirNormalized : !$this->_templateDirNormalized) {
+            $this->_normalizeTemplateConfig($isConfig);
+        }
+        if ($index !== null) {
+            return isset($dir[ $index ]) ? $dir[ $index ] : null;
+        }
+        return $dir;
     }
 
     /**
-     * Registers a prefilter function to apply
-     * to a template before compiling
+     * Set template directory
      *
-     * @param callback $function
+     * @param string|array $template_dir directory(s) of template sources
+     * @param bool         $isConfig     true for config_dir
+     *
+     * @return \Smarty current Smarty instance for chaining
      */
-    function register_prefilter($function)
+    public function setTemplateDir($template_dir, $isConfig = false)
     {
-        $this->_plugins['prefilter'][$this->_get_filter_name($function)]
-            = array($function, null, null, false);
+        if ($isConfig) {
+            $this->config_dir = array();
+            $this->_processedConfigDir = array();
+        } else {
+            $this->template_dir = array();
+            $this->_processedTemplateDir = array();
+        }
+        $this->addTemplateDir($template_dir, null, $isConfig);
+        return $this;
     }
 
     /**
-     * Unregisters a prefilter function
+     * Add config directory(s)
+     *
+     * @param string|array $config_dir directory(s) of config sources
+     * @param mixed        $key        key of the array element to assign the config dir to
      *
-     * @param callback $function
+     * @return Smarty current Smarty instance for chaining
      */
-    function unregister_prefilter($function)
+    public function addConfigDir($config_dir, $key = null)
     {
-        unset($this->_plugins['prefilter'][$this->_get_filter_name($function)]);
+        return $this->addTemplateDir($config_dir, $key, true);
     }
 
     /**
-     * Registers a postfilter function to apply
-     * to a compiled template after compilation
+     * Get config directory
      *
-     * @param callback $function
+     * @param mixed $index index of directory to get, null to get all
+     *
+     * @return array configuration directory
      */
-    function register_postfilter($function)
+    public function getConfigDir($index = null)
     {
-        $this->_plugins['postfilter'][$this->_get_filter_name($function)]
-            = array($function, null, null, false);
+        return $this->getTemplateDir($index, true);
     }
 
     /**
-     * Unregisters a postfilter function
+     * Set config directory
+     *
+     * @param $config_dir
      *
-     * @param callback $function
+     * @return Smarty       current Smarty instance for chaining
      */
-    function unregister_postfilter($function)
+    public function setConfigDir($config_dir)
     {
-        unset($this->_plugins['postfilter'][$this->_get_filter_name($function)]);
+        return $this->setTemplateDir($config_dir, true);
     }
 
     /**
-     * Registers an output filter function to apply
-     * to a template output
+     * Adds directory of plugin files
      *
-     * @param callback $function
+     * @param null|array|string $plugins_dir
+     *
+     * @return Smarty current Smarty instance for chaining
      */
-    function register_outputfilter($function)
+    public function addPluginsDir($plugins_dir)
     {
-        $this->_plugins['outputfilter'][$this->_get_filter_name($function)]
-            = array($function, null, null, false);
+        if (empty($this->plugins_dir)) {
+            $this->plugins_dir[] = SMARTY_PLUGINS_DIR;
+        }
+        $this->plugins_dir = array_merge($this->plugins_dir, (array)$plugins_dir);
+        $this->_pluginsDirNormalized = false;
+        return $this;
     }
 
     /**
-     * Unregisters an outputfilter function
+     * Get plugin directories
      *
-     * @param callback $function
+     * @return array list of plugin directories
      */
-    function unregister_outputfilter($function)
+    public function getPluginsDir()
     {
-        unset($this->_plugins['outputfilter'][$this->_get_filter_name($function)]);
+        if (empty($this->plugins_dir)) {
+            $this->plugins_dir[] = SMARTY_PLUGINS_DIR;
+            $this->_pluginsDirNormalized = false;
+        }
+        if (!$this->_pluginsDirNormalized) {
+            if (!is_array($this->plugins_dir)) {
+                $this->plugins_dir = (array)$this->plugins_dir;
+            }
+            foreach ($this->plugins_dir as $k => $v) {
+                $this->plugins_dir[ $k ] = $this->_realpath(rtrim($v, '/\\') . DIRECTORY_SEPARATOR, true);
+            }
+            $this->_cache[ 'plugin_files' ] = array();
+            $this->_pluginsDirNormalized = true;
+        }
+        return $this->plugins_dir;
     }
 
     /**
-     * load a filter of specified type and name
+     * Set plugins directory
+     *
+     * @param string|array $plugins_dir directory(s) of plugins
      *
-     * @param string $type filter type
-     * @param string $name filter name
+     * @return Smarty       current Smarty instance for chaining
      */
-    function load_filter($type, $name)
+    public function setPluginsDir($plugins_dir)
     {
-        switch ($type) {
-            case 'output':
-                $_params = array('plugins' => array(array($type . 'filter', $name, null, null, false)));
-                require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
-                smarty_core_load_plugins($_params, $this);
-                break;
-
-            case 'pre':
-            case 'post':
-                if (!isset($this->_plugins[$type . 'filter'][$name]))
-                    $this->_plugins[$type . 'filter'][$name] = false;
-                break;
-        }
+        $this->plugins_dir = (array)$plugins_dir;
+        $this->_pluginsDirNormalized = false;
+        return $this;
     }
 
     /**
-     * clear cached content for the given template and cache id
+     * Get compiled directory
      *
-     * @param string $tpl_file name of template file
-     * @param string $cache_id name of cache_id
-     * @param string $compile_id name of compile_id
-     * @param string $exp_time expiration time
-     * @return boolean
+     * @return string path to compiled templates
      */
-    function clear_cache($tpl_file = null, $cache_id = null, $compile_id = null, $exp_time = null)
+    public function getCompileDir()
     {
-
-        if (!isset($compile_id))
-            $compile_id = $this->compile_id;
-
-        if (!isset($tpl_file))
-            $compile_id = null;
-
-        $_auto_id = $this->_get_auto_id($cache_id, $compile_id);
-
-        if (!empty($this->cache_handler_func)) {
-            return call_user_func_array($this->cache_handler_func,
-                                  array('clear', &$this, &$dummy, $tpl_file, $cache_id, $compile_id, $exp_time));
-        } else {
-            $_params = array('auto_base' => $this->cache_dir,
-                            'auto_source' => $tpl_file,
-                            'auto_id' => $_auto_id,
-                            'exp_time' => $exp_time);
-            require_once(SMARTY_CORE_DIR . 'core.rm_auto.php');
-            return smarty_core_rm_auto($_params, $this);
+        if (!$this->_compileDirNormalized) {
+            $this->_normalizeDir('compile_dir', $this->compile_dir);
+            $this->_compileDirNormalized = true;
         }
-
+        return $this->compile_dir;
     }
 
-
     /**
-     * clear the entire contents of cache (all templates)
      *
-     * @param string $exp_time expire time
-     * @return boolean results of {@link smarty_core_rm_auto()}
+     * @param  string $compile_dir directory to store compiled templates in
+     *
+     * @return Smarty current Smarty instance for chaining
      */
-    function clear_all_cache($exp_time = null)
+    public function setCompileDir($compile_dir)
     {
-        return $this->clear_cache(null, null, null, $exp_time);
+        $this->_normalizeDir('compile_dir', $compile_dir);
+        $this->_compileDirNormalized = true;
+        return $this;
     }
 
-
     /**
-     * test to see if valid cache exists for this template
+     * Get cache directory
      *
-     * @param string $tpl_file name of template file
-     * @param string $cache_id
-     * @param string $compile_id
-     * @return string|false results of {@link _read_cache_file()}
+     * @return string path of cache directory
      */
-    function is_cached($tpl_file, $cache_id = null, $compile_id = null)
+    public function getCacheDir()
     {
-        if (!$this->caching)
-            return false;
-
-        if (!isset($compile_id))
-            $compile_id = $this->compile_id;
-
-        $_params = array(
-            'tpl_file' => $tpl_file,
-            'cache_id' => $cache_id,
-            'compile_id' => $compile_id
-        );
-        require_once(SMARTY_CORE_DIR . 'core.read_cache_file.php');
-        return smarty_core_read_cache_file($_params, $this);
+        if (!$this->_cacheDirNormalized) {
+            $this->_normalizeDir('cache_dir', $this->cache_dir);
+            $this->_cacheDirNormalized = true;
+        }
+        return $this->cache_dir;
     }
 
-
     /**
-     * clear all the assigned template variables.
+     * Set cache directory
+     *
+     * @param string $cache_dir directory to store cached templates in
      *
+     * @return Smarty current Smarty instance for chaining
      */
-    function clear_all_assign()
+    public function setCacheDir($cache_dir)
     {
-        $this->_tpl_vars = array();
+        $this->_normalizeDir('cache_dir', $cache_dir);
+        $this->_cacheDirNormalized = true;
+        return $this;
     }
 
     /**
-     * clears compiled version of specified template resource,
-     * or all compiled template files if one is not specified.
-     * This function is for advanced use only, not normally needed.
+     * creates a template object
      *
-     * @param string $tpl_file
-     * @param string $compile_id
-     * @param string $exp_time
-     * @return boolean results of {@link smarty_core_rm_auto()}
+     * @param string  $template   the resource handle of the template file
+     * @param mixed   $cache_id   cache id to be used with this template
+     * @param mixed   $compile_id compile id to be used with this template
+     * @param object  $parent     next higher level of Smarty variables
+     * @param boolean $do_clone   flag is Smarty object shall be cloned
+     *
+     * @return \Smarty_Internal_Template template object
+     * @throws \SmartyException
      */
-    function clear_compiled_tpl($tpl_file = null, $compile_id = null, $exp_time = null)
+    public function createTemplate($template, $cache_id = null, $compile_id = null, $parent = null, $do_clone = true)
     {
-        if (!isset($compile_id)) {
-            $compile_id = $this->compile_id;
+        if ($cache_id !== null && (is_object($cache_id) || is_array($cache_id))) {
+            $parent = $cache_id;
+            $cache_id = null;
+        }
+        if ($parent !== null && is_array($parent)) {
+            $data = $parent;
+            $parent = null;
+        } else {
+            $data = null;
+        }
+        if (!$this->_templateDirNormalized) {
+            $this->_normalizeTemplateConfig(false);
+        }
+        $_templateId = $this->_getTemplateId($template, $cache_id, $compile_id);
+        $tpl = null;
+        if ($this->caching && isset(Smarty_Internal_Template::$isCacheTplObj[ $_templateId ])) {
+            $tpl = $do_clone ? clone Smarty_Internal_Template::$isCacheTplObj[ $_templateId ] :
+                Smarty_Internal_Template::$isCacheTplObj[ $_templateId ];
+            $tpl->inheritance = null;
+            $tpl->tpl_vars = $tpl->config_vars = array();
+        } elseif (!$do_clone && isset(Smarty_Internal_Template::$tplObjCache[ $_templateId ])) {
+            $tpl = clone Smarty_Internal_Template::$tplObjCache[ $_templateId ];
+            $tpl->inheritance = null;
+            $tpl->tpl_vars = $tpl->config_vars = array();
+        } else {
+            /* @var Smarty_Internal_Template $tpl */
+            $tpl = new $this->template_class($template, $this, null, $cache_id, $compile_id, null, null);
+            $tpl->templateId = $_templateId;
         }
-        $_params = array('auto_base' => $this->compile_dir,
-                        'auto_source' => $tpl_file,
-                        'auto_id' => $compile_id,
-                        'exp_time' => $exp_time,
-                        'extensions' => array('.inc', '.php'));
-        require_once(SMARTY_CORE_DIR . 'core.rm_auto.php');
-        return smarty_core_rm_auto($_params, $this);
+        if ($do_clone) {
+            $tpl->smarty = clone $tpl->smarty;
+        }
+        $tpl->parent = $parent ? $parent : $this;
+        // fill data if present
+        if (!empty($data) && is_array($data)) {
+            // set up variable values
+            foreach ($data as $_key => $_val) {
+                $tpl->tpl_vars[ $_key ] = new Smarty_Variable($_val);
+            }
+        }
+        if ($this->debugging || $this->debugging_ctrl === 'URL') {
+            $tpl->smarty->_debug = new Smarty_Internal_Debug();
+            // check URL debugging control
+            if (!$this->debugging && $this->debugging_ctrl === 'URL') {
+                $tpl->smarty->_debug->debugUrl($tpl->smarty);
+            }
+        }
+        return $tpl;
     }
 
     /**
-     * Checks whether requested template exists.
+     * Takes unknown classes and loads plugin files for them
+     * class name format: Smarty_PluginType_PluginName
+     * plugin filename format: plugintype.pluginname.php
      *
-     * @param string $tpl_file
-     * @return boolean
+     * @param string $plugin_name class plugin name to load
+     * @param bool   $check       check if already loaded
+     *
+     * @return string |boolean filepath of loaded file or false
+     * @throws \SmartyException
      */
-    function template_exists($tpl_file)
+    public function loadPlugin($plugin_name, $check = true)
     {
-        $_params = array('resource_name' => $tpl_file, 'quiet'=>true, 'get_source'=>false);
-        return $this->_fetch_resource_info($_params);
+        return $this->ext->loadPlugin->loadPlugin($this, $plugin_name, $check);
     }
 
     /**
-     * Returns an array containing template variables
+     * Get unique template id
      *
-     * @param string $name
-     * @param string $type
-     * @return array
+     * @param string                    $template_name
+     * @param null|mixed                $cache_id
+     * @param null|mixed                $compile_id
+     * @param null                      $caching
+     * @param \Smarty_Internal_Template $template
+     *
+     * @return string
+     * @throws \SmartyException
      */
-    function &get_template_vars($name=null)
-    {
-        if(!isset($name)) {
-            return $this->_tpl_vars;
-        } elseif(isset($this->_tpl_vars[$name])) {
-            return $this->_tpl_vars[$name];
+    public function _getTemplateId(
+        $template_name,
+        $cache_id = null,
+        $compile_id = null,
+        $caching = null,
+        Smarty_Internal_Template $template = null
+    ) {
+        $template_name = (strpos($template_name, ':') === false) ? "{$this->default_resource_type}:{$template_name}" :
+            $template_name;
+        $cache_id = $cache_id === null ? $this->cache_id : $cache_id;
+        $compile_id = $compile_id === null ? $this->compile_id : $compile_id;
+        $caching = (int)($caching === null ? $this->caching : $caching);
+        if ((isset($template) && strpos($template_name, ':.') !== false) || $this->allow_ambiguous_resources) {
+            $_templateId =
+                Smarty_Resource::getUniqueTemplateName((isset($template) ? $template : $this), $template_name) .
+                "#{$cache_id}#{$compile_id}#{$caching}";
         } else {
-            // var non-existant, return valid reference
-            $_tmp = null;
-            return $_tmp;
+            $_templateId = $this->_joined_template_dir . "#{$template_name}#{$cache_id}#{$compile_id}#{$caching}";
+        }
+        if (isset($_templateId[ 150 ])) {
+            $_templateId = sha1($_templateId);
         }
+        return $_templateId;
     }
 
     /**
-     * Returns an array containing config variables
+     * Normalize path
+     *  - remove /./ and /../
+     *  - make it absolute if required
      *
-     * @param string $name
-     * @param string $type
-     * @return array
+     * @param string $path     file path
+     * @param bool   $realpath if true - convert to absolute
+     *                         false - convert to relative
+     *                         null - keep as it is but
+     *                         remove /./ /../
+     *
+     * @return string
      */
-    function &get_config_vars($name=null)
+    public function _realpath($path, $realpath = null)
     {
-        if(!isset($name) && is_array($this->_config[0])) {
-            return $this->_config[0]['vars'];
-        } else if(isset($this->_config[0]['vars'][$name])) {
-            return $this->_config[0]['vars'][$name];
+        $nds = array('/' => '\\', '\\' => '/');
+        preg_match(
+            '%^(?<root>(?:[[:alpha:]]:[\\\\/]|/|[\\\\]{2}[[:alpha:]]+|[[:print:]]{2,}:[/]{2}|[\\\\])?)(?<path>(.*))$%u',
+            $path,
+            $parts
+        );
+        $path = $parts[ 'path' ];
+        if ($parts[ 'root' ] === '\\') {
+            $parts[ 'root' ] = substr(getcwd(), 0, 2) . $parts[ 'root' ];
         } else {
-            // var non-existant, return valid reference
-            $_tmp = null;
-            return $_tmp;
+            if ($realpath !== null && !$parts[ 'root' ]) {
+                $path = getcwd() . DIRECTORY_SEPARATOR . $path;
+            }
         }
+        // normalize DIRECTORY_SEPARATOR
+        $path = str_replace($nds[ DIRECTORY_SEPARATOR ], DIRECTORY_SEPARATOR, $path);
+        $parts[ 'root' ] = str_replace($nds[ DIRECTORY_SEPARATOR ], DIRECTORY_SEPARATOR, $parts[ 'root' ]);
+        do {
+            $path = preg_replace(
+                array('#[\\\\/]{2}#', '#[\\\\/][.][\\\\/]#', '#[\\\\/]([^\\\\/.]+)[\\\\/][.][.][\\\\/]#'),
+                DIRECTORY_SEPARATOR,
+                $path,
+                -1,
+                $count
+            );
+        } while ($count > 0);
+        return $realpath !== false ? $parts[ 'root' ] . $path : str_ireplace(getcwd(), '.', $parts[ 'root' ] . $path);
     }
 
     /**
-     * trigger Smarty error
-     *
-     * @param string $error_msg
-     * @param integer $error_type
+     * Empty template objects cache
      */
-    function trigger_error($error_msg, $error_type = E_USER_WARNING)
+    public function _clearTemplateCache()
     {
-        $msg = htmlentities($error_msg);
-        trigger_error("Smarty error: $msg", $error_type);
+        Smarty_Internal_Template::$isCacheTplObj = array();
+        Smarty_Internal_Template::$tplObjCache = array();
     }
 
-
     /**
-     * executes & displays the template results
-     *
-     * @param string $resource_name
-     * @param string $cache_id
-     * @param string $compile_id
+     * @param boolean $use_sub_dirs
      */
-    function display($resource_name, $cache_id = null, $compile_id = null)
+    public function setUseSubDirs($use_sub_dirs)
     {
-        $this->fetch($resource_name, $cache_id, $compile_id, true);
+        $this->use_sub_dirs = $use_sub_dirs;
     }
 
     /**
-     * executes & returns or displays the template results
-     *
-     * @param string $resource_name
-     * @param string $cache_id
-     * @param string $compile_id
-     * @param boolean $display
+     * @param int $error_reporting
      */
-    function fetch($resource_name, $cache_id = null, $compile_id = null, $display = false)
+    public function setErrorReporting($error_reporting)
     {
-        static $_cache_info = array();
-
-        $_smarty_old_error_level = $this->debugging ? error_reporting() : error_reporting(isset($this->error_reporting)
-               ? $this->error_reporting : error_reporting() & ~E_NOTICE);
-
-        if (!$this->debugging && $this->debugging_ctrl == 'URL') {
-            $_query_string = $this->request_use_auto_globals ? $_SERVER['QUERY_STRING'] : $GLOBALS['HTTP_SERVER_VARS']['QUERY_STRING'];
-            if (@strstr($_query_string, $this->_smarty_debug_id)) {
-                if (@strstr($_query_string, $this->_smarty_debug_id . '=on')) {
-                    // enable debugging for this browser session
-                    @setcookie('SMARTY_DEBUG', true);
-                    $this->debugging = true;
-                } elseif (@strstr($_query_string, $this->_smarty_debug_id . '=off')) {
-                    // disable debugging for this browser session
-                    @setcookie('SMARTY_DEBUG', false);
-                    $this->debugging = false;
-                } else {
-                    // enable debugging for this page
-                    $this->debugging = true;
-                }
-            } else {
-                $this->debugging = (bool)($this->request_use_auto_globals ? @$_COOKIE['SMARTY_DEBUG'] : @$GLOBALS['HTTP_COOKIE_VARS']['SMARTY_DEBUG']);
-            }
-        }
-
-        if ($this->debugging) {
-            // capture time for debugging info
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $_debug_start_time = smarty_core_get_microtime($_params, $this);
-            $this->_smarty_debug_info[] = array('type'      => 'template',
-                                                'filename'  => $resource_name,
-                                                'depth'     => 0);
-            $_included_tpls_idx = count($this->_smarty_debug_info) - 1;
-        }
-
-        if (!isset($compile_id)) {
-            $compile_id = $this->compile_id;
-        }
-
-        $this->_compile_id = $compile_id;
-        $this->_inclusion_depth = 0;
-
-        if ($this->caching) {
-            // save old cache_info, initialize cache_info
-            array_push($_cache_info, $this->_cache_info);
-            $this->_cache_info = array();
-            $_params = array(
-                'tpl_file' => $resource_name,
-                'cache_id' => $cache_id,
-                'compile_id' => $compile_id,
-                'results' => null
-            );
-            require_once(SMARTY_CORE_DIR . 'core.read_cache_file.php');
-            if (smarty_core_read_cache_file($_params, $this)) {
-                $_smarty_results = $_params['results'];
-                if (!empty($this->_cache_info['insert_tags'])) {
-                    $_params = array('plugins' => $this->_cache_info['insert_tags']);
-                    require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
-                    smarty_core_load_plugins($_params, $this);
-                    $_params = array('results' => $_smarty_results);
-                    require_once(SMARTY_CORE_DIR . 'core.process_cached_inserts.php');
-                    $_smarty_results = smarty_core_process_cached_inserts($_params, $this);
-                }
-                if (!empty($this->_cache_info['cache_serials'])) {
-                    $_params = array('results' => $_smarty_results);
-                    require_once(SMARTY_CORE_DIR . 'core.process_compiled_include.php');
-                    $_smarty_results = smarty_core_process_compiled_include($_params, $this);
-                }
-
-
-                if ($display) {
-                    if ($this->debugging)
-                    {
-                        // capture time for debugging info
-                        $_params = array();
-                        require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-                        $this->_smarty_debug_info[$_included_tpls_idx]['exec_time'] = smarty_core_get_microtime($_params, $this) - $_debug_start_time;
-                        require_once(SMARTY_CORE_DIR . 'core.display_debug_console.php');
-                        $_smarty_results .= smarty_core_display_debug_console($_params, $this);
-                    }
-                    if ($this->cache_modified_check) {
-                        $_server_vars = ($this->request_use_auto_globals) ? $_SERVER : $GLOBALS['HTTP_SERVER_VARS'];
-                        $_last_modified_date = @substr($_server_vars['HTTP_IF_MODIFIED_SINCE'], 0, strpos($_server_vars['HTTP_IF_MODIFIED_SINCE'], 'GMT') + 3);
-                        $_gmt_mtime = gmdate('D, d M Y H:i:s', $this->_cache_info['timestamp']).' GMT';
-                        if (@count($this->_cache_info['insert_tags']) == 0
-                            && !$this->_cache_serials
-                            && $_gmt_mtime == $_last_modified_date) {
-                            if (php_sapi_name()=='cgi')
-                                header('Status: 304 Not Modified');
-                            else
-                                header('HTTP/1.1 304 Not Modified');
-
-                        } else {
-                            header('Last-Modified: '.$_gmt_mtime);
-                            echo $_smarty_results;
-                        }
-                    } else {
-                            echo $_smarty_results;
-                    }
-                    error_reporting($_smarty_old_error_level);
-                    // restore initial cache_info
-                    $this->_cache_info = array_pop($_cache_info);
-                    return true;
-                } else {
-                    error_reporting($_smarty_old_error_level);
-                    // restore initial cache_info
-                    $this->_cache_info = array_pop($_cache_info);
-                    return $_smarty_results;
-                }
-            } else {
-                $this->_cache_info['template'][$resource_name] = true;
-                if ($this->cache_modified_check && $display) {
-                    header('Last-Modified: '.gmdate('D, d M Y H:i:s', time()).' GMT');
-                }
-            }
-        }
-
-        // load filters that are marked as autoload
-        if (count($this->autoload_filters)) {
-            foreach ($this->autoload_filters as $_filter_type => $_filters) {
-                foreach ($_filters as $_filter) {
-                    $this->load_filter($_filter_type, $_filter);
-                }
-            }
-        }
-
-        $_smarty_compile_path = $this->_get_compile_path($resource_name);
-
-        // if we just need to display the results, don't perform output
-        // buffering - for speed
-        $_cache_including = $this->_cache_including;
-        $this->_cache_including = false;
-        if ($display && !$this->caching && count($this->_plugins['outputfilter']) == 0) {
-            if ($this->_is_compiled($resource_name, $_smarty_compile_path)
-                    || $this->_compile_resource($resource_name, $_smarty_compile_path))
-            {
-                include($_smarty_compile_path);
-            }
-        } else {
-            ob_start();
-            if ($this->_is_compiled($resource_name, $_smarty_compile_path)
-                    || $this->_compile_resource($resource_name, $_smarty_compile_path))
-            {
-                include($_smarty_compile_path);
-            }
-            $_smarty_results = ob_get_contents();
-            ob_end_clean();
-
-            foreach ((array)$this->_plugins['outputfilter'] as $_output_filter) {
-                $_smarty_results = call_user_func_array($_output_filter[0], array($_smarty_results, &$this));
-            }
-        }
-
-        if ($this->caching) {
-            $_params = array('tpl_file' => $resource_name,
-                        'cache_id' => $cache_id,
-                        'compile_id' => $compile_id,
-                        'results' => $_smarty_results);
-            require_once(SMARTY_CORE_DIR . 'core.write_cache_file.php');
-            smarty_core_write_cache_file($_params, $this);
-            require_once(SMARTY_CORE_DIR . 'core.process_cached_inserts.php');
-            $_smarty_results = smarty_core_process_cached_inserts($_params, $this);
-
-            if ($this->_cache_serials) {
-                // strip nocache-tags from output
-                $_smarty_results = preg_replace('!(\{/?nocache\:[0-9a-f]{32}#\d+\})!s'
-                                                ,''
-                                                ,$_smarty_results);
-            }
-            // restore initial cache_info
-            $this->_cache_info = array_pop($_cache_info);
-        }
-        $this->_cache_including = $_cache_including;
-
-        if ($display) {
-            if (isset($_smarty_results)) { echo $_smarty_results; }
-            if ($this->debugging) {
-                // capture time for debugging info
-                $_params = array();
-                require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-                $this->_smarty_debug_info[$_included_tpls_idx]['exec_time'] = (smarty_core_get_microtime($_params, $this) - $_debug_start_time);
-                require_once(SMARTY_CORE_DIR . 'core.display_debug_console.php');
-                echo smarty_core_display_debug_console($_params, $this);
-            }
-            error_reporting($_smarty_old_error_level);
-            return;
-        } else {
-            error_reporting($_smarty_old_error_level);
-            if (isset($_smarty_results)) { return $_smarty_results; }
-        }
+        $this->error_reporting = $error_reporting;
     }
 
     /**
-     * load configuration values
-     *
-     * @param string $file
-     * @param string $section
-     * @param string $scope
+     * @param boolean $escape_html
      */
-    function config_load($file, $section = null, $scope = 'global')
+    public function setEscapeHtml($escape_html)
     {
-        require_once($this->_get_plugin_filepath('function', 'config_load'));
-        smarty_function_config_load(array('file' => $file, 'section' => $section, 'scope' => $scope), $this);
+        $this->escape_html = $escape_html;
     }
 
     /**
-     * return a reference to a registered object
+     * Return auto_literal flag
      *
-     * @param string $name
-     * @return object
+     * @return boolean
      */
-    function &get_registered_object($name) {
-        if (!isset($this->_reg_objects[$name]))
-        $this->_trigger_fatal_error("'$name' is not a registered object");
-
-        if (!is_object($this->_reg_objects[$name][0]))
-        $this->_trigger_fatal_error("registered '$name' is not an object");
-
-        return $this->_reg_objects[$name][0];
+    public function getAutoLiteral()
+    {
+        return $this->auto_literal;
     }
 
     /**
-     * clear configuration values
+     * Set auto_literal flag
      *
-     * @param string $var
+     * @param boolean $auto_literal
      */
-    function clear_config($var = null)
+    public function setAutoLiteral($auto_literal = true)
     {
-        if(!isset($var)) {
-            // clear all values
-            $this->_config = array(array('vars'  => array(),
-                                         'files' => array()));
-        } else {
-            unset($this->_config[0]['vars'][$var]);
-        }
+        $this->auto_literal = $auto_literal;
     }
 
     /**
-     * get filepath of requested plugin
-     *
-     * @param string $type
-     * @param string $name
-     * @return string|false
+     * @param boolean $force_compile
      */
-    function _get_plugin_filepath($type, $name)
+    public function setForceCompile($force_compile)
     {
-        $_params = array('type' => $type, 'name' => $name);
-        require_once(SMARTY_CORE_DIR . 'core.assemble_plugin_filepath.php');
-        return smarty_core_assemble_plugin_filepath($_params, $this);
+        $this->force_compile = $force_compile;
     }
 
-   /**
-     * test if resource needs compiling
-     *
-     * @param string $resource_name
-     * @param string $compile_path
-     * @return boolean
+    /**
+     * @param boolean $merge_compiled_includes
      */
-    function _is_compiled($resource_name, $compile_path)
+    public function setMergeCompiledIncludes($merge_compiled_includes)
     {
-        if (!$this->force_compile && file_exists($compile_path)) {
-            if (!$this->compile_check) {
-                // no need to check compiled file
-                return true;
-            } else {
-                // get file source and timestamp
-                $_params = array('resource_name' => $resource_name, 'get_source'=>false);
-                if (!$this->_fetch_resource_info($_params)) {
-                    return false;
-                }
-                if ($_params['resource_timestamp'] <= filemtime($compile_path)) {
-                    // template not expired, no recompile
-                    return true;
-                } else {
-                    // compile template
-                    return false;
-                }
-            }
-        } else {
-            // compiled template does not exist, or forced compile
-            return false;
-        }
+        $this->merge_compiled_includes = $merge_compiled_includes;
     }
 
-   /**
-     * compile the template
+    /**
+     * Get left delimiter
      *
-     * @param string $resource_name
-     * @param string $compile_path
-     * @return boolean
+     * @return string
      */
-    function _compile_resource($resource_name, $compile_path)
+    public function getLeftDelimiter()
     {
-
-        $_params = array('resource_name' => $resource_name);
-        if (!$this->_fetch_resource_info($_params)) {
-            return false;
-        }
-
-        $_source_content = $_params['source_content'];
-        $_cache_include    = substr($compile_path, 0, -4).'.inc';
-
-        if ($this->_compile_source($resource_name, $_source_content, $_compiled_content, $_cache_include)) {
-            // if a _cache_serial was set, we also have to write an include-file:
-            if ($this->_cache_include_info) {
-                require_once(SMARTY_CORE_DIR . 'core.write_compiled_include.php');
-                smarty_core_write_compiled_include(array_merge($this->_cache_include_info, array('compiled_content'=>$_compiled_content, 'resource_name'=>$resource_name)),  $this);
-            }
-
-            $_params = array('compile_path'=>$compile_path, 'compiled_content' => $_compiled_content);
-            require_once(SMARTY_CORE_DIR . 'core.write_compiled_resource.php');
-            smarty_core_write_compiled_resource($_params, $this);
-
-            return true;
-        } else {
-            return false;
-        }
-
+        return $this->left_delimiter;
     }
 
-   /**
-     * compile the given source
+    /**
+     * Set left delimiter
      *
-     * @param string $resource_name
-     * @param string $source_content
-     * @param string $compiled_content
-     * @return boolean
+     * @param string $left_delimiter
      */
-    function _compile_source($resource_name, &$source_content, &$compiled_content, $cache_include_path=null)
+    public function setLeftDelimiter($left_delimiter)
     {
-        if (file_exists(SMARTY_DIR . $this->compiler_file)) {
-            require_once(SMARTY_DIR . $this->compiler_file);
-        } else {
-            // use include_path
-            require_once($this->compiler_file);
-        }
-
-
-        $smarty_compiler = new $this->compiler_class;
-
-        $smarty_compiler->template_dir      = $this->template_dir;
-        $smarty_compiler->compile_dir       = $this->compile_dir;
-        $smarty_compiler->plugins_dir       = $this->plugins_dir;
-        $smarty_compiler->config_dir        = $this->config_dir;
-        $smarty_compiler->force_compile     = $this->force_compile;
-        $smarty_compiler->caching           = $this->caching;
-        $smarty_compiler->php_handling      = $this->php_handling;
-        $smarty_compiler->left_delimiter    = $this->left_delimiter;
-        $smarty_compiler->right_delimiter   = $this->right_delimiter;
-        $smarty_compiler->_version          = $this->_version;
-        $smarty_compiler->security          = $this->security;
-        $smarty_compiler->secure_dir        = $this->secure_dir;
-        $smarty_compiler->security_settings = $this->security_settings;
-        $smarty_compiler->trusted_dir       = $this->trusted_dir;
-        $smarty_compiler->use_sub_dirs      = $this->use_sub_dirs;
-        $smarty_compiler->_reg_objects      = &$this->_reg_objects;
-        $smarty_compiler->_plugins          = &$this->_plugins;
-        $smarty_compiler->_tpl_vars         = &$this->_tpl_vars;
-        $smarty_compiler->default_modifiers = $this->default_modifiers;
-        $smarty_compiler->compile_id        = $this->_compile_id;
-        $smarty_compiler->_config            = $this->_config;
-        $smarty_compiler->request_use_auto_globals  = $this->request_use_auto_globals;
-
-        if (isset($cache_include_path) && isset($this->_cache_serials[$cache_include_path])) {
-            $smarty_compiler->_cache_serial = $this->_cache_serials[$cache_include_path];
-        }
-        $smarty_compiler->_cache_include = $cache_include_path;
-
-
-        $_results = $smarty_compiler->_compile_file($resource_name, $source_content, $compiled_content);
-
-        if ($smarty_compiler->_cache_serial) {
-            $this->_cache_include_info = array(
-                'cache_serial'=>$smarty_compiler->_cache_serial
-                ,'plugins_code'=>$smarty_compiler->_plugins_code
-                ,'include_file_path' => $cache_include_path);
-
-        } else {
-            $this->_cache_include_info = null;
-
-        }
-
-        return $_results;
+        $this->left_delimiter = $left_delimiter;
     }
 
     /**
-     * Get the compile path for this resource
+     * Get right delimiter
      *
-     * @param string $resource_name
-     * @return string results of {@link _get_auto_filename()}
+     * @return string $right_delimiter
      */
-    function _get_compile_path($resource_name)
+    public function getRightDelimiter()
     {
-        return $this->_get_auto_filename($this->compile_dir, $resource_name,
-                                         $this->_compile_id) . '.php';
+        return $this->right_delimiter;
     }
 
     /**
-     * fetch the template info. Gets timestamp, and source
-     * if get_source is true
+     * Set right delimiter
      *
-     * sets $source_content to the source of the template, and
-     * $resource_timestamp to its time stamp
-     * @param string $resource_name
-     * @param string $source_content
-     * @param integer $resource_timestamp
-     * @param boolean $get_source
-     * @param boolean $quiet
-     * @return boolean
+     * @param string
      */
-
-    function _fetch_resource_info(&$params)
+    public function setRightDelimiter($right_delimiter)
     {
-        if(!isset($params['get_source'])) { $params['get_source'] = true; }
-        if(!isset($params['quiet'])) { $params['quiet'] = false; }
-
-        $_return = false;
-        $_params = array('resource_name' => $params['resource_name']) ;
-        if (isset($params['resource_base_path']))
-            $_params['resource_base_path'] = $params['resource_base_path'];
-        else
-            $_params['resource_base_path'] = $this->template_dir;
-
-        if ($this->_parse_resource_name($_params)) {
-            $_resource_type = $_params['resource_type'];
-            $_resource_name = $_params['resource_name'];
-            switch ($_resource_type) {
-                case 'file':
-                    if ($params['get_source']) {
-                        $params['source_content'] = $this->_read_file($_resource_name);
-                    }
-                    $params['resource_timestamp'] = filemtime($_resource_name);
-                    $_return = is_file($_resource_name) && is_readable($_resource_name);
-                    break;
-
-                default:
-                    // call resource functions to fetch the template source and timestamp
-                    if ($params['get_source']) {
-                        $_source_return = isset($this->_plugins['resource'][$_resource_type]) &&
-                            call_user_func_array($this->_plugins['resource'][$_resource_type][0][0],
-                                                 array($_resource_name, &$params['source_content'], &$this));
-                    } else {
-                        $_source_return = true;
-                    }
-
-                    $_timestamp_return = isset($this->_plugins['resource'][$_resource_type]) &&
-                        call_user_func_array($this->_plugins['resource'][$_resource_type][0][1],
-                                             array($_resource_name, &$params['resource_timestamp'], &$this));
-
-                    $_return = $_source_return && $_timestamp_return;
-                    break;
-            }
-        }
-
-        if (!$_return) {
-            // see if we can get a template with the default template handler
-            if (!empty($this->default_template_handler_func)) {
-                if (!is_callable($this->default_template_handler_func)) {
-                    $this->trigger_error("default template handler function \"$this->default_template_handler_func\" doesn't exist.");
-                } else {
-                    $_return = call_user_func_array(
-                        $this->default_template_handler_func,
-                        array($_params['resource_type'], $_params['resource_name'], &$params['source_content'], &$params['resource_timestamp'], &$this));
-                }
-            }
-        }
-
-        if (!$_return) {
-            if (!$params['quiet']) {
-                $this->trigger_error('unable to read resource: "' . $params['resource_name'] . '"');
-            }
-        } else if ($_return && $this->security) {
-            require_once(SMARTY_CORE_DIR . 'core.is_secure.php');
-            if (!smarty_core_is_secure($_params, $this)) {
-                if (!$params['quiet'])
-                    $this->trigger_error('(secure mode) accessing "' . $params['resource_name'] . '" is not allowed');
-                $params['source_content'] = null;
-                $params['resource_timestamp'] = null;
-                return false;
-            }
-        }
-        return $_return;
+        $this->right_delimiter = $right_delimiter;
     }
 
-
     /**
-     * parse out the type and name from the resource
-     *
-     * @param string $resource_base_path
-     * @param string $resource_name
-     * @param string $resource_type
-     * @param string $resource_name
-     * @return boolean
+     * @param boolean $debugging
      */
-
-    function _parse_resource_name(&$params)
+    public function setDebugging($debugging)
     {
-
-        // split tpl_path by the first colon
-        $_resource_name_parts = explode(':', $params['resource_name'], 2);
-
-        if (count($_resource_name_parts) == 1) {
-            // no resource type given
-            $params['resource_type'] = $this->default_resource_type;
-            $params['resource_name'] = $_resource_name_parts[0];
-        } else {
-            if(strlen($_resource_name_parts[0]) == 1) {
-                // 1 char is not resource type, but part of filepath
-                $params['resource_type'] = $this->default_resource_type;
-                $params['resource_name'] = $params['resource_name'];
-            } else {
-                $params['resource_type'] = $_resource_name_parts[0];
-                $params['resource_name'] = $_resource_name_parts[1];
-            }
-        }
-
-        if ($params['resource_type'] == 'file') {
-            if (!preg_match('/^([\/\\\\]|[a-zA-Z]:[\/\\\\])/', $params['resource_name'])) {
-                // relative pathname to $params['resource_base_path']
-                // use the first directory where the file is found
-                foreach ((array)$params['resource_base_path'] as $_curr_path) {
-                    $_fullpath = $_curr_path . DIRECTORY_SEPARATOR . $params['resource_name'];
-                    if (file_exists($_fullpath) && is_file($_fullpath)) {
-                        $params['resource_name'] = $_fullpath;
-                        return true;
-                    }
-                    // didn't find the file, try include_path
-                    $_params = array('file_path' => $_fullpath);
-                    require_once(SMARTY_CORE_DIR . 'core.get_include_path.php');
-                    if(smarty_core_get_include_path($_params, $this)) {
-                        $params['resource_name'] = $_params['new_file_path'];
-                        return true;
-                    }
-                }
-                return false;
-            } else {
-                /* absolute path */
-                return file_exists($params['resource_name']);
-            }
-        } elseif (empty($this->_plugins['resource'][$params['resource_type']])) {
-            $_params = array('type' => $params['resource_type']);
-            require_once(SMARTY_CORE_DIR . 'core.load_resource_plugin.php');
-            smarty_core_load_resource_plugin($_params, $this);
-        }
-
-        return true;
+        $this->debugging = $debugging;
     }
 
-
     /**
-     * Handle modifiers
-     *
-     * @param string|null $modifier_name
-     * @param array|null $map_array
-     * @return string result of modifiers
+     * @param boolean $config_overwrite
      */
-    function _run_mod_handler()
+    public function setConfigOverwrite($config_overwrite)
     {
-        $_args = func_get_args();
-        list($_modifier_name, $_map_array) = array_splice($_args, 0, 2);
-        list($_func_name, $_tpl_file, $_tpl_line) =
-            $this->_plugins['modifier'][$_modifier_name];
-
-        $_var = $_args[0];
-        foreach ($_var as $_key => $_val) {
-            $_args[0] = $_val;
-            $_var[$_key] = call_user_func_array($_func_name, $_args);
-        }
-        return $_var;
+        $this->config_overwrite = $config_overwrite;
     }
 
     /**
-     * Remove starting and ending quotes from the string
-     *
-     * @param string $string
-     * @return string
+     * @param boolean $config_booleanize
      */
-    function _dequote($string)
+    public function setConfigBooleanize($config_booleanize)
     {
-        if ((substr($string, 0, 1) == "'" || substr($string, 0, 1) == '"') &&
-            substr($string, -1) == substr($string, 0, 1))
-            return substr($string, 1, -1);
-        else
-            return $string;
+        $this->config_booleanize = $config_booleanize;
     }
 
-
     /**
-     * read in a file
-     *
-     * @param string $filename
-     * @return string
+     * @param boolean $config_read_hidden
      */
-    function _read_file($filename)
+    public function setConfigReadHidden($config_read_hidden)
     {
-        if ( file_exists($filename) && is_readable($filename) && ($fd = @fopen($filename, 'rb')) ) {
-            $contents = '';
-            while (!feof($fd)) {
-                $contents .= fread($fd, 8192);
-            }
-            fclose($fd);
-            return $contents;
-        } else {
-            return false;
-        }
+        $this->config_read_hidden = $config_read_hidden;
     }
 
     /**
-     * get a concrete filename for automagically created content
-     *
-     * @param string $auto_base
-     * @param string $auto_source
-     * @param string $auto_id
-     * @return string
-     * @staticvar string|null
-     * @staticvar string|null
+     * @param boolean $compile_locking
      */
-    function _get_auto_filename($auto_base, $auto_source = null, $auto_id = null)
+    public function setCompileLocking($compile_locking)
     {
-        $_compile_dir_sep =  $this->use_sub_dirs ? DIRECTORY_SEPARATOR : '^';
-        $_return = $auto_base . DIRECTORY_SEPARATOR;
-
-        if(isset($auto_id)) {
-            // make auto_id safe for directory names
-            $auto_id = str_replace('%7C',$_compile_dir_sep,(urlencode($auto_id)));
-            // split into separate directories
-            $_return .= $auto_id . $_compile_dir_sep;
-        }
-
-        if(isset($auto_source)) {
-            // make source name safe for filename
-            $_filename = urlencode(basename($auto_source));
-            $_crc32 = sprintf('%08X', crc32($auto_source));
-            // prepend %% to avoid name conflicts with
-            // with $params['auto_id'] names
-            $_crc32 = substr($_crc32, 0, 2) . $_compile_dir_sep .
-                      substr($_crc32, 0, 3) . $_compile_dir_sep . $_crc32;
-            $_return .= '%%' . $_crc32 . '%%' . $_filename;
-        }
-
-        return $_return;
+        $this->compile_locking = $compile_locking;
     }
 
     /**
-     * unlink a file, possibly using expiration time
-     *
-     * @param string $resource
-     * @param integer $exp_time
+     * @param string $default_resource_type
      */
-    function _unlink($resource, $exp_time = null)
+    public function setDefaultResourceType($default_resource_type)
     {
-        if(isset($exp_time)) {
-            if(time() - @filemtime($resource) >= $exp_time) {
-                return @unlink($resource);
-            }
-        } else {
-            return @unlink($resource);
-        }
+        $this->default_resource_type = $default_resource_type;
     }
 
     /**
-     * returns an auto_id for auto-file-functions
-     *
-     * @param string $cache_id
-     * @param string $compile_id
-     * @return string|null
+     * @param string $caching_type
      */
-    function _get_auto_id($cache_id=null, $compile_id=null) {
-    if (isset($cache_id))
-        return (isset($compile_id)) ? $cache_id . '|' . $compile_id  : $cache_id;
-    elseif(isset($compile_id))
-        return $compile_id;
-    else
-        return null;
+    public function setCachingType($caching_type)
+    {
+        $this->caching_type = $caching_type;
     }
 
     /**
-     * trigger Smarty plugin error
+     * Test install
      *
-     * @param string $error_msg
-     * @param string $tpl_file
-     * @param integer $tpl_line
-     * @param string $file
-     * @param integer $line
-     * @param integer $error_type
+     * @param null $errors
      */
-    function _trigger_fatal_error($error_msg, $tpl_file = null, $tpl_line = null,
-            $file = null, $line = null, $error_type = E_USER_ERROR)
+    public function testInstall(&$errors = null)
     {
-        if(isset($file) && isset($line)) {
-            $info = ' ('.basename($file).", line $line)";
-        } else {
-            $info = '';
-        }
-        if (isset($tpl_line) && isset($tpl_file)) {
-            $this->trigger_error('[in ' . $tpl_file . ' line ' . $tpl_line . "]: $error_msg$info", $error_type);
-        } else {
-            $this->trigger_error($error_msg . $info, $error_type);
-        }
+        Smarty_Internal_TestInstall::testInstall($this, $errors);
     }
 
-
     /**
-     * callback function for preg_replace, to call a non-cacheable block
-     * @return string
-     */
-    function _process_compiled_include_callback($match) {
-        $_func = '_smarty_tplfunc_'.$match[2].'_'.$match[3];
-        ob_start();
-        $_func($this);
-        $_ret = ob_get_contents();
-        ob_end_clean();
-        return $_ret;
-    }
-
-
-    /**
-     * called for included templates
+     * Get Smarty object
      *
-     * @param string $_smarty_include_tpl_file
-     * @param string $_smarty_include_vars
+     * @return Smarty
      */
-
-    // $_smarty_include_tpl_file, $_smarty_include_vars
-
-    function _smarty_include($params)
+    public function _getSmartyObj()
     {
-        if ($this->debugging) {
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $debug_start_time = smarty_core_get_microtime($_params, $this);
-            $this->_smarty_debug_info[] = array('type'      => 'template',
-                                                  'filename'  => $params['smarty_include_tpl_file'],
-                                                  'depth'     => ++$this->_inclusion_depth);
-            $included_tpls_idx = count($this->_smarty_debug_info) - 1;
-        }
-
-        $this->_tpl_vars = array_merge($this->_tpl_vars, $params['smarty_include_vars']);
-
-        // config vars are treated as local, so push a copy of the
-        // current ones onto the front of the stack
-        array_unshift($this->_config, $this->_config[0]);
-
-        $_smarty_compile_path = $this->_get_compile_path($params['smarty_include_tpl_file']);
-
-
-        if ($this->_is_compiled($params['smarty_include_tpl_file'], $_smarty_compile_path)
-            || $this->_compile_resource($params['smarty_include_tpl_file'], $_smarty_compile_path))
-        {
-            include($_smarty_compile_path);
-        }
-
-        // pop the local vars off the front of the stack
-        array_shift($this->_config);
-
-        $this->_inclusion_depth--;
-
-        if ($this->debugging) {
-            // capture time for debugging info
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $this->_smarty_debug_info[$included_tpls_idx]['exec_time'] = smarty_core_get_microtime($_params, $this) - $debug_start_time;
-        }
-
-        if ($this->caching) {
-            $this->_cache_info['template'][$params['smarty_include_tpl_file']] = true;
-        }
+        return $this;
     }
 
-
     /**
-     * get or set an array of cached attributes for function that is
-     * not cacheable
-     * @return array
+     * <<magic>> Generic getter.
+     * Calls the appropriate getter function.
+     * Issues an E_USER_NOTICE if no valid getter is found.
+     *
+     * @param string $name property name
+     *
+     * @return mixed
      */
-    function &_smarty_cache_attrs($cache_serial, $count) {
-        $_cache_attrs =& $this->_cache_info['cache_attrs'][$cache_serial][$count];
-
-        if ($this->_cache_including) {
-            /* return next set of cache_attrs */
-            $_return = current($_cache_attrs);
-            next($_cache_attrs);
-            return $_return;
-
+    public function __get($name)
+    {
+        if (isset($this->accessMap[ $name ])) {
+            $method = 'get' . $this->accessMap[ $name ];
+            return $this->{$method}();
+        } elseif (isset($this->_cache[ $name ])) {
+            return $this->_cache[ $name ];
+        } elseif (in_array($name, $this->obsoleteProperties)) {
+            return null;
         } else {
-            /* add a reference to a new set of cache_attrs */
-            $_cache_attrs[] = array();
-            return $_cache_attrs[count($_cache_attrs)-1];
-
+            trigger_error('Undefined property: ' . get_class($this) . '::$' . $name, E_USER_NOTICE);
         }
-
+        return null;
     }
 
-
     /**
-     * wrapper for include() retaining $this
-     * @return mixed
+     * <<magic>> Generic setter.
+     * Calls the appropriate setter function.
+     * Issues an E_USER_NOTICE if no valid setter is found.
+     *
+     * @param string $name  property name
+     * @param mixed  $value parameter passed to setter
+     *
      */
-    function _include($filename, $once=false, $params=null)
+    public function __set($name, $value)
     {
-        if ($once) {
-            return include_once($filename);
+        if (isset($this->accessMap[ $name ])) {
+            $method = 'set' . $this->accessMap[ $name ];
+            $this->{$method}($value);
+        } elseif (in_array($name, $this->obsoleteProperties)) {
+            return;
+        } elseif (is_object($value) && method_exists($value, $name)) {
+            $this->$name = $value;
         } else {
-            return include($filename);
+            trigger_error('Undefined property: ' . get_class($this) . '::$' . $name, E_USER_NOTICE);
         }
     }
 
-
     /**
-     * wrapper for eval() retaining $this
-     * @return mixed
+     * Normalize and set directory string
+     *
+     * @param string $dirName cache_dir or compile_dir
+     * @param string $dir     filepath of folder
      */
-    function _eval($code, $params=null)
+    private function _normalizeDir($dirName, $dir)
     {
-        return eval($code);
+        $this->{$dirName} = $this->_realpath(rtrim($dir, "/\\") . DIRECTORY_SEPARATOR, true);
+        if (class_exists('Smarty_Internal_ErrorHandler', false)) {
+            if (!isset(Smarty_Internal_ErrorHandler::$mutedDirectories[ $this->{$dirName} ])) {
+                Smarty_Internal_ErrorHandler::$mutedDirectories[ $this->{$dirName} ] = null;
+            }
+        }
     }
 
     /**
-     * Extracts the filter name from the given callback
+     * Normalize template_dir or config_dir
      *
-     * @param callback $function
-     * @return string
+     * @param bool $isConfig true for config_dir
      */
-	function _get_filter_name($function)
-	{
-		if (is_array($function)) {
-			$_class_name = (is_object($function[0]) ?
-				get_class($function[0]) : $function[0]);
-			return $_class_name . '_' . $function[1];
-		}
-		else {
-			return $function;
-		}
-	}
-
-    /**#@-*/
-
+    private function _normalizeTemplateConfig($isConfig)
+    {
+        if ($isConfig) {
+            $processed = &$this->_processedConfigDir;
+            $dir = &$this->config_dir;
+        } else {
+            $processed = &$this->_processedTemplateDir;
+            $dir = &$this->template_dir;
+        }
+        if (!is_array($dir)) {
+            $dir = (array)$dir;
+        }
+        foreach ($dir as $k => $v) {
+            if (!isset($processed[ $k ])) {
+                $dir[ $k ] = $v = $this->_realpath(rtrim($v, "/\\") . DIRECTORY_SEPARATOR, true);
+                $processed[ $k ] = true;
+            }
+        }
+        $isConfig ? $this->_configDirNormalized = true : $this->_templateDirNormalized = true;
+        $isConfig ? $this->_joined_config_dir = join('#', $this->config_dir) :
+            $this->_joined_template_dir = join('#', $this->template_dir);
+    }
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/SmartyBC.class.php b/epgrec/Smarty/SmartyBC.class.php
--- a/epgrec/Smarty/SmartyBC.class.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/SmartyBC.class.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,477 @@
+<?php
+/**
+ * Project:     Smarty: the PHP compiling template engine
+ * File:        SmartyBC.class.php
+ * SVN:         $Id: $
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3.0 of the License, or (at your option) any later version.
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * For questions, help, comments, discussion, etc., please join the
+ * Smarty mailing list. Send a blank e-mail to
+ * smarty-discussion-subscribe@googlegroups.com
+ *
+ * @link      http://www.smarty.net/
+ * @copyright 2008 New Digital Group, Inc.
+ * @author    Monte Ohrt <monte at ohrt dot com>
+ * @author    Uwe Tews
+ * @author    Rodney Rehm
+ * @package   Smarty
+ */
+/**
+ * @ignore
+ */
+require_once dirname(__FILE__) . '/Smarty.class.php';
+
+/**
+ * Smarty Backward Compatibility Wrapper Class
+ *
+ * @package Smarty
+ */
+class SmartyBC extends Smarty
+{
+    /**
+     * Smarty 2 BC
+     *
+     * @var string
+     */
+    public $_version = self::SMARTY_VERSION;
+
+    /**
+     * This is an array of directories where trusted php scripts reside.
+     *
+     * @var array
+     */
+    public $trusted_dir = array();
+
+    /**
+     * Initialize new SmartyBC object
+     */
+    public function __construct()
+    {
+        parent::__construct();
+    }
+
+    /**
+     * wrapper for assign_by_ref
+     *
+     * @param string $tpl_var the template variable name
+     * @param mixed  &$value  the referenced value to assign
+     */
+    public function assign_by_ref($tpl_var, &$value)
+    {
+        $this->assignByRef($tpl_var, $value);
+    }
+
+    /**
+     * wrapper for append_by_ref
+     *
+     * @param string  $tpl_var the template variable name
+     * @param mixed   &$value  the referenced value to append
+     * @param boolean $merge   flag if array elements shall be merged
+     */
+    public function append_by_ref($tpl_var, &$value, $merge = false)
+    {
+        $this->appendByRef($tpl_var, $value, $merge);
+    }
+
+    /**
+     * clear the given assigned template variable.
+     *
+     * @param string $tpl_var the template variable to clear
+     */
+    public function clear_assign($tpl_var)
+    {
+        $this->clearAssign($tpl_var);
+    }
+
+    /**
+     * Registers custom function to be used in templates
+     *
+     * @param string $function      the name of the template function
+     * @param string $function_impl the name of the PHP function to register
+     * @param bool   $cacheable
+     * @param mixed  $cache_attrs
+     *
+     * @throws \SmartyException
+     */
+    public function register_function($function, $function_impl, $cacheable = true, $cache_attrs = null)
+    {
+        $this->registerPlugin('function', $function, $function_impl, $cacheable, $cache_attrs);
+    }
+
+    /**
+     * Unregister custom function
+     *
+     * @param string $function name of template function
+     */
+    public function unregister_function($function)
+    {
+        $this->unregisterPlugin('function', $function);
+    }
+
+    /**
+     * Registers object to be used in templates
+     *
+     * @param string  $object        name of template object
+     * @param object  $object_impl   the referenced PHP object to register
+     * @param array   $allowed       list of allowed methods (empty = all)
+     * @param boolean $smarty_args   smarty argument format, else traditional
+     * @param array   $block_methods list of methods that are block format
+     *
+     * @throws   SmartyException
+     * @internal param array $block_functs list of methods that are block format
+     */
+    public function register_object(
+        $object,
+        $object_impl,
+        $allowed = array(),
+        $smarty_args = true,
+        $block_methods = array()
+    ) {
+        settype($allowed, 'array');
+        settype($smarty_args, 'boolean');
+        $this->registerObject($object, $object_impl, $allowed, $smarty_args, $block_methods);
+    }
+
+    /**
+     * Unregister object
+     *
+     * @param string $object name of template object
+     */
+    public function unregister_object($object)
+    {
+        $this->unregisterObject($object);
+    }
+
+    /**
+     * Registers block function to be used in templates
+     *
+     * @param string $block      name of template block
+     * @param string $block_impl PHP function to register
+     * @param bool   $cacheable
+     * @param mixed  $cache_attrs
+     *
+     * @throws \SmartyException
+     */
+    public function register_block($block, $block_impl, $cacheable = true, $cache_attrs = null)
+    {
+        $this->registerPlugin('block', $block, $block_impl, $cacheable, $cache_attrs);
+    }
+
+    /**
+     * Unregister block function
+     *
+     * @param string $block name of template function
+     */
+    public function unregister_block($block)
+    {
+        $this->unregisterPlugin('block', $block);
+    }
+
+    /**
+     * Registers compiler function
+     *
+     * @param string $function      name of template function
+     * @param string $function_impl name of PHP function to register
+     * @param bool   $cacheable
+     *
+     * @throws \SmartyException
+     */
+    public function register_compiler_function($function, $function_impl, $cacheable = true)
+    {
+        $this->registerPlugin('compiler', $function, $function_impl, $cacheable);
+    }
+
+    /**
+     * Unregister compiler function
+     *
+     * @param string $function name of template function
+     */
+    public function unregister_compiler_function($function)
+    {
+        $this->unregisterPlugin('compiler', $function);
+    }
+
+    /**
+     * Registers modifier to be used in templates
+     *
+     * @param string $modifier      name of template modifier
+     * @param string $modifier_impl name of PHP function to register
+     *
+     * @throws \SmartyException
+     */
+    public function register_modifier($modifier, $modifier_impl)
+    {
+        $this->registerPlugin('modifier', $modifier, $modifier_impl);
+    }
+
+    /**
+     * Unregister modifier
+     *
+     * @param string $modifier name of template modifier
+     */
+    public function unregister_modifier($modifier)
+    {
+        $this->unregisterPlugin('modifier', $modifier);
+    }
+
+    /**
+     * Registers a resource to fetch a template
+     *
+     * @param string $type      name of resource
+     * @param array  $functions array of functions to handle resource
+     */
+    public function register_resource($type, $functions)
+    {
+        $this->registerResource($type, $functions);
+    }
+
+    /**
+     * Unregister a resource
+     *
+     * @param string $type name of resource
+     */
+    public function unregister_resource($type)
+    {
+        $this->unregisterResource($type);
+    }
+
+    /**
+     * Registers a prefilter function to apply
+     * to a template before compiling
+     *
+     * @param callable $function
+     *
+     * @throws \SmartyException
+     */
+    public function register_prefilter($function)
+    {
+        $this->registerFilter('pre', $function);
+    }
+
+    /**
+     * Unregister a prefilter function
+     *
+     * @param callable $function
+     */
+    public function unregister_prefilter($function)
+    {
+        $this->unregisterFilter('pre', $function);
+    }
+
+    /**
+     * Registers a postfilter function to apply
+     * to a compiled template after compilation
+     *
+     * @param callable $function
+     *
+     * @throws \SmartyException
+     */
+    public function register_postfilter($function)
+    {
+        $this->registerFilter('post', $function);
+    }
+
+    /**
+     * Unregister a postfilter function
+     *
+     * @param callable $function
+     */
+    public function unregister_postfilter($function)
+    {
+        $this->unregisterFilter('post', $function);
+    }
+
+    /**
+     * Registers an output filter function to apply
+     * to a template output
+     *
+     * @param callable $function
+     *
+     * @throws \SmartyException
+     */
+    public function register_outputfilter($function)
+    {
+        $this->registerFilter('output', $function);
+    }
+
+    /**
+     * Unregister an outputfilter function
+     *
+     * @param callable $function
+     */
+    public function unregister_outputfilter($function)
+    {
+        $this->unregisterFilter('output', $function);
+    }
+
+    /**
+     * load a filter of specified type and name
+     *
+     * @param string $type filter type
+     * @param string $name filter name
+     *
+     * @throws \SmartyException
+     */
+    public function load_filter($type, $name)
+    {
+        $this->loadFilter($type, $name);
+    }
+
+    /**
+     * clear cached content for the given template and cache id
+     *
+     * @param string $tpl_file   name of template file
+     * @param string $cache_id   name of cache_id
+     * @param string $compile_id name of compile_id
+     * @param string $exp_time   expiration time
+     *
+     * @return boolean
+     */
+    public function clear_cache($tpl_file = null, $cache_id = null, $compile_id = null, $exp_time = null)
+    {
+        return $this->clearCache($tpl_file, $cache_id, $compile_id, $exp_time);
+    }
+
+    /**
+     * clear the entire contents of cache (all templates)
+     *
+     * @param string $exp_time expire time
+     *
+     * @return boolean
+     */
+    public function clear_all_cache($exp_time = null)
+    {
+        return $this->clearCache(null, null, null, $exp_time);
+    }
+
+    /**
+     * test to see if valid cache exists for this template
+     *
+     * @param string $tpl_file name of template file
+     * @param string $cache_id
+     * @param string $compile_id
+     *
+     * @return bool
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function is_cached($tpl_file, $cache_id = null, $compile_id = null)
+    {
+        return $this->isCached($tpl_file, $cache_id, $compile_id);
+    }
+
+    /**
+     * clear all the assigned template variables.
+     */
+    public function clear_all_assign()
+    {
+        $this->clearAllAssign();
+    }
+
+    /**
+     * clears compiled version of specified template resource,
+     * or all compiled template files if one is not specified.
+     * This function is for advanced use only, not normally needed.
+     *
+     * @param string $tpl_file
+     * @param string $compile_id
+     * @param string $exp_time
+     *
+     * @return boolean results of {@link smarty_core_rm_auto()}
+     */
+    public function clear_compiled_tpl($tpl_file = null, $compile_id = null, $exp_time = null)
+    {
+        return $this->clearCompiledTemplate($tpl_file, $compile_id, $exp_time);
+    }
+
+    /**
+     * Checks whether requested template exists.
+     *
+     * @param string $tpl_file
+     *
+     * @return bool
+     * @throws \SmartyException
+     */
+    public function template_exists($tpl_file)
+    {
+        return $this->templateExists($tpl_file);
+    }
+
+    /**
+     * Returns an array containing template variables
+     *
+     * @param string $name
+     *
+     * @return array
+     */
+    public function get_template_vars($name = null)
+    {
+        return $this->getTemplateVars($name);
+    }
+
+    /**
+     * Returns an array containing config variables
+     *
+     * @param string $name
+     *
+     * @return array
+     */
+    public function get_config_vars($name = null)
+    {
+        return $this->getConfigVars($name);
+    }
+
+    /**
+     * load configuration values
+     *
+     * @param string $file
+     * @param string $section
+     * @param string $scope
+     */
+    public function config_load($file, $section = null, $scope = 'global')
+    {
+        $this->ConfigLoad($file, $section, $scope);
+    }
+
+    /**
+     * return a reference to a registered object
+     *
+     * @param string $name
+     *
+     * @return object
+     */
+    public function get_registered_object($name)
+    {
+        return $this->getRegisteredObject($name);
+    }
+
+    /**
+     * clear configuration values
+     *
+     * @param string $var
+     */
+    public function clear_config($var = null)
+    {
+        $this->clearConfig($var);
+    }
+
+    /**
+     * trigger Smarty error
+     *
+     * @param string  $error_msg
+     * @param integer $error_type
+     */
+    public function trigger_error($error_msg, $error_type = E_USER_WARNING)
+    {
+        trigger_error("Smarty error: $error_msg", $error_type);
+    }
+}
diff -urN a/epgrec/Smarty/Smarty_Compiler.class.php b/epgrec/Smarty/Smarty_Compiler.class.php
--- a/epgrec/Smarty/Smarty_Compiler.class.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/Smarty_Compiler.class.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,2365 +0,0 @@
-<?php
-
-/**
- * Project:     Smarty: the PHP compiling template engine
- * File:        Smarty_Compiler.class.php
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * @link http://smarty.php.net/
- * @author Monte Ohrt <monte at ohrt dot com>
- * @author Andrei Zmievski <andrei@php.net>
- * @version 2.6.25-dev
- * @copyright 2001-2005 New Digital Group, Inc.
- * @package Smarty
- */
-
-/* $Id$ */
-
-/**
- * Template compiling class
- * @package Smarty
- */
-class Smarty_Compiler extends Smarty {
-
-    // internal vars
-    /**#@+
-     * @access private
-     */
-    var $_folded_blocks         =   array();    // keeps folded template blocks
-    var $_current_file          =   null;       // the current template being compiled
-    var $_current_line_no       =   1;          // line number for error messages
-    var $_capture_stack         =   array();    // keeps track of nested capture buffers
-    var $_plugin_info           =   array();    // keeps track of plugins to load
-    var $_init_smarty_vars      =   false;
-    var $_permitted_tokens      =   array('true','false','yes','no','on','off','null');
-    var $_db_qstr_regexp        =   null;        // regexps are setup in the constructor
-    var $_si_qstr_regexp        =   null;
-    var $_qstr_regexp           =   null;
-    var $_func_regexp           =   null;
-    var $_reg_obj_regexp        =   null;
-    var $_var_bracket_regexp    =   null;
-    var $_num_const_regexp      =   null;
-    var $_dvar_guts_regexp      =   null;
-    var $_dvar_regexp           =   null;
-    var $_cvar_regexp           =   null;
-    var $_svar_regexp           =   null;
-    var $_avar_regexp           =   null;
-    var $_mod_regexp            =   null;
-    var $_var_regexp            =   null;
-    var $_parenth_param_regexp  =   null;
-    var $_func_call_regexp      =   null;
-    var $_obj_ext_regexp        =   null;
-    var $_obj_start_regexp      =   null;
-    var $_obj_params_regexp     =   null;
-    var $_obj_call_regexp       =   null;
-    var $_cacheable_state       =   0;
-    var $_cache_attrs_count     =   0;
-    var $_nocache_count         =   0;
-    var $_cache_serial          =   null;
-    var $_cache_include         =   null;
-
-    var $_strip_depth           =   0;
-    var $_additional_newline    =   "\n";
-
-    /**#@-*/
-    /**
-     * The class constructor.
-     */
-    public function __construct()
-    {
-        // matches double quoted strings:
-        // "foobar"
-        // "foo\"bar"
-        $this->_db_qstr_regexp = '"[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
-
-        // matches single quoted strings:
-        // 'foobar'
-        // 'foo\'bar'
-        $this->_si_qstr_regexp = '\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'';
-
-        // matches single or double quoted strings
-        $this->_qstr_regexp = '(?:' . $this->_db_qstr_regexp . '|' . $this->_si_qstr_regexp . ')';
-
-        // matches bracket portion of vars
-        // [0]
-        // [foo]
-        // [$bar]
-        $this->_var_bracket_regexp = '\[\$?[\w\.]+\]';
-
-        // matches numerical constants
-        // 30
-        // -12
-        // 13.22
-        $this->_num_const_regexp = '(?:\-?\d+(?:\.\d+)?)';
-
-        // matches $ vars (not objects):
-        // $foo
-        // $foo.bar
-        // $foo.bar.foobar
-        // $foo[0]
-        // $foo[$bar]
-        // $foo[5][blah]
-        // $foo[5].bar[$foobar][4]
-        $this->_dvar_math_regexp = '(?:[\+\*\/\%]|(?:-(?!>)))';
-        $this->_dvar_math_var_regexp = '[\$\w\.\+\-\*\/\%\d\>\[\]]';
-        $this->_dvar_guts_regexp = '\w+(?:' . $this->_var_bracket_regexp
-                . ')*(?:\.\$?\w+(?:' . $this->_var_bracket_regexp . ')*)*(?:' . $this->_dvar_math_regexp . '(?:' . $this->_num_const_regexp . '|' . $this->_dvar_math_var_regexp . ')*)?';
-        $this->_dvar_regexp = '\$' . $this->_dvar_guts_regexp;
-
-        // matches config vars:
-        // #foo#
-        // #foobar123_foo#
-        $this->_cvar_regexp = '\#\w+\#';
-
-        // matches section vars:
-        // %foo.bar%
-        $this->_svar_regexp = '\%\w+\.\w+\%';
-
-        // matches all valid variables (no quotes, no modifiers)
-        $this->_avar_regexp = '(?:' . $this->_dvar_regexp . '|'
-           . $this->_cvar_regexp . '|' . $this->_svar_regexp . ')';
-
-        // matches valid variable syntax:
-        // $foo
-        // $foo
-        // #foo#
-        // #foo#
-        // "text"
-        // "text"
-        $this->_var_regexp = '(?:' . $this->_avar_regexp . '|' . $this->_qstr_regexp . ')';
-
-        // matches valid object call (one level of object nesting allowed in parameters):
-        // $foo->bar
-        // $foo->bar()
-        // $foo->bar("text")
-        // $foo->bar($foo, $bar, "text")
-        // $foo->bar($foo, "foo")
-        // $foo->bar->foo()
-        // $foo->bar->foo->bar()
-        // $foo->bar($foo->bar)
-        // $foo->bar($foo->bar())
-        // $foo->bar($foo->bar($blah,$foo,44,"foo",$foo[0].bar))
-        $this->_obj_ext_regexp = '\->(?:\$?' . $this->_dvar_guts_regexp . ')';
-        $this->_obj_restricted_param_regexp = '(?:'
-                . '(?:' . $this->_var_regexp . '|' . $this->_num_const_regexp . ')(?:' . $this->_obj_ext_regexp . '(?:\((?:(?:' . $this->_var_regexp . '|' . $this->_num_const_regexp . ')'
-                . '(?:\s*,\s*(?:' . $this->_var_regexp . '|' . $this->_num_const_regexp . '))*)?\))?)*)';
-        $this->_obj_single_param_regexp = '(?:\w+|' . $this->_obj_restricted_param_regexp . '(?:\s*,\s*(?:(?:\w+|'
-                . $this->_var_regexp . $this->_obj_restricted_param_regexp . ')))*)';
-        $this->_obj_params_regexp = '\((?:' . $this->_obj_single_param_regexp
-                . '(?:\s*,\s*' . $this->_obj_single_param_regexp . ')*)?\)';
-        $this->_obj_start_regexp = '(?:' . $this->_dvar_regexp . '(?:' . $this->_obj_ext_regexp . ')+)';
-        $this->_obj_call_regexp = '(?:' . $this->_obj_start_regexp . '(?:' . $this->_obj_params_regexp . ')?(?:' . $this->_dvar_math_regexp . '(?:' . $this->_num_const_regexp . '|' . $this->_dvar_math_var_regexp . ')*)?)';
-        
-        // matches valid modifier syntax:
-        // |foo
-        // |@foo
-        // |foo:"bar"
-        // |foo:$bar
-        // |foo:"bar":$foobar
-        // |foo|bar
-        // |foo:$foo->bar
-        $this->_mod_regexp = '(?:\|@?\w+(?::(?:\w+|' . $this->_num_const_regexp . '|'
-           . $this->_obj_call_regexp . '|' . $this->_avar_regexp . '|' . $this->_qstr_regexp .'))*)';
-
-        // matches valid function name:
-        // foo123
-        // _foo_bar
-        $this->_func_regexp = '[a-zA-Z_]\w*';
-
-        // matches valid registered object:
-        // foo->bar
-        $this->_reg_obj_regexp = '[a-zA-Z_]\w*->[a-zA-Z_]\w*';
-
-        // matches valid parameter values:
-        // true
-        // $foo
-        // $foo|bar
-        // #foo#
-        // #foo#|bar
-        // "text"
-        // "text"|bar
-        // $foo->bar
-        $this->_param_regexp = '(?:\s*(?:' . $this->_obj_call_regexp . '|'
-           . $this->_var_regexp . '|' . $this->_num_const_regexp  . '|\w+)(?>' . $this->_mod_regexp . '*)\s*)';
-
-        // matches valid parenthesised function parameters:
-        //
-        // "text"
-        //    $foo, $bar, "text"
-        // $foo|bar, "foo"|bar, $foo->bar($foo)|bar
-        $this->_parenth_param_regexp = '(?:\((?:\w+|'
-                . $this->_param_regexp . '(?:\s*,\s*(?:(?:\w+|'
-                . $this->_param_regexp . ')))*)?\))';
-
-        // matches valid function call:
-        // foo()
-        // foo_bar($foo)
-        // _foo_bar($foo,"bar")
-        // foo123($foo,$foo->bar(),"foo")
-        $this->_func_call_regexp = '(?:' . $this->_func_regexp . '\s*(?:'
-           . $this->_parenth_param_regexp . '))';
-    }
-
-    /**
-     * compile a resource
-     *
-     * sets $compiled_content to the compiled source
-     * @param string $resource_name
-     * @param string $source_content
-     * @param string $compiled_content
-     * @return true
-     */
-    function _compile_file($resource_name, $source_content, &$compiled_content)
-    {
-
-        if ($this->security) {
-            // do not allow php syntax to be executed unless specified
-            if ($this->php_handling == SMARTY_PHP_ALLOW &&
-                !$this->security_settings['PHP_HANDLING']) {
-                $this->php_handling = SMARTY_PHP_PASSTHRU;
-            }
-        }
-
-        $this->_load_filters();
-
-        $this->_current_file = $resource_name;
-        $this->_current_line_no = 1;
-        $ldq = preg_quote($this->left_delimiter, '~');
-        $rdq = preg_quote($this->right_delimiter, '~');
-
-        // run template source through prefilter functions
-        if (count($this->_plugins['prefilter']) > 0) {
-            foreach ($this->_plugins['prefilter'] as $filter_name => $prefilter) {
-                if ($prefilter === false) continue;
-                if ($prefilter[3] || is_callable($prefilter[0])) {
-                    $source_content = call_user_func_array($prefilter[0],
-                                                            array($source_content, &$this));
-                    $this->_plugins['prefilter'][$filter_name][3] = true;
-                } else {
-                    $this->_trigger_fatal_error("[plugin] prefilter '$filter_name' is not implemented");
-                }
-            }
-        }
-
-        /* fetch all special blocks */
-        $search = "~{$ldq}\*(.*?)\*{$rdq}|{$ldq}\s*literal\s*{$rdq}(.*?){$ldq}\s*/literal\s*{$rdq}|{$ldq}\s*php\s*{$rdq}(.*?){$ldq}\s*/php\s*{$rdq}~s";
-
-        preg_match_all($search, $source_content, $match,  PREG_SET_ORDER);
-        $this->_folded_blocks = $match;
-        reset($this->_folded_blocks);
-
-        /* replace special blocks by "{php}" */
-        $source_content = preg_replace_callback($search, create_function ('$matches', "return '"
-                                       . $this->_quote_replace($this->left_delimiter) . 'php'
-                                       . "' . str_repeat(\"\n\", substr_count('\$matches[1]', \"\n\")) .'"
-                                       . $this->_quote_replace($this->right_delimiter)
-                                       . "';")
-                                       , $source_content);
-
-        /* Gather all template tags. */
-        preg_match_all("~{$ldq}\s*(.*?)\s*{$rdq}~s", $source_content, $_match);
-        $template_tags = $_match[1];
-        /* Split content by template tags to obtain non-template content. */
-        $text_blocks = preg_split("~{$ldq}.*?{$rdq}~s", $source_content);
-
-        /* loop through text blocks */
-        for ($curr_tb = 0, $for_max = count($text_blocks); $curr_tb < $for_max; $curr_tb++) {
-            /* match anything resembling php tags */
-            if (preg_match_all('~(<\?(?:\w+|=)?|\?>|language\s*=\s*[\"\']?\s*php\s*[\"\']?)~is', $text_blocks[$curr_tb], $sp_match)) {
-                /* replace tags with placeholders to prevent recursive replacements */
-                $sp_match[1] = array_unique($sp_match[1]);
-                usort($sp_match[1], '_smarty_sort_length');
-                for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp < $for_max2; $curr_sp++) {
-                    $text_blocks[$curr_tb] = str_replace($sp_match[1][$curr_sp],'%%%SMARTYSP'.$curr_sp.'%%%',$text_blocks[$curr_tb]);
-                }
-                /* process each one */
-                for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp < $for_max2; $curr_sp++) {
-                    if ($this->php_handling == SMARTY_PHP_PASSTHRU) {
-                        /* echo php contents */
-                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', '<?php echo \''.str_replace("'", "\'", $sp_match[1][$curr_sp]).'\'; ?>'."\n", $text_blocks[$curr_tb]);
-                    } else if ($this->php_handling == SMARTY_PHP_QUOTE) {
-                        /* quote php tags */
-                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', htmlspecialchars($sp_match[1][$curr_sp]), $text_blocks[$curr_tb]);
-                    } else if ($this->php_handling == SMARTY_PHP_REMOVE) {
-                        /* remove php tags */
-                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', '', $text_blocks[$curr_tb]);
-                    } else {
-                        /* SMARTY_PHP_ALLOW, but echo non php starting tags */
-                        $sp_match[1][$curr_sp] = preg_replace('~(<\?(?!php|=|$))~i', '<?php echo \'\\1\'?>'."\n", $sp_match[1][$curr_sp]);
-                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', $sp_match[1][$curr_sp], $text_blocks[$curr_tb]);
-                    }
-                }
-            }
-        }
-        
-        /* Compile the template tags into PHP code. */
-        $compiled_tags = array();
-        for ($i = 0, $for_max = count($template_tags); $i < $for_max; $i++) {
-            $this->_current_line_no += substr_count($text_blocks[$i], "\n");
-            $compiled_tags[] = $this->_compile_tag($template_tags[$i]);
-            $this->_current_line_no += substr_count($template_tags[$i], "\n");
-        }
-        if (count($this->_tag_stack)>0) {
-            list($_open_tag, $_line_no) = end($this->_tag_stack);
-            $this->_syntax_error("unclosed tag \{$_open_tag} (opened line $_line_no).", E_USER_ERROR, __FILE__, __LINE__);
-            return;
-        }
-
-        /* Reformat $text_blocks between 'strip' and '/strip' tags,
-           removing spaces, tabs and newlines. */
-        $strip = false;
-        for ($i = 0, $for_max = count($compiled_tags); $i < $for_max; $i++) {
-            if ($compiled_tags[$i] == '{strip}') {
-                $compiled_tags[$i] = '';
-                $strip = true;
-                /* remove leading whitespaces */
-                $text_blocks[$i + 1] = ltrim($text_blocks[$i + 1]);
-            }
-            if ($strip) {
-                /* strip all $text_blocks before the next '/strip' */
-                for ($j = $i + 1; $j < $for_max; $j++) {
-                    /* remove leading and trailing whitespaces of each line */
-                    $text_blocks[$j] = preg_replace('![\t ]*[\r\n]+[\t ]*!', '', $text_blocks[$j]);
-                    if ($compiled_tags[$j] == '{/strip}') {                       
-                        /* remove trailing whitespaces from the last text_block */
-                        $text_blocks[$j] = rtrim($text_blocks[$j]);
-                    }
-                    $text_blocks[$j] = "<?php echo '" . strtr($text_blocks[$j], array("'"=>"\'", "\\"=>"\\\\")) . "'; ?>";
-                    if ($compiled_tags[$j] == '{/strip}') {
-                        $compiled_tags[$j] = "\n"; /* slurped by php, but necessary
-                                    if a newline is following the closing strip-tag */
-                        $strip = false;
-                        $i = $j;
-                        break;
-                    }
-                }
-            }
-        }
-        $compiled_content = '';
-        
-        $tag_guard = '%%%SMARTYOTG' . md5(uniqid(rand(), true)) . '%%%';
-        
-        /* Interleave the compiled contents and text blocks to get the final result. */
-        for ($i = 0, $for_max = count($compiled_tags); $i < $for_max; $i++) {
-            if ($compiled_tags[$i] == '') {
-                // tag result empty, remove first newline from following text block
-                $text_blocks[$i+1] = preg_replace('~^(\r\n|\r|\n)~', '', $text_blocks[$i+1]);
-            }
-            // replace legit PHP tags with placeholder
-            $text_blocks[$i] = str_replace('<?', $tag_guard, $text_blocks[$i]);
-            $compiled_tags[$i] = str_replace('<?', $tag_guard, $compiled_tags[$i]);
-            
-            $compiled_content .= $text_blocks[$i] . $compiled_tags[$i];
-        }
-        $compiled_content .= str_replace('<?', $tag_guard, $text_blocks[$i]);
-
-        // escape php tags created by interleaving
-        $compiled_content = str_replace('<?', "<?php echo '<?' ?>\n", $compiled_content);
-        $compiled_content = preg_replace("~(?<!')language\s*=\s*[\"\']?\s*php\s*[\"\']?~", "<?php echo 'language=php' ?>\n", $compiled_content);
-
-        // recover legit tags
-        $compiled_content = str_replace($tag_guard, '<?', $compiled_content); 
-        
-        // remove \n from the end of the file, if any
-        if (strlen($compiled_content) && (substr($compiled_content, -1) == "\n") ) {
-            $compiled_content = substr($compiled_content, 0, -1);
-        }
-
-        if (!empty($this->_cache_serial)) {
-            $compiled_content = "<?php \$this->_cache_serials['".$this->_cache_include."'] = '".$this->_cache_serial."'; ?>" . $compiled_content;
-        }
-
-        // run compiled template through postfilter functions
-        if (count($this->_plugins['postfilter']) > 0) {
-            foreach ($this->_plugins['postfilter'] as $filter_name => $postfilter) {
-                if ($postfilter === false) continue;
-                if ($postfilter[3] || is_callable($postfilter[0])) {
-                    $compiled_content = call_user_func_array($postfilter[0],
-                                                              array($compiled_content, &$this));
-                    $this->_plugins['postfilter'][$filter_name][3] = true;
-                } else {
-                    $this->_trigger_fatal_error("Smarty plugin error: postfilter '$filter_name' is not implemented");
-                }
-            }
-        }
-
-        // put header at the top of the compiled template
-        $template_header = "<?php /* Smarty version ".$this->_version.", created on ".strftime("%Y-%m-%d %H:%M:%S")."\n";
-        $template_header .= "         compiled from ".strtr(urlencode($resource_name), array('%2F'=>'/', '%3A'=>':'))." */ ?>\n";
-
-        /* Emit code to load needed plugins. */
-        $this->_plugins_code = '';
-        if (count($this->_plugin_info)) {
-            $_plugins_params = "array('plugins' => array(";
-            foreach ($this->_plugin_info as $plugin_type => $plugins) {
-                foreach ($plugins as $plugin_name => $plugin_info) {
-                    $_plugins_params .= "array('$plugin_type', '$plugin_name', '" . strtr($plugin_info[0], array("'" => "\\'", "\\" => "\\\\")) . "', $plugin_info[1], ";
-                    $_plugins_params .= $plugin_info[2] ? 'true),' : 'false),';
-                }
-            }
-            $_plugins_params .= '))';
-            $plugins_code = "<?php require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');\nsmarty_core_load_plugins($_plugins_params, \$this); ?>\n";
-            $template_header .= $plugins_code;
-            $this->_plugin_info = array();
-            $this->_plugins_code = $plugins_code;
-        }
-
-        if ($this->_init_smarty_vars) {
-            $template_header .= "<?php require_once(SMARTY_CORE_DIR . 'core.assign_smarty_interface.php');\nsmarty_core_assign_smarty_interface(null, \$this); ?>\n";
-            $this->_init_smarty_vars = false;
-        }
-
-        $compiled_content = $template_header . $compiled_content;
-        return true;
-    }
-
-    /**
-     * Compile a template tag
-     *
-     * @param string $template_tag
-     * @return string
-     */
-    function _compile_tag($template_tag)
-    {
-        /* Matched comment. */
-        if (substr($template_tag, 0, 1) == '*' && substr($template_tag, -1) == '*')
-            return '';
-        
-        /* Split tag into two three parts: command, command modifiers and the arguments. */
-        if(! preg_match('~^(?:(' . $this->_num_const_regexp . '|' . $this->_obj_call_regexp . '|' . $this->_var_regexp
-                . '|\/?' . $this->_reg_obj_regexp . '|\/?' . $this->_func_regexp . ')(' . $this->_mod_regexp . '*))
-                      (?:\s+(.*))?$
-                    ~xs', $template_tag, $match)) {
-            $this->_syntax_error("unrecognized tag: $template_tag", E_USER_ERROR, __FILE__, __LINE__);
-        }
-        
-        $tag_command = $match[1];
-        $tag_modifier = isset($match[2]) ? $match[2] : null;
-        $tag_args = isset($match[3]) ? $match[3] : null;
-
-        if (preg_match('~^' . $this->_num_const_regexp . '|' . $this->_obj_call_regexp . '|' . $this->_var_regexp . '$~', $tag_command)) {
-            /* tag name is a variable or object */
-            $_return = $this->_parse_var_props($tag_command . $tag_modifier);
-            return "<?php echo $_return; ?>" . $this->_additional_newline;
-        }
-
-        /* If the tag name is a registered object, we process it. */
-        if (preg_match('~^\/?' . $this->_reg_obj_regexp . '$~', $tag_command)) {
-            return $this->_compile_registered_object_tag($tag_command, $this->_parse_attrs($tag_args), $tag_modifier);
-        }
-
-        switch ($tag_command) {
-            case 'include':
-                return $this->_compile_include_tag($tag_args);
-
-            case 'include_php':
-                return $this->_compile_include_php_tag($tag_args);
-
-            case 'if':
-                $this->_push_tag('if');
-                return $this->_compile_if_tag($tag_args);
-
-            case 'else':
-                list($_open_tag) = end($this->_tag_stack);
-                if ($_open_tag != 'if' && $_open_tag != 'elseif')
-                    $this->_syntax_error('unexpected {else}', E_USER_ERROR, __FILE__, __LINE__);
-                else
-                    $this->_push_tag('else');
-                return '<?php else: ?>';
-
-            case 'elseif':
-                list($_open_tag) = end($this->_tag_stack);
-                if ($_open_tag != 'if' && $_open_tag != 'elseif')
-                    $this->_syntax_error('unexpected {elseif}', E_USER_ERROR, __FILE__, __LINE__);
-                if ($_open_tag == 'if')
-                    $this->_push_tag('elseif');
-                return $this->_compile_if_tag($tag_args, true);
-
-            case '/if':
-                $this->_pop_tag('if');
-                return '<?php endif; ?>';
-
-            case 'capture':
-                return $this->_compile_capture_tag(true, $tag_args);
-
-            case '/capture':
-                return $this->_compile_capture_tag(false);
-
-            case 'ldelim':
-                return $this->left_delimiter;
-
-            case 'rdelim':
-                return $this->right_delimiter;
-
-            case 'section':
-                $this->_push_tag('section');
-                return $this->_compile_section_start($tag_args);
-
-            case 'sectionelse':
-                $this->_push_tag('sectionelse');
-                return "<?php endfor; else: ?>";
-                break;
-
-            case '/section':
-                $_open_tag = $this->_pop_tag('section');
-                if ($_open_tag == 'sectionelse')
-                    return "<?php endif; ?>";
-                else
-                    return "<?php endfor; endif; ?>";
-
-            case 'foreach':
-                $this->_push_tag('foreach');
-                return $this->_compile_foreach_start($tag_args);
-                break;
-
-            case 'foreachelse':
-                $this->_push_tag('foreachelse');
-                return "<?php endforeach; else: ?>";
-
-            case '/foreach':
-                $_open_tag = $this->_pop_tag('foreach');
-                if ($_open_tag == 'foreachelse')
-                    return "<?php endif; unset(\$_from); ?>";
-                else
-                    return "<?php endforeach; endif; unset(\$_from); ?>";
-                break;
-
-            case 'strip':
-            case '/strip':
-                if (substr($tag_command, 0, 1)=='/') {
-                    $this->_pop_tag('strip');
-                    if (--$this->_strip_depth==0) { /* outermost closing {/strip} */
-                        $this->_additional_newline = "\n";
-                        return '{' . $tag_command . '}';
-                    }
-                } else {
-                    $this->_push_tag('strip');
-                    if ($this->_strip_depth++==0) { /* outermost opening {strip} */
-                        $this->_additional_newline = "";
-                        return '{' . $tag_command . '}';
-                    }
-                }
-                return '';
-
-            case 'php':
-                /* handle folded tags replaced by {php} */
-                list(, $block) = each($this->_folded_blocks);
-                $this->_current_line_no += substr_count($block[0], "\n");
-                /* the number of matched elements in the regexp in _compile_file()
-                   determins the type of folded tag that was found */
-                switch (count($block)) {
-                    case 2: /* comment */
-                        return '';
-
-                    case 3: /* literal */
-                        return "<?php echo '" . strtr($block[2], array("'"=>"\'", "\\"=>"\\\\")) . "'; ?>" . $this->_additional_newline;
-
-                    case 4: /* php */
-                        if ($this->security && !$this->security_settings['PHP_TAGS']) {
-                            $this->_syntax_error("(secure mode) php tags not permitted", E_USER_WARNING, __FILE__, __LINE__);
-                            return;
-                        }
-                        return '<?php ' . $block[3] .' ?>';
-                }
-                break;
-
-            case 'insert':
-                return $this->_compile_insert_tag($tag_args);
-
-            default:
-                if ($this->_compile_compiler_tag($tag_command, $tag_args, $output)) {
-                    return $output;
-                } else if ($this->_compile_block_tag($tag_command, $tag_args, $tag_modifier, $output)) {
-                    return $output;
-                } else if ($this->_compile_custom_tag($tag_command, $tag_args, $tag_modifier, $output)) {
-                    return $output;                    
-                } else {
-                    $this->_syntax_error("unrecognized tag '$tag_command'", E_USER_ERROR, __FILE__, __LINE__);
-                }
-
-        }
-    }
-
-
-    /**
-     * compile the custom compiler tag
-     *
-     * sets $output to the compiled custom compiler tag
-     * @param string $tag_command
-     * @param string $tag_args
-     * @param string $output
-     * @return boolean
-     */
-    function _compile_compiler_tag($tag_command, $tag_args, &$output)
-    {
-        $found = false;
-        $have_function = true;
-
-        /*
-         * First we check if the compiler function has already been registered
-         * or loaded from a plugin file.
-         */
-        if (isset($this->_plugins['compiler'][$tag_command])) {
-            $found = true;
-            $plugin_func = $this->_plugins['compiler'][$tag_command][0];
-            if (!is_callable($plugin_func)) {
-                $message = "compiler function '$tag_command' is not implemented";
-                $have_function = false;
-            }
-        }
-        /*
-         * Otherwise we need to load plugin file and look for the function
-         * inside it.
-         */
-        else if ($plugin_file = $this->_get_plugin_filepath('compiler', $tag_command)) {
-            $found = true;
-
-            include_once $plugin_file;
-
-            $plugin_func = 'smarty_compiler_' . $tag_command;
-            if (!is_callable($plugin_func)) {
-                $message = "plugin function $plugin_func() not found in $plugin_file\n";
-                $have_function = false;
-            } else {
-                $this->_plugins['compiler'][$tag_command] = array($plugin_func, null, null, null, true);
-            }
-        }
-
-        /*
-         * True return value means that we either found a plugin or a
-         * dynamically registered function. False means that we didn't and the
-         * compiler should now emit code to load custom function plugin for this
-         * tag.
-         */
-        if ($found) {
-            if ($have_function) {
-                $output = call_user_func_array($plugin_func, array($tag_args, &$this));
-                if($output != '') {
-                $output = '<?php ' . $this->_push_cacheable_state('compiler', $tag_command)
-                                   . $output
-                                   . $this->_pop_cacheable_state('compiler', $tag_command) . ' ?>';
-                }
-            } else {
-                $this->_syntax_error($message, E_USER_WARNING, __FILE__, __LINE__);
-            }
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-
-    /**
-     * compile block function tag
-     *
-     * sets $output to compiled block function tag
-     * @param string $tag_command
-     * @param string $tag_args
-     * @param string $tag_modifier
-     * @param string $output
-     * @return boolean
-     */
-    function _compile_block_tag($tag_command, $tag_args, $tag_modifier, &$output)
-    {
-        if (substr($tag_command, 0, 1) == '/') {
-            $start_tag = false;
-            $tag_command = substr($tag_command, 1);
-        } else
-            $start_tag = true;
-
-        $found = false;
-        $have_function = true;
-
-        /*
-         * First we check if the block function has already been registered
-         * or loaded from a plugin file.
-         */
-        if (isset($this->_plugins['block'][$tag_command])) {
-            $found = true;
-            $plugin_func = $this->_plugins['block'][$tag_command][0];
-            if (!is_callable($plugin_func)) {
-                $message = "block function '$tag_command' is not implemented";
-                $have_function = false;
-            }
-        }
-        /*
-         * Otherwise we need to load plugin file and look for the function
-         * inside it.
-         */
-        else if ($plugin_file = $this->_get_plugin_filepath('block', $tag_command)) {
-            $found = true;
-
-            include_once $plugin_file;
-
-            $plugin_func = 'smarty_block_' . $tag_command;
-            if (!function_exists($plugin_func)) {
-                $message = "plugin function $plugin_func() not found in $plugin_file\n";
-                $have_function = false;
-            } else {
-                $this->_plugins['block'][$tag_command] = array($plugin_func, null, null, null, true);
-
-            }
-        }
-
-        if (!$found) {
-            return false;
-        } else if (!$have_function) {
-            $this->_syntax_error($message, E_USER_WARNING, __FILE__, __LINE__);
-            return true;
-        }
-
-        /*
-         * Even though we've located the plugin function, compilation
-         * happens only once, so the plugin will still need to be loaded
-         * at runtime for future requests.
-         */
-        $this->_add_plugin('block', $tag_command);
-
-        if ($start_tag)
-            $this->_push_tag($tag_command);
-        else
-            $this->_pop_tag($tag_command);
-
-        if ($start_tag) {
-            $output = '<?php ' . $this->_push_cacheable_state('block', $tag_command);
-            $attrs = $this->_parse_attrs($tag_args);
-            $_cache_attrs='';
-            $arg_list = $this->_compile_arg_list('block', $tag_command, $attrs, $_cache_attrs);
-            $output .= "$_cache_attrs\$this->_tag_stack[] = array('$tag_command', array(".implode(',', $arg_list).')); ';
-            $output .= '$_block_repeat=true;' . $this->_compile_plugin_call('block', $tag_command).'($this->_tag_stack[count($this->_tag_stack)-1][1], null, $this, $_block_repeat);';
-            $output .= 'while ($_block_repeat) { ob_start(); ?>';
-        } else {
-            $output = '<?php $_block_content = ob_get_contents(); ob_end_clean(); ';
-            $_out_tag_text = $this->_compile_plugin_call('block', $tag_command).'($this->_tag_stack[count($this->_tag_stack)-1][1], $_block_content, $this, $_block_repeat)';
-            if ($tag_modifier != '') {
-                $this->_parse_modifiers($_out_tag_text, $tag_modifier);
-            }
-            $output .= '$_block_repeat=false;echo ' . $_out_tag_text . '; } ';
-            $output .= " array_pop(\$this->_tag_stack); " . $this->_pop_cacheable_state('block', $tag_command) . '?>';
-        }
-
-        return true;
-    }
-
-
-    /**
-     * compile custom function tag
-     *
-     * @param string $tag_command
-     * @param string $tag_args
-     * @param string $tag_modifier
-     * @return string
-     */
-    function _compile_custom_tag($tag_command, $tag_args, $tag_modifier, &$output)
-    {
-        $found = false;
-        $have_function = true;
-
-        /*
-         * First we check if the custom function has already been registered
-         * or loaded from a plugin file.
-         */
-        if (isset($this->_plugins['function'][$tag_command])) {
-            $found = true;
-            $plugin_func = $this->_plugins['function'][$tag_command][0];
-            if (!is_callable($plugin_func)) {
-                $message = "custom function '$tag_command' is not implemented";
-                $have_function = false;
-            }
-        }
-        /*
-         * Otherwise we need to load plugin file and look for the function
-         * inside it.
-         */
-        else if ($plugin_file = $this->_get_plugin_filepath('function', $tag_command)) {
-            $found = true;
-
-            include_once $plugin_file;
-
-            $plugin_func = 'smarty_function_' . $tag_command;
-            if (!function_exists($plugin_func)) {
-                $message = "plugin function $plugin_func() not found in $plugin_file\n";
-                $have_function = false;
-            } else {
-                $this->_plugins['function'][$tag_command] = array($plugin_func, null, null, null, true);
-
-            }
-        }
-
-        if (!$found) {
-            return false;
-        } else if (!$have_function) {
-            $this->_syntax_error($message, E_USER_WARNING, __FILE__, __LINE__);
-            return true;
-        }
-
-        /* declare plugin to be loaded on display of the template that
-           we compile right now */
-        $this->_add_plugin('function', $tag_command);
-
-        $_cacheable_state = $this->_push_cacheable_state('function', $tag_command);
-        $attrs = $this->_parse_attrs($tag_args);
-        $_cache_attrs = '';
-        $arg_list = $this->_compile_arg_list('function', $tag_command, $attrs, $_cache_attrs);
-
-        $output = $this->_compile_plugin_call('function', $tag_command).'(array('.implode(',', $arg_list)."), \$this)";
-        if($tag_modifier != '') {
-            $this->_parse_modifiers($output, $tag_modifier);
-        }
-
-        if($output != '') {
-            $output =  '<?php ' . $_cacheable_state . $_cache_attrs . 'echo ' . $output . ';'
-                . $this->_pop_cacheable_state('function', $tag_command) . "?>" . $this->_additional_newline;
-        }
-
-        return true;
-    }
-
-    /**
-     * compile a registered object tag
-     *
-     * @param string $tag_command
-     * @param array $attrs
-     * @param string $tag_modifier
-     * @return string
-     */
-    function _compile_registered_object_tag($tag_command, $attrs, $tag_modifier)
-    {
-        if (substr($tag_command, 0, 1) == '/') {
-            $start_tag = false;
-            $tag_command = substr($tag_command, 1);
-        } else {
-            $start_tag = true;
-        }
-
-        list($object, $obj_comp) = explode('->', $tag_command);
-
-        $arg_list = array();
-        if(count($attrs)) {
-            $_assign_var = false;
-            foreach ($attrs as $arg_name => $arg_value) {
-                if($arg_name == 'assign') {
-                    $_assign_var = $arg_value;
-                    unset($attrs['assign']);
-                    continue;
-                }
-                if (is_bool($arg_value))
-                    $arg_value = $arg_value ? 'true' : 'false';
-                $arg_list[] = "'$arg_name' => $arg_value";
-            }
-        }
-
-        if($this->_reg_objects[$object][2]) {
-            // smarty object argument format
-            $args = "array(".implode(',', (array)$arg_list)."), \$this";
-        } else {
-            // traditional argument format
-            $args = implode(',', array_values($attrs));
-            if (empty($args)) {
-                $args = '';
-            }
-        }
-
-        $prefix = '';
-        $postfix = '';
-        $newline = '';
-        if(!is_object($this->_reg_objects[$object][0])) {
-            $this->_trigger_fatal_error("registered '$object' is not an object" , $this->_current_file, $this->_current_line_no, __FILE__, __LINE__);
-        } elseif(!empty($this->_reg_objects[$object][1]) && !in_array($obj_comp, $this->_reg_objects[$object][1])) {
-            $this->_trigger_fatal_error("'$obj_comp' is not a registered component of object '$object'", $this->_current_file, $this->_current_line_no, __FILE__, __LINE__);
-        } elseif(method_exists($this->_reg_objects[$object][0], $obj_comp)) {
-            // method
-            if(in_array($obj_comp, $this->_reg_objects[$object][3])) {
-                // block method
-                if ($start_tag) {
-                    $prefix = "\$this->_tag_stack[] = array('$obj_comp', $args); ";
-                    $prefix .= "\$_block_repeat=true; \$this->_reg_objects['$object'][0]->$obj_comp(\$this->_tag_stack[count(\$this->_tag_stack)-1][1], null, \$this, \$_block_repeat); ";
-                    $prefix .= "while (\$_block_repeat) { ob_start();";
-                    $return = null;
-                    $postfix = '';
-                } else {
-                    $prefix = "\$_obj_block_content = ob_get_contents(); ob_end_clean(); \$_block_repeat=false;";
-                    $return = "\$this->_reg_objects['$object'][0]->$obj_comp(\$this->_tag_stack[count(\$this->_tag_stack)-1][1], \$_obj_block_content, \$this, \$_block_repeat)";
-                    $postfix = "} array_pop(\$this->_tag_stack);";
-                }
-            } else {
-                // non-block method
-                $return = "\$this->_reg_objects['$object'][0]->$obj_comp($args)";
-            }
-        } else {
-            // property
-            $return = "\$this->_reg_objects['$object'][0]->$obj_comp";
-        }
-
-        if($return != null) {
-            if($tag_modifier != '') {
-                $this->_parse_modifiers($return, $tag_modifier);
-            }
-
-            if(!empty($_assign_var)) {
-                $output = "\$this->assign('" . $this->_dequote($_assign_var) ."',  $return);";
-            } else {
-                $output = 'echo ' . $return . ';';
-                $newline = $this->_additional_newline;
-            }
-        } else {
-            $output = '';
-        }
-
-        return '<?php ' . $prefix . $output . $postfix . "?>" . $newline;
-    }
-
-    /**
-     * Compile {insert ...} tag
-     *
-     * @param string $tag_args
-     * @return string
-     */
-    function _compile_insert_tag($tag_args)
-    {
-        $attrs = $this->_parse_attrs($tag_args);
-        $name = $this->_dequote($attrs['name']);
-
-        if (empty($name)) {
-            return $this->_syntax_error("missing insert name", E_USER_ERROR, __FILE__, __LINE__);
-        }
-        
-        if (!preg_match('~^\w+$~', $name)) {
-            return $this->_syntax_error("'insert: 'name' must be an insert function name", E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        if (!empty($attrs['script'])) {
-            $delayed_loading = true;
-        } else {
-            $delayed_loading = false;
-        }
-
-        foreach ($attrs as $arg_name => $arg_value) {
-            if (is_bool($arg_value))
-                $arg_value = $arg_value ? 'true' : 'false';
-            $arg_list[] = "'$arg_name' => $arg_value";
-        }
-
-        $this->_add_plugin('insert', $name, $delayed_loading);
-
-        $_params = "array('args' => array(".implode(', ', (array)$arg_list)."))";
-
-        return "<?php require_once(SMARTY_CORE_DIR . 'core.run_insert_handler.php');\necho smarty_core_run_insert_handler($_params, \$this); ?>" . $this->_additional_newline;
-    }
-
-    /**
-     * Compile {include ...} tag
-     *
-     * @param string $tag_args
-     * @return string
-     */
-    function _compile_include_tag($tag_args)
-    {
-        $attrs = $this->_parse_attrs($tag_args);
-        $arg_list = array();
-
-        if (empty($attrs['file'])) {
-            $this->_syntax_error("missing 'file' attribute in include tag", E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        foreach ($attrs as $arg_name => $arg_value) {
-            if ($arg_name == 'file') {
-                $include_file = $arg_value;
-                continue;
-            } else if ($arg_name == 'assign') {
-                $assign_var = $arg_value;
-                continue;
-            }
-            if (is_bool($arg_value))
-                $arg_value = $arg_value ? 'true' : 'false';
-            $arg_list[] = "'$arg_name' => $arg_value";
-        }
-
-        $output = '<?php ';
-
-        if (isset($assign_var)) {
-            $output .= "ob_start();\n";
-        }
-
-        $output .=
-            "\$_smarty_tpl_vars = \$this->_tpl_vars;\n";
-
-
-        $_params = "array('smarty_include_tpl_file' => " . $include_file . ", 'smarty_include_vars' => array(".implode(',', (array)$arg_list)."))";
-        $output .= "\$this->_smarty_include($_params);\n" .
-        "\$this->_tpl_vars = \$_smarty_tpl_vars;\n" .
-        "unset(\$_smarty_tpl_vars);\n";
-
-        if (isset($assign_var)) {
-            $output .= "\$this->assign(" . $assign_var . ", ob_get_contents()); ob_end_clean();\n";
-        }
-
-        $output .= ' ?>';
-
-        return $output;
-
-    }
-
-    /**
-     * Compile {include ...} tag
-     *
-     * @param string $tag_args
-     * @return string
-     */
-    function _compile_include_php_tag($tag_args)
-    {
-        $attrs = $this->_parse_attrs($tag_args);
-
-        if (empty($attrs['file'])) {
-            $this->_syntax_error("missing 'file' attribute in include_php tag", E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        $assign_var = (empty($attrs['assign'])) ? '' : $this->_dequote($attrs['assign']);
-        $once_var = (empty($attrs['once']) || $attrs['once']=='false') ? 'false' : 'true';
-
-        $arg_list = array();
-        foreach($attrs as $arg_name => $arg_value) {
-            if($arg_name != 'file' AND $arg_name != 'once' AND $arg_name != 'assign') {
-                if(is_bool($arg_value))
-                    $arg_value = $arg_value ? 'true' : 'false';
-                $arg_list[] = "'$arg_name' => $arg_value";
-            }
-        }
-
-        $_params = "array('smarty_file' => " . $attrs['file'] . ", 'smarty_assign' => '$assign_var', 'smarty_once' => $once_var, 'smarty_include_vars' => array(".implode(',', $arg_list)."))";
-
-        return "<?php require_once(SMARTY_CORE_DIR . 'core.smarty_include_php.php');\nsmarty_core_smarty_include_php($_params, \$this); ?>" . $this->_additional_newline;
-    }
-
-
-    /**
-     * Compile {section ...} tag
-     *
-     * @param string $tag_args
-     * @return string
-     */
-    function _compile_section_start($tag_args)
-    {
-        $attrs = $this->_parse_attrs($tag_args);
-        $arg_list = array();
-
-        $output = '<?php ';
-        $section_name = $attrs['name'];
-        if (empty($section_name)) {
-            $this->_syntax_error("missing section name", E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        $output .= "unset(\$this->_sections[$section_name]);\n";
-        $section_props = "\$this->_sections[$section_name]";
-
-        foreach ($attrs as $attr_name => $attr_value) {
-            switch ($attr_name) {
-                case 'loop':
-                    $output .= "{$section_props}['loop'] = is_array(\$_loop=$attr_value) ? count(\$_loop) : max(0, (int)\$_loop); unset(\$_loop);\n";
-                    break;
-
-                case 'show':
-                    if (is_bool($attr_value))
-                        $show_attr_value = $attr_value ? 'true' : 'false';
-                    else
-                        $show_attr_value = "(bool)$attr_value";
-                    $output .= "{$section_props}['show'] = $show_attr_value;\n";
-                    break;
-
-                case 'name':
-                    $output .= "{$section_props}['$attr_name'] = $attr_value;\n";
-                    break;
-
-                case 'max':
-                case 'start':
-                    $output .= "{$section_props}['$attr_name'] = (int)$attr_value;\n";
-                    break;
-
-                case 'step':
-                    $output .= "{$section_props}['$attr_name'] = ((int)$attr_value) == 0 ? 1 : (int)$attr_value;\n";
-                    break;
-
-                default:
-                    $this->_syntax_error("unknown section attribute - '$attr_name'", E_USER_ERROR, __FILE__, __LINE__);
-                    break;
-            }
-        }
-
-        if (!isset($attrs['show']))
-            $output .= "{$section_props}['show'] = true;\n";
-
-        if (!isset($attrs['loop']))
-            $output .= "{$section_props}['loop'] = 1;\n";
-
-        if (!isset($attrs['max']))
-            $output .= "{$section_props}['max'] = {$section_props}['loop'];\n";
-        else
-            $output .= "if ({$section_props}['max'] < 0)\n" .
-                       "    {$section_props}['max'] = {$section_props}['loop'];\n";
-
-        if (!isset($attrs['step']))
-            $output .= "{$section_props}['step'] = 1;\n";
-
-        if (!isset($attrs['start']))
-            $output .= "{$section_props}['start'] = {$section_props}['step'] > 0 ? 0 : {$section_props}['loop']-1;\n";
-        else {
-            $output .= "if ({$section_props}['start'] < 0)\n" .
-                       "    {$section_props}['start'] = max({$section_props}['step'] > 0 ? 0 : -1, {$section_props}['loop'] + {$section_props}['start']);\n" .
-                       "else\n" .
-                       "    {$section_props}['start'] = min({$section_props}['start'], {$section_props}['step'] > 0 ? {$section_props}['loop'] : {$section_props}['loop']-1);\n";
-        }
-
-        $output .= "if ({$section_props}['show']) {\n";
-        if (!isset($attrs['start']) && !isset($attrs['step']) && !isset($attrs['max'])) {
-            $output .= "    {$section_props}['total'] = {$section_props}['loop'];\n";
-        } else {
-            $output .= "    {$section_props}['total'] = min(ceil(({$section_props}['step'] > 0 ? {$section_props}['loop'] - {$section_props}['start'] : {$section_props}['start']+1)/abs({$section_props}['step'])), {$section_props}['max']);\n";
-        }
-        $output .= "    if ({$section_props}['total'] == 0)\n" .
-                   "        {$section_props}['show'] = false;\n" .
-                   "} else\n" .
-                   "    {$section_props}['total'] = 0;\n";
-
-        $output .= "if ({$section_props}['show']):\n";
-        $output .= "
-            for ({$section_props}['index'] = {$section_props}['start'], {$section_props}['iteration'] = 1;
-                 {$section_props}['iteration'] <= {$section_props}['total'];
-                 {$section_props}['index'] += {$section_props}['step'], {$section_props}['iteration']++):\n";
-        $output .= "{$section_props}['rownum'] = {$section_props}['iteration'];\n";
-        $output .= "{$section_props}['index_prev'] = {$section_props}['index'] - {$section_props}['step'];\n";
-        $output .= "{$section_props}['index_next'] = {$section_props}['index'] + {$section_props}['step'];\n";
-        $output .= "{$section_props}['first']      = ({$section_props}['iteration'] == 1);\n";
-        $output .= "{$section_props}['last']       = ({$section_props}['iteration'] == {$section_props}['total']);\n";
-
-        $output .= "?>";
-
-        return $output;
-    }
-
-
-    /**
-     * Compile {foreach ...} tag.
-     *
-     * @param string $tag_args
-     * @return string
-     */
-    function _compile_foreach_start($tag_args)
-    {
-        $attrs = $this->_parse_attrs($tag_args);
-        $arg_list = array();
-
-        if (empty($attrs['from'])) {
-            return $this->_syntax_error("foreach: missing 'from' attribute", E_USER_ERROR, __FILE__, __LINE__);
-        }
-        $from = $attrs['from'];
-
-        if (empty($attrs['item'])) {
-            return $this->_syntax_error("foreach: missing 'item' attribute", E_USER_ERROR, __FILE__, __LINE__);
-        }
-        $item = $this->_dequote($attrs['item']);
-        if (!preg_match('~^\w+$~', $item)) {
-            return $this->_syntax_error("foreach: 'item' must be a variable name (literal string)", E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        if (isset($attrs['key'])) {
-            $key  = $this->_dequote($attrs['key']);
-            if (!preg_match('~^\w+$~', $key)) {
-                return $this->_syntax_error("foreach: 'key' must to be a variable name (literal string)", E_USER_ERROR, __FILE__, __LINE__);
-            }
-            $key_part = "\$this->_tpl_vars['$key'] => ";
-        } else {
-            $key = null;
-            $key_part = '';
-        }
-
-        if (isset($attrs['name'])) {
-            $name = $attrs['name'];
-        } else {
-            $name = null;
-        }
-
-        $output = '<?php ';
-        $output .= "\$_from = $from; if (!is_array(\$_from) && !is_object(\$_from)) { settype(\$_from, 'array'); }";
-        if (isset($name)) {
-            $foreach_props = "\$this->_foreach[$name]";
-            $output .= "{$foreach_props} = array('total' => count(\$_from), 'iteration' => 0);\n";
-            $output .= "if ({$foreach_props}['total'] > 0):\n";
-            $output .= "    foreach (\$_from as $key_part\$this->_tpl_vars['$item']):\n";
-            $output .= "        {$foreach_props}['iteration']++;\n";
-        } else {
-            $output .= "if (count(\$_from)):\n";
-            $output .= "    foreach (\$_from as $key_part\$this->_tpl_vars['$item']):\n";
-        }
-        $output .= '?>';
-
-        return $output;
-    }
-
-
-    /**
-     * Compile {capture} .. {/capture} tags
-     *
-     * @param boolean $start true if this is the {capture} tag
-     * @param string $tag_args
-     * @return string
-     */
-
-    function _compile_capture_tag($start, $tag_args = '')
-    {
-        $attrs = $this->_parse_attrs($tag_args);
-
-        if ($start) {
-            $buffer = isset($attrs['name']) ? $attrs['name'] : "'default'";
-            $assign = isset($attrs['assign']) ? $attrs['assign'] : null;
-            $append = isset($attrs['append']) ? $attrs['append'] : null;
-            
-            $output = "<?php ob_start(); ?>";
-            $this->_capture_stack[] = array($buffer, $assign, $append);
-        } else {
-            list($buffer, $assign, $append) = array_pop($this->_capture_stack);
-            $output = "<?php \$this->_smarty_vars['capture'][$buffer] = ob_get_contents(); ";
-            if (isset($assign)) {
-                $output .= " \$this->assign($assign, ob_get_contents());";
-            }
-            if (isset($append)) {
-                $output .= " \$this->append($append, ob_get_contents());";
-            }
-            $output .= "ob_end_clean(); ?>";
-        }
-
-        return $output;
-    }
-
-    /**
-     * Compile {if ...} tag
-     *
-     * @param string $tag_args
-     * @param boolean $elseif if true, uses elseif instead of if
-     * @return string
-     */
-    function _compile_if_tag($tag_args, $elseif = false)
-    {
-
-        /* Tokenize args for 'if' tag. */
-        preg_match_all('~(?>
-                ' . $this->_obj_call_regexp . '(?:' . $this->_mod_regexp . '*)? | # valid object call
-                ' . $this->_var_regexp . '(?:' . $this->_mod_regexp . '*)?    | # var or quoted string
-                \-?0[xX][0-9a-fA-F]+|\-?\d+(?:\.\d+)?|\.\d+|!==|===|==|!=|<>|<<|>>|<=|>=|\&\&|\|\||\(|\)|,|\!|\^|=|\&|\~|<|>|\||\%|\+|\-|\/|\*|\@    | # valid non-word token
-                \b\w+\b                                                        | # valid word token
-                \S+                                                           # anything else
-                )~x', $tag_args, $match);
-
-        $tokens = $match[0];
-
-        if(empty($tokens)) {
-            $_error_msg = $elseif ? "'elseif'" : "'if'";
-            $_error_msg .= ' statement requires arguments'; 
-            $this->_syntax_error($_error_msg, E_USER_ERROR, __FILE__, __LINE__);
-        }
-            
-                
-        // make sure we have balanced parenthesis
-        $token_count = array_count_values($tokens);
-        if(isset($token_count['(']) && $token_count['('] != $token_count[')']) {
-            $this->_syntax_error("unbalanced parenthesis in if statement", E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        $is_arg_stack = array();
-
-        for ($i = 0; $i < count($tokens); $i++) {
-
-            $token = &$tokens[$i];
-
-            switch (strtolower($token)) {
-                case '!':
-                case '%':
-                case '!==':
-                case '==':
-                case '===':
-                case '>':
-                case '<':
-                case '!=':
-                case '<>':
-                case '<<':
-                case '>>':
-                case '<=':
-                case '>=':
-                case '&&':
-                case '||':
-                case '|':
-                case '^':
-                case '&':
-                case '~':
-                case ')':
-                case ',':
-                case '+':
-                case '-':
-                case '*':
-                case '/':
-                case '@':
-                    break;
-
-                case 'eq':
-                    $token = '==';
-                    break;
-
-                case 'ne':
-                case 'neq':
-                    $token = '!=';
-                    break;
-
-                case 'lt':
-                    $token = '<';
-                    break;
-
-                case 'le':
-                case 'lte':
-                    $token = '<=';
-                    break;
-
-                case 'gt':
-                    $token = '>';
-                    break;
-
-                case 'ge':
-                case 'gte':
-                    $token = '>=';
-                    break;
-
-                case 'and':
-                    $token = '&&';
-                    break;
-
-                case 'or':
-                    $token = '||';
-                    break;
-
-                case 'not':
-                    $token = '!';
-                    break;
-
-                case 'mod':
-                    $token = '%';
-                    break;
-
-                case '(':
-                    array_push($is_arg_stack, $i);
-                    break;
-
-                case 'is':
-                    /* If last token was a ')', we operate on the parenthesized
-                       expression. The start of the expression is on the stack.
-                       Otherwise, we operate on the last encountered token. */
-                    if ($tokens[$i-1] == ')') {
-                        $is_arg_start = array_pop($is_arg_stack);
-                        if ($is_arg_start != 0) {
-                            if (preg_match('~^' . $this->_func_regexp . '$~', $tokens[$is_arg_start-1])) {
-                                $is_arg_start--;
-                            } 
-                        } 
-                    } else
-                        $is_arg_start = $i-1;
-                    /* Construct the argument for 'is' expression, so it knows
-                       what to operate on. */
-                    $is_arg = implode(' ', array_slice($tokens, $is_arg_start, $i - $is_arg_start));
-
-                    /* Pass all tokens from next one until the end to the
-                       'is' expression parsing function. The function will
-                       return modified tokens, where the first one is the result
-                       of the 'is' expression and the rest are the tokens it
-                       didn't touch. */
-                    $new_tokens = $this->_parse_is_expr($is_arg, array_slice($tokens, $i+1));
-
-                    /* Replace the old tokens with the new ones. */
-                    array_splice($tokens, $is_arg_start, count($tokens), $new_tokens);
-
-                    /* Adjust argument start so that it won't change from the
-                       current position for the next iteration. */
-                    $i = $is_arg_start;
-                    break;
-
-                default:
-                    if(preg_match('~^' . $this->_func_regexp . '$~', $token) ) {
-                            // function call
-                            if($this->security &&
-                               !in_array($token, $this->security_settings['IF_FUNCS'])) {
-                                $this->_syntax_error("(secure mode) '$token' not allowed in if statement", E_USER_ERROR, __FILE__, __LINE__);
-                            }
-                    } elseif(preg_match('~^' . $this->_var_regexp . '$~', $token) && (strpos('+-*/^%&|', substr($token, -1)) === false) && isset($tokens[$i+1]) && $tokens[$i+1] == '(') {
-                        // variable function call
-                        $this->_syntax_error("variable function call '$token' not allowed in if statement", E_USER_ERROR, __FILE__, __LINE__);                      
-                    } elseif(preg_match('~^' . $this->_obj_call_regexp . '|' . $this->_var_regexp . '(?:' . $this->_mod_regexp . '*)$~', $token)) {
-                        // object or variable
-                        $token = $this->_parse_var_props($token);
-                    } elseif(is_numeric($token)) {
-                        // number, skip it
-                    } else {
-                        $this->_syntax_error("unidentified token '$token'", E_USER_ERROR, __FILE__, __LINE__);
-                    }
-                    break;
-            }
-        }
-
-        if ($elseif)
-            return '<?php elseif ('.implode(' ', $tokens).'): ?>';
-        else
-            return '<?php if ('.implode(' ', $tokens).'): ?>';
-    }
-
-
-    function _compile_arg_list($type, $name, $attrs, &$cache_code) {
-        $arg_list = array();
-
-        if (isset($type) && isset($name)
-            && isset($this->_plugins[$type])
-            && isset($this->_plugins[$type][$name])
-            && empty($this->_plugins[$type][$name][4])
-            && is_array($this->_plugins[$type][$name][5])
-            ) {
-            /* we have a list of parameters that should be cached */
-            $_cache_attrs = $this->_plugins[$type][$name][5];
-            $_count = $this->_cache_attrs_count++;
-            $cache_code = "\$_cache_attrs =& \$this->_smarty_cache_attrs('$this->_cache_serial','$_count');";
-
-        } else {
-            /* no parameters are cached */
-            $_cache_attrs = null;
-        }
-
-        foreach ($attrs as $arg_name => $arg_value) {
-            if (is_bool($arg_value))
-                $arg_value = $arg_value ? 'true' : 'false';
-            if (is_null($arg_value))
-                $arg_value = 'null';
-            if ($_cache_attrs && in_array($arg_name, $_cache_attrs)) {
-                $arg_list[] = "'$arg_name' => (\$this->_cache_including) ? \$_cache_attrs['$arg_name'] : (\$_cache_attrs['$arg_name']=$arg_value)";
-            } else {
-                $arg_list[] = "'$arg_name' => $arg_value";
-            }
-        }
-        return $arg_list;
-    }
-
-    /**
-     * Parse is expression
-     *
-     * @param string $is_arg
-     * @param array $tokens
-     * @return array
-     */
-    function _parse_is_expr($is_arg, $tokens)
-    {
-        $expr_end = 0;
-        $negate_expr = false;
-
-        if (($first_token = array_shift($tokens)) == 'not') {
-            $negate_expr = true;
-            $expr_type = array_shift($tokens);
-        } else
-            $expr_type = $first_token;
-
-        switch ($expr_type) {
-            case 'even':
-                if (isset($tokens[$expr_end]) && $tokens[$expr_end] == 'by') {
-                    $expr_end++;
-                    $expr_arg = $tokens[$expr_end++];
-                    $expr = "!(1 & ($is_arg / " . $this->_parse_var_props($expr_arg) . "))";
-                } else
-                    $expr = "!(1 & $is_arg)";
-                break;
-
-            case 'odd':
-                if (isset($tokens[$expr_end]) && $tokens[$expr_end] == 'by') {
-                    $expr_end++;
-                    $expr_arg = $tokens[$expr_end++];
-                    $expr = "(1 & ($is_arg / " . $this->_parse_var_props($expr_arg) . "))";
-                } else
-                    $expr = "(1 & $is_arg)";
-                break;
-
-            case 'div':
-                if (@$tokens[$expr_end] == 'by') {
-                    $expr_end++;
-                    $expr_arg = $tokens[$expr_end++];
-                    $expr = "!($is_arg % " . $this->_parse_var_props($expr_arg) . ")";
-                } else {
-                    $this->_syntax_error("expecting 'by' after 'div'", E_USER_ERROR, __FILE__, __LINE__);
-                }
-                break;
-
-            default:
-                $this->_syntax_error("unknown 'is' expression - '$expr_type'", E_USER_ERROR, __FILE__, __LINE__);
-                break;
-        }
-
-        if ($negate_expr) {
-            $expr = "!($expr)";
-        }
-
-        array_splice($tokens, 0, $expr_end, $expr);
-
-        return $tokens;
-    }
-
-
-    /**
-     * Parse attribute string
-     *
-     * @param string $tag_args
-     * @return array
-     */
-    function _parse_attrs($tag_args)
-    {
-
-        /* Tokenize tag attributes. */
-        preg_match_all('~(?:' . $this->_obj_call_regexp . '|' . $this->_qstr_regexp . ' | (?>[^"\'=\s]+)
-                         )+ |
-                         [=]
-                        ~x', $tag_args, $match);
-        $tokens       = $match[0];
-
-        $attrs = array();
-        /* Parse state:
-            0 - expecting attribute name
-            1 - expecting '='
-            2 - expecting attribute value (not '=') */
-        $state = 0;
-
-        foreach ($tokens as $token) {
-            switch ($state) {
-                case 0:
-                    /* If the token is a valid identifier, we set attribute name
-                       and go to state 1. */
-                    if (preg_match('~^\w+$~', $token)) {
-                        $attr_name = $token;
-                        $state = 1;
-                    } else
-                        $this->_syntax_error("invalid attribute name: '$token'", E_USER_ERROR, __FILE__, __LINE__);
-                    break;
-
-                case 1:
-                    /* If the token is '=', then we go to state 2. */
-                    if ($token == '=') {
-                        $state = 2;
-                    } else
-                        $this->_syntax_error("expecting '=' after attribute name '$last_token'", E_USER_ERROR, __FILE__, __LINE__);
-                    break;
-
-                case 2:
-                    /* If token is not '=', we set the attribute value and go to
-                       state 0. */
-                    if ($token != '=') {
-                        /* We booleanize the token if it's a non-quoted possible
-                           boolean value. */
-                        if (preg_match('~^(on|yes|true)$~', $token)) {
-                            $token = 'true';
-                        } else if (preg_match('~^(off|no|false)$~', $token)) {
-                            $token = 'false';
-                        } else if ($token == 'null') {
-                            $token = 'null';
-                        } else if (preg_match('~^' . $this->_num_const_regexp . '|0[xX][0-9a-fA-F]+$~', $token)) {
-                            /* treat integer literally */
-                        } else if (!preg_match('~^' . $this->_obj_call_regexp . '|' . $this->_var_regexp . '(?:' . $this->_mod_regexp . ')*$~', $token)) {
-                            /* treat as a string, double-quote it escaping quotes */
-                            $token = '"'.addslashes($token).'"';
-                        }
-
-                        $attrs[$attr_name] = $token;
-                        $state = 0;
-                    } else
-                        $this->_syntax_error("'=' cannot be an attribute value", E_USER_ERROR, __FILE__, __LINE__);
-                    break;
-            }
-            $last_token = $token;
-        }
-
-        if($state != 0) {
-            if($state == 1) {
-                $this->_syntax_error("expecting '=' after attribute name '$last_token'", E_USER_ERROR, __FILE__, __LINE__);
-            } else {
-                $this->_syntax_error("missing attribute value", E_USER_ERROR, __FILE__, __LINE__);
-            }
-        }
-
-        $this->_parse_vars_props($attrs);
-
-        return $attrs;
-    }
-
-    /**
-     * compile multiple variables and section properties tokens into
-     * PHP code
-     *
-     * @param array $tokens
-     */
-    function _parse_vars_props(&$tokens)
-    {
-        foreach($tokens as $key => $val) {
-            $tokens[$key] = $this->_parse_var_props($val);
-        }
-    }
-
-    /**
-     * compile single variable and section properties token into
-     * PHP code
-     *
-     * @param string $val
-     * @param string $tag_attrs
-     * @return string
-     */
-    function _parse_var_props($val)
-    {
-        $val = trim($val);
-
-        if(preg_match('~^(' . $this->_obj_call_regexp . '|' . $this->_dvar_regexp . ')(' . $this->_mod_regexp . '*)$~', $val, $match)) {
-            // $ variable or object
-            $return = $this->_parse_var($match[1]);
-            $modifiers = $match[2];
-            if (!empty($this->default_modifiers) && !preg_match('~(^|\|)smarty:nodefaults($|\|)~',$modifiers)) {
-                $_default_mod_string = implode('|',(array)$this->default_modifiers);
-                $modifiers = empty($modifiers) ? $_default_mod_string : $_default_mod_string . '|' . $modifiers;
-            }
-            $this->_parse_modifiers($return, $modifiers);
-            return $return;
-        } elseif (preg_match('~^' . $this->_db_qstr_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
-                // double quoted text
-                preg_match('~^(' . $this->_db_qstr_regexp . ')('. $this->_mod_regexp . '*)$~', $val, $match);
-                $return = $this->_expand_quoted_text($match[1]);
-                if($match[2] != '') {
-                    $this->_parse_modifiers($return, $match[2]);
-                }
-                return $return;
-            }
-        elseif(preg_match('~^' . $this->_num_const_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
-                // numerical constant
-                preg_match('~^(' . $this->_num_const_regexp . ')('. $this->_mod_regexp . '*)$~', $val, $match);
-                if($match[2] != '') {
-                    $this->_parse_modifiers($match[1], $match[2]);
-                    return $match[1];
-                }
-            }
-        elseif(preg_match('~^' . $this->_si_qstr_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
-                // single quoted text
-                preg_match('~^(' . $this->_si_qstr_regexp . ')('. $this->_mod_regexp . '*)$~', $val, $match);
-                if($match[2] != '') {
-                    $this->_parse_modifiers($match[1], $match[2]);
-                    return $match[1];
-                }
-            }
-        elseif(preg_match('~^' . $this->_cvar_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
-                // config var
-                return $this->_parse_conf_var($val);
-            }
-        elseif(preg_match('~^' . $this->_svar_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
-                // section var
-                return $this->_parse_section_prop($val);
-            }
-        elseif(!in_array($val, $this->_permitted_tokens) && !is_numeric($val)) {
-            // literal string
-            return $this->_expand_quoted_text('"' . strtr($val, array('\\' => '\\\\', '"' => '\\"')) .'"');
-        }
-        return $val;
-    }
-
-    /**
-     * expand quoted text with embedded variables
-     *
-     * @param string $var_expr
-     * @return string
-     */
-    function _expand_quoted_text($var_expr)
-    {
-        // if contains unescaped $, expand it
-        if(preg_match_all('~(?:\`(?<!\\\\)\$' . $this->_dvar_guts_regexp . '(?:' . $this->_obj_ext_regexp . ')*\`)|(?:(?<!\\\\)\$\w+(\[[a-zA-Z0-9]+\])*)~', $var_expr, $_match)) {
-            $_match = $_match[0];
-            $_replace = array();
-            foreach($_match as $_var) {
-                $_replace[$_var] = '".(' . $this->_parse_var(str_replace('`','',$_var)) . ')."';
-            }
-            $var_expr = strtr($var_expr, $_replace);
-            $_return = preg_replace('~\.""|(?<!\\\\)""\.~', '', $var_expr);
-        } else {
-            $_return = $var_expr;
-        }
-        // replace double quoted literal string with single quotes
-        $_return = preg_replace('~^"([\s\w]+)"$~',"'\\1'",$_return);
-        return $_return;
-    }
-
-    /**
-     * parse variable expression into PHP code
-     *
-     * @param string $var_expr
-     * @param string $output
-     * @return string
-     */
-    function _parse_var($var_expr)
-    {
-        $_has_math = false;
-        $_math_vars = preg_split('~('.$this->_dvar_math_regexp.'|'.$this->_qstr_regexp.')~', $var_expr, -1, PREG_SPLIT_DELIM_CAPTURE);
-
-        if(count($_math_vars) > 1) {
-            $_first_var = "";
-            $_complete_var = "";
-            $_output = "";
-            // simple check if there is any math, to stop recursion (due to modifiers with "xx % yy" as parameter)
-            foreach($_math_vars as $_k => $_math_var) {
-                $_math_var = $_math_vars[$_k];
-
-                if(!empty($_math_var) || is_numeric($_math_var)) {
-                    // hit a math operator, so process the stuff which came before it
-                    if(preg_match('~^' . $this->_dvar_math_regexp . '$~', $_math_var)) {
-                        $_has_math = true;
-                        if(!empty($_complete_var) || is_numeric($_complete_var)) {
-                            $_output .= $this->_parse_var($_complete_var);
-                        }
-
-                        // just output the math operator to php
-                        $_output .= $_math_var;
-
-                        if(empty($_first_var))
-                            $_first_var = $_complete_var;
-
-                        $_complete_var = "";
-                    } else {
-                        $_complete_var .= $_math_var;
-                    }
-                }
-            }
-            if($_has_math) {
-                if(!empty($_complete_var) || is_numeric($_complete_var))
-                    $_output .= $this->_parse_var($_complete_var);
-
-                // get the modifiers working (only the last var from math + modifier is left)
-                $var_expr = $_complete_var;
-            }
-        }
-
-        // prevent cutting of first digit in the number (we _definitly_ got a number if the first char is a digit)
-        if(is_numeric(substr($var_expr, 0, 1)))
-            $_var_ref = $var_expr;
-        else
-            $_var_ref = substr($var_expr, 1);
-        
-        if(!$_has_math) {
-            
-            // get [foo] and .foo and ->foo and (...) pieces
-            preg_match_all('~(?:^\w+)|' . $this->_obj_params_regexp . '|(?:' . $this->_var_bracket_regexp . ')|->\$?\w+|\.\$?\w+|\S+~', $_var_ref, $match);
-                        
-            $_indexes = $match[0];
-            $_var_name = array_shift($_indexes);
-
-            /* Handle $smarty.* variable references as a special case. */
-            if ($_var_name == 'smarty') {
-                /*
-                 * If the reference could be compiled, use the compiled output;
-                 * otherwise, fall back on the $smarty variable generated at
-                 * run-time.
-                 */
-                if (($smarty_ref = $this->_compile_smarty_ref($_indexes)) !== null) {
-                    $_output = $smarty_ref;
-                } else {
-                    $_var_name = substr(array_shift($_indexes), 1);
-                    $_output = "\$this->_smarty_vars['$_var_name']";
-                }
-            } elseif(is_numeric($_var_name) && is_numeric(substr($var_expr, 0, 1))) {
-                // because . is the operator for accessing arrays thru inidizes we need to put it together again for floating point numbers
-                if(count($_indexes) > 0)
-                {
-                    $_var_name .= implode("", $_indexes);
-                    $_indexes = array();
-                }
-                $_output = $_var_name;
-            } else {
-                $_output = "\$this->_tpl_vars['$_var_name']";
-            }
-
-            foreach ($_indexes as $_index) {
-                if (substr($_index, 0, 1) == '[') {
-                    $_index = substr($_index, 1, -1);
-                    if (is_numeric($_index)) {
-                        $_output .= "[$_index]";
-                    } elseif (substr($_index, 0, 1) == '$') {
-                        if (strpos($_index, '.') !== false) {
-                            $_output .= '[' . $this->_parse_var($_index) . ']';
-                        } else {
-                            $_output .= "[\$this->_tpl_vars['" . substr($_index, 1) . "']]";
-                        }
-                    } else {
-                        $_var_parts = explode('.', $_index);
-                        $_var_section = $_var_parts[0];
-                        $_var_section_prop = isset($_var_parts[1]) ? $_var_parts[1] : 'index';
-                        $_output .= "[\$this->_sections['$_var_section']['$_var_section_prop']]";
-                    }
-                } else if (substr($_index, 0, 1) == '.') {
-                    if (substr($_index, 1, 1) == '$')
-                        $_output .= "[\$this->_tpl_vars['" . substr($_index, 2) . "']]";
-                    else
-                        $_output .= "['" . substr($_index, 1) . "']";
-                } else if (substr($_index,0,2) == '->') {
-                    if(substr($_index,2,2) == '__') {
-                        $this->_syntax_error('call to internal object members is not allowed', E_USER_ERROR, __FILE__, __LINE__);
-                    } elseif($this->security && substr($_index, 2, 1) == '_') {
-                        $this->_syntax_error('(secure) call to private object member is not allowed', E_USER_ERROR, __FILE__, __LINE__);
-                    } elseif (substr($_index, 2, 1) == '$') {
-                        if ($this->security) {
-                            $this->_syntax_error('(secure) call to dynamic object member is not allowed', E_USER_ERROR, __FILE__, __LINE__);
-                        } else {
-                            $_output .= '->{(($_var=$this->_tpl_vars[\''.substr($_index,3).'\']) && substr($_var,0,2)!=\'__\') ? $_var : $this->trigger_error("cannot access property \\"$_var\\"")}';
-                        }
-                    } else {
-                        $_output .= $_index;
-                    }
-                } elseif (substr($_index, 0, 1) == '(') {
-                    $_index = $this->_parse_parenth_args($_index);
-                    $_output .= $_index;
-                } else {
-                    $_output .= $_index;
-                }
-            }
-        }
-
-        return $_output;
-    }
-
-    /**
-     * parse arguments in function call parenthesis
-     *
-     * @param string $parenth_args
-     * @return string
-     */
-    function _parse_parenth_args($parenth_args)
-    {
-        preg_match_all('~' . $this->_param_regexp . '~',$parenth_args, $match);
-        $orig_vals = $match = $match[0];
-        $this->_parse_vars_props($match);
-        $replace = array();
-        for ($i = 0, $count = count($match); $i < $count; $i++) {
-            $replace[$orig_vals[$i]] = $match[$i];
-        }
-        return strtr($parenth_args, $replace);
-    }
-
-    /**
-     * parse configuration variable expression into PHP code
-     *
-     * @param string $conf_var_expr
-     */
-    function _parse_conf_var($conf_var_expr)
-    {
-        $parts = explode('|', $conf_var_expr, 2);
-        $var_ref = $parts[0];
-        $modifiers = isset($parts[1]) ? $parts[1] : '';
-
-        $var_name = substr($var_ref, 1, -1);
-
-        $output = "\$this->_config[0]['vars']['$var_name']";
-
-        $this->_parse_modifiers($output, $modifiers);
-
-        return $output;
-    }
-
-    /**
-     * parse section property expression into PHP code
-     *
-     * @param string $section_prop_expr
-     * @return string
-     */
-    function _parse_section_prop($section_prop_expr)
-    {
-        $parts = explode('|', $section_prop_expr, 2);
-        $var_ref = $parts[0];
-        $modifiers = isset($parts[1]) ? $parts[1] : '';
-
-        preg_match('!%(\w+)\.(\w+)%!', $var_ref, $match);
-        $section_name = $match[1];
-        $prop_name = $match[2];
-
-        $output = "\$this->_sections['$section_name']['$prop_name']";
-
-        $this->_parse_modifiers($output, $modifiers);
-
-        return $output;
-    }
-
-
-    /**
-     * parse modifier chain into PHP code
-     *
-     * sets $output to parsed modified chain
-     * @param string $output
-     * @param string $modifier_string
-     */
-    function _parse_modifiers(&$output, $modifier_string)
-    {
-        preg_match_all('~\|(@?\w+)((?>:(?:'. $this->_qstr_regexp . '|[^|]+))*)~', '|' . $modifier_string, $_match);
-        list(, $_modifiers, $modifier_arg_strings) = $_match;
-
-        for ($_i = 0, $_for_max = count($_modifiers); $_i < $_for_max; $_i++) {
-            $_modifier_name = $_modifiers[$_i];
-
-            if($_modifier_name == 'smarty') {
-                // skip smarty modifier
-                continue;
-            }
-
-            preg_match_all('~:(' . $this->_qstr_regexp . '|[^:]+)~', $modifier_arg_strings[$_i], $_match);
-            $_modifier_args = $_match[1];
-
-            if (substr($_modifier_name, 0, 1) == '@') {
-                $_map_array = false;
-                $_modifier_name = substr($_modifier_name, 1);
-            } else {
-                $_map_array = true;
-            }
-
-            if (empty($this->_plugins['modifier'][$_modifier_name])
-                && !$this->_get_plugin_filepath('modifier', $_modifier_name)
-                && function_exists($_modifier_name)) {
-                if ($this->security && !in_array($_modifier_name, $this->security_settings['MODIFIER_FUNCS'])) {
-                    $this->_trigger_fatal_error("[plugin] (secure mode) modifier '$_modifier_name' is not allowed" , $this->_current_file, $this->_current_line_no, __FILE__, __LINE__);
-                } else {
-                    $this->_plugins['modifier'][$_modifier_name] = array($_modifier_name,  null, null, false);
-                }
-            }
-            $this->_add_plugin('modifier', $_modifier_name);
-
-            $this->_parse_vars_props($_modifier_args);
-
-            if($_modifier_name == 'default') {
-                // supress notifications of default modifier vars and args
-                if(substr($output, 0, 1) == '$') {
-                    $output = '@' . $output;
-                }
-                if(isset($_modifier_args[0]) && substr($_modifier_args[0], 0, 1) == '$') {
-                    $_modifier_args[0] = '@' . $_modifier_args[0];
-                }
-            }
-            if (count($_modifier_args) > 0)
-                $_modifier_args = ', '.implode(', ', $_modifier_args);
-            else
-                $_modifier_args = '';
-
-            if ($_map_array) {
-                $output = "((is_array(\$_tmp=$output)) ? \$this->_run_mod_handler('$_modifier_name', true, \$_tmp$_modifier_args) : " . $this->_compile_plugin_call('modifier', $_modifier_name) . "(\$_tmp$_modifier_args))";
-
-            } else {
-
-                $output = $this->_compile_plugin_call('modifier', $_modifier_name)."($output$_modifier_args)";
-
-            }
-        }
-    }
-
-
-    /**
-     * add plugin
-     *
-     * @param string $type
-     * @param string $name
-     * @param boolean? $delayed_loading
-     */
-    function _add_plugin($type, $name, $delayed_loading = null)
-    {
-        if (!isset($this->_plugin_info[$type])) {
-            $this->_plugin_info[$type] = array();
-        }
-        if (!isset($this->_plugin_info[$type][$name])) {
-            $this->_plugin_info[$type][$name] = array($this->_current_file,
-                                                      $this->_current_line_no,
-                                                      $delayed_loading);
-        }
-    }
-
-
-    /**
-     * Compiles references of type $smarty.foo
-     *
-     * @param string $indexes
-     * @return string
-     */
-    function _compile_smarty_ref(&$indexes)
-    {
-        /* Extract the reference name. */
-        $_ref = substr($indexes[0], 1);
-        foreach($indexes as $_index_no=>$_index) {
-            if (substr($_index, 0, 1) != '.' && $_index_no<2 || !preg_match('~^(\.|\[|->)~', $_index)) {
-                $this->_syntax_error('$smarty' . implode('', array_slice($indexes, 0, 2)) . ' is an invalid reference', E_USER_ERROR, __FILE__, __LINE__);
-            }
-        }
-
-        switch ($_ref) {
-            case 'now':
-                $compiled_ref = 'time()';
-                $_max_index = 1;
-                break;
-
-            case 'foreach':
-                array_shift($indexes);
-                $_var = $this->_parse_var_props(substr($indexes[0], 1));
-                $_propname = substr($indexes[1], 1);
-                $_max_index = 1;
-                switch ($_propname) {
-                    case 'index':
-                        array_shift($indexes);
-                        $compiled_ref = "(\$this->_foreach[$_var]['iteration']-1)";
-                        break;
-                        
-                    case 'first':
-                        array_shift($indexes);
-                        $compiled_ref = "(\$this->_foreach[$_var]['iteration'] <= 1)";
-                        break;
-
-                    case 'last':
-                        array_shift($indexes);
-                        $compiled_ref = "(\$this->_foreach[$_var]['iteration'] == \$this->_foreach[$_var]['total'])";
-                        break;
-                        
-                    case 'show':
-                        array_shift($indexes);
-                        $compiled_ref = "(\$this->_foreach[$_var]['total'] > 0)";
-                        break;
-                        
-                    default:
-                        unset($_max_index);
-                        $compiled_ref = "\$this->_foreach[$_var]";
-                }
-                break;
-
-            case 'section':
-                array_shift($indexes);
-                $_var = $this->_parse_var_props(substr($indexes[0], 1));
-                $compiled_ref = "\$this->_sections[$_var]";
-                break;
-
-            case 'get':
-                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
-                    $this->_syntax_error("(secure mode) super global access not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                $compiled_ref = "\$_GET";
-                break;
-
-            case 'post':
-                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
-                    $this->_syntax_error("(secure mode) super global access not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                $compiled_ref = "\$_POST";
-                break;
-
-            case 'cookies':
-                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
-                    $this->_syntax_error("(secure mode) super global access not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                $compiled_ref = "\$_COOKIE";
-                break;
-
-            case 'env':
-                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
-                    $this->_syntax_error("(secure mode) super global access not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                $compiled_ref = "\$_ENV";
-                break;
-
-            case 'server':
-                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
-                    $this->_syntax_error("(secure mode) super global access not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                $compiled_ref = "\$_SERVER";
-                break;
-
-            case 'session':
-                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
-                    $this->_syntax_error("(secure mode) super global access not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                $compiled_ref = "\$_SESSION";
-                break;
-
-            /*
-             * These cases are handled either at run-time or elsewhere in the
-             * compiler.
-             */
-            case 'request':
-                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
-                    $this->_syntax_error("(secure mode) super global access not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                if ($this->request_use_auto_globals) {
-                    $compiled_ref = "\$_REQUEST";
-                    break;
-                } else {
-                    $this->_init_smarty_vars = true;
-                }
-                return null;
-
-            case 'capture':
-                return null;
-
-            case 'template':
-                $compiled_ref = "'" . addslashes($this->_current_file) . "'";
-                $_max_index = 1;
-                break;
-
-            case 'version':
-                $compiled_ref = "'$this->_version'";
-                $_max_index = 1;
-                break;
-
-            case 'const':
-                if ($this->security && !$this->security_settings['ALLOW_CONSTANTS']) {
-                    $this->_syntax_error("(secure mode) constants not permitted",
-                                         E_USER_WARNING, __FILE__, __LINE__);
-                    return;
-                }
-                array_shift($indexes);
-                if (preg_match('!^\.\w+$!', $indexes[0])) {
-                    $compiled_ref = '@' . substr($indexes[0], 1);
-                } else {
-                    $_val = $this->_parse_var_props(substr($indexes[0], 1));
-                    $compiled_ref = '@constant(' . $_val . ')';
-                }
-                $_max_index = 1;
-                break;
-
-            case 'config':
-                $compiled_ref = "\$this->_config[0]['vars']";
-                $_max_index = 3;
-                break;
-
-            case 'ldelim':
-                $compiled_ref = "'$this->left_delimiter'";
-                break;
-
-            case 'rdelim':
-                $compiled_ref = "'$this->right_delimiter'";
-                break;
-                
-            default:
-                $this->_syntax_error('$smarty.' . $_ref . ' is an unknown reference', E_USER_ERROR, __FILE__, __LINE__);
-                break;
-        }
-
-        if (isset($_max_index) && count($indexes) > $_max_index) {
-            $this->_syntax_error('$smarty' . implode('', $indexes) .' is an invalid reference', E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        array_shift($indexes);
-        return $compiled_ref;
-    }
-
-    /**
-     * compiles call to plugin of type $type with name $name
-     * returns a string containing the function-name or method call
-     * without the paramter-list that would have follow to make the
-     * call valid php-syntax
-     *
-     * @param string $type
-     * @param string $name
-     * @return string
-     */
-    function _compile_plugin_call($type, $name) {
-        if (isset($this->_plugins[$type][$name])) {
-            /* plugin loaded */
-            if (is_array($this->_plugins[$type][$name][0])) {
-                return ((is_object($this->_plugins[$type][$name][0][0])) ?
-                        "\$this->_plugins['$type']['$name'][0][0]->"    /* method callback */
-                        : (string)($this->_plugins[$type][$name][0][0]).'::'    /* class callback */
-                       ). $this->_plugins[$type][$name][0][1];
-
-            } else {
-                /* function callback */
-                return $this->_plugins[$type][$name][0];
-
-            }
-        } else {
-            /* plugin not loaded -> auto-loadable-plugin */
-            return 'smarty_'.$type.'_'.$name;
-
-        }
-    }
-
-    /**
-     * load pre- and post-filters
-     */
-    function _load_filters()
-    {
-        if (count($this->_plugins['prefilter']) > 0) {
-            foreach ($this->_plugins['prefilter'] as $filter_name => $prefilter) {
-                if ($prefilter === false) {
-                    unset($this->_plugins['prefilter'][$filter_name]);
-                    $_params = array('plugins' => array(array('prefilter', $filter_name, null, null, false)));
-                    require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
-                    smarty_core_load_plugins($_params, $this);
-                }
-            }
-        }
-        if (count($this->_plugins['postfilter']) > 0) {
-            foreach ($this->_plugins['postfilter'] as $filter_name => $postfilter) {
-                if ($postfilter === false) {
-                    unset($this->_plugins['postfilter'][$filter_name]);
-                    $_params = array('plugins' => array(array('postfilter', $filter_name, null, null, false)));
-                    require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
-                    smarty_core_load_plugins($_params, $this);
-                }
-            }
-        }
-    }
-
-
-    /**
-     * Quote subpattern references
-     *
-     * @param string $string
-     * @return string
-     */
-    function _quote_replace($string)
-    {
-        return strtr($string, array('\\' => '\\\\', '$' => '\\$'));
-    }
-
-    /**
-     * display Smarty syntax error
-     *
-     * @param string $error_msg
-     * @param integer $error_type
-     * @param string $file
-     * @param integer $line
-     */
-    function _syntax_error($error_msg, $error_type = E_USER_ERROR, $file=null, $line=null)
-    {
-        $this->_trigger_fatal_error("syntax error: $error_msg", $this->_current_file, $this->_current_line_no, $file, $line, $error_type);
-    }
-
-
-    /**
-     * check if the compilation changes from cacheable to
-     * non-cacheable state with the beginning of the current
-     * plugin. return php-code to reflect the transition.
-     * @return string
-     */
-    function _push_cacheable_state($type, $name) {
-        $_cacheable = !isset($this->_plugins[$type][$name]) || $this->_plugins[$type][$name][4];
-        if ($_cacheable
-            || 0<$this->_cacheable_state++) return '';
-        if (!isset($this->_cache_serial)) $this->_cache_serial = md5(uniqid('Smarty'));
-        $_ret = 'if ($this->caching && !$this->_cache_including): echo \'{nocache:'
-            . $this->_cache_serial . '#' . $this->_nocache_count
-            . '}\'; endif;';
-        return $_ret;
-    }
-
-
-    /**
-     * check if the compilation changes from non-cacheable to
-     * cacheable state with the end of the current plugin return
-     * php-code to reflect the transition.
-     * @return string
-     */
-    function _pop_cacheable_state($type, $name) {
-        $_cacheable = !isset($this->_plugins[$type][$name]) || $this->_plugins[$type][$name][4];
-        if ($_cacheable
-            || --$this->_cacheable_state>0) return '';
-        return 'if ($this->caching && !$this->_cache_including): echo \'{/nocache:'
-            . $this->_cache_serial . '#' . ($this->_nocache_count++)
-            . '}\'; endif;';
-    }
-
-
-    /**
-     * push opening tag-name, file-name and line-number on the tag-stack
-     * @param string the opening tag's name
-     */
-    function _push_tag($open_tag)
-    {
-        array_push($this->_tag_stack, array($open_tag, $this->_current_line_no));
-    }
-
-    /**
-     * pop closing tag-name
-     * raise an error if this stack-top doesn't match with the closing tag
-     * @param string the closing tag's name
-     * @return string the opening tag's name
-     */
-    function _pop_tag($close_tag)
-    {
-        $message = '';
-        if (count($this->_tag_stack)>0) {
-            list($_open_tag, $_line_no) = array_pop($this->_tag_stack);
-            if ($close_tag == $_open_tag) {
-                return $_open_tag;
-            }
-            if ($close_tag == 'if' && ($_open_tag == 'else' || $_open_tag == 'elseif' )) {
-                return $this->_pop_tag($close_tag);
-            }
-            if ($close_tag == 'section' && $_open_tag == 'sectionelse') {
-                $this->_pop_tag($close_tag);
-                return $_open_tag;
-            }
-            if ($close_tag == 'foreach' && $_open_tag == 'foreachelse') {
-                $this->_pop_tag($close_tag);
-                return $_open_tag;
-            }
-            if ($_open_tag == 'else' || $_open_tag == 'elseif') {
-                $_open_tag = 'if';
-            } elseif ($_open_tag == 'sectionelse') {
-                $_open_tag = 'section';
-            } elseif ($_open_tag == 'foreachelse') {
-                $_open_tag = 'foreach';
-            }
-            $message = " expected {/$_open_tag} (opened line $_line_no).";
-        }
-        $this->_syntax_error("mismatched tag {/$close_tag}.$message",
-                             E_USER_ERROR, __FILE__, __LINE__);
-    }
-
-}
-
-/**
- * compare to values by their string length
- *
- * @access private
- * @param string $a
- * @param string $b
- * @return 0|-1|1
- */
-function _smarty_sort_length($a, $b)
-{
-    if($a == $b)
-        return 0;
-
-    if(strlen($a) == strlen($b))
-        return ($a > $b) ? -1 : 1;
-
-    return (strlen($a) > strlen($b)) ? -1 : 1;
-}
-
-
-/* vim: set et: */
-
-?>
diff -urN a/epgrec/Smarty/bootstrap.php b/epgrec/Smarty/bootstrap.php
--- a/epgrec/Smarty/bootstrap.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/bootstrap.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,16 @@
+<?php
+/**
+ * This file is part of the Smarty package.
+ *
+ * (c) Sebastian Bergmann <sebastian@phpunit.de>
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+/**
+ * Load and register Smarty Autoloader
+ */
+if (!class_exists('Smarty_Autoloader')) {
+    include dirname(__FILE__) . '/Autoloader.php';
+}
+Smarty_Autoloader::register(true);
diff -urN a/epgrec/Smarty/debug.tpl b/epgrec/Smarty/debug.tpl
--- a/epgrec/Smarty/debug.tpl	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/debug.tpl	2022-09-14 20:29:00.000000000 +0900
@@ -1,157 +1,160 @@
-{* Smarty *}
-{* debug.tpl, last updated version 2.1.0 *}
-{assign_debug_info}
-{capture assign=debug_output}
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
-<head>
-    <title>Smarty Debug Console</title>
-{literal}
-<style type="text/css">
-/* <![CDATA[ */
-body, h1, h2, td, th, p {
-    font-family: sans-serif;
-    font-weight: normal;
-    font-size: 0.9em;
-    margin: 1px;
-    padding: 0;
-}
-
-h1 {
-    margin: 0;
-    text-align: left;
-    padding: 2px;
-    background-color: #f0c040;
-    color:  black;
-    font-weight: bold;
-    font-size: 1.2em;
- }
-
-h2 {
-    background-color: #9B410E;
-    color: white;
-    text-align: left;
-    font-weight: bold;
-    padding: 2px;
-    border-top: 1px solid black;
-}
-
-body {
-    background: black; 
-}
-
-p, table, div {
-    background: #f0ead8;
-} 
-
-p {
-    margin: 0;
-    font-style: italic;
-    text-align: center;
-}
-
-table {
-    width: 100%;
-}
-
-th, td {
-    font-family: monospace;
-    vertical-align: top;
-    text-align: left;
-    width: 50%;
-}
-
-td {
-    color: green;
-}
-
-.odd {
-    background-color: #eeeeee;
-}
-
-.even {
-    background-color: #fafafa;
-}
-
-.exectime {
-    font-size: 0.8em;
-    font-style: italic;
-}
-
-#table_assigned_vars th {
-    color: blue;
-}
-
-#table_config_vars th {
-    color: maroon;
-}
-/* ]]> */
-</style>
-{/literal}
-</head>
-<body>
-
-<h1>Smarty Debug Console</h1>
-
-<h2>included templates &amp; config files (load time in seconds)</h2>
-
-<div>
-{section name=templates loop=$_debug_tpls}
-    {section name=indent loop=$_debug_tpls[templates].depth}&nbsp;&nbsp;&nbsp;{/section}
-    <font color={if $_debug_tpls[templates].type eq "template"}brown{elseif $_debug_tpls[templates].type eq "insert"}black{else}green{/if}>
-        {$_debug_tpls[templates].filename|escape:html}</font>
-    {if isset($_debug_tpls[templates].exec_time)}
-        <span class="exectime">
-        ({$_debug_tpls[templates].exec_time|string_format:"%.5f"})
-        {if %templates.index% eq 0}(total){/if}
-        </span>
+{capture name='_smarty_debug' assign=debug_output}
+    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
+    <head>
+        <title>Smarty Debug Console</title>
+        <style type="text/css">
+            {literal}
+            body, h1, h2, h3, td, th, p {
+                font-family: sans-serif;
+                font-weight: normal;
+                font-size: 0.9em;
+                margin: 1px;
+                padding: 0;
+            }
+
+            h1 {
+                margin: 0;
+                text-align: left;
+                padding: 2px;
+                background-color: #f0c040;
+                color: black;
+                font-weight: bold;
+                font-size: 1.2em;
+            }
+
+            h2 {
+                background-color: #9B410E;
+                color: white;
+                text-align: left;
+                font-weight: bold;
+                padding: 2px;
+                border-top: 1px solid black;
+            }
+            h3 {
+                text-align: left;
+                font-weight: bold;
+                color: black;
+                font-size: 0.7em;
+                padding: 2px;
+            }
+
+            body {
+                background: black;
+            }
+
+            p, table, div {
+                background: #f0ead8;
+            }
+
+            p {
+                margin: 0;
+                font-style: italic;
+                text-align: center;
+            }
+
+            table {
+                width: 100%;
+            }
+
+            th, td {
+                font-family: monospace;
+                vertical-align: top;
+                text-align: left;
+            }
+
+            td {
+                color: green;
+            }
+
+            .odd {
+                background-color: #eeeeee;
+            }
+
+            .even {
+                background-color: #fafafa;
+            }
+
+            .exectime {
+                font-size: 0.8em;
+                font-style: italic;
+            }
+
+            #bold div {
+                color: black;
+                font-weight: bold;
+            }
+            #blue h3 {
+                color: blue;
+            }
+            #normal div {
+                color: black;
+                font-weight: normal;
+            }
+            #table_assigned_vars th {
+                color: blue;
+                font-weight: bold;
+            }
+
+            #table_config_vars th {
+                color: maroon;
+            }
+
+            {/literal}
+        </style>
+    </head>
+    <body>
+
+    <h1>Smarty {Smarty::SMARTY_VERSION} Debug Console
+        -  {if isset($template_name)}{$template_name|debug_print_var nofilter} {/if}{if !empty($template_data)}Total Time {$execution_time|string_format:"%.5f"}{/if}</h1>
+
+    {if !empty($template_data)}
+        <h2>included templates &amp; config files (load time in seconds)</h2>
+        <div>
+            {foreach $template_data as $template}
+                <font color=brown>{$template.name}</font>
+                <br />&nbsp;&nbsp;<span class="exectime">
+                (compile {$template['compile_time']|string_format:"%.5f"}) (render {$template['render_time']|string_format:"%.5f"}) (cache {$template['cache_time']|string_format:"%.5f"})
+                 </span>
+                <br />
+            {/foreach}
+        </div>
     {/if}
-    <br />
-{sectionelse}
-    <p>no templates included</p>
-{/section}
-</div>
-
-<h2>assigned template variables</h2>
-
-<table id="table_assigned_vars">
-    {section name=vars loop=$_debug_keys}
-        <tr class="{cycle values="odd,even"}">
-            <th>{ldelim}${$_debug_keys[vars]|escape:'html'}{rdelim}</th>
-            <td>{$_debug_vals[vars]|@debug_print_var}</td></tr>
-    {sectionelse}
-        <tr><td><p>no template variables assigned</p></td></tr>
-    {/section}
-</table>
-
-<h2>assigned config file variables (outer template scope)</h2>
-
-<table id="table_config_vars">
-    {section name=config_vars loop=$_debug_config_keys}
-        <tr class="{cycle values="odd,even"}">
-            <th>{ldelim}#{$_debug_config_keys[config_vars]|escape:'html'}#{rdelim}</th>
-            <td>{$_debug_config_vals[config_vars]|@debug_print_var}</td></tr>
-    {sectionelse}
-        <tr><td><p>no config vars assigned</p></td></tr>
-    {/section}
-</table>
-</body>
-</html>
+
+    <h2>assigned template variables</h2>
+
+    <table id="table_assigned_vars">
+        {foreach $assigned_vars as $vars}
+            <tr class="{if $vars@iteration % 2 eq 0}odd{else}even{/if}">
+                <td><h3><font color=blue>${$vars@key}</font></h3>
+                    {if isset($vars['nocache'])}<b>Nocache</b><br />{/if}
+                    {if isset($vars['scope'])}<b>Origin:</b> {$vars['scope']|debug_print_var nofilter}{/if}
+                </td>
+                <td><h3>Value</h3>{$vars['value']|debug_print_var:10:80 nofilter}</td>
+                <td>{if isset($vars['attributes'])}<h3>Attributes</h3>{$vars['attributes']|debug_print_var nofilter} {/if}</td>
+         {/foreach}
+    </table>
+
+    <h2>assigned config file variables</h2>
+
+    <table id="table_config_vars">
+        {foreach $config_vars as $vars}
+            <tr class="{if $vars@iteration % 2 eq 0}odd{else}even{/if}">
+                <td><h3><font color=blue>#{$vars@key}#</font></h3>
+                    {if isset($vars['scope'])}<b>Origin:</b> {$vars['scope']|debug_print_var nofilter}{/if}
+                </td>
+                <td>{$vars['value']|debug_print_var:10:80 nofilter}</td>
+            </tr>
+        {/foreach}
+
+    </table>
+    </body>
+    </html>
 {/capture}
-{if isset($_smarty_debug_output) and $_smarty_debug_output eq "html"}
-    {$debug_output}
-{else}
 <script type="text/javascript">
-// <![CDATA[
-    if ( self.name == '' ) {ldelim}
-       var title = 'Console';
-    {rdelim}
-    else {ldelim}
-       var title = 'Console_' + self.name;
-    {rdelim}
-    _smarty_console = window.open("",title.value,"width=680,height=600,resizable,scrollbars=yes");
-    _smarty_console.document.write('{$debug_output|escape:'javascript'}');
+    {$id = '__Smarty__'}
+    {if $display_mode}{$id = "$offset$template_name"|md5}{/if}
+    _smarty_console = window.open("", "console{$id}", "width=1024,height=600,left={$offset},top={$offset},resizable,scrollbars=yes");
+    _smarty_console.document.write("{$debug_output|escape:'javascript' nofilter}");
     _smarty_console.document.close();
-// ]]>
 </script>
-{/if}
\ 
diff -urN a/epgrec/Smarty/internals/core.assemble_plugin_filepath.php b/epgrec/Smarty/internals/core.assemble_plugin_filepath.php
--- a/epgrec/Smarty/internals/core.assemble_plugin_filepath.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.assemble_plugin_filepath.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,67 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * assemble filepath of requested plugin
- *
- * @param string $type
- * @param string $name
- * @return string|false
- */
-function smarty_core_assemble_plugin_filepath($params, &$smarty)
-{
-    static $_filepaths_cache = array();
-
-    $_plugin_filename = $params['type'] . '.' . $params['name'] . '.php';
-    if (isset($_filepaths_cache[$_plugin_filename])) {
-        return $_filepaths_cache[$_plugin_filename];
-    }
-    $_return = false;
-
-    foreach ((array)$smarty->plugins_dir as $_plugin_dir) {
-
-        $_plugin_filepath = $_plugin_dir . DIRECTORY_SEPARATOR . $_plugin_filename;
-
-        // see if path is relative
-        if (!preg_match("/^([\/\\\\]|[a-zA-Z]:[\/\\\\])/", $_plugin_dir)) {
-            $_relative_paths[] = $_plugin_dir;
-            // relative path, see if it is in the SMARTY_DIR
-            if (@is_readable(SMARTY_DIR . $_plugin_filepath)) {
-                $_return = SMARTY_DIR . $_plugin_filepath;
-                break;
-            }
-        }
-        // try relative to cwd (or absolute)
-        if (@is_readable($_plugin_filepath)) {
-            $_return = $_plugin_filepath;
-            break;
-        }
-    }
-
-    if($_return === false) {
-        // still not found, try PHP include_path
-        if(isset($_relative_paths)) {
-            foreach ((array)$_relative_paths as $_plugin_dir) {
-
-                $_plugin_filepath = $_plugin_dir . DIRECTORY_SEPARATOR . $_plugin_filename;
-
-                $_params = array('file_path' => $_plugin_filepath);
-                require_once(SMARTY_CORE_DIR . 'core.get_include_path.php');
-                if(smarty_core_get_include_path($_params, $smarty)) {
-                    $_return = $_params['new_file_path'];
-                    break;
-                }
-            }
-        }
-    }
-    $_filepaths_cache[$_plugin_filename] = $_return;
-    return $_return;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.assign_smarty_interface.php b/epgrec/Smarty/internals/core.assign_smarty_interface.php
--- a/epgrec/Smarty/internals/core.assign_smarty_interface.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.assign_smarty_interface.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,43 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Smarty assign_smarty_interface core plugin
- *
- * Type:     core<br>
- * Name:     assign_smarty_interface<br>
- * Purpose:  assign the $smarty interface variable
- * @param array Format: null
- * @param Smarty
- */
-function smarty_core_assign_smarty_interface($params, &$smarty)
-{
-        if (isset($smarty->_smarty_vars) && isset($smarty->_smarty_vars['request'])) {
-            return;
-        }
-
-        $_globals_map = array('g'  => 'HTTP_GET_VARS',
-                             'p'  => 'HTTP_POST_VARS',
-                             'c'  => 'HTTP_COOKIE_VARS',
-                             's'  => 'HTTP_SERVER_VARS',
-                             'e'  => 'HTTP_ENV_VARS');
-
-        $_smarty_vars_request  = array();
-
-        foreach (preg_split('!!', strtolower($smarty->request_vars_order)) as $_c) {
-            if (isset($_globals_map[$_c])) {
-                $_smarty_vars_request = array_merge($_smarty_vars_request, $GLOBALS[$_globals_map[$_c]]);
-            }
-        }
-        $_smarty_vars_request = @array_merge($_smarty_vars_request, $GLOBALS['HTTP_SESSION_VARS']);
-
-        $smarty->_smarty_vars['request'] = $_smarty_vars_request;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.create_dir_structure.php b/epgrec/Smarty/internals/core.create_dir_structure.php
--- a/epgrec/Smarty/internals/core.create_dir_structure.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.create_dir_structure.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,79 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * create full directory structure
- *
- * @param string $dir
- */
-
-// $dir
-
-function smarty_core_create_dir_structure($params, &$smarty)
-{
-    if (!file_exists($params['dir'])) {
-        $_open_basedir_ini = ini_get('open_basedir');
-
-        if (DIRECTORY_SEPARATOR=='/') {
-            /* unix-style paths */
-            $_dir = $params['dir'];
-            $_dir_parts = preg_split('!/+!', $_dir, -1, PREG_SPLIT_NO_EMPTY);
-            $_new_dir = (substr($_dir, 0, 1)=='/') ? '/' : getcwd().'/';
-            if($_use_open_basedir = !empty($_open_basedir_ini)) {
-                $_open_basedirs = explode(':', $_open_basedir_ini);
-            }
-
-        } else {
-            /* other-style paths */
-            $_dir = str_replace('\\','/', $params['dir']);
-            $_dir_parts = preg_split('!/+!', $_dir, -1, PREG_SPLIT_NO_EMPTY);
-            if (preg_match('!^((//)|([a-zA-Z]:/))!', $_dir, $_root_dir)) {
-                /* leading "//" for network volume, or "[letter]:/" for full path */
-                $_new_dir = $_root_dir[1];
-                /* remove drive-letter from _dir_parts */
-                if (isset($_root_dir[3])) array_shift($_dir_parts);
-
-            } else {
-                $_new_dir = str_replace('\\', '/', getcwd()).'/';
-
-            }
-
-            if($_use_open_basedir = !empty($_open_basedir_ini)) {
-                $_open_basedirs = explode(';', str_replace('\\', '/', $_open_basedir_ini));
-            }
-
-        }
-
-        /* all paths use "/" only from here */
-        foreach ($_dir_parts as $_dir_part) {
-            $_new_dir .= $_dir_part;
-
-            if ($_use_open_basedir) {
-                // do not attempt to test or make directories outside of open_basedir
-                $_make_new_dir = false;
-                foreach ($_open_basedirs as $_open_basedir) {
-                    if (substr($_new_dir, 0, strlen($_open_basedir)) == $_open_basedir) {
-                        $_make_new_dir = true;
-                        break;
-                    }
-                }
-            } else {
-                $_make_new_dir = true;
-            }
-
-            if ($_make_new_dir && !file_exists($_new_dir) && !@mkdir($_new_dir, $smarty->_dir_perms) && !is_dir($_new_dir)) {
-                $smarty->trigger_error("problem creating directory '" . $_new_dir . "'");
-                return false;
-            }
-            $_new_dir .= '/';
-        }
-    }
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.display_debug_console.php b/epgrec/Smarty/internals/core.display_debug_console.php
--- a/epgrec/Smarty/internals/core.display_debug_console.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.display_debug_console.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,61 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Smarty debug_console function plugin
- *
- * Type:     core<br>
- * Name:     display_debug_console<br>
- * Purpose:  display the javascript debug console window
- * @param array Format: null
- * @param Smarty
- */
-function smarty_core_display_debug_console($params, &$smarty)
-{
-    // we must force compile the debug template in case the environment
-    // changed between separate applications.
-
-    if(empty($smarty->debug_tpl)) {
-        // set path to debug template from SMARTY_DIR
-        $smarty->debug_tpl = SMARTY_DIR . 'debug.tpl';
-        if($smarty->security && is_file($smarty->debug_tpl)) {
-            $smarty->secure_dir[] = realpath($smarty->debug_tpl);
-        }
-        $smarty->debug_tpl = 'file:' . SMARTY_DIR . 'debug.tpl';
-    }
-
-    $_ldelim_orig = $smarty->left_delimiter;
-    $_rdelim_orig = $smarty->right_delimiter;
-
-    $smarty->left_delimiter = '{';
-    $smarty->right_delimiter = '}';
-
-    $_compile_id_orig = $smarty->_compile_id;
-    $smarty->_compile_id = null;
-
-    $_compile_path = $smarty->_get_compile_path($smarty->debug_tpl);
-    if ($smarty->_compile_resource($smarty->debug_tpl, $_compile_path))
-    {
-        ob_start();
-        $smarty->_include($_compile_path);
-        $_results = ob_get_contents();
-        ob_end_clean();
-    } else {
-        $_results = '';
-    }
-
-    $smarty->_compile_id = $_compile_id_orig;
-
-    $smarty->left_delimiter = $_ldelim_orig;
-    $smarty->right_delimiter = $_rdelim_orig;
-
-    return $_results;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.get_include_path.php b/epgrec/Smarty/internals/core.get_include_path.php
--- a/epgrec/Smarty/internals/core.get_include_path.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.get_include_path.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,44 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Get path to file from include_path
- *
- * @param string $file_path
- * @param string $new_file_path
- * @return boolean
- * @staticvar array|null
- */
-
-//  $file_path, &$new_file_path
-
-function smarty_core_get_include_path(&$params, &$smarty)
-{
-    static $_path_array = null;
-
-    if(!isset($_path_array)) {
-        $_ini_include_path = ini_get('include_path');
-
-        if(strstr($_ini_include_path,';')) {
-            // windows pathnames
-            $_path_array = explode(';',$_ini_include_path);
-        } else {
-            $_path_array = explode(':',$_ini_include_path);
-        }
-    }
-    foreach ($_path_array as $_include_path) {
-        if (@is_readable($_include_path . DIRECTORY_SEPARATOR . $params['file_path'])) {
-               $params['new_file_path'] = $_include_path . DIRECTORY_SEPARATOR . $params['file_path'];
-            return true;
-        }
-    }
-    return false;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.get_microtime.php b/epgrec/Smarty/internals/core.get_microtime.php
--- a/epgrec/Smarty/internals/core.get_microtime.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.get_microtime.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,23 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Get seconds and microseconds
- * @return double
- */
-function smarty_core_get_microtime($params, &$smarty)
-{
-    $mtime = microtime();
-    $mtime = explode(" ", $mtime);
-    $mtime = (double)($mtime[1]) + (double)($mtime[0]);
-    return ($mtime);
-}
-
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.get_php_resource.php b/epgrec/Smarty/internals/core.get_php_resource.php
--- a/epgrec/Smarty/internals/core.get_php_resource.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.get_php_resource.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,80 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Retrieves PHP script resource
- *
- * sets $php_resource to the returned resource
- * @param string $resource
- * @param string $resource_type
- * @param  $php_resource
- * @return boolean
- */
-
-function smarty_core_get_php_resource(&$params, &$smarty)
-{
-
-    $params['resource_base_path'] = $smarty->trusted_dir;
-    $smarty->_parse_resource_name($params, $smarty);
-
-    /*
-     * Find out if the resource exists.
-     */
-
-    if ($params['resource_type'] == 'file') {
-        $_readable = false;
-        if(file_exists($params['resource_name']) && is_readable($params['resource_name'])) {
-            $_readable = true;
-        } else {
-            // test for file in include_path
-            $_params = array('file_path' => $params['resource_name']);
-            require_once(SMARTY_CORE_DIR . 'core.get_include_path.php');
-            if(smarty_core_get_include_path($_params, $smarty)) {
-                $_include_path = $_params['new_file_path'];
-                $_readable = true;
-            }
-        }
-    } else if ($params['resource_type'] != 'file') {
-        $_template_source = null;
-        $_readable = is_callable($smarty->_plugins['resource'][$params['resource_type']][0][0])
-            && call_user_func_array($smarty->_plugins['resource'][$params['resource_type']][0][0],
-                                    array($params['resource_name'], &$_template_source, &$smarty));
-    }
-
-    /*
-     * Set the error function, depending on which class calls us.
-     */
-    if (method_exists($smarty, '_syntax_error')) {
-        $_error_funcc = '_syntax_error';
-    } else {
-        $_error_funcc = 'trigger_error';
-    }
-
-    if ($_readable) {
-        if ($smarty->security) {
-            require_once(SMARTY_CORE_DIR . 'core.is_trusted.php');
-            if (!smarty_core_is_trusted($params, $smarty)) {
-                $smarty->$_error_funcc('(secure mode) ' . $params['resource_type'] . ':' . $params['resource_name'] . ' is not trusted');
-                return false;
-            }
-        }
-    } else {
-        $smarty->$_error_funcc($params['resource_type'] . ':' . $params['resource_name'] . ' is not readable');
-        return false;
-    }
-
-    if ($params['resource_type'] == 'file') {
-        $params['php_resource'] = $params['resource_name'];
-    } else {
-        $params['php_resource'] = $_template_source;
-    }
-    return true;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.is_secure.php b/epgrec/Smarty/internals/core.is_secure.php
--- a/epgrec/Smarty/internals/core.is_secure.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.is_secure.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,59 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * determines if a resource is secure or not.
- *
- * @param string $resource_type
- * @param string $resource_name
- * @return boolean
- */
-
-//  $resource_type, $resource_name
-
-function smarty_core_is_secure($params, &$smarty)
-{
-    if (!$smarty->security || $smarty->security_settings['INCLUDE_ANY']) {
-        return true;
-    }
-
-    if ($params['resource_type'] == 'file') {
-        $_rp = realpath($params['resource_name']);
-        if (isset($params['resource_base_path'])) {
-            foreach ((array)$params['resource_base_path'] as $curr_dir) {
-                if ( ($_cd = realpath($curr_dir)) !== false &&
-                     strncmp($_rp, $_cd, strlen($_cd)) == 0 &&
-                     substr($_rp, strlen($_cd), 1) == DIRECTORY_SEPARATOR ) {
-                    return true;
-                }
-            }
-        }
-        if (!empty($smarty->secure_dir)) {
-            foreach ((array)$smarty->secure_dir as $curr_dir) {
-                if ( ($_cd = realpath($curr_dir)) !== false) {
-                    if($_cd == $_rp) {
-                        return true;
-                    } elseif (strncmp($_rp, $_cd, strlen($_cd)) == 0 &&
-                        substr($_rp, strlen($_cd), 1) == DIRECTORY_SEPARATOR) {
-                        return true;
-                    }
-                }
-            }
-        }
-    } else {
-        // resource is not on local file system
-        return call_user_func_array(
-            $smarty->_plugins['resource'][$params['resource_type']][0][2],
-            array($params['resource_name'], &$smarty));
-    }
-
-    return false;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.is_trusted.php b/epgrec/Smarty/internals/core.is_trusted.php
--- a/epgrec/Smarty/internals/core.is_trusted.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.is_trusted.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,47 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * determines if a resource is trusted or not
- *
- * @param string $resource_type
- * @param string $resource_name
- * @return boolean
- */
-
- // $resource_type, $resource_name
-
-function smarty_core_is_trusted($params, &$smarty)
-{
-    $_smarty_trusted = false;
-    if ($params['resource_type'] == 'file') {
-        if (!empty($smarty->trusted_dir)) {
-            $_rp = realpath($params['resource_name']);
-            foreach ((array)$smarty->trusted_dir as $curr_dir) {
-                if (!empty($curr_dir) && is_readable ($curr_dir)) {
-                    $_cd = realpath($curr_dir);
-                    if (strncmp($_rp, $_cd, strlen($_cd)) == 0
-                        && substr($_rp, strlen($_cd), 1) == DIRECTORY_SEPARATOR ) {
-                        $_smarty_trusted = true;
-                        break;
-                    }
-                }
-            }
-        }
-
-    } else {
-        // resource is not on local file system
-        $_smarty_trusted = call_user_func_array($smarty->_plugins['resource'][$params['resource_type']][0][3],
-                                                array($params['resource_name'], $smarty));
-    }
-
-    return $_smarty_trusted;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.load_plugins.php b/epgrec/Smarty/internals/core.load_plugins.php
--- a/epgrec/Smarty/internals/core.load_plugins.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.load_plugins.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,125 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Load requested plugins
- *
- * @param array $plugins
- */
-
-// $plugins
-
-function smarty_core_load_plugins($params, &$smarty)
-{
-
-    foreach ($params['plugins'] as $_plugin_info) {
-        list($_type, $_name, $_tpl_file, $_tpl_line, $_delayed_loading) = $_plugin_info;
-        $_plugin = &$smarty->_plugins[$_type][$_name];
-
-        /*
-         * We do not load plugin more than once for each instance of Smarty.
-         * The following code checks for that. The plugin can also be
-         * registered dynamically at runtime, in which case template file
-         * and line number will be unknown, so we fill them in.
-         *
-         * The final element of the info array is a flag that indicates
-         * whether the dynamically registered plugin function has been
-         * checked for existence yet or not.
-         */
-        if (isset($_plugin)) {
-            if (empty($_plugin[3])) {
-                if (!is_callable($_plugin[0])) {
-                    $smarty->_trigger_fatal_error("[plugin] $_type '$_name' is not implemented", $_tpl_file, $_tpl_line, __FILE__, __LINE__);
-                } else {
-                    $_plugin[1] = $_tpl_file;
-                    $_plugin[2] = $_tpl_line;
-                    $_plugin[3] = true;
-                    if (!isset($_plugin[4])) $_plugin[4] = true; /* cacheable */
-                }
-            }
-            continue;
-        } else if ($_type == 'insert') {
-            /*
-             * For backwards compatibility, we check for insert functions in
-             * the symbol table before trying to load them as a plugin.
-             */
-            $_plugin_func = 'insert_' . $_name;
-            if (function_exists($_plugin_func)) {
-                $_plugin = array($_plugin_func, $_tpl_file, $_tpl_line, true, false);
-                continue;
-            }
-        }
-
-        $_plugin_file = $smarty->_get_plugin_filepath($_type, $_name);
-
-        if (! $_found = ($_plugin_file != false)) {
-            $_message = "could not load plugin file '$_type.$_name.php'\n";
-        }
-
-        /*
-         * If plugin file is found, it -must- provide the properly named
-         * plugin function. In case it doesn't, simply output the error and
-         * do not fall back on any other method.
-         */
-        if ($_found) {
-            include_once $_plugin_file;
-
-            $_plugin_func = 'smarty_' . $_type . '_' . $_name;
-            if (!function_exists($_plugin_func)) {
-                $smarty->_trigger_fatal_error("[plugin] function $_plugin_func() not found in $_plugin_file", $_tpl_file, $_tpl_line, __FILE__, __LINE__);
-                continue;
-            }
-        }
-        /*
-         * In case of insert plugins, their code may be loaded later via
-         * 'script' attribute.
-         */
-        else if ($_type == 'insert' && $_delayed_loading) {
-            $_plugin_func = 'smarty_' . $_type . '_' . $_name;
-            $_found = true;
-        }
-
-        /*
-         * Plugin specific processing and error checking.
-         */
-        if (!$_found) {
-            if ($_type == 'modifier') {
-                /*
-                 * In case modifier falls back on using PHP functions
-                 * directly, we only allow those specified in the security
-                 * context.
-                 */
-                if ($smarty->security && !in_array($_name, $smarty->security_settings['MODIFIER_FUNCS'])) {
-                    $_message = "(secure mode) modifier '$_name' is not allowed";
-                } else {
-                    if (!function_exists($_name)) {
-                        $_message = "modifier '$_name' is not implemented";
-                    } else {
-                        $_plugin_func = $_name;
-                        $_found = true;
-                    }
-                }
-            } else if ($_type == 'function') {
-                /*
-                 * This is a catch-all situation.
-                 */
-                $_message = "unknown tag - '$_name'";
-            }
-        }
-
-        if ($_found) {
-            $smarty->_plugins[$_type][$_name] = array($_plugin_func, $_tpl_file, $_tpl_line, true, true);
-        } else {
-            // output error
-            $smarty->_trigger_fatal_error('[plugin] ' . $_message, $_tpl_file, $_tpl_line, __FILE__, __LINE__);
-        }
-    }
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.load_resource_plugin.php b/epgrec/Smarty/internals/core.load_resource_plugin.php
--- a/epgrec/Smarty/internals/core.load_resource_plugin.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.load_resource_plugin.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,74 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * load a resource plugin
- *
- * @param string $type
- */
-
-// $type
-
-function smarty_core_load_resource_plugin($params, &$smarty)
-{
-    /*
-     * Resource plugins are not quite like the other ones, so they are
-     * handled differently. The first element of plugin info is the array of
-     * functions provided by the plugin, the second one indicates whether
-     * all of them exist or not.
-     */
-
-    $_plugin = &$smarty->_plugins['resource'][$params['type']];
-    if (isset($_plugin)) {
-        if (!$_plugin[1] && count($_plugin[0])) {
-            $_plugin[1] = true;
-            foreach ($_plugin[0] as $_plugin_func) {
-                if (!is_callable($_plugin_func)) {
-                    $_plugin[1] = false;
-                    break;
-                }
-            }
-        }
-
-        if (!$_plugin[1]) {
-            $smarty->_trigger_fatal_error("[plugin] resource '" . $params['type'] . "' is not implemented", null, null, __FILE__, __LINE__);
-        }
-
-        return;
-    }
-
-    $_plugin_file = $smarty->_get_plugin_filepath('resource', $params['type']);
-    $_found = ($_plugin_file != false);
-
-    if ($_found) {            /*
-         * If the plugin file is found, it -must- provide the properly named
-         * plugin functions.
-         */
-        include_once($_plugin_file);
-
-        /*
-         * Locate functions that we require the plugin to provide.
-         */
-        $_resource_ops = array('source', 'timestamp', 'secure', 'trusted');
-        $_resource_funcs = array();
-        foreach ($_resource_ops as $_op) {
-            $_plugin_func = 'smarty_resource_' . $params['type'] . '_' . $_op;
-            if (!function_exists($_plugin_func)) {
-                $smarty->_trigger_fatal_error("[plugin] function $_plugin_func() not found in $_plugin_file", null, null, __FILE__, __LINE__);
-                return;
-            } else {
-                $_resource_funcs[] = $_plugin_func;
-            }
-        }
-
-        $smarty->_plugins['resource'][$params['type']] = array($_resource_funcs, true);
-    }
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.process_cached_inserts.php b/epgrec/Smarty/internals/core.process_cached_inserts.php
--- a/epgrec/Smarty/internals/core.process_cached_inserts.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.process_cached_inserts.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,71 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Replace cached inserts with the actual results
- *
- * @param string $results
- * @return string
- */
-function smarty_core_process_cached_inserts($params, &$smarty)
-{
-    preg_match_all('!'.$smarty->_smarty_md5.'{insert_cache (.*)}'.$smarty->_smarty_md5.'!Uis',
-                   $params['results'], $match);
-    list($cached_inserts, $insert_args) = $match;
-
-    for ($i = 0, $for_max = count($cached_inserts); $i < $for_max; $i++) {
-        if ($smarty->debugging) {
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $debug_start_time = smarty_core_get_microtime($_params, $smarty);
-        }
-
-        $args = unserialize($insert_args[$i]);
-        $name = $args['name'];
-
-        if (isset($args['script'])) {
-            $_params = array('resource_name' => $smarty->_dequote($args['script']));
-            require_once(SMARTY_CORE_DIR . 'core.get_php_resource.php');
-            if(!smarty_core_get_php_resource($_params, $smarty)) {
-                return false;
-            }
-            $resource_type = $_params['resource_type'];
-            $php_resource = $_params['php_resource'];
-
-
-            if ($resource_type == 'file') {
-                $smarty->_include($php_resource, true);
-            } else {
-                $smarty->_eval($php_resource);
-            }
-        }
-
-        $function_name = $smarty->_plugins['insert'][$name][0];
-        if (empty($args['assign'])) {
-            $replace = $function_name($args, $smarty);
-        } else {
-            $smarty->assign($args['assign'], $function_name($args, $smarty));
-            $replace = '';
-        }
-
-        $params['results'] = substr_replace($params['results'], $replace, strpos($params['results'], $cached_inserts[$i]), strlen($cached_inserts[$i]));
-        if ($smarty->debugging) {
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $smarty->_smarty_debug_info[] = array('type'      => 'insert',
-                                                'filename'  => 'insert_'.$name,
-                                                'depth'     => $smarty->_inclusion_depth,
-                                                'exec_time' => smarty_core_get_microtime($_params, $smarty) - $debug_start_time);
-        }
-    }
-
-    return $params['results'];
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.process_compiled_include.php b/epgrec/Smarty/internals/core.process_compiled_include.php
--- a/epgrec/Smarty/internals/core.process_compiled_include.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.process_compiled_include.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,37 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Replace nocache-tags by results of the corresponding non-cacheable
- * functions and return it
- *
- * @param string $compiled_tpl
- * @param string $cached_source
- * @return string
- */
-
-function smarty_core_process_compiled_include($params, &$smarty)
-{
-    $_cache_including = $smarty->_cache_including;
-    $smarty->_cache_including = true;
-
-    $_return = $params['results'];
-
-    foreach ($smarty->_cache_info['cache_serials'] as $_include_file_path=>$_cache_serial) {
-        $smarty->_include($_include_file_path, true);
-    }
-
-    foreach ($smarty->_cache_info['cache_serials'] as $_include_file_path=>$_cache_serial) {
-        $_return = preg_replace_callback('!(\{nocache\:('.$_cache_serial.')#(\d+)\})!s',
-                                         array(&$smarty, '_process_compiled_include_callback'),
-                                         $_return);
-    }
-    $smarty->_cache_including = $_cache_including;
-    return $_return;
-}
-
-?>
diff -urN a/epgrec/Smarty/internals/core.read_cache_file.php b/epgrec/Smarty/internals/core.read_cache_file.php
--- a/epgrec/Smarty/internals/core.read_cache_file.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.read_cache_file.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,101 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * read a cache file, determine if it needs to be
- * regenerated or not
- *
- * @param string $tpl_file
- * @param string $cache_id
- * @param string $compile_id
- * @param string $results
- * @return boolean
- */
-
-//  $tpl_file, $cache_id, $compile_id, &$results
-
-function smarty_core_read_cache_file(&$params, &$smarty)
-{
-    static  $content_cache = array();
-
-    if ($smarty->force_compile) {
-        // force compile enabled, always regenerate
-        return false;
-    }
-
-    if (isset($content_cache[$params['tpl_file'].','.$params['cache_id'].','.$params['compile_id']])) {
-        list($params['results'], $smarty->_cache_info) = $content_cache[$params['tpl_file'].','.$params['cache_id'].','.$params['compile_id']];
-        return true;
-    }
-
-    if (!empty($smarty->cache_handler_func)) {
-        // use cache_handler function
-        call_user_func_array($smarty->cache_handler_func,
-                             array('read', &$smarty, &$params['results'], $params['tpl_file'], $params['cache_id'], $params['compile_id'], null));
-    } else {
-        // use local cache file
-        $_auto_id = $smarty->_get_auto_id($params['cache_id'], $params['compile_id']);
-        $_cache_file = $smarty->_get_auto_filename($smarty->cache_dir, $params['tpl_file'], $_auto_id);
-        $params['results'] = $smarty->_read_file($_cache_file);
-    }
-
-    if (empty($params['results'])) {
-        // nothing to parse (error?), regenerate cache
-        return false;
-    }
-
-    $_contents = $params['results'];
-    $_info_start = strpos($_contents, "\n") + 1;
-    $_info_len = (int)substr($_contents, 0, $_info_start - 1);
-    $_cache_info = unserialize(substr($_contents, $_info_start, $_info_len));
-    $params['results'] = substr($_contents, $_info_start + $_info_len);
-
-    if ($smarty->caching == 2 && isset ($_cache_info['expires'])){
-        // caching by expiration time
-        if ($_cache_info['expires'] > -1 && (time() > $_cache_info['expires'])) {
-            // cache expired, regenerate
-            return false;
-        }
-    } else {
-        // caching by lifetime
-        if ($smarty->cache_lifetime > -1 && (time() - $_cache_info['timestamp'] > $smarty->cache_lifetime)) {
-            // cache expired, regenerate
-            return false;
-        }
-    }
-
-    if ($smarty->compile_check) {
-        $_params = array('get_source' => false, 'quiet'=>true);
-        foreach (array_keys($_cache_info['template']) as $_template_dep) {
-            $_params['resource_name'] = $_template_dep;
-            if (!$smarty->_fetch_resource_info($_params) || $_cache_info['timestamp'] < $_params['resource_timestamp']) {
-                // template file has changed, regenerate cache
-                return false;
-            }
-        }
-
-        if (isset($_cache_info['config'])) {
-            $_params = array('resource_base_path' => $smarty->config_dir, 'get_source' => false, 'quiet'=>true);
-            foreach (array_keys($_cache_info['config']) as $_config_dep) {
-                $_params['resource_name'] = $_config_dep;
-                if (!$smarty->_fetch_resource_info($_params) || $_cache_info['timestamp'] < $_params['resource_timestamp']) {
-                    // config file has changed, regenerate cache
-                    return false;
-                }
-            }
-        }
-    }
-
-    $content_cache[$params['tpl_file'].','.$params['cache_id'].','.$params['compile_id']] = array($params['results'], $_cache_info);
-
-    $smarty->_cache_info = $_cache_info;
-    return true;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.rm_auto.php b/epgrec/Smarty/internals/core.rm_auto.php
--- a/epgrec/Smarty/internals/core.rm_auto.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.rm_auto.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,71 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * delete an automagically created file by name and id
- *
- * @param string $auto_base
- * @param string $auto_source
- * @param string $auto_id
- * @param integer $exp_time
- * @return boolean
- */
-
-// $auto_base, $auto_source = null, $auto_id = null, $exp_time = null
-
-function smarty_core_rm_auto($params, &$smarty)
-{
-    if (!@is_dir($params['auto_base']))
-      return false;
-
-    if(!isset($params['auto_id']) && !isset($params['auto_source'])) {
-        $_params = array(
-            'dirname' => $params['auto_base'],
-            'level' => 0,
-            'exp_time' => $params['exp_time']
-        );
-        require_once(SMARTY_CORE_DIR . 'core.rmdir.php');
-        $_res = smarty_core_rmdir($_params, $smarty);
-    } else {
-        $_tname = $smarty->_get_auto_filename($params['auto_base'], $params['auto_source'], $params['auto_id']);
-
-        if(isset($params['auto_source'])) {
-            if (isset($params['extensions'])) {
-                $_res = false;
-                foreach ((array)$params['extensions'] as $_extension)
-                    $_res |= $smarty->_unlink($_tname.$_extension, $params['exp_time']);
-            } else {
-                $_res = $smarty->_unlink($_tname, $params['exp_time']);
-            }
-        } elseif ($smarty->use_sub_dirs) {
-            $_params = array(
-                'dirname' => $_tname,
-                'level' => 1,
-                'exp_time' => $params['exp_time']
-            );
-            require_once(SMARTY_CORE_DIR . 'core.rmdir.php');
-            $_res = smarty_core_rmdir($_params, $smarty);
-        } else {
-            // remove matching file names
-            $_handle = opendir($params['auto_base']);
-            $_res = true;
-            while (false !== ($_filename = readdir($_handle))) {
-                if($_filename == '.' || $_filename == '..') {
-                    continue;
-                } elseif (substr($params['auto_base'] . DIRECTORY_SEPARATOR . $_filename, 0, strlen($_tname)) == $_tname) {
-                    $_res &= (bool)$smarty->_unlink($params['auto_base'] . DIRECTORY_SEPARATOR . $_filename, $params['exp_time']);
-                }
-            }
-        }
-    }
-
-    return $_res;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.rmdir.php b/epgrec/Smarty/internals/core.rmdir.php
--- a/epgrec/Smarty/internals/core.rmdir.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.rmdir.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,54 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * delete a dir recursively (level=0 -> keep root)
- * WARNING: no tests, it will try to remove what you tell it!
- *
- * @param string $dirname
- * @param integer $level
- * @param integer $exp_time
- * @return boolean
- */
-
-//  $dirname, $level = 1, $exp_time = null
-
-function smarty_core_rmdir($params, &$smarty)
-{
-   if(!isset($params['level'])) { $params['level'] = 1; }
-   if(!isset($params['exp_time'])) { $params['exp_time'] = null; }
-
-   if($_handle = @opendir($params['dirname'])) {
-
-        while (false !== ($_entry = readdir($_handle))) {
-            if ($_entry != '.' && $_entry != '..') {
-                if (@is_dir($params['dirname'] . DIRECTORY_SEPARATOR . $_entry)) {
-                    $_params = array(
-                        'dirname' => $params['dirname'] . DIRECTORY_SEPARATOR . $_entry,
-                        'level' => $params['level'] + 1,
-                        'exp_time' => $params['exp_time']
-                    );
-                    smarty_core_rmdir($_params, $smarty);
-                }
-                else {
-                    $smarty->_unlink($params['dirname'] . DIRECTORY_SEPARATOR . $_entry, $params['exp_time']);
-                }
-            }
-        }
-        closedir($_handle);
-   }
-
-   if ($params['level']) {
-       return @rmdir($params['dirname']);
-   }
-   return (bool)$_handle;
-
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.run_insert_handler.php b/epgrec/Smarty/internals/core.run_insert_handler.php
--- a/epgrec/Smarty/internals/core.run_insert_handler.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.run_insert_handler.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,71 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Handle insert tags
- *
- * @param array $args
- * @return string
- */
-function smarty_core_run_insert_handler($params, &$smarty)
-{
-
-    require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-    if ($smarty->debugging) {
-        $_params = array();
-        $_debug_start_time = smarty_core_get_microtime($_params, $smarty);
-    }
-
-    if ($smarty->caching) {
-        $_arg_string = serialize($params['args']);
-        $_name = $params['args']['name'];
-        if (!isset($smarty->_cache_info['insert_tags'][$_name])) {
-            $smarty->_cache_info['insert_tags'][$_name] = array('insert',
-                                                             $_name,
-                                                             $smarty->_plugins['insert'][$_name][1],
-                                                             $smarty->_plugins['insert'][$_name][2],
-                                                             !empty($params['args']['script']) ? true : false);
-        }
-        return $smarty->_smarty_md5."{insert_cache $_arg_string}".$smarty->_smarty_md5;
-    } else {
-        if (isset($params['args']['script'])) {
-            $_params = array('resource_name' => $smarty->_dequote($params['args']['script']));
-            require_once(SMARTY_CORE_DIR . 'core.get_php_resource.php');
-            if(!smarty_core_get_php_resource($_params, $smarty)) {
-                return false;
-            }
-
-            if ($_params['resource_type'] == 'file') {
-                $smarty->_include($_params['php_resource'], true);
-            } else {
-                $smarty->_eval($_params['php_resource']);
-            }
-            unset($params['args']['script']);
-        }
-
-        $_funcname = $smarty->_plugins['insert'][$params['args']['name']][0];
-        $_content = $_funcname($params['args'], $smarty);
-        if ($smarty->debugging) {
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $smarty->_smarty_debug_info[] = array('type'      => 'insert',
-                                                'filename'  => 'insert_'.$params['args']['name'],
-                                                'depth'     => $smarty->_inclusion_depth,
-                                                'exec_time' => smarty_core_get_microtime($_params, $smarty) - $_debug_start_time);
-        }
-
-        if (!empty($params['args']["assign"])) {
-            $smarty->assign($params['args']["assign"], $_content);
-        } else {
-            return $_content;
-        }
-    }
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.smarty_include_php.php b/epgrec/Smarty/internals/core.smarty_include_php.php
--- a/epgrec/Smarty/internals/core.smarty_include_php.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.smarty_include_php.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,50 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * called for included php files within templates
- *
- * @param string $smarty_file
- * @param string $smarty_assign variable to assign the included template's
- *               output into
- * @param boolean $smarty_once uses include_once if this is true
- * @param array $smarty_include_vars associative array of vars from
- *              {include file="blah" var=$var}
- */
-
-//  $file, $assign, $once, $_smarty_include_vars
-
-function smarty_core_smarty_include_php($params, &$smarty)
-{
-    $_params = array('resource_name' => $params['smarty_file']);
-    require_once(SMARTY_CORE_DIR . 'core.get_php_resource.php');
-    smarty_core_get_php_resource($_params, $smarty);
-    $_smarty_resource_type = $_params['resource_type'];
-    $_smarty_php_resource = $_params['php_resource'];
-
-    if (!empty($params['smarty_assign'])) {
-        ob_start();
-        if ($_smarty_resource_type == 'file') {
-            $smarty->_include($_smarty_php_resource, $params['smarty_once'], $params['smarty_include_vars']);
-        } else {
-            $smarty->_eval($_smarty_php_resource, $params['smarty_include_vars']);
-        }
-        $smarty->assign($params['smarty_assign'], ob_get_contents());
-        ob_end_clean();
-    } else {
-        if ($_smarty_resource_type == 'file') {
-            $smarty->_include($_smarty_php_resource, $params['smarty_once'], $params['smarty_include_vars']);
-        } else {
-            $smarty->_eval($_smarty_php_resource, $params['smarty_include_vars']);
-        }
-    }
-}
-
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.write_cache_file.php b/epgrec/Smarty/internals/core.write_cache_file.php
--- a/epgrec/Smarty/internals/core.write_cache_file.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.write_cache_file.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,96 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Prepend the cache information to the cache file
- * and write it
- *
- * @param string $tpl_file
- * @param string $cache_id
- * @param string $compile_id
- * @param string $results
- * @return true|null
- */
-
- // $tpl_file, $cache_id, $compile_id, $results
-
-function smarty_core_write_cache_file($params, &$smarty)
-{
-
-    // put timestamp in cache header
-    $smarty->_cache_info['timestamp'] = time();
-    if ($smarty->cache_lifetime > -1){
-        // expiration set
-        $smarty->_cache_info['expires'] = $smarty->_cache_info['timestamp'] + $smarty->cache_lifetime;
-    } else {
-        // cache will never expire
-        $smarty->_cache_info['expires'] = -1;
-    }
-
-    // collapse nocache.../nocache-tags
-    if (preg_match_all('!\{(/?)nocache\:[0-9a-f]{32}#\d+\}!', $params['results'], $match, PREG_PATTERN_ORDER)) {
-        // remove everything between every pair of outermost noache.../nocache-tags
-        // and replace it by a single nocache-tag
-        // this new nocache-tag will be replaced by dynamic contents in
-        // smarty_core_process_compiled_includes() on a cache-read
-        
-        $match_count = count($match[0]);
-        $results = preg_split('!(\{/?nocache\:[0-9a-f]{32}#\d+\})!', $params['results'], -1, PREG_SPLIT_DELIM_CAPTURE);
-        
-        $level = 0;
-        $j = 0;
-        for ($i=0, $results_count = count($results); $i < $results_count && $j < $match_count; $i++) {
-            if ($results[$i] == $match[0][$j]) {
-                // nocache tag
-                if ($match[1][$j]) { // closing tag
-                    $level--;
-                    unset($results[$i]);
-                } else { // opening tag
-                    if ($level++ > 0) unset($results[$i]);
-                }
-                $j++;
-            } elseif ($level > 0) {
-                unset($results[$i]);
-            }
-        }
-        $params['results'] = implode('', $results);
-    }
-    $smarty->_cache_info['cache_serials'] = $smarty->_cache_serials;
-
-    // prepend the cache header info into cache file
-    $_cache_info = serialize($smarty->_cache_info);
-    $params['results'] = strlen($_cache_info) . "\n" . $_cache_info . $params['results'];
-
-    if (!empty($smarty->cache_handler_func)) {
-        // use cache_handler function
-        call_user_func_array($smarty->cache_handler_func,
-                             array('write', &$smarty, &$params['results'], $params['tpl_file'], $params['cache_id'], $params['compile_id'], $smarty->_cache_info['expires']));
-    } else {
-        // use local cache file
-
-        if(!@is_writable($smarty->cache_dir)) {
-            // cache_dir not writable, see if it exists
-            if(!@is_dir($smarty->cache_dir)) {
-                $smarty->trigger_error('the $cache_dir \'' . $smarty->cache_dir . '\' does not exist, or is not a directory.', E_USER_ERROR);
-                return false;
-            }
-            $smarty->trigger_error('unable to write to $cache_dir \'' . realpath($smarty->cache_dir) . '\'. Be sure $cache_dir is writable by the web server user.', E_USER_ERROR);
-            return false;
-        }
-
-        $_auto_id = $smarty->_get_auto_id($params['cache_id'], $params['compile_id']);
-        $_cache_file = $smarty->_get_auto_filename($smarty->cache_dir, $params['tpl_file'], $_auto_id);
-        $_params = array('filename' => $_cache_file, 'contents' => $params['results'], 'create_dirs' => true);
-        require_once(SMARTY_CORE_DIR . 'core.write_file.php');
-        smarty_core_write_file($_params, $smarty);
-        return true;
-    }
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.write_compiled_include.php b/epgrec/Smarty/internals/core.write_compiled_include.php
--- a/epgrec/Smarty/internals/core.write_compiled_include.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.write_compiled_include.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,91 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Extract non-cacheable parts out of compiled template and write it
- *
- * @param string $compile_path
- * @param string $template_compiled
- * @return boolean
- */
-
-function smarty_core_write_compiled_include($params, &$smarty)
-{
-    $_tag_start = 'if \(\$this->caching && \!\$this->_cache_including\)\: echo \'\{nocache\:('.$params['cache_serial'].')#(\d+)\}\'; endif;';
-    $_tag_end   = 'if \(\$this->caching && \!\$this->_cache_including\)\: echo \'\{/nocache\:(\\2)#(\\3)\}\'; endif;';
-
-    preg_match_all('!('.$_tag_start.'(.*)'.$_tag_end.')!Us',
-                   $params['compiled_content'], $_match_source, PREG_SET_ORDER);
-    
-    // no nocache-parts found: done
-    if (count($_match_source)==0) return;
-
-    // convert the matched php-code to functions
-    $_include_compiled =  "<?php /* Smarty version ".$smarty->_version.", created on ".strftime("%Y-%m-%d %H:%M:%S")."\n";
-    $_include_compiled .= "         compiled from " . strtr(urlencode($params['resource_name']), array('%2F'=>'/', '%3A'=>':')) . " */\n\n";
-
-    $_compile_path = $params['include_file_path'];
-
-    $smarty->_cache_serials[$_compile_path] = $params['cache_serial'];
-    $_include_compiled .= "\$this->_cache_serials['".$_compile_path."'] = '".$params['cache_serial']."';\n\n?>";
-
-    $_include_compiled .= $params['plugins_code'];
-    $_include_compiled .= "<?php";
-
-    $this_varname = ((double)phpversion() >= 5.0) ? '_smarty' : 'this';
-    for ($_i = 0, $_for_max = count($_match_source); $_i < $_for_max; $_i++) {
-        $_match =& $_match_source[$_i];
-        $source = $_match[4];
-        if ($this_varname == '_smarty') {
-            /* rename $this to $_smarty in the sourcecode */
-            $tokens = token_get_all('<?php ' . $_match[4]);
-
-            /* remove trailing <?php */
-            $open_tag = '';
-            while ($tokens) {
-                $token = array_shift($tokens);
-                if (is_array($token)) {
-                    $open_tag .= $token[1];
-                } else {
-                    $open_tag .= $token;
-                }
-                if ($open_tag == '<?php ') break;
-            }
-
-            for ($i=0, $count = count($tokens); $i < $count; $i++) {
-                if (is_array($tokens[$i])) {
-                    if ($tokens[$i][0] == T_VARIABLE && $tokens[$i][1] == '$this') {
-                        $tokens[$i] = '$' . $this_varname;
-                    } else {
-                        $tokens[$i] = $tokens[$i][1];
-                    }                   
-                }
-            }
-            $source = implode('', $tokens);
-        }
-
-        /* add function to compiled include */
-        $_include_compiled .= "
-function _smarty_tplfunc_$_match[2]_$_match[3](&\$$this_varname)
-{
-$source
-}
-
-";
-    }
-    $_include_compiled .= "\n\n?>\n";
-
-    $_params = array('filename' => $_compile_path,
-                     'contents' => $_include_compiled, 'create_dirs' => true);
-
-    require_once(SMARTY_CORE_DIR . 'core.write_file.php');
-    smarty_core_write_file($_params, $smarty);
-    return true;
-}
-
-
-?>
diff -urN a/epgrec/Smarty/internals/core.write_compiled_resource.php b/epgrec/Smarty/internals/core.write_compiled_resource.php
--- a/epgrec/Smarty/internals/core.write_compiled_resource.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.write_compiled_resource.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,35 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * write the compiled resource
- *
- * @param string $compile_path
- * @param string $compiled_content
- * @return true
- */
-function smarty_core_write_compiled_resource($params, &$smarty)
-{
-    if(!@is_writable($smarty->compile_dir)) {
-        // compile_dir not writable, see if it exists
-        if(!@is_dir($smarty->compile_dir)) {
-            $smarty->trigger_error('the $compile_dir \'' . $smarty->compile_dir . '\' does not exist, or is not a directory.', E_USER_ERROR);
-            return false;
-        }
-        $smarty->trigger_error('unable to write to $compile_dir \'' . realpath($smarty->compile_dir) . '\'. Be sure $compile_dir is writable by the web server user.', E_USER_ERROR);
-        return false;
-    }
-
-    $_params = array('filename' => $params['compile_path'], 'contents' => $params['compiled_content'], 'create_dirs' => true);
-    require_once(SMARTY_CORE_DIR . 'core.write_file.php');
-    smarty_core_write_file($_params, $smarty);
-    return true;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/internals/core.write_file.php b/epgrec/Smarty/internals/core.write_file.php
--- a/epgrec/Smarty/internals/core.write_file.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/internals/core.write_file.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,54 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * write out a file to disk
- *
- * @param string $filename
- * @param string $contents
- * @param boolean $create_dirs
- * @return boolean
- */
-function smarty_core_write_file($params, &$smarty)
-{
-    $_dirname = dirname($params['filename']);
-
-    if ($params['create_dirs']) {
-        $_params = array('dir' => $_dirname);
-        require_once(SMARTY_CORE_DIR . 'core.create_dir_structure.php');
-        smarty_core_create_dir_structure($_params, $smarty);
-    }
-
-    // write to tmp file, then rename it to avoid file locking race condition
-    $_tmp_file = tempnam($_dirname, 'wrt');
-
-    if (!($fd = @fopen($_tmp_file, 'wb'))) {
-        $_tmp_file = $_dirname . DIRECTORY_SEPARATOR . uniqid('wrt');
-        if (!($fd = @fopen($_tmp_file, 'wb'))) {
-            $smarty->trigger_error("problem writing temporary file '$_tmp_file'");
-            return false;
-        }
-    }
-
-    fwrite($fd, $params['contents']);
-    fclose($fd);
-
-    if (DIRECTORY_SEPARATOR == '\\' || !@rename($_tmp_file, $params['filename'])) {
-        // On platforms and filesystems that cannot overwrite with rename() 
-        // delete the file before renaming it -- because windows always suffers
-        // this, it is short-circuited to avoid the initial rename() attempt
-        @unlink($params['filename']);
-        @rename($_tmp_file, $params['filename']);
-    }
-    @chmod($params['filename'], $smarty->_file_perms);
-
-    return true;
-}
-
-/* vim: set expandtab: */
-
-?>
\ 
diff -urN a/epgrec/Smarty/plugins/block.textformat.php b/epgrec/Smarty/plugins/block.textformat.php
--- a/epgrec/Smarty/plugins/block.textformat.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/block.textformat.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,39 +1,52 @@
 <?php
 /**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ * Smarty plugin to format text blocks
+ *
+ * @package    Smarty
+ * @subpackage PluginsBlock
  */
-
 /**
  * Smarty {textformat}{/textformat} block plugin
- *
- * Type:     block function<br>
- * Name:     textformat<br>
+ * Type:     block function
+ * Name:     textformat
  * Purpose:  format text a certain way with preset styles
- *           or custom wrap/indent settings<br>
- * @link http://smarty.php.net/manual/en/language.function.textformat.php {textformat}
- *       (Smarty online manual)
- * @param array
- * <pre>
- * Params:   style: string (email)
- *           indent: integer (0)
- *           wrap: integer (80)
- *           wrap_char string ("\n")
- *           indent_char: string (" ")
- *           wrap_boundary: boolean (true)
- * </pre>
+ *           or custom wrap/indent settings
+ * Params:
+ *
+ * - style         - string (email)
+ * - indent        - integer (0)
+ * - wrap          - integer (80)
+ * - wrap_char     - string ("\n")
+ * - indent_char   - string (" ")
+ * - wrap_boundary - boolean (true)
+ *
+ * @link   http://www.smarty.net/manual/en/language.function.textformat.php {textformat}
+ *         (Smarty online manual)
+ *
+ * @param array                    $params   parameters
+ * @param string                   $content  contents of the block
+ * @param Smarty_Internal_Template $template template object
+ * @param boolean                  &$repeat  repeat flag
+ *
+ * @return string content re-formatted
  * @author Monte Ohrt <monte at ohrt dot com>
- * @param string contents of the block
- * @param Smarty clever simulation of a method
- * @return string string $content re-formatted
+ * @throws \SmartyException
  */
-function smarty_block_textformat($params, $content, &$smarty)
+function smarty_block_textformat($params, $content, Smarty_Internal_Template $template, &$repeat)
 {
     if (is_null($content)) {
         return;
     }
-
+    if (Smarty::$_MBSTRING) {
+        $template->_checkPlugins(
+            array(
+                array(
+                    'function' => 'smarty_modifier_mb_wordwrap',
+                    'file'     => SMARTY_PLUGINS_DIR . 'modifier.mb_wordwrap.php'
+                )
+            )
+        );
+    }
     $style = null;
     $indent = 0;
     $indent_first = 0;
@@ -42,7 +55,6 @@
     $wrap_char = "\n";
     $wrap_cut = false;
     $assign = null;
-    
     foreach ($params as $_key => $_val) {
         switch ($_key) {
             case 'style':
@@ -51,53 +63,59 @@
             case 'assign':
                 $$_key = (string)$_val;
                 break;
-
             case 'indent':
             case 'indent_first':
             case 'wrap':
                 $$_key = (int)$_val;
                 break;
-
             case 'wrap_cut':
                 $$_key = (bool)$_val;
                 break;
-
             default:
-                $smarty->trigger_error("textformat: unknown attribute '$_key'");
+                trigger_error("textformat: unknown attribute '{$_key}'");
         }
     }
-
-    if ($style == 'email') {
+    if ($style === 'email') {
         $wrap = 72;
     }
-
     // split into paragraphs
-    $_paragraphs = preg_split('![\r\n][\r\n]!',$content);
-    $_output = '';
-
-    for($_x = 0, $_y = count($_paragraphs); $_x < $_y; $_x++) {
-        if ($_paragraphs[$_x] == '') {
+    $_paragraphs = preg_split('![\r\n]{2}!', $content);
+    foreach ($_paragraphs as &$_paragraph) {
+        if (!$_paragraph) {
             continue;
         }
         // convert mult. spaces & special chars to single space
-        $_paragraphs[$_x] = preg_replace(array('!\s+!','!(^\s+)|(\s+$)!'), array(' ',''), $_paragraphs[$_x]);
+        $_paragraph =
+            preg_replace(
+                array(
+                    '!\s+!' . Smarty::$_UTF8_MODIFIER,
+                    '!(^\s+)|(\s+$)!' . Smarty::$_UTF8_MODIFIER
+                ),
+                array(
+                    ' ',
+                    ''
+                ),
+                $_paragraph
+            );
         // indent first line
-        if($indent_first > 0) {
-            $_paragraphs[$_x] = str_repeat($indent_char, $indent_first) . $_paragraphs[$_x];
+        if ($indent_first > 0) {
+            $_paragraph = str_repeat($indent_char, $indent_first) . $_paragraph;
         }
         // wordwrap sentences
-        $_paragraphs[$_x] = wordwrap($_paragraphs[$_x], $wrap - $indent, $wrap_char, $wrap_cut);
+        if (Smarty::$_MBSTRING) {
+            $_paragraph = smarty_modifier_mb_wordwrap($_paragraph, $wrap - $indent, $wrap_char, $wrap_cut);
+        } else {
+            $_paragraph = wordwrap($_paragraph, $wrap - $indent, $wrap_char, $wrap_cut);
+        }
         // indent lines
-        if($indent > 0) {
-            $_paragraphs[$_x] = preg_replace('!^!m', str_repeat($indent_char, $indent), $_paragraphs[$_x]);
+        if ($indent > 0) {
+            $_paragraph = preg_replace('!^!m', str_repeat($indent_char, $indent), $_paragraph);
         }
     }
     $_output = implode($wrap_char . $wrap_char, $_paragraphs);
-
-    return $assign ? $smarty->assign($assign, $_output) : $_output;
-
+    if ($assign) {
+        $template->assign($assign, $_output);
+    } else {
+        return $_output;
+    }
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/compiler.assign.php b/epgrec/Smarty/plugins/compiler.assign.php
--- a/epgrec/Smarty/plugins/compiler.assign.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/compiler.assign.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,40 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Smarty {assign} compiler function plugin
- *
- * Type:     compiler function<br>
- * Name:     assign<br>
- * Purpose:  assign a value to a template variable
- * @link http://smarty.php.net/manual/en/language.custom.functions.php#LANGUAGE.FUNCTION.ASSIGN {assign}
- *       (Smarty online manual)
- * @author Monte Ohrt <monte at ohrt dot com> (initial author)
- * @author messju mohr <messju at lammfellpuschen dot de> (conversion to compiler function)
- * @param string containing var-attribute and value-attribute
- * @param Smarty_Compiler
- */
-function smarty_compiler_assign($tag_attrs, &$compiler)
-{
-    $_params = $compiler->_parse_attrs($tag_attrs);
-
-    if (!isset($_params['var'])) {
-        $compiler->_syntax_error("assign: missing 'var' parameter", E_USER_WARNING);
-        return;
-    }
-
-    if (!isset($_params['value'])) {
-        $compiler->_syntax_error("assign: missing 'value' parameter", E_USER_WARNING);
-        return;
-    }
-
-    return "\$this->assign({$_params['var']}, {$_params['value']});";
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.assign_debug_info.php b/epgrec/Smarty/plugins/function.assign_debug_info.php
--- a/epgrec/Smarty/plugins/function.assign_debug_info.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.assign_debug_info.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,40 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Smarty {assign_debug_info} function plugin
- *
- * Type:     function<br>
- * Name:     assign_debug_info<br>
- * Purpose:  assign debug info to the template<br>
- * @author Monte Ohrt <monte at ohrt dot com>
- * @param array unused in this plugin, this plugin uses {@link Smarty::$_config},
- *              {@link Smarty::$_tpl_vars} and {@link Smarty::$_smarty_debug_info}
- * @param Smarty
- */
-function smarty_function_assign_debug_info($params, &$smarty)
-{
-    $assigned_vars = $smarty->_tpl_vars;
-    ksort($assigned_vars);
-    if (@is_array($smarty->_config[0])) {
-        $config_vars = $smarty->_config[0];
-        ksort($config_vars);
-        $smarty->assign("_debug_config_keys", array_keys($config_vars));
-        $smarty->assign("_debug_config_vals", array_values($config_vars));
-    }
-    
-    $included_templates = $smarty->_smarty_debug_info;
-    
-    $smarty->assign("_debug_keys", array_keys($assigned_vars));
-    $smarty->assign("_debug_vals", array_values($assigned_vars));
-    
-    $smarty->assign("_debug_tpls", $included_templates);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.config_load.php b/epgrec/Smarty/plugins/function.config_load.php
--- a/epgrec/Smarty/plugins/function.config_load.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.config_load.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,142 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Smarty {config_load} function plugin
- *
- * Type:     function<br>
- * Name:     config_load<br>
- * Purpose:  load config file vars
- * @link http://smarty.php.net/manual/en/language.function.config.load.php {config_load}
- *       (Smarty online manual)
- * @author Monte Ohrt <monte at ohrt dot com>
- * @author messju mohr <messju at lammfellpuschen dot de> (added use of resources)
- * @param array Format:
- * <pre>
- * array('file' => required config file name,
- *       'section' => optional config file section to load
- *       'scope' => local/parent/global
- *       'global' => overrides scope, setting to parent if true)
- * </pre>
- * @param Smarty
- */
-function smarty_function_config_load($params, &$smarty)
-{
-        if ($smarty->debugging) {
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $_debug_start_time = smarty_core_get_microtime($_params, $smarty);
-        }
-
-        $_file = isset($params['file']) ? $smarty->_dequote($params['file']) : null;
-        $_section = isset($params['section']) ? $smarty->_dequote($params['section']) : null;
-        $_scope = isset($params['scope']) ? $smarty->_dequote($params['scope']) : 'global';
-        $_global = isset($params['global']) ? $smarty->_dequote($params['global']) : false;
-
-        if (!isset($_file) || strlen($_file) == 0) {
-            $smarty->trigger_error("missing 'file' attribute in config_load tag", E_USER_ERROR, __FILE__, __LINE__);
-        }
-
-        if (isset($_scope)) {
-            if ($_scope != 'local' &&
-                $_scope != 'parent' &&
-                $_scope != 'global') {
-                $smarty->trigger_error("invalid 'scope' attribute value", E_USER_ERROR, __FILE__, __LINE__);
-            }
-        } else {
-            if ($_global) {
-                $_scope = 'parent';
-            } else {
-                $_scope = 'local';
-            }
-        }
-
-        $_params = array('resource_name' => $_file,
-                         'resource_base_path' => $smarty->config_dir,
-                         'get_source' => false);
-        $smarty->_parse_resource_name($_params);
-        $_file_path = $_params['resource_type'] . ':' . $_params['resource_name'];
-        if (isset($_section))
-            $_compile_file = $smarty->_get_compile_path($_file_path.'|'.$_section);
-        else
-            $_compile_file = $smarty->_get_compile_path($_file_path);
-
-        if($smarty->force_compile || !file_exists($_compile_file)) {
-            $_compile = true;
-        } elseif ($smarty->compile_check) {
-            $_params = array('resource_name' => $_file,
-                             'resource_base_path' => $smarty->config_dir,
-                             'get_source' => false);
-            $_compile = $smarty->_fetch_resource_info($_params) &&
-                $_params['resource_timestamp'] > filemtime($_compile_file);
-        } else {
-            $_compile = false;
-        }
-
-        if($_compile) {
-            // compile config file
-            if(!is_object($smarty->_conf_obj)) {
-                require_once SMARTY_DIR . $smarty->config_class . '.class.php';
-                $smarty->_conf_obj = new $smarty->config_class();
-                $smarty->_conf_obj->overwrite = $smarty->config_overwrite;
-                $smarty->_conf_obj->booleanize = $smarty->config_booleanize;
-                $smarty->_conf_obj->read_hidden = $smarty->config_read_hidden;
-                $smarty->_conf_obj->fix_newlines = $smarty->config_fix_newlines;
-            }
-
-            $_params = array('resource_name' => $_file,
-                             'resource_base_path' => $smarty->config_dir,
-                             $_params['get_source'] = true);
-            if (!$smarty->_fetch_resource_info($_params)) {
-                return;
-            }
-            $smarty->_conf_obj->set_file_contents($_file, $_params['source_content']);
-            $_config_vars = array_merge($smarty->_conf_obj->get($_file),
-                    $smarty->_conf_obj->get($_file, $_section));
-            if(function_exists('var_export')) {
-                $_output = '<?php $_config_vars = ' . var_export($_config_vars, true) . '; ?>';
-            } else {
-                $_output = '<?php $_config_vars = unserialize(\'' . strtr(serialize($_config_vars),array('\''=>'\\\'', '\\'=>'\\\\')) . '\'); ?>';
-            }
-            $_params = (array('compile_path' => $_compile_file, 'compiled_content' => $_output, 'resource_timestamp' => $_params['resource_timestamp']));
-            require_once(SMARTY_CORE_DIR . 'core.write_compiled_resource.php');
-            smarty_core_write_compiled_resource($_params, $smarty);
-        } else {
-            include($_compile_file);
-        }
-
-        if ($smarty->caching) {
-            $smarty->_cache_info['config'][$_file] = true;
-        }
-
-        $smarty->_config[0]['vars'] = @array_merge($smarty->_config[0]['vars'], $_config_vars);
-        $smarty->_config[0]['files'][$_file] = true;
-
-        if ($_scope == 'parent') {
-                $smarty->_config[1]['vars'] = @array_merge($smarty->_config[1]['vars'], $_config_vars);
-                $smarty->_config[1]['files'][$_file] = true;
-        } else if ($_scope == 'global') {
-            for ($i = 1, $for_max = count($smarty->_config); $i < $for_max; $i++) {
-                $smarty->_config[$i]['vars'] = @array_merge($smarty->_config[$i]['vars'], $_config_vars);
-                $smarty->_config[$i]['files'][$_file] = true;
-            }
-        }
-
-        if ($smarty->debugging) {
-            $_params = array();
-            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
-            $smarty->_smarty_debug_info[] = array('type'      => 'config',
-                                                'filename'  => $_file.' ['.$_section.'] '.$_scope,
-                                                'depth'     => $smarty->_inclusion_depth,
-                                                'exec_time' => smarty_core_get_microtime($_params, $smarty) - $_debug_start_time);
-        }
-
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.counter.php b/epgrec/Smarty/plugins/function.counter.php
--- a/epgrec/Smarty/plugins/function.counter.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.counter.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,80 +1,62 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {counter} function plugin
- *
- * Type:     function<br>
- * Name:     counter<br>
+ * Type:     function
+ * Name:     counter
  * Purpose:  print out a counter value
+ *
  * @author Monte Ohrt <monte at ohrt dot com>
- * @link http://smarty.php.net/manual/en/language.function.counter.php {counter}
- *       (Smarty online manual)
- * @param array parameters
- * @param Smarty
+ * @link   http://www.smarty.net/manual/en/language.function.counter.php {counter}
+ *         (Smarty online manual)
+ *
+ * @param array                    $params   parameters
+ * @param Smarty_Internal_Template $template template object
+ *
  * @return string|null
  */
-function smarty_function_counter($params, &$smarty)
+function smarty_function_counter($params, $template)
 {
     static $counters = array();
-
-    $name = (isset($params['name'])) ? $params['name'] : 'default';
-    if (!isset($counters[$name])) {
-        $counters[$name] = array(
-            'start'=>1,
-            'skip'=>1,
-            'direction'=>'up',
-            'count'=>1
-            );
-    }
-    $counter =& $counters[$name];
-
-    if (isset($params['start'])) {
-        $counter['start'] = $counter['count'] = (int)$params['start'];
-    }
-
-    if (!empty($params['assign'])) {
-        $counter['assign'] = $params['assign'];
-    }
-
-    if (isset($counter['assign'])) {
-        $smarty->assign($counter['assign'], $counter['count']);
-    }
-    
-    if (isset($params['print'])) {
-        $print = (bool)$params['print'];
+    $name = (isset($params[ 'name' ])) ? $params[ 'name' ] : 'default';
+    if (!isset($counters[ $name ])) {
+        $counters[ $name ] = array('start' => 1, 'skip' => 1, 'direction' => 'up', 'count' => 1);
+    }
+    $counter =& $counters[ $name ];
+    if (isset($params[ 'start' ])) {
+        $counter[ 'start' ] = $counter[ 'count' ] = (int)$params[ 'start' ];
+    }
+    if (!empty($params[ 'assign' ])) {
+        $counter[ 'assign' ] = $params[ 'assign' ];
+    }
+    if (isset($counter[ 'assign' ])) {
+        $template->assign($counter[ 'assign' ], $counter[ 'count' ]);
+    }
+    if (isset($params[ 'print' ])) {
+        $print = (bool)$params[ 'print' ];
     } else {
-        $print = empty($counter['assign']);
+        $print = empty($counter[ 'assign' ]);
     }
-
     if ($print) {
-        $retval = $counter['count'];
+        $retval = $counter[ 'count' ];
     } else {
         $retval = null;
     }
-
-    if (isset($params['skip'])) {
-        $counter['skip'] = $params['skip'];
-    }
-    
-    if (isset($params['direction'])) {
-        $counter['direction'] = $params['direction'];
-    }
-
-    if ($counter['direction'] == "down")
-        $counter['count'] -= $counter['skip'];
-    else
-        $counter['count'] += $counter['skip'];
-    
+    if (isset($params[ 'skip' ])) {
+        $counter[ 'skip' ] = $params[ 'skip' ];
+    }
+    if (isset($params[ 'direction' ])) {
+        $counter[ 'direction' ] = $params[ 'direction' ];
+    }
+    if ($counter[ 'direction' ] === 'down') {
+        $counter[ 'count' ] -= $counter[ 'skip' ];
+    } else {
+        $counter[ 'count' ] += $counter[ 'skip' ];
+    }
     return $retval;
-    
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.cycle.php b/epgrec/Smarty/plugins/function.cycle.php
--- a/epgrec/Smarty/plugins/function.cycle.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.cycle.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,106 +1,92 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
 /**
  * Smarty {cycle} function plugin
+ * Type:     function
+ * Name:     cycle
+ * Date:     May 3, 2002
+ * Purpose:  cycle through given values
+ * Params:
+ *
+ * - name      - name of cycle (optional)
+ * - values    - comma separated list of values to cycle, or an array of values to cycle
+ *               (this can be left out for subsequent calls)
+ * - reset     - boolean - resets given var to true
+ * - print     - boolean - print var or not. default is true
+ * - advance   - boolean - whether or not to advance the cycle
+ * - delimiter - the value delimiter, default is ","
+ * - assign    - boolean, assigns to template var instead of printed.
  *
- * Type:     function<br>
- * Name:     cycle<br>
- * Date:     May 3, 2002<br>
- * Purpose:  cycle through given values<br>
- * Input:
- *         - name = name of cycle (optional)
- *         - values = comma separated list of values to cycle,
- *                    or an array of values to cycle
- *                    (this can be left out for subsequent calls)
- *         - reset = boolean - resets given var to true
- *         - print = boolean - print var or not. default is true
- *         - advance = boolean - whether or not to advance the cycle
- *         - delimiter = the value delimiter, default is ","
- *         - assign = boolean, assigns to template var instead of
- *                    printed.
+ * Examples:
  *
- * Examples:<br>
- * <pre>
  * {cycle values="#eeeeee,#d0d0d0d"}
  * {cycle name=row values="one,two,three" reset=true}
  * {cycle name=row}
- * </pre>
- * @link http://smarty.php.net/manual/en/language.function.cycle.php {cycle}
- *       (Smarty online manual)
- * @author Monte Ohrt <monte at ohrt dot com>
- * @author credit to Mark Priatel <mpriatel@rogers.com>
- * @author credit to Gerard <gerard@interfold.com>
- * @author credit to Jason Sweat <jsweat_php@yahoo.com>
- * @version  1.3
- * @param array
- * @param Smarty
+ *
+ * @link    http://www.smarty.net/manual/en/language.function.cycle.php {cycle}
+ *           (Smarty online manual)
+ * @author  Monte Ohrt <monte at ohrt dot com>
+ * @author  credit to Mark Priatel <mpriatel@rogers.com>
+ * @author  credit to Gerard <gerard@interfold.com>
+ * @author  credit to Jason Sweat <jsweat_php@yahoo.com>
+ * @version 1.3
+ *
+ * @param array                    $params   parameters
+ * @param Smarty_Internal_Template $template template object
+ *
  * @return string|null
  */
-function smarty_function_cycle($params, &$smarty)
+function smarty_function_cycle($params, $template)
 {
     static $cycle_vars;
-    
-    $name = (empty($params['name'])) ? 'default' : $params['name'];
-    $print = (isset($params['print'])) ? (bool)$params['print'] : true;
-    $advance = (isset($params['advance'])) ? (bool)$params['advance'] : true;
-    $reset = (isset($params['reset'])) ? (bool)$params['reset'] : false;
-            
-    if (!in_array('values', array_keys($params))) {
-        if(!isset($cycle_vars[$name]['values'])) {
-            $smarty->trigger_error("cycle: missing 'values' parameter");
+    $name = (empty($params[ 'name' ])) ? 'default' : $params[ 'name' ];
+    $print = (isset($params[ 'print' ])) ? (bool)$params[ 'print' ] : true;
+    $advance = (isset($params[ 'advance' ])) ? (bool)$params[ 'advance' ] : true;
+    $reset = (isset($params[ 'reset' ])) ? (bool)$params[ 'reset' ] : false;
+    if (!isset($params[ 'values' ])) {
+        if (!isset($cycle_vars[ $name ][ 'values' ])) {
+            trigger_error('cycle: missing \'values\' parameter');
             return;
         }
     } else {
-        if(isset($cycle_vars[$name]['values'])
-            && $cycle_vars[$name]['values'] != $params['values'] ) {
-            $cycle_vars[$name]['index'] = 0;
+        if (isset($cycle_vars[ $name ][ 'values' ]) && $cycle_vars[ $name ][ 'values' ] !== $params[ 'values' ]) {
+            $cycle_vars[ $name ][ 'index' ] = 0;
         }
-        $cycle_vars[$name]['values'] = $params['values'];
+        $cycle_vars[ $name ][ 'values' ] = $params[ 'values' ];
+    }
+    if (isset($params[ 'delimiter' ])) {
+        $cycle_vars[ $name ][ 'delimiter' ] = $params[ 'delimiter' ];
+    } elseif (!isset($cycle_vars[ $name ][ 'delimiter' ])) {
+        $cycle_vars[ $name ][ 'delimiter' ] = ',';
     }
-
-    if (isset($params['delimiter'])) {
-        $cycle_vars[$name]['delimiter'] = $params['delimiter'];
-    } elseif (!isset($cycle_vars[$name]['delimiter'])) {
-        $cycle_vars[$name]['delimiter'] = ',';       
-    }
-    
-    if(is_array($cycle_vars[$name]['values'])) {
-        $cycle_array = $cycle_vars[$name]['values'];
+    if (is_array($cycle_vars[ $name ][ 'values' ])) {
+        $cycle_array = $cycle_vars[ $name ][ 'values' ];
     } else {
-        $cycle_array = explode($cycle_vars[$name]['delimiter'],$cycle_vars[$name]['values']);
+        $cycle_array = explode($cycle_vars[ $name ][ 'delimiter' ], $cycle_vars[ $name ][ 'values' ]);
     }
-    
-    if(!isset($cycle_vars[$name]['index']) || $reset ) {
-        $cycle_vars[$name]['index'] = 0;
+    if (!isset($cycle_vars[ $name ][ 'index' ]) || $reset) {
+        $cycle_vars[ $name ][ 'index' ] = 0;
     }
-    
-    if (isset($params['assign'])) {
+    if (isset($params[ 'assign' ])) {
         $print = false;
-        $smarty->assign($params['assign'], $cycle_array[$cycle_vars[$name]['index']]);
+        $template->assign($params[ 'assign' ], $cycle_array[ $cycle_vars[ $name ][ 'index' ] ]);
     }
-        
-    if($print) {
-        $retval = $cycle_array[$cycle_vars[$name]['index']];
+    if ($print) {
+        $retval = $cycle_array[ $cycle_vars[ $name ][ 'index' ] ];
     } else {
         $retval = null;
     }
-
-    if($advance) {
-        if ( $cycle_vars[$name]['index'] >= count($cycle_array) -1 ) {
-            $cycle_vars[$name]['index'] = 0;
+    if ($advance) {
+        if ($cycle_vars[ $name ][ 'index' ] >= count($cycle_array) - 1) {
+            $cycle_vars[ $name ][ 'index' ] = 0;
         } else {
-            $cycle_vars[$name]['index']++;
+            $cycle_vars[ $name ][ 'index' ]++;
         }
     }
-    
     return $retval;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.debug.php b/epgrec/Smarty/plugins/function.debug.php
--- a/epgrec/Smarty/plugins/function.debug.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.debug.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,35 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty {debug} function plugin
- *
- * Type:     function<br>
- * Name:     debug<br>
- * Date:     July 1, 2002<br>
- * Purpose:  popup debug window
- * @link http://smarty.php.net/manual/en/language.function.debug.php {debug}
- *       (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @version  1.0
- * @param array
- * @param Smarty
- * @return string output from {@link Smarty::_generate_debug_output()}
- */
-function smarty_function_debug($params, &$smarty)
-{
-    if (isset($params['output'])) {
-        $smarty->assign('_smarty_debug_output', $params['output']);
-    }
-    require_once(SMARTY_CORE_DIR . 'core.display_debug_console.php');
-    return smarty_core_display_debug_console(null, $smarty);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.eval.php b/epgrec/Smarty/plugins/function.eval.php
--- a/epgrec/Smarty/plugins/function.eval.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.eval.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,49 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty {eval} function plugin
- *
- * Type:     function<br>
- * Name:     eval<br>
- * Purpose:  evaluate a template variable as a template<br>
- * @link http://smarty.php.net/manual/en/language.function.eval.php {eval}
- *       (Smarty online manual)
- * @author Monte Ohrt <monte at ohrt dot com>
- * @param array
- * @param Smarty
- */
-function smarty_function_eval($params, &$smarty)
-{
-
-    if (!isset($params['var'])) {
-        $smarty->trigger_error("eval: missing 'var' parameter");
-        return;
-    }
-
-    if($params['var'] == '') {
-        return;
-    }
-
-    $smarty->_compile_source('evaluated template', $params['var'], $_var_compiled);
-
-    ob_start();
-    $smarty->_eval('?>' . $_var_compiled);
-    $_contents = ob_get_contents();
-    ob_end_clean();
-
-    if (!empty($params['assign'])) {
-        $smarty->assign($params['assign'], $_contents);
-    } else {
-        return $_contents;
-    }
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.fetch.php b/epgrec/Smarty/plugins/function.fetch.php
--- a/epgrec/Smarty/plugins/function.fetch.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.fetch.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,221 +1,204 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {fetch} plugin
- *
- * Type:     function<br>
- * Name:     fetch<br>
+ * Type:     function
+ * Name:     fetch
  * Purpose:  fetch file, web or ftp data and display results
- * @link http://smarty.php.net/manual/en/language.function.fetch.php {fetch}
- *       (Smarty online manual)
+ *
+ * @link   http://www.smarty.net/manual/en/language.function.fetch.php {fetch}
+ *         (Smarty online manual)
  * @author Monte Ohrt <monte at ohrt dot com>
- * @param array
- * @param Smarty
- * @return string|null if the assign parameter is passed, Smarty assigns the
- *                     result to a template variable
+ *
+ * @param array                    $params   parameters
+ * @param Smarty_Internal_Template $template template object
+ *
+ * @throws SmartyException
+ * @return string|null if the assign parameter is passed, Smarty assigns the result to a template variable
  */
-function smarty_function_fetch($params, &$smarty)
+function smarty_function_fetch($params, $template)
 {
-    if (empty($params['file'])) {
-        $smarty->_trigger_fatal_error("[plugin] parameter 'file' cannot be empty");
+    if (empty($params[ 'file' ])) {
+        trigger_error('[plugin] fetch parameter \'file\' cannot be empty', E_USER_NOTICE);
         return;
     }
-
-    $content = '';
-    if ($smarty->security && !preg_match('!^(http|ftp)://!i', $params['file'])) {
-        $_params = array('resource_type' => 'file', 'resource_name' => $params['file']);
-        require_once(SMARTY_CORE_DIR . 'core.is_secure.php');
-        if(!smarty_core_is_secure($_params, $smarty)) {
-            $smarty->_trigger_fatal_error('[plugin] (secure mode) fetch \'' . $params['file'] . '\' is not allowed');
-            return;
-        }
-        
-        // fetch the file
-        if($fp = @fopen($params['file'],'r')) {
-            while(!feof($fp)) {
-                $content .= fgets ($fp,4096);
+    // strip file protocol
+    if (stripos($params[ 'file' ], 'file://') === 0) {
+        $params[ 'file' ] = substr($params[ 'file' ], 7);
+    }
+    $protocol = strpos($params[ 'file' ], '://');
+    if ($protocol !== false) {
+        $protocol = strtolower(substr($params[ 'file' ], 0, $protocol));
+    }
+    if (isset($template->smarty->security_policy)) {
+        if ($protocol) {
+            // remote resource (or php stream, )
+            if (!$template->smarty->security_policy->isTrustedUri($params[ 'file' ])) {
+                return;
             }
-            fclose($fp);
         } else {
-            $smarty->_trigger_fatal_error('[plugin] fetch cannot read file \'' . $params['file'] . '\'');
-            return;
+            // local file
+            if (!$template->smarty->security_policy->isTrustedResourceDir($params[ 'file' ])) {
+                return;
+            }
         }
-    } else {
-        // not a local file
-        if(preg_match('!^http://!i',$params['file'])) {
-            // http fetch
-            if($uri_parts = parse_url($params['file'])) {
-                // set defaults
-                $host = $server_name = $uri_parts['host'];
-                $timeout = 30;
-                $accept = "image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*";
-                $agent = "Smarty Template Engine ".$smarty->_version;
-                $referer = "";
-                $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';
-                $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';
-                $_is_proxy = false;
-                if(empty($uri_parts['port'])) {
-                    $port = 80;
-                } else {
-                    $port = $uri_parts['port'];
-                }
-                if(!empty($uri_parts['user'])) {
-                    $user = $uri_parts['user'];
-                }
-                if(!empty($uri_parts['pass'])) {
-                    $pass = $uri_parts['pass'];
-                }
-                // loop through parameters, setup headers
-                foreach($params as $param_key => $param_value) {
-                    switch($param_key) {
-                        case "file":
-                        case "assign":
-                        case "assign_headers":
-                            break;
-                        case "user":
-                            if(!empty($param_value)) {
-                                $user = $param_value;
-                            }
-                            break;
-                        case "pass":
-                            if(!empty($param_value)) {
-                                $pass = $param_value;
-                            }
-                            break;
-                        case "accept":
-                            if(!empty($param_value)) {
-                                $accept = $param_value;
-                            }
-                            break;
-                        case "header":
-                            if(!empty($param_value)) {
-                                if(!preg_match('![\w\d-]+: .+!',$param_value)) {
-                                    $smarty->_trigger_fatal_error("[plugin] invalid header format '".$param_value."'");
-                                    return;
-                                } else {
-                                    $extra_headers[] = $param_value;
-                                }
-                            }
-                            break;
-                        case "proxy_host":
-                            if(!empty($param_value)) {
-                                $proxy_host = $param_value;
-                            }
-                            break;
-                        case "proxy_port":
-                            if(!preg_match('!\D!', $param_value)) {
-                                $proxy_port = (int) $param_value;
-                            } else {
-                                $smarty->_trigger_fatal_error("[plugin] invalid value for attribute '".$param_key."'");
+    }
+    $content = '';
+    if ($protocol === 'http') {
+        // http fetch
+        if ($uri_parts = parse_url($params[ 'file' ])) {
+            // set defaults
+            $host = $server_name = $uri_parts[ 'host' ];
+            $timeout = 30;
+            $accept = 'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*';
+            $agent = 'Smarty Template Engine ' . Smarty::SMARTY_VERSION;
+            $referer = '';
+            $uri = !empty($uri_parts[ 'path' ]) ? $uri_parts[ 'path' ] : '/';
+            $uri .= !empty($uri_parts[ 'query' ]) ? '?' . $uri_parts[ 'query' ] : '';
+            $_is_proxy = false;
+            if (empty($uri_parts[ 'port' ])) {
+                $port = 80;
+            } else {
+                $port = $uri_parts[ 'port' ];
+            }
+            if (!empty($uri_parts[ 'user' ])) {
+                $user = $uri_parts[ 'user' ];
+            }
+            if (!empty($uri_parts[ 'pass' ])) {
+                $pass = $uri_parts[ 'pass' ];
+            }
+            // loop through parameters, setup headers
+            foreach ($params as $param_key => $param_value) {
+                switch ($param_key) {
+                    case 'file':
+                    case 'assign':
+                    case 'assign_headers':
+                        break;
+                    case 'user':
+                        if (!empty($param_value)) {
+                            $user = $param_value;
+                        }
+                        break;
+                    case 'pass':
+                        if (!empty($param_value)) {
+                            $pass = $param_value;
+                        }
+                        break;
+                    case 'accept':
+                        if (!empty($param_value)) {
+                            $accept = $param_value;
+                        }
+                        break;
+                    case 'header':
+                        if (!empty($param_value)) {
+                            if (!preg_match('![\w\d-]+: .+!', $param_value)) {
+                                trigger_error("[plugin] invalid header format '{$param_value}'", E_USER_NOTICE);
                                 return;
-                            }
-                            break;
-                        case "agent":
-                            if(!empty($param_value)) {
-                                $agent = $param_value;
-                            }
-                            break;
-                        case "referer":
-                            if(!empty($param_value)) {
-                                $referer = $param_value;
-                            }
-                            break;
-                        case "timeout":
-                            if(!preg_match('!\D!', $param_value)) {
-                                $timeout = (int) $param_value;
                             } else {
-                                $smarty->_trigger_fatal_error("[plugin] invalid value for attribute '".$param_key."'");
-                                return;
+                                $extra_headers[] = $param_value;
                             }
-                            break;
-                        default:
-                            $smarty->_trigger_fatal_error("[plugin] unrecognized attribute '".$param_key."'");
+                        }
+                        break;
+                    case 'proxy_host':
+                        if (!empty($param_value)) {
+                            $proxy_host = $param_value;
+                        }
+                        break;
+                    case 'proxy_port':
+                        if (!preg_match('!\D!', $param_value)) {
+                            $proxy_port = (int)$param_value;
+                        } else {
+                            trigger_error("[plugin] invalid value for attribute '{$param_key }'", E_USER_NOTICE);
                             return;
-                    }
+                        }
+                        break;
+                    case 'agent':
+                        if (!empty($param_value)) {
+                            $agent = $param_value;
+                        }
+                        break;
+                    case 'referer':
+                        if (!empty($param_value)) {
+                            $referer = $param_value;
+                        }
+                        break;
+                    case 'timeout':
+                        if (!preg_match('!\D!', $param_value)) {
+                            $timeout = (int)$param_value;
+                        } else {
+                            trigger_error("[plugin] invalid value for attribute '{$param_key}'", E_USER_NOTICE);
+                            return;
+                        }
+                        break;
+                    default:
+                        trigger_error("[plugin] unrecognized attribute '{$param_key}'", E_USER_NOTICE);
+                        return;
                 }
-                if(!empty($proxy_host) && !empty($proxy_port)) {
-                    $_is_proxy = true;
-                    $fp = fsockopen($proxy_host,$proxy_port,$errno,$errstr,$timeout);
+            }
+            if (!empty($proxy_host) && !empty($proxy_port)) {
+                $_is_proxy = true;
+                $fp = fsockopen($proxy_host, $proxy_port, $errno, $errstr, $timeout);
+            } else {
+                $fp = fsockopen($server_name, $port, $errno, $errstr, $timeout);
+            }
+            if (!$fp) {
+                trigger_error("[plugin] unable to fetch: $errstr ($errno)", E_USER_NOTICE);
+                return;
+            } else {
+                if ($_is_proxy) {
+                    fputs($fp, 'GET ' . $params[ 'file' ] . " HTTP/1.0\r\n");
                 } else {
-                    $fp = fsockopen($server_name,$port,$errno,$errstr,$timeout);
+                    fputs($fp, "GET $uri HTTP/1.0\r\n");
                 }
-
-                if(!$fp) {
-                    $smarty->_trigger_fatal_error("[plugin] unable to fetch: $errstr ($errno)");
-                    return;
-                } else {
-                    if($_is_proxy) {
-                        fputs($fp, 'GET ' . $params['file'] . " HTTP/1.0\r\n");
-                    } else {
-                        fputs($fp, "GET $uri HTTP/1.0\r\n");
-                    }
-                    if(!empty($host)) {
-                        fputs($fp, "Host: $host\r\n");
-                    }
-                    if(!empty($accept)) {
-                        fputs($fp, "Accept: $accept\r\n");
-                    }
-                    if(!empty($agent)) {
-                        fputs($fp, "User-Agent: $agent\r\n");
-                    }
-                    if(!empty($referer)) {
-                        fputs($fp, "Referer: $referer\r\n");
-                    }
-                    if(isset($extra_headers) && is_array($extra_headers)) {
-                        foreach($extra_headers as $curr_header) {
-                            fputs($fp, $curr_header."\r\n");
-                        }
-                    }
-                    if(!empty($user) && !empty($pass)) {
-                        fputs($fp, "Authorization: BASIC ".base64_encode("$user:$pass")."\r\n");
-                    }
-
-                    fputs($fp, "\r\n");
-                    while(!feof($fp)) {
-                        $content .= fgets($fp,4096);
-                    }
-                    fclose($fp);
-                    $csplit = preg_split("!\r\n\r\n!",$content,2);
-
-                    $content = $csplit[1];
-
-                    if(!empty($params['assign_headers'])) {
-                        $smarty->assign($params['assign_headers'],preg_split("!\r\n!",$csplit[0]));
+                if (!empty($host)) {
+                    fputs($fp, "Host: $host\r\n");
+                }
+                if (!empty($accept)) {
+                    fputs($fp, "Accept: $accept\r\n");
+                }
+                if (!empty($agent)) {
+                    fputs($fp, "User-Agent: $agent\r\n");
+                }
+                if (!empty($referer)) {
+                    fputs($fp, "Referer: $referer\r\n");
+                }
+                if (isset($extra_headers) && is_array($extra_headers)) {
+                    foreach ($extra_headers as $curr_header) {
+                        fputs($fp, $curr_header . "\r\n");
                     }
                 }
-            } else {
-                $smarty->_trigger_fatal_error("[plugin] unable to parse URL, check syntax");
-                return;
-            }
-        } else {
-            // ftp fetch
-            if($fp = @fopen($params['file'],'r')) {
-                while(!feof($fp)) {
-                    $content .= fgets ($fp,4096);
+                if (!empty($user) && !empty($pass)) {
+                    fputs($fp, 'Authorization: BASIC ' . base64_encode("$user:$pass") . "\r\n");
+                }
+                fputs($fp, "\r\n");
+                while (!feof($fp)) {
+                    $content .= fgets($fp, 4096);
                 }
                 fclose($fp);
-            } else {
-                $smarty->_trigger_fatal_error('[plugin] fetch cannot read file \'' . $params['file'] .'\'');
-                return;
+                $csplit = preg_split("!\r\n\r\n!", $content, 2);
+                $content = $csplit[ 1 ];
+                if (!empty($params[ 'assign_headers' ])) {
+                    $template->assign($params[ 'assign_headers' ], preg_split("!\r\n!", $csplit[ 0 ]));
+                }
             }
+        } else {
+            trigger_error("[plugin fetch] unable to parse URL, check syntax", E_USER_NOTICE);
+            return;
+        }
+    } else {
+        $content = @file_get_contents($params[ 'file' ]);
+        if ($content === false) {
+            throw new SmartyException("{fetch} cannot read resource '" . $params[ 'file' ] . "'");
         }
-
     }
-
-
-    if (!empty($params['assign'])) {
-        $smarty->assign($params['assign'],$content);
+    if (!empty($params[ 'assign' ])) {
+        $template->assign($params[ 'assign' ], $content);
     } else {
         return $content;
     }
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.html_checkboxes.php b/epgrec/Smarty/plugins/function.html_checkboxes.php
--- a/epgrec/Smarty/plugins/function.html_checkboxes.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.html_checkboxes.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,143 +1,286 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {html_checkboxes} function plugin
- *
- * File:       function.html_checkboxes.php<br>
- * Type:       function<br>
- * Name:       html_checkboxes<br>
- * Date:       24.Feb.2003<br>
- * Purpose:    Prints out a list of checkbox input types<br>
- * Input:<br>
- *           - name       (optional) - string default "checkbox"
- *           - values     (required) - array
- *           - options    (optional) - associative array
- *           - checked    (optional) - array default not set
- *           - separator  (optional) - ie <br> or &nbsp;
- *           - output     (optional) - the output next to each checkbox
- *           - assign     (optional) - assign the output as an array to this variable
+ * File:       function.html_checkboxes.php
+ * Type:       function
+ * Name:       html_checkboxes
+ * Date:       24.Feb.2003
+ * Purpose:    Prints out a list of checkbox input types
  * Examples:
- * <pre>
+ *
  * {html_checkboxes values=$ids output=$names}
  * {html_checkboxes values=$ids name='box' separator='<br>' output=$names}
  * {html_checkboxes values=$ids checked=$checked separator='<br>' output=$names}
- * </pre>
- * @link http://smarty.php.net/manual/en/language.function.html.checkboxes.php {html_checkboxes}
- *      (Smarty online manual)
- * @author     Christopher Kvarme <christopher.kvarme@flashjab.com>
- * @author credits to Monte Ohrt <monte at ohrt dot com>
- * @version    1.0
- * @param array
- * @param Smarty
+ *
+ * Params:
+ *
+ * - name       (optional) - string default "checkbox"
+ * - values     (required) - array
+ * - options    (optional) - associative array
+ * - checked    (optional) - array default not set
+ * - separator  (optional) - ie <br> or &nbsp;
+ * - output     (optional) - the output next to each checkbox
+ * - assign     (optional) - assign the output as an array to this variable
+ * - escape     (optional) - escape the content (not value), defaults to true
+ *
+ * @link    http://www.smarty.net/manual/en/language.function.html.checkboxes.php {html_checkboxes}
+ *             (Smarty online manual)
+ * @author  Christopher Kvarme <christopher.kvarme@flashjab.com>
+ * @author  credits to Monte Ohrt <monte at ohrt dot com>
+ * @version 1.0
+ *
+ * @param array                    $params   parameters
+ * @param Smarty_Internal_Template $template template object
+ *
  * @return string
- * @uses smarty_function_escape_special_chars()
+ * @uses    smarty_function_escape_special_chars()
+ * @throws \SmartyException
  */
-function smarty_function_html_checkboxes($params, &$smarty)
+function smarty_function_html_checkboxes($params, Smarty_Internal_Template $template)
 {
-    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
-
+    $template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_function_escape_special_chars',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.escape_special_chars.php'
+            )
+        )
+    );
     $name = 'checkbox';
     $values = null;
     $options = null;
-    $selected = null;
+    $selected = array();
     $separator = '';
+    $escape = true;
     $labels = true;
+    $label_ids = false;
     $output = null;
-
     $extra = '';
-
-    foreach($params as $_key => $_val) {
-        switch($_key) {
+    foreach ($params as $_key => $_val) {
+        switch ($_key) {
             case 'name':
             case 'separator':
-                $$_key = $_val;
+                $$_key = (string)$_val;
                 break;
-
+            case 'escape':
             case 'labels':
+            case 'label_ids':
                 $$_key = (bool)$_val;
                 break;
-
             case 'options':
                 $$_key = (array)$_val;
                 break;
-
             case 'values':
             case 'output':
                 $$_key = array_values((array)$_val);
                 break;
-
             case 'checked':
             case 'selected':
-                $selected = array_map('strval', array_values((array)$_val));
+                if (is_array($_val)) {
+                    $selected = array();
+                    foreach ($_val as $_sel) {
+                        if (is_object($_sel)) {
+                            if (method_exists($_sel, '__toString')) {
+                                $_sel = smarty_function_escape_special_chars((string)$_sel->__toString());
+                            } else {
+                                trigger_error(
+                                    'html_checkboxes: selected attribute contains an object of class \'' .
+                                    get_class($_sel) . '\' without __toString() method',
+                                    E_USER_NOTICE
+                                );
+                                continue;
+                            }
+                        } else {
+                            $_sel = smarty_function_escape_special_chars((string)$_sel);
+                        }
+                        $selected[ $_sel ] = true;
+                    }
+                } elseif (is_object($_val)) {
+                    if (method_exists($_val, '__toString')) {
+                        $selected = smarty_function_escape_special_chars((string)$_val->__toString());
+                    } else {
+                        trigger_error(
+                            'html_checkboxes: selected attribute is an object of class \'' . get_class($_val) .
+                            '\' without __toString() method',
+                            E_USER_NOTICE
+                        );
+                    }
+                } else {
+                    $selected = smarty_function_escape_special_chars((string)$_val);
+                }
                 break;
-
             case 'checkboxes':
-                $smarty->trigger_error('html_checkboxes: the use of the "checkboxes" attribute is deprecated, use "options" instead', E_USER_WARNING);
+                trigger_error(
+                    'html_checkboxes: the use of the "checkboxes" attribute is deprecated, use "options" instead',
+                    E_USER_WARNING
+                );
                 $options = (array)$_val;
                 break;
-
             case 'assign':
                 break;
-
+            case 'strict':
+                break;
+            case 'disabled':
+            case 'readonly':
+                if (!empty($params[ 'strict' ])) {
+                    if (!is_scalar($_val)) {
+                        trigger_error(
+                            "html_options: {$_key} attribute must be a scalar, only boolean true or string '{$_key}' will actually add the attribute",
+                            E_USER_NOTICE
+                        );
+                    }
+                    if ($_val === true || $_val === $_key) {
+                        $extra .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_key) . '"';
+                    }
+                    break;
+                }
+            // omit break; to fall through!
+            // no break
             default:
-                if(!is_array($_val)) {
-                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                if (!is_array($_val)) {
+                    $extra .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_val) . '"';
                 } else {
-                    $smarty->trigger_error("html_checkboxes: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                    trigger_error("html_checkboxes: extra attribute '{$_key}' cannot be an array", E_USER_NOTICE);
                 }
                 break;
         }
     }
-
-    if (!isset($options) && !isset($values))
-        return ''; /* raise error here? */
-
-    settype($selected, 'array');
+    if (!isset($options) && !isset($values)) {
+        return '';
+    } /* raise error here? */
     $_html_result = array();
-
     if (isset($options)) {
-
-        foreach ($options as $_key=>$_val)
-            $_html_result[] = smarty_function_html_checkboxes_output($name, $_key, $_val, $selected, $extra, $separator, $labels);
-
-
+        foreach ($options as $_key => $_val) {
+            $_html_result[] =
+                smarty_function_html_checkboxes_output(
+                    $name,
+                    $_key,
+                    $_val,
+                    $selected,
+                    $extra,
+                    $separator,
+                    $labels,
+                    $label_ids,
+                    $escape
+                );
+        }
     } else {
-        foreach ($values as $_i=>$_key) {
-            $_val = isset($output[$_i]) ? $output[$_i] : '';
-            $_html_result[] = smarty_function_html_checkboxes_output($name, $_key, $_val, $selected, $extra, $separator, $labels);
+        foreach ($values as $_i => $_key) {
+            $_val = isset($output[ $_i ]) ? $output[ $_i ] : '';
+            $_html_result[] =
+                smarty_function_html_checkboxes_output(
+                    $name,
+                    $_key,
+                    $_val,
+                    $selected,
+                    $extra,
+                    $separator,
+                    $labels,
+                    $label_ids,
+                    $escape
+                );
         }
-
     }
-
-    if(!empty($params['assign'])) {
-        $smarty->assign($params['assign'], $_html_result);
+    if (!empty($params[ 'assign' ])) {
+        $template->assign($params[ 'assign' ], $_html_result);
     } else {
-        return implode("\n",$_html_result);
+        return implode("\n", $_html_result);
     }
-
 }
 
-function smarty_function_html_checkboxes_output($name, $value, $output, $selected, $extra, $separator, $labels) {
+/**
+ * @param      $name
+ * @param      $value
+ * @param      $output
+ * @param      $selected
+ * @param      $extra
+ * @param      $separator
+ * @param      $labels
+ * @param      $label_ids
+ * @param bool $escape
+ *
+ * @return string
+ */
+function smarty_function_html_checkboxes_output(
+    $name,
+    $value,
+    $output,
+    $selected,
+    $extra,
+    $separator,
+    $labels,
+    $label_ids,
+    $escape = true
+) {
     $_output = '';
-    if ($labels) $_output .= '<label>';
-    $_output .= '<input type="checkbox" name="'
-        . smarty_function_escape_special_chars($name) . '[]" value="'
-        . smarty_function_escape_special_chars($value) . '"';
-
-    if (in_array((string)$value, $selected)) {
+    if (is_object($value)) {
+        if (method_exists($value, '__toString')) {
+            $value = (string)$value->__toString();
+        } else {
+            trigger_error(
+                'html_options: value is an object of class \'' . get_class($value) .
+                '\' without __toString() method',
+                E_USER_NOTICE
+            );
+            return '';
+        }
+    } else {
+        $value = (string)$value;
+    }
+    if (is_object($output)) {
+        if (method_exists($output, '__toString')) {
+            $output = (string)$output->__toString();
+        } else {
+            trigger_error(
+                'html_options: output is an object of class \'' . get_class($output) .
+                '\' without __toString() method',
+                E_USER_NOTICE
+            );
+            return '';
+        }
+    } else {
+        $output = (string)$output;
+    }
+    if ($labels) {
+        if ($label_ids) {
+            $_id = smarty_function_escape_special_chars(
+                preg_replace(
+                    '![^\w\-\.]!' . Smarty::$_UTF8_MODIFIER,
+                    '_',
+                    $name . '_' . $value
+                )
+            );
+            $_output .= '<label for="' . $_id . '">';
+        } else {
+            $_output .= '<label>';
+        }
+    }
+    $name = smarty_function_escape_special_chars($name);
+    $value = smarty_function_escape_special_chars($value);
+    if ($escape) {
+        $output = smarty_function_escape_special_chars($output);
+    }
+    $_output .= '<input type="checkbox" name="' . $name . '[]" value="' . $value . '"';
+    if ($labels && $label_ids) {
+        $_output .= ' id="' . $_id . '"';
+    }
+    if (is_array($selected)) {
+        if (isset($selected[ $value ])) {
+            $_output .= ' checked="checked"';
+        }
+    } elseif ($value === $selected) {
         $_output .= ' checked="checked"';
     }
     $_output .= $extra . ' />' . $output;
-    if ($labels) $_output .= '</label>';
-    $_output .=  $separator;
-
+    if ($labels) {
+        $_output .= '</label>';
+    }
+    $_output .= $separator;
     return $_output;
 }
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.html_image.php b/epgrec/Smarty/plugins/function.html_image.php
--- a/epgrec/Smarty/plugins/function.html_image.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.html_image.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,43 +1,49 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {html_image} function plugin
- *
- * Type:     function<br>
- * Name:     html_image<br>
- * Date:     Feb 24, 2003<br>
- * Purpose:  format HTML tags for the image<br>
- * Input:<br>
- *         - file = file (and path) of image (required)
- *         - height = image height (optional, default actual height)
- *         - width = image width (optional, default actual width)
- *         - basedir = base directory for absolute paths, default
- *                     is environment variable DOCUMENT_ROOT
- *         - path_prefix = prefix for path output (optional, default empty)
- *
+ * Type:     function
+ * Name:     html_image
+ * Date:     Feb 24, 2003
+ * Purpose:  format HTML tags for the image
  * Examples: {html_image file="/images/masthead.gif"}
  * Output:   <img src="/images/masthead.gif" width=400 height=23>
- * @link http://smarty.php.net/manual/en/language.function.html.image.php {html_image}
- *      (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @author credits to Duda <duda@big.hu> - wrote first image function
- *           in repository, helped with lots of functionality
- * @version  1.0
- * @param array
- * @param Smarty
+ * Params:
+ *
+ * - file        - (required) - file (and path) of image
+ * - height      - (optional) - image height (default actual height)
+ * - width       - (optional) - image width (default actual width)
+ * - basedir     - (optional) - base directory for absolute paths, default is environment variable DOCUMENT_ROOT
+ * - path_prefix - prefix for path output (optional, default empty)
+ *
+ * @link    http://www.smarty.net/manual/en/language.function.html.image.php {html_image}
+ *          (Smarty online manual)
+ * @author  Monte Ohrt <monte at ohrt dot com>
+ * @author  credits to Duda <duda@big.hu>
+ * @version 1.0
+ *
+ * @param array                    $params   parameters
+ * @param Smarty_Internal_Template $template template object
+ *
+ * @throws SmartyException
  * @return string
- * @uses smarty_function_escape_special_chars()
+ * @uses    smarty_function_escape_special_chars()
  */
-function smarty_function_html_image($params, &$smarty)
+function smarty_function_html_image($params, Smarty_Internal_Template $template)
 {
-    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
-    
+    $template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_function_escape_special_chars',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.escape_special_chars.php'
+            )
+        )
+    );
     $alt = '';
     $file = '';
     $height = '';
@@ -46,10 +52,9 @@
     $prefix = '';
     $suffix = '';
     $path_prefix = '';
-    $server_vars = ($smarty->request_use_auto_globals) ? $_SERVER : $GLOBALS['HTTP_SERVER_VARS'];
-    $basedir = isset($server_vars['DOCUMENT_ROOT']) ? $server_vars['DOCUMENT_ROOT'] : '';
-    foreach($params as $_key => $_val) {
-        switch($_key) {
+    $basedir = isset($_SERVER[ 'DOCUMENT_ROOT' ]) ? $_SERVER[ 'DOCUMENT_ROOT' ] : '';
+    foreach ($params as $_key => $_val) {
+        switch ($_key) {
             case 'file':
             case 'height':
             case 'width':
@@ -58,85 +63,96 @@
             case 'basedir':
                 $$_key = $_val;
                 break;
-
             case 'alt':
-                if(!is_array($_val)) {
+                if (!is_array($_val)) {
                     $$_key = smarty_function_escape_special_chars($_val);
                 } else {
-                    $smarty->trigger_error("html_image: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                    throw new SmartyException(
+                        "html_image: extra attribute '{$_key}' cannot be an array",
+                        E_USER_NOTICE
+                    );
                 }
                 break;
-
             case 'link':
             case 'href':
                 $prefix = '<a href="' . $_val . '">';
                 $suffix = '</a>';
                 break;
-
             default:
-                if(!is_array($_val)) {
-                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                if (!is_array($_val)) {
+                    $extra .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_val) . '"';
                 } else {
-                    $smarty->trigger_error("html_image: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                    throw new SmartyException(
+                        "html_image: extra attribute '{$_key}' cannot be an array",
+                        E_USER_NOTICE
+                    );
                 }
                 break;
         }
     }
-
     if (empty($file)) {
-        $smarty->trigger_error("html_image: missing 'file' parameter", E_USER_NOTICE);
+        trigger_error('html_image: missing \'file\' parameter', E_USER_NOTICE);
         return;
     }
-
-    if (substr($file,0,1) == '/') {
+    if ($file[ 0 ] === '/') {
         $_image_path = $basedir . $file;
     } else {
         $_image_path = $file;
     }
-    
-    if(!isset($params['width']) || !isset($params['height'])) {
-        if(!$_image_data = @getimagesize($_image_path)) {
-            if(!file_exists($_image_path)) {
-                $smarty->trigger_error("html_image: unable to find '$_image_path'", E_USER_NOTICE);
+    // strip file protocol
+    if (stripos($params[ 'file' ], 'file://') === 0) {
+        $params[ 'file' ] = substr($params[ 'file' ], 7);
+    }
+    $protocol = strpos($params[ 'file' ], '://');
+    if ($protocol !== false) {
+        $protocol = strtolower(substr($params[ 'file' ], 0, $protocol));
+    }
+    if (isset($template->smarty->security_policy)) {
+        if ($protocol) {
+            // remote resource (or php stream, )
+            if (!$template->smarty->security_policy->isTrustedUri($params[ 'file' ])) {
                 return;
-            } else if(!is_readable($_image_path)) {
-                $smarty->trigger_error("html_image: unable to read '$_image_path'", E_USER_NOTICE);
+            }
+        } else {
+            // local file
+            if (!$template->smarty->security_policy->isTrustedResourceDir($_image_path)) {
+                return;
+            }
+        }
+    }
+    if (!isset($params[ 'width' ]) || !isset($params[ 'height' ])) {
+        // FIXME: (rodneyrehm) getimagesize() loads the complete file off a remote resource, use custom [jpg,png,gif]header reader!
+        if (!$_image_data = @getimagesize($_image_path)) {
+            if (!file_exists($_image_path)) {
+                trigger_error("html_image: unable to find '{$_image_path}'", E_USER_NOTICE);
+                return;
+            } elseif (!is_readable($_image_path)) {
+                trigger_error("html_image: unable to read '{$_image_path}'", E_USER_NOTICE);
                 return;
             } else {
-                $smarty->trigger_error("html_image: '$_image_path' is not a valid image file", E_USER_NOTICE);
+                trigger_error("html_image: '{$_image_path}' is not a valid image file", E_USER_NOTICE);
                 return;
             }
         }
-        if ($smarty->security &&
-            ($_params = array('resource_type' => 'file', 'resource_name' => $_image_path)) &&
-            (require_once(SMARTY_CORE_DIR . 'core.is_secure.php')) &&
-            (!smarty_core_is_secure($_params, $smarty)) ) {
-            $smarty->trigger_error("html_image: (secure) '$_image_path' not in secure directory", E_USER_NOTICE);
-        }        
-        
-        if(!isset($params['width'])) {
-            $width = $_image_data[0];
-        }
-        if(!isset($params['height'])) {
-            $height = $_image_data[1];
-        }
-
-    }
-
-    if(isset($params['dpi'])) {
-        if(strstr($server_vars['HTTP_USER_AGENT'], 'Mac')) {
+        if (!isset($params[ 'width' ])) {
+            $width = $_image_data[ 0 ];
+        }
+        if (!isset($params[ 'height' ])) {
+            $height = $_image_data[ 1 ];
+        }
+    }
+    if (isset($params[ 'dpi' ])) {
+        if (strstr($_SERVER[ 'HTTP_USER_AGENT' ], 'Mac')) {
+            // FIXME: (rodneyrehm) wrong dpi assumption
+            // don't know who thought this up even if it was true in 1998, it's definitely wrong in 2011.
             $dpi_default = 72;
         } else {
             $dpi_default = 96;
         }
-        $_resize = $dpi_default/$params['dpi'];
+        $_resize = $dpi_default / $params[ 'dpi' ];
         $width = round($width * $_resize);
         $height = round($height * $_resize);
     }
-
-    return $prefix . '<img src="'.$path_prefix.$file.'" alt="'.$alt.'" width="'.$width.'" height="'.$height.'"'.$extra.' />' . $suffix;
+    return $prefix . '<img src="' . $path_prefix . $file . '" alt="' . $alt . '" width="' . $width . '" height="' .
+           $height . '"' . $extra . ' />' . $suffix;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.html_options.php b/epgrec/Smarty/plugins/function.html_options.php
--- a/epgrec/Smarty/plugins/function.html_options.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.html_options.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,122 +1,230 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {html_options} function plugin
- *
- * Type:     function<br>
- * Name:     html_options<br>
- * Input:<br>
- *           - name       (optional) - string default "select"
- *           - values     (required if no options supplied) - array
- *           - options    (required if no values supplied) - associative array
- *           - selected   (optional) - string default not set
- *           - output     (required if not options supplied) - array
+ * Type:     function
+ * Name:     html_options
  * Purpose:  Prints the list of <option> tags generated from
  *           the passed parameters
- * @link http://smarty.php.net/manual/en/language.function.html.options.php {html_image}
- *      (Smarty online manual)
+ * Params:
+ *
+ * - name       (optional) - string default "select"
+ * - values     (required) - if no options supplied) - array
+ * - options    (required) - if no values supplied) - associative array
+ * - selected   (optional) - string default not set
+ * - output     (required) - if not options supplied) - array
+ * - id         (optional) - string default not set
+ * - class      (optional) - string default not set
+ *
+ * @link   http://www.smarty.net/manual/en/language.function.html.options.php {html_image}
+ *           (Smarty online manual)
  * @author Monte Ohrt <monte at ohrt dot com>
- * @param array
- * @param Smarty
+ * @author Ralf Strehle (minor optimization) <ralf dot strehle at yahoo dot de>
+ *
+ * @param array                     $params parameters
+ *
+ * @param \Smarty_Internal_Template $template
+ *
  * @return string
- * @uses smarty_function_escape_special_chars()
+ * @uses   smarty_function_escape_special_chars()
+ * @throws \SmartyException
  */
-function smarty_function_html_options($params, &$smarty)
+function smarty_function_html_options($params, Smarty_Internal_Template $template)
 {
-    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
-    
+    $template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_function_escape_special_chars',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.escape_special_chars.php'
+            )
+        )
+    );
     $name = null;
     $values = null;
     $options = null;
-    $selected = array();
+    $selected = null;
     $output = null;
-    
+    $id = null;
+    $class = null;
     $extra = '';
-    
-    foreach($params as $_key => $_val) {
-        switch($_key) {
+    foreach ($params as $_key => $_val) {
+        switch ($_key) {
             case 'name':
+            case 'class':
+            case 'id':
                 $$_key = (string)$_val;
                 break;
-            
             case 'options':
-                $$_key = (array)$_val;
+                $options = (array)$_val;
                 break;
-                
             case 'values':
             case 'output':
                 $$_key = array_values((array)$_val);
                 break;
-
             case 'selected':
-                $$_key = array_map('strval', array_values((array)$_val));
+                if (is_array($_val)) {
+                    $selected = array();
+                    foreach ($_val as $_sel) {
+                        if (is_object($_sel)) {
+                            if (method_exists($_sel, '__toString')) {
+                                $_sel = smarty_function_escape_special_chars((string)$_sel->__toString());
+                            } else {
+                                trigger_error(
+                                    'html_options: selected attribute contains an object of class \'' .
+                                    get_class($_sel) . '\' without __toString() method',
+                                    E_USER_NOTICE
+                                );
+                                continue;
+                            }
+                        } else {
+                            $_sel = smarty_function_escape_special_chars((string)$_sel);
+                        }
+                        $selected[ $_sel ] = true;
+                    }
+                } elseif (is_object($_val)) {
+                    if (method_exists($_val, '__toString')) {
+                        $selected = smarty_function_escape_special_chars((string)$_val->__toString());
+                    } else {
+                        trigger_error(
+                            'html_options: selected attribute is an object of class \'' . get_class($_val) .
+                            '\' without __toString() method',
+                            E_USER_NOTICE
+                        );
+                    }
+                } else {
+                    $selected = smarty_function_escape_special_chars((string)$_val);
+                }
+                break;
+            case 'strict':
                 break;
-                
+            case 'disabled':
+            case 'readonly':
+                if (!empty($params[ 'strict' ])) {
+                    if (!is_scalar($_val)) {
+                        trigger_error(
+                            "html_options: {$_key} attribute must be a scalar, only boolean true or string '{$_key}' will actually add the attribute",
+                            E_USER_NOTICE
+                        );
+                    }
+                    if ($_val === true || $_val === $_key) {
+                        $extra .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_key) . '"';
+                    }
+                    break;
+                }
+            // omit break; to fall through!
+            // no break
             default:
-                if(!is_array($_val)) {
-                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                if (!is_array($_val)) {
+                    $extra .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_val) . '"';
                 } else {
-                    $smarty->trigger_error("html_options: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                    trigger_error("html_options: extra attribute '{$_key}' cannot be an array", E_USER_NOTICE);
                 }
                 break;
         }
     }
-
-    if (!isset($options) && !isset($values))
-        return ''; /* raise error here? */
-
+    if (!isset($options) && !isset($values)) {
+        /* raise error here? */
+        return '';
+    }
     $_html_result = '';
-
+    $_idx = 0;
     if (isset($options)) {
-        
-        foreach ($options as $_key=>$_val)
-            $_html_result .= smarty_function_html_options_optoutput($_key, $_val, $selected);
-
+        foreach ($options as $_key => $_val) {
+            $_html_result .= smarty_function_html_options_optoutput($_key, $_val, $selected, $id, $class, $_idx);
+        }
     } else {
-        
-        foreach ($values as $_i=>$_key) {
-            $_val = isset($output[$_i]) ? $output[$_i] : '';
-            $_html_result .= smarty_function_html_options_optoutput($_key, $_val, $selected);
+        foreach ($values as $_i => $_key) {
+            $_val = isset($output[ $_i ]) ? $output[ $_i ] : '';
+            $_html_result .= smarty_function_html_options_optoutput($_key, $_val, $selected, $id, $class, $_idx);
         }
-
     }
-
-    if(!empty($name)) {
-        $_html_result = '<select name="' . $name . '"' . $extra . '>' . "\n" . $_html_result . '</select>' . "\n";
+    if (!empty($name)) {
+        $_html_class = !empty($class) ? ' class="' . $class . '"' : '';
+        $_html_id = !empty($id) ? ' id="' . $id . '"' : '';
+        $_html_result =
+            '<select name="' . $name . '"' . $_html_class . $_html_id . $extra . '>' . "\n" . $_html_result .
+            '</select>' . "\n";
     }
-
     return $_html_result;
-
 }
 
-function smarty_function_html_options_optoutput($key, $value, $selected) {
-    if(!is_array($value)) {
-        $_html_result = '<option label="' . smarty_function_escape_special_chars($value) . '" value="' .
-            smarty_function_escape_special_chars($key) . '"';
-        if (in_array((string)$key, $selected))
+/**
+ * @param $key
+ * @param $value
+ * @param $selected
+ * @param $id
+ * @param $class
+ * @param $idx
+ *
+ * @return string
+ */
+function smarty_function_html_options_optoutput($key, $value, $selected, $id, $class, &$idx)
+{
+    if (!is_array($value)) {
+        $_key = smarty_function_escape_special_chars($key);
+        $_html_result = '<option value="' . $_key . '"';
+        if (is_array($selected)) {
+            if (isset($selected[ $_key ])) {
+                $_html_result .= ' selected="selected"';
+            }
+        } elseif ($_key === $selected) {
             $_html_result .= ' selected="selected"';
-        $_html_result .= '>' . smarty_function_escape_special_chars($value) . '</option>' . "\n";
+        }
+        $_html_class = !empty($class) ? ' class="' . $class . ' option"' : '';
+        $_html_id = !empty($id) ? ' id="' . $id . '-' . $idx . '"' : '';
+        if (is_object($value)) {
+            if (method_exists($value, '__toString')) {
+                $value = smarty_function_escape_special_chars((string)$value->__toString());
+            } else {
+                trigger_error(
+                    'html_options: value is an object of class \'' . get_class($value) .
+                    '\' without __toString() method',
+                    E_USER_NOTICE
+                );
+                return '';
+            }
+        } else {
+            $value = smarty_function_escape_special_chars((string)$value);
+        }
+        $_html_result .= $_html_class . $_html_id . '>' . $value . '</option>' . "\n";
+        $idx++;
     } else {
-        $_html_result = smarty_function_html_options_optgroup($key, $value, $selected);
+        $_idx = 0;
+        $_html_result =
+            smarty_function_html_options_optgroup(
+                $key,
+                $value,
+                $selected,
+                !empty($id) ? ($id . '-' . $idx) : null,
+                $class,
+                $_idx
+            );
+        $idx++;
     }
     return $_html_result;
 }
 
-function smarty_function_html_options_optgroup($key, $values, $selected) {
+/**
+ * @param $key
+ * @param $values
+ * @param $selected
+ * @param $id
+ * @param $class
+ * @param $idx
+ *
+ * @return string
+ */
+function smarty_function_html_options_optgroup($key, $values, $selected, $id, $class, &$idx)
+{
     $optgroup_html = '<optgroup label="' . smarty_function_escape_special_chars($key) . '">' . "\n";
     foreach ($values as $key => $value) {
-        $optgroup_html .= smarty_function_html_options_optoutput($key, $value, $selected);
+        $optgroup_html .= smarty_function_html_options_optoutput($key, $value, $selected, $id, $class, $idx);
     }
     $optgroup_html .= "</optgroup>\n";
     return $optgroup_html;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.html_radios.php b/epgrec/Smarty/plugins/function.html_radios.php
--- a/epgrec/Smarty/plugins/function.html_radios.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.html_radios.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,156 +1,266 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {html_radios} function plugin
+ * File:       function.html_radios.php
+ * Type:       function
+ * Name:       html_radios
+ * Date:       24.Feb.2003
+ * Purpose:    Prints out a list of radio input types
+ * Params:
+ *
+ * - name       (optional) - string default "radio"
+ * - values     (required) - array
+ * - options    (required) - associative array
+ * - checked    (optional) - array default not set
+ * - separator  (optional) - ie <br> or &nbsp;
+ * - output     (optional) - the output next to each radio button
+ * - assign     (optional) - assign the output as an array to this variable
+ * - escape     (optional) - escape the content (not value), defaults to true
  *
- * File:       function.html_radios.php<br>
- * Type:       function<br>
- * Name:       html_radios<br>
- * Date:       24.Feb.2003<br>
- * Purpose:    Prints out a list of radio input types<br>
- * Input:<br>
- *           - name       (optional) - string default "radio"
- *           - values     (required) - array
- *           - options    (optional) - associative array
- *           - checked    (optional) - array default not set
- *           - separator  (optional) - ie <br> or &nbsp;
- *           - output     (optional) - the output next to each radio button
- *           - assign     (optional) - assign the output as an array to this variable
  * Examples:
- * <pre>
+ *
  * {html_radios values=$ids output=$names}
  * {html_radios values=$ids name='box' separator='<br>' output=$names}
  * {html_radios values=$ids checked=$checked separator='<br>' output=$names}
- * </pre>
- * @link http://smarty.php.net/manual/en/language.function.html.radios.php {html_radios}
- *      (Smarty online manual)
- * @author     Christopher Kvarme <christopher.kvarme@flashjab.com>
- * @author credits to Monte Ohrt <monte at ohrt dot com>
- * @version    1.0
- * @param array
- * @param Smarty
+ *
+ * @link    http://smarty.php.net/manual/en/language.function.html.radios.php {html_radios}
+ *          (Smarty online manual)
+ * @author  Christopher Kvarme <christopher.kvarme@flashjab.com>
+ * @author  credits to Monte Ohrt <monte at ohrt dot com>
+ * @version 1.0
+ *
+ * @param array                    $params   parameters
+ * @param Smarty_Internal_Template $template template object
+ *
  * @return string
- * @uses smarty_function_escape_special_chars()
+ * @uses    smarty_function_escape_special_chars()
+ * @throws \SmartyException
  */
-function smarty_function_html_radios($params, &$smarty)
+function smarty_function_html_radios($params, Smarty_Internal_Template $template)
 {
-    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
-   
+    $template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_function_escape_special_chars',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.escape_special_chars.php'
+            )
+        )
+    );
     $name = 'radio';
     $values = null;
     $options = null;
     $selected = null;
     $separator = '';
+    $escape = true;
     $labels = true;
     $label_ids = false;
     $output = null;
     $extra = '';
-
-    foreach($params as $_key => $_val) {
-        switch($_key) {
+    foreach ($params as $_key => $_val) {
+        switch ($_key) {
             case 'name':
             case 'separator':
                 $$_key = (string)$_val;
                 break;
-
             case 'checked':
             case 'selected':
-                if(is_array($_val)) {
-                    $smarty->trigger_error('html_radios: the "' . $_key . '" attribute cannot be an array', E_USER_WARNING);
+                if (is_array($_val)) {
+                    trigger_error('html_radios: the "' . $_key . '" attribute cannot be an array', E_USER_WARNING);
+                } elseif (is_object($_val)) {
+                    if (method_exists($_val, '__toString')) {
+                        $selected = smarty_function_escape_special_chars((string)$_val->__toString());
+                    } else {
+                        trigger_error(
+                            'html_radios: selected attribute is an object of class \'' . get_class($_val) .
+                            '\' without __toString() method',
+                            E_USER_NOTICE
+                        );
+                    }
                 } else {
                     $selected = (string)$_val;
                 }
                 break;
-
+            case 'escape':
             case 'labels':
             case 'label_ids':
                 $$_key = (bool)$_val;
                 break;
-
             case 'options':
                 $$_key = (array)$_val;
                 break;
-
             case 'values':
             case 'output':
                 $$_key = array_values((array)$_val);
                 break;
-
             case 'radios':
-                $smarty->trigger_error('html_radios: the use of the "radios" attribute is deprecated, use "options" instead', E_USER_WARNING);
+                trigger_error(
+                    'html_radios: the use of the "radios" attribute is deprecated, use "options" instead',
+                    E_USER_WARNING
+                );
                 $options = (array)$_val;
                 break;
-
             case 'assign':
                 break;
-
+            case 'strict':
+                break;
+            case 'disabled':
+            case 'readonly':
+                if (!empty($params[ 'strict' ])) {
+                    if (!is_scalar($_val)) {
+                        trigger_error(
+                            "html_options: {$_key} attribute must be a scalar, only boolean true or string '$_key' will actually add the attribute",
+                            E_USER_NOTICE
+                        );
+                    }
+                    if ($_val === true || $_val === $_key) {
+                        $extra .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_key) . '"';
+                    }
+                    break;
+                }
+            // omit break; to fall through!
+            // no break
             default:
-                if(!is_array($_val)) {
-                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                if (!is_array($_val)) {
+                    $extra .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_val) . '"';
                 } else {
-                    $smarty->trigger_error("html_radios: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                    trigger_error("html_radios: extra attribute '{$_key}' cannot be an array", E_USER_NOTICE);
                 }
                 break;
         }
     }
-
-    if (!isset($options) && !isset($values))
-        return ''; /* raise error here? */
-
+    if (!isset($options) && !isset($values)) {
+        /* raise error here? */
+        return '';
+    }
     $_html_result = array();
-
     if (isset($options)) {
-
-        foreach ($options as $_key=>$_val)
-            $_html_result[] = smarty_function_html_radios_output($name, $_key, $_val, $selected, $extra, $separator, $labels, $label_ids);
-
+        foreach ($options as $_key => $_val) {
+            $_html_result[] =
+                smarty_function_html_radios_output(
+                    $name,
+                    $_key,
+                    $_val,
+                    $selected,
+                    $extra,
+                    $separator,
+                    $labels,
+                    $label_ids,
+                    $escape
+                );
+        }
     } else {
-
-        foreach ($values as $_i=>$_key) {
-            $_val = isset($output[$_i]) ? $output[$_i] : '';
-            $_html_result[] = smarty_function_html_radios_output($name, $_key, $_val, $selected, $extra, $separator, $labels, $label_ids);
+        foreach ($values as $_i => $_key) {
+            $_val = isset($output[ $_i ]) ? $output[ $_i ] : '';
+            $_html_result[] =
+                smarty_function_html_radios_output(
+                    $name,
+                    $_key,
+                    $_val,
+                    $selected,
+                    $extra,
+                    $separator,
+                    $labels,
+                    $label_ids,
+                    $escape
+                );
         }
-
     }
-
-    if(!empty($params['assign'])) {
-        $smarty->assign($params['assign'], $_html_result);
+    if (!empty($params[ 'assign' ])) {
+        $template->assign($params[ 'assign' ], $_html_result);
     } else {
-        return implode("\n",$_html_result);
+        return implode("\n", $_html_result);
     }
-
 }
 
-function smarty_function_html_radios_output($name, $value, $output, $selected, $extra, $separator, $labels, $label_ids) {
+/**
+ * @param $name
+ * @param $value
+ * @param $output
+ * @param $selected
+ * @param $extra
+ * @param $separator
+ * @param $labels
+ * @param $label_ids
+ * @param $escape
+ *
+ * @return string
+ */
+function smarty_function_html_radios_output(
+    $name,
+    $value,
+    $output,
+    $selected,
+    $extra,
+    $separator,
+    $labels,
+    $label_ids,
+    $escape
+) {
     $_output = '';
+    if (is_object($value)) {
+        if (method_exists($value, '__toString')) {
+            $value = (string)$value->__toString();
+        } else {
+            trigger_error(
+                'html_options: value is an object of class \'' . get_class($value) .
+                '\' without __toString() method',
+                E_USER_NOTICE
+            );
+            return '';
+        }
+    } else {
+        $value = (string)$value;
+    }
+    if (is_object($output)) {
+        if (method_exists($output, '__toString')) {
+            $output = (string)$output->__toString();
+        } else {
+            trigger_error(
+                'html_options: output is an object of class \'' . get_class($output) .
+                '\' without __toString() method',
+                E_USER_NOTICE
+            );
+            return '';
+        }
+    } else {
+        $output = (string)$output;
+    }
     if ($labels) {
-      if($label_ids) {
-          $_id = smarty_function_escape_special_chars(preg_replace('![^\w\-\.]!', '_', $name . '_' . $value));
-          $_output .= '<label for="' . $_id . '">';
-      } else {
-          $_output .= '<label>';           
-      }
-   }
-   $_output .= '<input type="radio" name="'
-        . smarty_function_escape_special_chars($name) . '" value="'
-        . smarty_function_escape_special_chars($value) . '"';
-
-   if ($labels && $label_ids) $_output .= ' id="' . $_id . '"';
-
-    if ((string)$value==$selected) {
+        if ($label_ids) {
+            $_id = smarty_function_escape_special_chars(
+                preg_replace(
+                    '![^\w\-\.]!' . Smarty::$_UTF8_MODIFIER,
+                    '_',
+                    $name . '_' . $value
+                )
+            );
+            $_output .= '<label for="' . $_id . '">';
+        } else {
+            $_output .= '<label>';
+        }
+    }
+    $name = smarty_function_escape_special_chars($name);
+    $value = smarty_function_escape_special_chars($value);
+    if ($escape) {
+        $output = smarty_function_escape_special_chars($output);
+    }
+    $_output .= '<input type="radio" name="' . $name . '" value="' . $value . '"';
+    if ($labels && $label_ids) {
+        $_output .= ' id="' . $_id . '"';
+    }
+    if ($value === $selected) {
         $_output .= ' checked="checked"';
     }
     $_output .= $extra . ' />' . $output;
-    if ($labels) $_output .= '</label>';
-    $_output .=  $separator;
-
+    if ($labels) {
+        $_output .= '</label>';
+    }
+    $_output .= $separator;
     return $_output;
 }
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.html_select_date.php b/epgrec/Smarty/plugins/function.html_select_date.php
--- a/epgrec/Smarty/plugins/function.html_select_date.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.html_select_date.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,99 +1,136 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
 /**
  * Smarty {html_select_date} plugin
- *
- * Type:     function<br>
- * Name:     html_select_date<br>
+ * Type:     function
+ * Name:     html_select_date
  * Purpose:  Prints the dropdowns for date selection.
+ * ChangeLog:
+ *
+ *            - 1.0 initial release
+ *            - 1.1 added support for +/- N syntax for begin
+ *              and end year values. (Monte)
+ *            - 1.2 added support for yyyy-mm-dd syntax for
+ *              time value. (Jan Rosier)
+ *            - 1.3 added support for choosing format for
+ *              month values (Gary Loescher)
+ *            - 1.3.1 added support for choosing format for
+ *              day values (Marcus Bointon)
+ *            - 1.3.2 support negative timestamps, force year
+ *              dropdown to include given date unless explicitly set (Monte)
+ *            - 1.3.4 fix behaviour of 0000-00-00 00:00:00 dates to match that
+ *              of 0000-00-00 dates (cybot, boots)
+ *            - 2.0 complete rewrite for performance,
+ *              added attributes month_names, *_id
+ *
+ * @link    http://www.smarty.net/manual/en/language.function.html.select.date.php {html_select_date}
+ *           (Smarty online manual)
+ * @version 2.0
+ * @author  Andrei Zmievski
+ * @author  Monte Ohrt <monte at ohrt dot com>
+ * @author  Rodney Rehm
+ *
+ * @param array                     $params parameters
+ *
+ * @param \Smarty_Internal_Template $template
  *
- * ChangeLog:<br>
- *           - 1.0 initial release
- *           - 1.1 added support for +/- N syntax for begin
- *                and end year values. (Monte)
- *           - 1.2 added support for yyyy-mm-dd syntax for
- *                time value. (Jan Rosier)
- *           - 1.3 added support for choosing format for
- *                month values (Gary Loescher)
- *           - 1.3.1 added support for choosing format for
- *                day values (Marcus Bointon)
- *           - 1.3.2 support negative timestamps, force year
- *             dropdown to include given date unless explicitly set (Monte)
- *           - 1.3.4 fix behaviour of 0000-00-00 00:00:00 dates to match that
- *             of 0000-00-00 dates (cybot, boots)
- * @link http://smarty.php.net/manual/en/language.function.html.select.date.php {html_select_date}
- *      (Smarty online manual)
- * @version 1.3.4
- * @author Andrei Zmievski
- * @author Monte Ohrt <monte at ohrt dot com>
- * @param array
- * @param Smarty
  * @return string
+ * @throws \SmartyException
  */
-function smarty_function_html_select_date($params, &$smarty)
+function smarty_function_html_select_date($params, Smarty_Internal_Template $template)
 {
-    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
-    require_once $smarty->_get_plugin_filepath('shared','make_timestamp');
-    require_once $smarty->_get_plugin_filepath('function','html_options');
+    $template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_function_escape_special_chars',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.escape_special_chars.php'
+            )
+        )
+    );
+    // generate timestamps used for month names only
+    static $_month_timestamps = null;
+    static $_current_year = null;
+    if ($_month_timestamps === null) {
+        $_current_year = date('Y');
+        $_month_timestamps = array();
+        for ($i = 1; $i <= 12; $i++) {
+            $_month_timestamps[ $i ] = mktime(0, 0, 0, $i, 1, 2000);
+        }
+    }
     /* Default values. */
-    $prefix          = "Date_";
-    $start_year      = strftime("%Y");
-    $end_year        = $start_year;
-    $display_days    = true;
-    $display_months  = true;
-    $display_years   = true;
-    $month_format    = "%B";
+    $prefix = 'Date_';
+    $start_year = null;
+    $end_year = null;
+    $display_days = true;
+    $display_months = true;
+    $display_years = true;
+    $month_format = '%B';
     /* Write months as numbers by default  GL */
-    $month_value_format = "%m";
-    $day_format      = "%02d";
+    $month_value_format = '%m';
+    $day_format = '%02d';
     /* Write day values using this format MB */
-    $day_value_format = "%d";
-    $year_as_text    = false;
+    $day_value_format = '%d';
+    $year_as_text = false;
     /* Display years in reverse order? Ie. 2000,1999,.... */
-    $reverse_years   = false;
+    $reverse_years = false;
     /* Should the select boxes be part of an array when returned from PHP?
        e.g. setting it to "birthday", would create "birthday[Day]",
        "birthday[Month]" & "birthday[Year]". Can be combined with prefix */
-    $field_array     = null;
+    $field_array = null;
     /* <select size>'s of the different <select> tags.
        If not set, uses default dropdown. */
-    $day_size        = null;
-    $month_size      = null;
-    $year_size       = null;
+    $day_size = null;
+    $month_size = null;
+    $year_size = null;
     /* Unparsed attributes common to *ALL* the <select>/<input> tags.
        An example might be in the template: all_extra ='class ="foo"'. */
-    $all_extra       = null;
+    $all_extra = null;
     /* Separate attributes for the tags. */
-    $day_extra       = null;
-    $month_extra     = null;
-    $year_extra      = null;
+    $day_extra = null;
+    $month_extra = null;
+    $year_extra = null;
     /* Order in which to display the fields.
        "D" -> day, "M" -> month, "Y" -> year. */
-    $field_order     = 'MDY';
+    $field_order = 'MDY';
     /* String printed between the different fields. */
     $field_separator = "\n";
-    $time = time();
-    $all_empty       = null;
-    $day_empty       = null;
-    $month_empty     = null;
-    $year_empty      = null;
-    $extra_attrs     = '';
+    $option_separator = "\n";
+    $time = null;
 
-    foreach ($params as $_key=>$_value) {
+    // $all_empty = null;
+    // $day_empty = null;
+    // $month_empty = null;
+    // $year_empty = null;
+    $extra_attrs = '';
+    $all_id = null;
+    $day_id = null;
+    $month_id = null;
+    $year_id = null;
+    foreach ($params as $_key => $_value) {
         switch ($_key) {
-            case 'prefix':
             case 'time':
+                $$_key = $_value; // we'll handle conversion below
+                break;
+            case 'month_names':
+                if (is_array($_value) && count($_value) === 12) {
+                    $$_key = $_value;
+                } else {
+                    trigger_error('html_select_date: month_names must be an array of 12 strings', E_USER_NOTICE);
+                }
+                break;
+            case 'prefix':
+            case 'field_array':
             case 'start_year':
             case 'end_year':
-            case 'month_format':
             case 'day_format':
             case 'day_value_format':
-            case 'field_array':
+            case 'month_format':
+            case 'month_value_format':
             case 'day_size':
             case 'month_size':
             case 'year_size':
@@ -103,18 +140,17 @@
             case 'year_extra':
             case 'field_order':
             case 'field_separator':
-            case 'month_value_format':
+            case 'option_separator':
+            case 'all_empty':
             case 'month_empty':
             case 'day_empty':
             case 'year_empty':
+            case 'all_id':
+            case 'month_id':
+            case 'day_id':
+            case 'year_id':
                 $$_key = (string)$_value;
                 break;
-
-            case 'all_empty':
-                $$_key = (string)$_value;
-                $day_empty = $month_empty = $year_empty = $all_empty;
-                break;
-
             case 'display_days':
             case 'display_months':
             case 'display_years':
@@ -122,210 +158,238 @@
             case 'reverse_years':
                 $$_key = (bool)$_value;
                 break;
-
             default:
-                if(!is_array($_value)) {
-                    $extra_attrs .= ' '.$_key.'="'.smarty_function_escape_special_chars($_value).'"';
+                if (!is_array($_value)) {
+                    $extra_attrs .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_value) . '"';
                 } else {
-                    $smarty->trigger_error("html_select_date: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                    trigger_error("html_select_date: extra attribute '{$_key}' cannot be an array", E_USER_NOTICE);
                 }
                 break;
         }
     }
+    // Note: date() is faster than strftime()
+    // Note: explode(date()) is faster than date() date() date()
 
-    if (preg_match('!^-\d+$!', $time)) {
-        // negative timestamp, use date()
-        $time = date('Y-m-d', $time);
-    }
-    // If $time is not in format yyyy-mm-dd
-    if (preg_match('/^(\d{0,4}-\d{0,2}-\d{0,2})/', $time, $found)) {
-        $time = $found[1];
-    } else {
-        // use smarty_make_timestamp to get an unix timestamp and
-        // strftime to make yyyy-mm-dd
-        $time = strftime('%Y-%m-%d', smarty_make_timestamp($time));
-    }
-    // Now split this in pieces, which later can be used to set the select
-    $time = explode("-", $time);
-
-    // make syntax "+N" or "-N" work with start_year and end_year
-    if (preg_match('!^(\+|\-)\s*(\d+)$!', $end_year, $match)) {
-        if ($match[1] == '+') {
-            $end_year = strftime('%Y') + $match[2];
+    if (isset($time) && is_array($time)) {
+        if (isset($time[$prefix . 'Year'])) {
+            // $_REQUEST[$field_array] given
+            foreach (array(
+                         'Y' => 'Year',
+                         'm' => 'Month',
+                         'd' => 'Day'
+                     ) as $_elementKey => $_elementName) {
+                $_variableName = '_' . strtolower($_elementName);
+                $$_variableName =
+                    isset($time[$prefix . $_elementName]) ? $time[$prefix . $_elementName] :
+                        date($_elementKey);
+            }
+        } elseif (isset($time[$field_array][$prefix . 'Year'])) {
+            // $_REQUEST given
+            foreach (array(
+                         'Y' => 'Year',
+                         'm' => 'Month',
+                         'd' => 'Day'
+                     ) as $_elementKey => $_elementName) {
+                $_variableName = '_' . strtolower($_elementName);
+                $$_variableName = isset($time[$field_array][$prefix . $_elementName]) ?
+                    $time[$field_array][$prefix . $_elementName] : date($_elementKey);
+            }
         } else {
-            $end_year = strftime('%Y') - $match[2];
+            // no date found, use NOW
+            list($_year, $_month, $_day) = explode('-', date('Y-m-d'));
         }
-    }
-    if (preg_match('!^(\+|\-)\s*(\d+)$!', $start_year, $match)) {
-        if ($match[1] == '+') {
-            $start_year = strftime('%Y') + $match[2];
+    } elseif (isset($time) && preg_match("/(\d*)-(\d*)-(\d*)/", $time, $matches)) {
+        $_year = $_month = $_day = null;
+        if ($matches[1] > '') $_year = (int) $matches[1];
+        if ($matches[2] > '') $_month = (int) $matches[2];
+        if ($matches[3] > '') $_day = (int) $matches[3];
+    } elseif ($time === null) {
+        if (array_key_exists('time', $params)) {
+            $_year = $_month = $_day = null;
         } else {
-            $start_year = strftime('%Y') - $match[2];
-        }
-    }
-    if (strlen($time[0]) > 0) {
-        if ($start_year > $time[0] && !isset($params['start_year'])) {
-            // force start year to include given date if not explicitly set
-            $start_year = $time[0];
-        }
-        if($end_year < $time[0] && !isset($params['end_year'])) {
-            // force end year to include given date if not explicitly set
-            $end_year = $time[0];
+            list($_year, $_month, $_day) = explode('-', date('Y-m-d'));
         }
+    } else {
+        $template->_checkPlugins(
+            array(
+                array(
+                    'function' => 'smarty_make_timestamp',
+                    'file'     => SMARTY_PLUGINS_DIR . 'shared.make_timestamp.php'
+                )
+            )
+        );
+        $time = smarty_make_timestamp($time);
+	    list($_year, $_month, $_day) = explode('-', date('Y-m-d', $time));
     }
 
-    $field_order = strtoupper($field_order);
-
-    $html_result = $month_result = $day_result = $year_result = "";
-
-    $field_separator_count = -1;
-    if ($display_months) {
-    	$field_separator_count++;
-        $month_names = array();
-        $month_values = array();
-        if(isset($month_empty)) {
-            $month_names[''] = $month_empty;
-            $month_values[''] = '';
-        }
-        for ($i = 1; $i <= 12; $i++) {
-            $month_names[$i] = strftime($month_format, mktime(0, 0, 0, $i, 1, 2000));
-            $month_values[$i] = strftime($month_value_format, mktime(0, 0, 0, $i, 1, 2000));
-        }
-
-        $month_result .= '<select name=';
-        if (null !== $field_array){
-            $month_result .= '"' . $field_array . '[' . $prefix . 'Month]"';
+    // make syntax "+N" or "-N" work with $start_year and $end_year
+    // Note preg_match('!^(\+|\-)\s*(\d+)$!', $end_year, $match) is slower than trim+substr
+    foreach (array(
+        'start',
+        'end'
+    ) as $key) {
+        $key .= '_year';
+        $t = $$key;
+        if ($t === null) {
+            $$key = (int)$_current_year;
+        } elseif ($t[ 0 ] === '+') {
+            $$key = (int)($_current_year + (int)trim(substr($t, 1)));
+        } elseif ($t[ 0 ] === '-') {
+            $$key = (int)($_current_year - (int)trim(substr($t, 1)));
         } else {
-            $month_result .= '"' . $prefix . 'Month"';
-        }
-        if (null !== $month_size){
-            $month_result .= ' size="' . $month_size . '"';
-        }
-        if (null !== $month_extra){
-            $month_result .= ' ' . $month_extra;
+            $$key = (int)$$key;
         }
-        if (null !== $all_extra){
-            $month_result .= ' ' . $all_extra;
-        }
-        $month_result .= $extra_attrs . '>'."\n";
-
-        $month_result .= smarty_function_html_options(array('output'     => $month_names,
-                                                            'values'     => $month_values,
-                                                            'selected'   => (int)$time[1] ? strftime($month_value_format, mktime(0, 0, 0, (int)$time[1], 1, 2000)) : '',
-                                                            'print_result' => false),
-                                                      $smarty);
-        $month_result .= '</select>';
     }
-
-    if ($display_days) {
-    	$field_separator_count++;
-        $days = array();
-        if (isset($day_empty)) {
-            $days[''] = $day_empty;
-            $day_values[''] = '';
-        }
-        for ($i = 1; $i <= 31; $i++) {
-            $days[] = sprintf($day_format, $i);
-            $day_values[] = sprintf($day_value_format, $i);
-        }
-
-        $day_result .= '<select name=';
-        if (null !== $field_array){
-            $day_result .= '"' . $field_array . '[' . $prefix . 'Day]"';
-        } else {
-            $day_result .= '"' . $prefix . 'Day"';
-        }
-        if (null !== $day_size){
-            $day_result .= ' size="' . $day_size . '"';
-        }
-        if (null !== $all_extra){
-            $day_result .= ' ' . $all_extra;
-        }
-        if (null !== $day_extra){
-            $day_result .= ' ' . $day_extra;
-        }
-        $day_result .= $extra_attrs . '>'."\n";
-        $day_result .= smarty_function_html_options(array('output'     => $days,
-                                                          'values'     => $day_values,
-                                                          'selected'   => $time[2],
-                                                          'print_result' => false),
-                                                    $smarty);
-        $day_result .= '</select>';
+    // flip for ascending or descending
+    if (($start_year > $end_year && !$reverse_years) || ($start_year < $end_year && $reverse_years)) {
+        $t = $end_year;
+        $end_year = $start_year;
+        $start_year = $t;
     }
-
+    // generate year <select> or <input>
     if ($display_years) {
-    	$field_separator_count++;
-        if (null !== $field_array){
-            $year_name = $field_array . '[' . $prefix . 'Year]';
-        } else {
-            $year_name = $prefix . 'Year';
+        $_extra = '';
+        $_name = $field_array ? ($field_array . '[' . $prefix . 'Year]') : ($prefix . 'Year');
+        if ($all_extra) {
+            $_extra .= ' ' . $all_extra;
+        }
+        if ($year_extra) {
+            $_extra .= ' ' . $year_extra;
         }
         if ($year_as_text) {
-            $year_result .= '<input type="text" name="' . $year_name . '" value="' . $time[0] . '" size="4" maxlength="4"';
-            if (null !== $all_extra){
-                $year_result .= ' ' . $all_extra;
-            }
-            if (null !== $year_extra){
-                $year_result .= ' ' . $year_extra;
-            }
-            $year_result .= ' />';
+            $_html_years =
+                '<input type="text" name="' . $_name . '" value="' . $_year . '" size="4" maxlength="4"' . $_extra .
+                $extra_attrs . ' />';
         } else {
-            $years = range((int)$start_year, (int)$end_year);
-            if ($reverse_years) {
-                rsort($years, SORT_NUMERIC);
-            } else {
-                sort($years, SORT_NUMERIC);
-            }
-            $yearvals = $years;
-            if(isset($year_empty)) {
-                array_unshift($years, $year_empty);
-                array_unshift($yearvals, '');
+            $_html_years = '<select name="' . $_name . '"';
+            if ($year_id !== null || $all_id !== null) {
+                $_html_years .= ' id="' . smarty_function_escape_special_chars(
+                        $year_id !== null ?
+                            ($year_id ? $year_id : $_name) :
+                            ($all_id ? ($all_id . $_name) :
+                                $_name)
+                    ) . '"';
             }
-            $year_result .= '<select name="' . $year_name . '"';
-            if (null !== $year_size){
-                $year_result .= ' size="' . $year_size . '"';
+            if ($year_size) {
+                $_html_years .= ' size="' . $year_size . '"';
             }
-            if (null !== $all_extra){
-                $year_result .= ' ' . $all_extra;
+            $_html_years .= $_extra . $extra_attrs . '>' . $option_separator;
+            if (isset($year_empty) || isset($all_empty)) {
+                $_html_years .= '<option value="">' . (isset($year_empty) ? $year_empty : $all_empty) . '</option>' .
+                                $option_separator;
             }
-            if (null !== $year_extra){
-                $year_result .= ' ' . $year_extra;
+            $op = $start_year > $end_year ? -1 : 1;
+            for ($i = $start_year; $op > 0 ? $i <= $end_year : $i >= $end_year; $i += $op) {
+                $_html_years .= '<option value="' . $i . '"' . ($_year == $i ? ' selected="selected"' : '') . '>' . $i .
+                                '</option>' . $option_separator;
             }
-            $year_result .= $extra_attrs . '>'."\n";
-            $year_result .= smarty_function_html_options(array('output' => $years,
-                                                               'values' => $yearvals,
-                                                               'selected'   => $time[0],
-                                                               'print_result' => false),
-                                                         $smarty);
-            $year_result .= '</select>';
+            $_html_years .= '</select>';
         }
     }
-
-    // Loop thru the field_order field
-    for ($i = 0; $i <= 2; $i++){
-        $c = substr($field_order, $i, 1);
-        switch ($c){
-            case 'D':
-                $html_result .= $day_result;
+    // generate month <select> or <input>
+    if ($display_months) {
+        $_extra = '';
+        $_name = $field_array ? ($field_array . '[' . $prefix . 'Month]') : ($prefix . 'Month');
+        if ($all_extra) {
+            $_extra .= ' ' . $all_extra;
+        }
+        if ($month_extra) {
+            $_extra .= ' ' . $month_extra;
+        }
+        $_html_months = '<select name="' . $_name . '"';
+        if ($month_id !== null || $all_id !== null) {
+            $_html_months .= ' id="' . smarty_function_escape_special_chars(
+                    $month_id !== null ?
+                        ($month_id ? $month_id : $_name) :
+                        ($all_id ? ($all_id . $_name) :
+                            $_name)
+                ) . '"';
+        }
+        if ($month_size) {
+            $_html_months .= ' size="' . $month_size . '"';
+        }
+        $_html_months .= $_extra . $extra_attrs . '>' . $option_separator;
+        if (isset($month_empty) || isset($all_empty)) {
+            $_html_months .= '<option value="">' . (isset($month_empty) ? $month_empty : $all_empty) . '</option>' .
+                             $option_separator;
+        }
+        for ($i = 1; $i <= 12; $i++) {
+            $_val = sprintf('%02d', $i);
+            $_text = isset($month_names) ? smarty_function_escape_special_chars($month_names[ $i ]) :
+                ($month_format === '%m' ? $_val : strftime($month_format, $_month_timestamps[ $i ]));
+            $_value = $month_value_format === '%m' ? $_val : strftime($month_value_format, $_month_timestamps[ $i ]);
+            $_html_months .= '<option value="' . $_value . '"' . ($_val == $_month ? ' selected="selected"' : '') .
+                             '>' . $_text . '</option>' . $option_separator;
+        }
+        $_html_months .= '</select>';
+    }
+    // generate day <select> or <input>
+    if ($display_days) {
+        $_extra = '';
+        $_name = $field_array ? ($field_array . '[' . $prefix . 'Day]') : ($prefix . 'Day');
+        if ($all_extra) {
+            $_extra .= ' ' . $all_extra;
+        }
+        if ($day_extra) {
+            $_extra .= ' ' . $day_extra;
+        }
+        $_html_days = '<select name="' . $_name . '"';
+        if ($day_id !== null || $all_id !== null) {
+            $_html_days .= ' id="' .
+                           smarty_function_escape_special_chars(
+                               $day_id !== null ? ($day_id ? $day_id : $_name) :
+                                   ($all_id ? ($all_id . $_name) : $_name)
+                           ) . '"';
+        }
+        if ($day_size) {
+            $_html_days .= ' size="' . $day_size . '"';
+        }
+        $_html_days .= $_extra . $extra_attrs . '>' . $option_separator;
+        if (isset($day_empty) || isset($all_empty)) {
+            $_html_days .= '<option value="">' . (isset($day_empty) ? $day_empty : $all_empty) . '</option>' .
+                           $option_separator;
+        }
+        for ($i = 1; $i <= 31; $i++) {
+            $_val = sprintf('%02d', $i);
+            $_text = $day_format === '%02d' ? $_val : sprintf($day_format, $i);
+            $_value = $day_value_format === '%02d' ? $_val : sprintf($day_value_format, $i);
+            $_html_days .= '<option value="' . $_value . '"' . ($_val == $_day ? ' selected="selected"' : '') . '>' .
+                           $_text . '</option>' . $option_separator;
+        }
+        $_html_days .= '</select>';
+    }
+    // order the fields for output
+    $_html = '';
+    for ($i = 0; $i <= 2; $i++) {
+        switch ($field_order[ $i ]) {
+            case 'Y':
+            case 'y':
+                if (isset($_html_years)) {
+                    if ($_html) {
+                        $_html .= $field_separator;
+                    }
+                    $_html .= $_html_years;
+                }
                 break;
-
+            case 'm':
             case 'M':
-                $html_result .= $month_result;
+                if (isset($_html_months)) {
+                    if ($_html) {
+                        $_html .= $field_separator;
+                    }
+                    $_html .= $_html_months;
+                }
                 break;
-
-            case 'Y':
-                $html_result .= $year_result;
+            case 'd':
+            case 'D':
+                if (isset($_html_days)) {
+                    if ($_html) {
+                        $_html .= $field_separator;
+                    }
+                    $_html .= $_html_days;
+                }
                 break;
         }
-        // Add the field seperator
-        if($i < $field_separator_count) {
-            $html_result .= $field_separator;
-        }
     }
-
-    return $html_result;
+    return $_html;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.html_select_time.php b/epgrec/Smarty/plugins/function.html_select_time.php
--- a/epgrec/Smarty/plugins/function.html_select_time.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.html_select_time.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,64 +1,119 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {html_select_time} function plugin
- *
- * Type:     function<br>
- * Name:     html_select_time<br>
+ * Type:     function
+ * Name:     html_select_time
  * Purpose:  Prints the dropdowns for time selection
- * @link http://smarty.php.net/manual/en/language.function.html.select.time.php {html_select_time}
- *          (Smarty online manual)
+ *
+ * @link   http://www.smarty.net/manual/en/language.function.html.select.time.php {html_select_time}
+ *           (Smarty online manual)
  * @author Roberto Berto <roberto@berto.net>
- * @credits Monte Ohrt <monte AT ohrt DOT com>
- * @param array
- * @param Smarty
+ * @author Monte Ohrt <monte AT ohrt DOT com>
+ *
+ * @param array                     $params parameters
+ *
+ * @param \Smarty_Internal_Template $template
+ *
  * @return string
- * @uses smarty_make_timestamp()
+ * @uses   smarty_make_timestamp()
+ * @throws \SmartyException
  */
-function smarty_function_html_select_time($params, &$smarty)
+function smarty_function_html_select_time($params, Smarty_Internal_Template $template)
 {
-    require_once $smarty->_get_plugin_filepath('shared','make_timestamp');
-    require_once $smarty->_get_plugin_filepath('function','html_options');
-    /* Default values. */
-    $prefix             = "Time_";
-    $time               = time();
-    $display_hours      = true;
-    $display_minutes    = true;
-    $display_seconds    = true;
-    $display_meridian   = true;
-    $use_24_hours       = true;
-    $minute_interval    = 1;
-    $second_interval    = 1;
-    /* Should the select boxes be part of an array when returned from PHP?
-       e.g. setting it to "birthday", would create "birthday[Hour]",
-       "birthday[Minute]", "birthday[Seconds]" & "birthday[Meridian]".
-       Can be combined with prefix. */
-    $field_array        = null;
-    $all_extra          = null;
-    $hour_extra         = null;
-    $minute_extra       = null;
-    $second_extra       = null;
-    $meridian_extra     = null;
-
-    foreach ($params as $_key=>$_value) {
+    $template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_function_escape_special_chars',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.escape_special_chars.php'
+            )
+        )
+    );
+    $prefix = 'Time_';
+    $field_array = null;
+    $field_separator = "\n";
+    $option_separator = "\n";
+    $time = null;
+    $display_hours = true;
+    $display_minutes = true;
+    $display_seconds = true;
+    $display_meridian = true;
+    $hour_format = '%02d';
+    $hour_value_format = '%02d';
+    $minute_format = '%02d';
+    $minute_value_format = '%02d';
+    $second_format = '%02d';
+    $second_value_format = '%02d';
+    $hour_size = null;
+    $minute_size = null;
+    $second_size = null;
+    $meridian_size = null;
+    $all_empty = null;
+    $hour_empty = null;
+    $minute_empty = null;
+    $second_empty = null;
+    $meridian_empty = null;
+    $all_id = null;
+    $hour_id = null;
+    $minute_id = null;
+    $second_id = null;
+    $meridian_id = null;
+    $use_24_hours = true;
+    $minute_interval = 1;
+    $second_interval = 1;
+    $extra_attrs = '';
+    $all_extra = null;
+    $hour_extra = null;
+    $minute_extra = null;
+    $second_extra = null;
+    $meridian_extra = null;
+    foreach ($params as $_key => $_value) {
         switch ($_key) {
-            case 'prefix':
             case 'time':
+                if (!is_array($_value) && $_value !== null) {
+                    $template->_checkPlugins(
+                        array(
+                            array(
+                                'function' => 'smarty_make_timestamp',
+                                'file'     => SMARTY_PLUGINS_DIR . 'shared.make_timestamp.php'
+                            )
+                        )
+                    );
+                    $time = smarty_make_timestamp($_value);
+                }
+                break;
+            case 'prefix':
             case 'field_array':
+            case 'field_separator':
+            case 'option_separator':
             case 'all_extra':
             case 'hour_extra':
             case 'minute_extra':
             case 'second_extra':
             case 'meridian_extra':
+            case 'all_empty':
+            case 'hour_empty':
+            case 'minute_empty':
+            case 'second_empty':
+            case 'meridian_empty':
+            case 'all_id':
+            case 'hour_id':
+            case 'minute_id':
+            case 'second_id':
+            case 'meridian_id':
+            case 'hour_format':
+            case 'hour_value_format':
+            case 'minute_format':
+            case 'minute_value_format':
+            case 'second_format':
+            case 'second_value_format':
                 $$_key = (string)$_value;
                 break;
-
             case 'display_hours':
             case 'display_minutes':
             case 'display_seconds':
@@ -66,129 +121,234 @@
             case 'use_24_hours':
                 $$_key = (bool)$_value;
                 break;
-
             case 'minute_interval':
             case 'second_interval':
+            case 'hour_size':
+            case 'minute_size':
+            case 'second_size':
+            case 'meridian_size':
                 $$_key = (int)$_value;
                 break;
-
             default:
-                $smarty->trigger_error("[html_select_time] unknown parameter $_key", E_USER_WARNING);
+                if (!is_array($_value)) {
+                    $extra_attrs .= ' ' . $_key . '="' . smarty_function_escape_special_chars($_value) . '"';
+                } else {
+                    trigger_error("html_select_date: extra attribute '{$_key}' cannot be an array", E_USER_NOTICE);
+                }
+                break;
         }
     }
-
-    $time = smarty_make_timestamp($time);
-
-    $html_result = '';
-
-    if ($display_hours) {
-        $hours       = $use_24_hours ? range(0, 23) : range(1, 12);
-        $hour_fmt = $use_24_hours ? '%H' : '%I';
-        for ($i = 0, $for_max = count($hours); $i < $for_max; $i++)
-            $hours[$i] = sprintf('%02d', $hours[$i]);
-        $html_result .= '<select name=';
-        if (null !== $field_array) {
-            $html_result .= '"' . $field_array . '[' . $prefix . 'Hour]"';
+    if (isset($params[ 'time' ]) && is_array($params[ 'time' ])) {
+        if (isset($params[ 'time' ][ $prefix . 'Hour' ])) {
+            // $_REQUEST[$field_array] given
+            foreach (array(
+                'H' => 'Hour',
+                'i' => 'Minute',
+                's' => 'Second'
+            ) as $_elementKey => $_elementName) {
+                $_variableName = '_' . strtolower($_elementName);
+                $$_variableName =
+                    isset($params[ 'time' ][ $prefix . $_elementName ]) ? $params[ 'time' ][ $prefix . $_elementName ] :
+                        date($_elementKey);
+            }
+            $_meridian =
+                isset($params[ 'time' ][ $prefix . 'Meridian' ]) ? (' ' . $params[ 'time' ][ $prefix . 'Meridian' ]) :
+                    '';
+            $time = strtotime($_hour . ':' . $_minute . ':' . $_second . $_meridian);
+            list($_hour, $_minute, $_second) = $time = explode('-', date('H-i-s', $time));
+        } elseif (isset($params[ 'time' ][ $field_array ][ $prefix . 'Hour' ])) {
+            // $_REQUEST given
+            foreach (array(
+                'H' => 'Hour',
+                'i' => 'Minute',
+                's' => 'Second'
+            ) as $_elementKey => $_elementName) {
+                $_variableName = '_' . strtolower($_elementName);
+                $$_variableName = isset($params[ 'time' ][ $field_array ][ $prefix . $_elementName ]) ?
+                    $params[ 'time' ][ $field_array ][ $prefix . $_elementName ] : date($_elementKey);
+            }
+            $_meridian = isset($params[ 'time' ][ $field_array ][ $prefix . 'Meridian' ]) ?
+                (' ' . $params[ 'time' ][ $field_array ][ $prefix . 'Meridian' ]) : '';
+            $time = strtotime($_hour . ':' . $_minute . ':' . $_second . $_meridian);
+            list($_hour, $_minute, $_second) = $time = explode('-', date('H-i-s', $time));
         } else {
-            $html_result .= '"' . $prefix . 'Hour"';
+            // no date found, use NOW
+            list($_year, $_month, $_day) = $time = explode('-', date('Y-m-d'));
         }
-        if (null !== $hour_extra){
-            $html_result .= ' ' . $hour_extra;
+    } elseif ($time === null) {
+        if (array_key_exists('time', $params)) {
+            $_hour = $_minute = $_second = $time = null;
+        } else {
+            list($_hour, $_minute, $_second) = $time = explode('-', date('H-i-s'));
         }
-        if (null !== $all_extra){
-            $html_result .= ' ' . $all_extra;
+    } else {
+        list($_hour, $_minute, $_second) = $time = explode('-', date('H-i-s', $time));
+    }
+    // generate hour <select>
+    if ($display_hours) {
+        $_html_hours = '';
+        $_extra = '';
+        $_name = $field_array ? ($field_array . '[' . $prefix . 'Hour]') : ($prefix . 'Hour');
+        if ($all_extra) {
+            $_extra .= ' ' . $all_extra;
+        }
+        if ($hour_extra) {
+            $_extra .= ' ' . $hour_extra;
+        }
+        $_html_hours = '<select name="' . $_name . '"';
+        if ($hour_id !== null || $all_id !== null) {
+            $_html_hours .= ' id="' .
+                            smarty_function_escape_special_chars(
+                                $hour_id !== null ? ($hour_id ? $hour_id : $_name) :
+                                    ($all_id ? ($all_id . $_name) : $_name)
+                            ) . '"';
+        }
+        if ($hour_size) {
+            $_html_hours .= ' size="' . $hour_size . '"';
+        }
+        $_html_hours .= $_extra . $extra_attrs . '>' . $option_separator;
+        if (isset($hour_empty) || isset($all_empty)) {
+            $_html_hours .= '<option value="">' . (isset($hour_empty) ? $hour_empty : $all_empty) . '</option>' .
+                            $option_separator;
+        }
+        $start = $use_24_hours ? 0 : 1;
+        $end = $use_24_hours ? 23 : 12;
+        for ($i = $start; $i <= $end; $i++) {
+            $_val = sprintf('%02d', $i);
+            $_text = $hour_format === '%02d' ? $_val : sprintf($hour_format, $i);
+            $_value = $hour_value_format === '%02d' ? $_val : sprintf($hour_value_format, $i);
+            if (!$use_24_hours) {
+                $_hour12 = $_hour == 0 ? 12 : ($_hour <= 12 ? $_hour : $_hour - 12);
+            }
+            $selected = $_hour !== null ? ($use_24_hours ? $_hour == $_val : $_hour12 == $_val) : null;
+            $_html_hours .= '<option value="' . $_value . '"' . ($selected ? ' selected="selected"' : '') . '>' .
+                            $_text . '</option>' . $option_separator;
         }
-        $html_result .= '>'."\n";
-        $html_result .= smarty_function_html_options(array('output'          => $hours,
-                                                           'values'          => $hours,
-                                                           'selected'      => strftime($hour_fmt, $time),
-                                                           'print_result' => false),
-                                                     $smarty);
-        $html_result .= "</select>\n";
+        $_html_hours .= '</select>';
     }
-
+    // generate minute <select>
     if ($display_minutes) {
-        $all_minutes = range(0, 59);
-        for ($i = 0, $for_max = count($all_minutes); $i < $for_max; $i+= $minute_interval)
-            $minutes[] = sprintf('%02d', $all_minutes[$i]);
-        $selected = intval(floor(strftime('%M', $time) / $minute_interval) * $minute_interval);
-        $html_result .= '<select name=';
-        if (null !== $field_array) {
-            $html_result .= '"' . $field_array . '[' . $prefix . 'Minute]"';
-        } else {
-            $html_result .= '"' . $prefix . 'Minute"';
+        $_html_minutes = '';
+        $_extra = '';
+        $_name = $field_array ? ($field_array . '[' . $prefix . 'Minute]') : ($prefix . 'Minute');
+        if ($all_extra) {
+            $_extra .= ' ' . $all_extra;
+        }
+        if ($minute_extra) {
+            $_extra .= ' ' . $minute_extra;
+        }
+        $_html_minutes = '<select name="' . $_name . '"';
+        if ($minute_id !== null || $all_id !== null) {
+            $_html_minutes .= ' id="' . smarty_function_escape_special_chars(
+                    $minute_id !== null ?
+                        ($minute_id ? $minute_id : $_name) :
+                        ($all_id ? ($all_id . $_name) :
+                            $_name)
+                ) . '"';
+        }
+        if ($minute_size) {
+            $_html_minutes .= ' size="' . $minute_size . '"';
+        }
+        $_html_minutes .= $_extra . $extra_attrs . '>' . $option_separator;
+        if (isset($minute_empty) || isset($all_empty)) {
+            $_html_minutes .= '<option value="">' . (isset($minute_empty) ? $minute_empty : $all_empty) . '</option>' .
+                              $option_separator;
+        }
+        $selected = $_minute !== null ? ($_minute - $_minute % $minute_interval) : null;
+        for ($i = 0; $i <= 59; $i += $minute_interval) {
+            $_val = sprintf('%02d', $i);
+            $_text = $minute_format === '%02d' ? $_val : sprintf($minute_format, $i);
+            $_value = $minute_value_format === '%02d' ? $_val : sprintf($minute_value_format, $i);
+            $_html_minutes .= '<option value="' . $_value . '"' . ($selected === $i ? ' selected="selected"' : '') .
+                              '>' . $_text . '</option>' . $option_separator;
         }
-        if (null !== $minute_extra){
-            $html_result .= ' ' . $minute_extra;
-        }
-        if (null !== $all_extra){
-            $html_result .= ' ' . $all_extra;
-        }
-        $html_result .= '>'."\n";
-        
-        $html_result .= smarty_function_html_options(array('output'          => $minutes,
-                                                           'values'          => $minutes,
-                                                           'selected'      => $selected,
-                                                           'print_result' => false),
-                                                     $smarty);
-        $html_result .= "</select>\n";
+        $_html_minutes .= '</select>';
     }
-
+    // generate second <select>
     if ($display_seconds) {
-        $all_seconds = range(0, 59);
-        for ($i = 0, $for_max = count($all_seconds); $i < $for_max; $i+= $second_interval)
-            $seconds[] = sprintf('%02d', $all_seconds[$i]);
-        $selected = intval(floor(strftime('%S', $time) / $second_interval) * $second_interval);
-        $html_result .= '<select name=';
-        if (null !== $field_array) {
-            $html_result .= '"' . $field_array . '[' . $prefix . 'Second]"';
-        } else {
-            $html_result .= '"' . $prefix . 'Second"';
+        $_html_seconds = '';
+        $_extra = '';
+        $_name = $field_array ? ($field_array . '[' . $prefix . 'Second]') : ($prefix . 'Second');
+        if ($all_extra) {
+            $_extra .= ' ' . $all_extra;
+        }
+        if ($second_extra) {
+            $_extra .= ' ' . $second_extra;
+        }
+        $_html_seconds = '<select name="' . $_name . '"';
+        if ($second_id !== null || $all_id !== null) {
+            $_html_seconds .= ' id="' . smarty_function_escape_special_chars(
+                    $second_id !== null ?
+                        ($second_id ? $second_id : $_name) :
+                        ($all_id ? ($all_id . $_name) :
+                            $_name)
+                ) . '"';
+        }
+        if ($second_size) {
+            $_html_seconds .= ' size="' . $second_size . '"';
+        }
+        $_html_seconds .= $_extra . $extra_attrs . '>' . $option_separator;
+        if (isset($second_empty) || isset($all_empty)) {
+            $_html_seconds .= '<option value="">' . (isset($second_empty) ? $second_empty : $all_empty) . '</option>' .
+                              $option_separator;
+        }
+        $selected = $_second !== null ? ($_second - $_second % $second_interval) : null;
+        for ($i = 0; $i <= 59; $i += $second_interval) {
+            $_val = sprintf('%02d', $i);
+            $_text = $second_format === '%02d' ? $_val : sprintf($second_format, $i);
+            $_value = $second_value_format === '%02d' ? $_val : sprintf($second_value_format, $i);
+            $_html_seconds .= '<option value="' . $_value . '"' . ($selected === $i ? ' selected="selected"' : '') .
+                              '>' . $_text . '</option>' . $option_separator;
         }
-        
-        if (null !== $second_extra){
-            $html_result .= ' ' . $second_extra;
-        }
-        if (null !== $all_extra){
-            $html_result .= ' ' . $all_extra;
-        }
-        $html_result .= '>'."\n";
-        
-        $html_result .= smarty_function_html_options(array('output'          => $seconds,
-                                                           'values'          => $seconds,
-                                                           'selected'      => $selected,
-                                                           'print_result' => false),
-                                                     $smarty);
-        $html_result .= "</select>\n";
+        $_html_seconds .= '</select>';
     }
-
+    // generate meridian <select>
     if ($display_meridian && !$use_24_hours) {
-        $html_result .= '<select name=';
-        if (null !== $field_array) {
-            $html_result .= '"' . $field_array . '[' . $prefix . 'Meridian]"';
-        } else {
-            $html_result .= '"' . $prefix . 'Meridian"';
+        $_html_meridian = '';
+        $_extra = '';
+        $_name = $field_array ? ($field_array . '[' . $prefix . 'Meridian]') : ($prefix . 'Meridian');
+        if ($all_extra) {
+            $_extra .= ' ' . $all_extra;
+        }
+        if ($meridian_extra) {
+            $_extra .= ' ' . $meridian_extra;
+        }
+        $_html_meridian = '<select name="' . $_name . '"';
+        if ($meridian_id !== null || $all_id !== null) {
+            $_html_meridian .= ' id="' . smarty_function_escape_special_chars(
+                    $meridian_id !== null ?
+                        ($meridian_id ? $meridian_id :
+                            $_name) :
+                        ($all_id ? ($all_id . $_name) :
+                            $_name)
+                ) . '"';
+        }
+        if ($meridian_size) {
+            $_html_meridian .= ' size="' . $meridian_size . '"';
+        }
+        $_html_meridian .= $_extra . $extra_attrs . '>' . $option_separator;
+        if (isset($meridian_empty) || isset($all_empty)) {
+            $_html_meridian .= '<option value="">' . (isset($meridian_empty) ? $meridian_empty : $all_empty) .
+                               '</option>' . $option_separator;
+        }
+        $_html_meridian .= '<option value="am"' . ($_hour > 0 && $_hour < 12 ? ' selected="selected"' : '') .
+                           '>AM</option>' . $option_separator . '<option value="pm"' .
+                           ($_hour < 12 ? '' : ' selected="selected"') . '>PM</option>' . $option_separator .
+                           '</select>';
+    }
+    $_html = '';
+    foreach (array(
+        '_html_hours',
+        '_html_minutes',
+        '_html_seconds',
+        '_html_meridian'
+    ) as $k) {
+        if (isset($$k)) {
+            if ($_html) {
+                $_html .= $field_separator;
+            }
+            $_html .= $$k;
         }
-        
-        if (null !== $meridian_extra){
-            $html_result .= ' ' . $meridian_extra;
-        }
-        if (null !== $all_extra){
-            $html_result .= ' ' . $all_extra;
-        }
-        $html_result .= '>'."\n";
-        
-        $html_result .= smarty_function_html_options(array('output'          => array('AM', 'PM'),
-                                                           'values'          => array('am', 'pm'),
-                                                           'selected'      => strtolower(strftime('%p', $time)),
-                                                           'print_result' => false),
-                                                     $smarty);
-        $html_result .= "</select>\n";
     }
-
-    return $html_result;
+    return $_html;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.html_table.php b/epgrec/Smarty/plugins/function.html_table.php
--- a/epgrec/Smarty/plugins/function.html_table.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.html_table.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,52 +1,51 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {html_table} function plugin
+ * Type:     function
+ * Name:     html_table
+ * Date:     Feb 17, 2003
+ * Purpose:  make an html table from an array of data
+ * Params:
  *
- * Type:     function<br>
- * Name:     html_table<br>
- * Date:     Feb 17, 2003<br>
- * Purpose:  make an html table from an array of data<br>
- * Input:<br>
- *         - loop = array to loop through
- *         - cols = number of columns, comma separated list of column names
- *                  or array of column names
- *         - rows = number of rows
- *         - table_attr = table attributes
- *         - th_attr = table heading attributes (arrays are cycled)
- *         - tr_attr = table row attributes (arrays are cycled)
- *         - td_attr = table cell attributes (arrays are cycled)
- *         - trailpad = value to pad trailing cells with
- *         - caption = text for caption element 
- *         - vdir = vertical direction (default: "down", means top-to-bottom)
- *         - hdir = horizontal direction (default: "right", means left-to-right)
- *         - inner = inner loop (default "cols": print $loop line by line,
- *                   $loop will be printed column by column otherwise)
- *
+ * - loop       - array to loop through
+ * - cols       - number of columns, comma separated list of column names
+ *                or array of column names
+ * - rows       - number of rows
+ * - table_attr - table attributes
+ * - th_attr    - table heading attributes (arrays are cycled)
+ * - tr_attr    - table row attributes (arrays are cycled)
+ * - td_attr    - table cell attributes (arrays are cycled)
+ * - trailpad   - value to pad trailing cells with
+ * - caption    - text for caption element
+ * - vdir       - vertical direction (default: "down", means top-to-bottom)
+ * - hdir       - horizontal direction (default: "right", means left-to-right)
+ * - inner      - inner loop (default "cols": print $loop line by line,
+ *                $loop will be printed column by column otherwise)
  *
  * Examples:
- * <pre>
+ *
  * {table loop=$data}
  * {table loop=$data cols=4 tr_attr='"bgcolor=red"'}
  * {table loop=$data cols="first,second,third" tr_attr=$colors}
- * </pre>
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @author credit to Messju Mohr <messju at lammfellpuschen dot de>
- * @author credit to boots <boots dot smarty at yahoo dot com>
- * @version  1.1
- * @link http://smarty.php.net/manual/en/language.function.html.table.php {html_table}
- *          (Smarty online manual)
- * @param array
- * @param Smarty
+ *
+ * @author  Monte Ohrt <monte at ohrt dot com>
+ * @author  credit to Messju Mohr <messju at lammfellpuschen dot de>
+ * @author  credit to boots <boots dot smarty at yahoo dot com>
+ * @version 1.1
+ * @link    http://www.smarty.net/manual/en/language.function.html.table.php {html_table}
+ *           (Smarty online manual)
+ *
+ * @param array $params parameters
+ *
  * @return string
  */
-function smarty_function_html_table($params, &$smarty)
+function smarty_function_html_table($params)
 {
     $table_attr = 'border="1"';
     $tr_attr = '';
@@ -59,18 +58,16 @@
     $hdir = 'right';
     $inner = 'cols';
     $caption = '';
-
-    if (!isset($params['loop'])) {
-        $smarty->trigger_error("html_table: missing 'loop' parameter");
+    $loop = null;
+    if (!isset($params[ 'loop' ])) {
+        trigger_error("html_table: missing 'loop' parameter", E_USER_WARNING);
         return;
     }
-
-    foreach ($params as $_key=>$_value) {
+    foreach ($params as $_key => $_value) {
         switch ($_key) {
             case 'loop':
                 $$_key = (array)$_value;
                 break;
-
             case 'cols':
                 if (is_array($_value) && !empty($_value)) {
                     $cols = $_value;
@@ -84,11 +81,9 @@
                     $cols_count = $cols;
                 }
                 break;
-
             case 'rows':
                 $$_key = (int)$_value;
                 break;
-
             case 'table_attr':
             case 'trailpad':
             case 'hdir':
@@ -97,7 +92,6 @@
             case 'caption':
                 $$_key = (string)$_value;
                 break;
-
             case 'tr_attr':
             case 'td_attr':
             case 'th_attr':
@@ -105,50 +99,42 @@
                 break;
         }
     }
-
     $loop_count = count($loop);
-    if (empty($params['rows'])) {
+    if (empty($params[ 'rows' ])) {
         /* no rows specified */
-        $rows = ceil($loop_count/$cols_count);
-    } elseif (empty($params['cols'])) {
-        if (!empty($params['rows'])) {
+        $rows = ceil($loop_count / $cols_count);
+    } elseif (empty($params[ 'cols' ])) {
+        if (!empty($params[ 'rows' ])) {
             /* no cols specified, but rows */
-            $cols_count = ceil($loop_count/$rows);
+            $cols_count = ceil($loop_count / $rows);
         }
     }
-
     $output = "<table $table_attr>\n";
-
     if (!empty($caption)) {
         $output .= '<caption>' . $caption . "</caption>\n";
     }
-
     if (is_array($cols)) {
-        $cols = ($hdir == 'right') ? $cols : array_reverse($cols);
+        $cols = ($hdir === 'right') ? $cols : array_reverse($cols);
         $output .= "<thead><tr>\n";
-
-        for ($r=0; $r<$cols_count; $r++) {
+        for ($r = 0; $r < $cols_count; $r++) {
             $output .= '<th' . smarty_function_html_table_cycle('th', $th_attr, $r) . '>';
-            $output .= $cols[$r];
+            $output .= $cols[ $r ];
             $output .= "</th>\n";
         }
         $output .= "</tr></thead>\n";
     }
-
     $output .= "<tbody>\n";
-    for ($r=0; $r<$rows; $r++) {
+    for ($r = 0; $r < $rows; $r++) {
         $output .= "<tr" . smarty_function_html_table_cycle('tr', $tr_attr, $r) . ">\n";
-        $rx =  ($vdir == 'down') ? $r*$cols_count : ($rows-1-$r)*$cols_count;
-
-        for ($c=0; $c<$cols_count; $c++) {
-            $x =  ($hdir == 'right') ? $rx+$c : $rx+$cols_count-1-$c;
-            if ($inner!='cols') {
+        $rx = ($vdir === 'down') ? $r * $cols_count : ($rows - 1 - $r) * $cols_count;
+        for ($c = 0; $c < $cols_count; $c++) {
+            $x = ($hdir === 'right') ? $rx + $c : $rx + $cols_count - 1 - $c;
+            if ($inner !== 'cols') {
                 /* shuffle x to loop over rows*/
-                $x = floor($x/$cols_count) + ($x%$cols_count)*$rows;
+                $x = floor($x / $cols_count) + ($x % $cols_count) * $rows;
             }
-
-            if ($x<$loop_count) {
-                $output .= "<td" . smarty_function_html_table_cycle('td', $td_attr, $c) . ">" . $loop[$x] . "</td>\n";
+            if ($x < $loop_count) {
+                $output .= "<td" . smarty_function_html_table_cycle('td', $td_attr, $c) . ">" . $loop[ $x ] . "</td>\n";
             } else {
                 $output .= "<td" . smarty_function_html_table_cycle('td', $td_attr, $c) . ">$trailpad</td>\n";
             }
@@ -157,21 +143,22 @@
     }
     $output .= "</tbody>\n";
     $output .= "</table>\n";
-    
     return $output;
 }
 
-function smarty_function_html_table_cycle($name, $var, $no) {
-    if(!is_array($var)) {
+/**
+ * @param $name
+ * @param $var
+ * @param $no
+ *
+ * @return string
+ */
+function smarty_function_html_table_cycle($name, $var, $no)
+{
+    if (!is_array($var)) {
         $ret = $var;
     } else {
-        $ret = $var[$no % count($var)];
+        $ret = $var[ $no % count($var) ];
     }
-    
-    return ($ret) ? ' '.$ret : '';
+    return ($ret) ? ' ' . $ret : '';
 }
-
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.mailto.php b/epgrec/Smarty/plugins/function.mailto.php
--- a/epgrec/Smarty/plugins/function.mailto.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.mailto.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,165 +1,147 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {mailto} function plugin
- *
- * Type:     function<br>
- * Name:     mailto<br>
+ * Type:     function
+ * Name:     mailto
  * Date:     May 21, 2002
- * Purpose:  automate mailto address link creation, and optionally
- *           encode them.<br>
- * Input:<br>
- *         - address = e-mail address
- *         - text = (optional) text to display, default is address
- *         - encode = (optional) can be one of:
- *                * none : no encoding (default)
- *                * javascript : encode with javascript
- *                * javascript_charcode : encode with javascript charcode
- *                * hex : encode with hexidecimal (no javascript)
- *         - cc = (optional) address(es) to carbon copy
- *         - bcc = (optional) address(es) to blind carbon copy
- *         - subject = (optional) e-mail subject
- *         - newsgroups = (optional) newsgroup(s) to post to
- *         - followupto = (optional) address(es) to follow up to
- *         - extra = (optional) extra tags for the href link
+ * Purpose:  automate mailto address link creation, and optionally encode them.
+ * Params:
+ *
+ * - address    - (required) - e-mail address
+ * - text       - (optional) - text to display, default is address
+ * - encode     - (optional) - can be one of:
+ *                             * none : no encoding (default)
+ *                             * javascript : encode with javascript
+ *                             * javascript_charcode : encode with javascript charcode
+ *                             * hex : encode with hexadecimal (no javascript)
+ * - cc         - (optional) - address(es) to carbon copy
+ * - bcc        - (optional) - address(es) to blind carbon copy
+ * - subject    - (optional) - e-mail subject
+ * - newsgroups - (optional) - newsgroup(s) to post to
+ * - followupto - (optional) - address(es) to follow up to
+ * - extra      - (optional) - extra tags for the href link
  *
  * Examples:
- * <pre>
+ *
  * {mailto address="me@domain.com"}
  * {mailto address="me@domain.com" encode="javascript"}
  * {mailto address="me@domain.com" encode="hex"}
  * {mailto address="me@domain.com" subject="Hello to you!"}
  * {mailto address="me@domain.com" cc="you@domain.com,they@domain.com"}
  * {mailto address="me@domain.com" extra='class="mailto"'}
- * </pre>
- * @link http://smarty.php.net/manual/en/language.function.mailto.php {mailto}
- *          (Smarty online manual)
- * @version  1.2
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @author   credits to Jason Sweat (added cc, bcc and subject functionality)
- * @param    array
- * @param    Smarty
- * @return   string
+ *
+ * @link    http://www.smarty.net/manual/en/language.function.mailto.php {mailto}
+ *           (Smarty online manual)
+ * @version 1.2
+ * @author  Monte Ohrt <monte at ohrt dot com>
+ * @author  credits to Jason Sweat (added cc, bcc and subject functionality)
+ *
+ * @param array $params parameters
+ *
+ * @return string
  */
-function smarty_function_mailto($params, &$smarty)
+function smarty_function_mailto($params)
 {
-    $extra = '';
+    static $_allowed_encoding = array(
+        'javascript' => true,
+        'javascript_charcode' => true,
+        'hex' => true,
+        'none' => true
+    );
 
-    if (empty($params['address'])) {
-        $smarty->trigger_error("mailto: missing 'address' parameter");
+    $extra = '';
+    if (empty($params[ 'address' ])) {
+        trigger_error("mailto: missing 'address' parameter", E_USER_WARNING);
         return;
     } else {
-        $address = $params['address'];
+        $address = $params[ 'address' ];
     }
 
     $text = $address;
 
     // netscape and mozilla do not decode %40 (@) in BCC field (bug?)
     // so, don't encode it.
-    $search = array('%40', '%2C');
-    $replace  = array('@', ',');
     $mail_parms = array();
-    foreach ($params as $var=>$value) {
+    foreach ($params as $var => $value) {
         switch ($var) {
             case 'cc':
             case 'bcc':
             case 'followupto':
-                if (!empty($value))
-                    $mail_parms[] = $var.'='.str_replace($search,$replace,rawurlencode($value));
+                if (!empty($value)) {
+                    $mail_parms[] = $var . '=' . str_replace(array('%40', '%2C'), array('@', ','), rawurlencode($value));
+                }
                 break;
-                
             case 'subject':
             case 'newsgroups':
-                $mail_parms[] = $var.'='.rawurlencode($value);
+                $mail_parms[] = $var . '=' . rawurlencode($value);
                 break;
-
             case 'extra':
             case 'text':
                 $$var = $value;
-
+            // no break
             default:
         }
     }
 
-    $mail_parm_vals = '';
-    for ($i=0; $i<count($mail_parms); $i++) {
-        $mail_parm_vals .= (0==$i) ? '?' : '&';
-        $mail_parm_vals .= $mail_parms[$i];
-    }
-    $address .= $mail_parm_vals;
-
-    $encode = (empty($params['encode'])) ? 'none' : $params['encode'];
-    if (!in_array($encode,array('javascript','javascript_charcode','hex','none')) ) {
-        $smarty->trigger_error("mailto: 'encode' parameter must be none, javascript or hex");
+    if ($mail_parms) {
+        $address .= '?' . join('&', $mail_parms);
+    }
+    $encode = (empty($params[ 'encode' ])) ? 'none' : $params[ 'encode' ];
+    if (!isset($_allowed_encoding[ $encode ])) {
+        trigger_error(
+            "mailto: 'encode' parameter must be none, javascript, javascript_charcode or hex",
+            E_USER_WARNING
+        );
         return;
     }
 
-    if ($encode == 'javascript' ) {
-        $string = 'document.write(\'<a href="mailto:'.$address.'" '.$extra.'>'.$text.'</a>\');';
+    $flags = ENT_QUOTES;
+    if (defined('ENT_SUBSTITUTE') && defined('ENT_HTML401')) {
+        $flags |= ENT_SUBSTITUTE | ENT_HTML401;
+    }
+
+    $string = '<a href="mailto:' . htmlspecialchars($address, $flags, Smarty::$_CHARSET) .
+        '" ' . $extra . '>' . htmlspecialchars($text, $flags, Smarty::$_CHARSET) . '</a>';
 
+    if ($encode === 'javascript') {
         $js_encode = '';
-        for ($x=0; $x < strlen($string); $x++) {
-            $js_encode .= '%' . bin2hex($string[$x]);
+        for ($x = 0, $_length = strlen($string); $x < $_length; $x++) {
+            $js_encode .= '%' . bin2hex($string[ $x ]);
         }
-
-        return '<script type="text/javascript">eval(unescape(\''.$js_encode.'\'))</script>';
-
-    } elseif ($encode == 'javascript_charcode' ) {
-        $string = '<a href="mailto:'.$address.'" '.$extra.'>'.$text.'</a>';
-
-        for($x = 0, $y = strlen($string); $x < $y; $x++ ) {
-            $ord[] = ord($string[$x]);   
-        }
-
-        $_ret = "<script type=\"text/javascript\" language=\"javascript\">\n";
-        $_ret .= "<!--\n";
-        $_ret .= "{document.write(String.fromCharCode(";
-        $_ret .= implode(',',$ord);
-        $_ret .= "))";
-        $_ret .= "}\n";
-        $_ret .= "//-->\n";
-        $_ret .= "</script>\n";
-        
-        return $_ret;
-        
-        
-    } elseif ($encode == 'hex') {
-
-        preg_match('!^(.*)(\?.*)$!',$address,$match);
-        if(!empty($match[2])) {
-            $smarty->trigger_error("mailto: hex encoding does not work with extra attributes. Try javascript.");
+        return '<script type="text/javascript">document.write(unescape(\'' . $js_encode . '\'))</script>';
+    } elseif ($encode === 'javascript_charcode') {
+        for ($x = 0, $_length = strlen($string); $x < $_length; $x++) {
+            $ord[] = ord($string[ $x ]);
+        }
+        return '<script type="text/javascript">document.write(String.fromCharCode(' . implode(',', $ord) . '))</script>';
+    } elseif ($encode === 'hex') {
+        preg_match('!^(.*)(\?.*)$!', $address, $match);
+        if (!empty($match[ 2 ])) {
+            trigger_error("mailto: hex encoding does not work with extra attributes. Try javascript.", E_USER_WARNING);
             return;
         }
         $address_encode = '';
-        for ($x=0; $x < strlen($address); $x++) {
-            if(preg_match('!\w!',$address[$x])) {
-                $address_encode .= '%' . bin2hex($address[$x]);
+        for ($x = 0, $_length = strlen($address); $x < $_length; $x++) {
+            if (preg_match('!\w!' . Smarty::$_UTF8_MODIFIER, $address[ $x ])) {
+                $address_encode .= '%' . bin2hex($address[ $x ]);
             } else {
-                $address_encode .= $address[$x];
+                $address_encode .= $address[ $x ];
             }
         }
         $text_encode = '';
-        for ($x=0; $x < strlen($text); $x++) {
-            $text_encode .= '&#x' . bin2hex($text[$x]).';';
+        for ($x = 0, $_length = strlen($text); $x < $_length; $x++) {
+            $text_encode .= '&#x' . bin2hex($text[ $x ]) . ';';
         }
-
         $mailto = "&#109;&#97;&#105;&#108;&#116;&#111;&#58;";
-        return '<a href="'.$mailto.$address_encode.'" '.$extra.'>'.$text_encode.'</a>';
-
+        return '<a href="' . $mailto . $address_encode . '" ' . $extra . '>' . $text_encode . '</a>';
     } else {
         // no encoding
-        return '<a href="mailto:'.$address.'" '.$extra.'>'.$text.'</a>';
-
+        return $string;
     }
-
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.math.php b/epgrec/Smarty/plugins/function.math.php
--- a/epgrec/Smarty/plugins/function.math.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.math.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,85 +1,142 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ * This plugin is only for Smarty2 BC
+ *
+ * @package    Smarty
+ * @subpackage PluginsFunction
  */
-
-
 /**
  * Smarty {math} function plugin
+ * Type:     function
+ * Name:     math
+ * Purpose:  handle math computations in template
+ *
+ * @link   http://www.smarty.net/manual/en/language.function.math.php {math}
+ *           (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
  *
- * Type:     function<br>
- * Name:     math<br>
- * Purpose:  handle math computations in template<br>
- * @link http://smarty.php.net/manual/en/language.function.math.php {math}
- *          (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param array
- * @param Smarty
- * @return string
+ * @param array                    $params   parameters
+ * @param Smarty_Internal_Template $template template object
+ *
+ * @return string|null
  */
-function smarty_function_math($params, &$smarty)
+function smarty_function_math($params, $template)
 {
+    static $_allowed_funcs =
+        array(
+            'int'   => true,
+            'abs'   => true,
+            'ceil'  => true,
+            'acos'   => true,
+            'acosh'   => true,
+            'cos'   => true,
+            'cosh'   => true,
+            'deg2rad'   => true,
+            'rad2deg'   => true,
+            'exp'   => true,
+            'floor' => true,
+            'log'   => true,
+            'log10' => true,
+            'max'   => true,
+            'min'   => true,
+            'pi'    => true,
+            'pow'   => true,
+            'rand'  => true,
+            'round' => true,
+            'asin'   => true,
+            'asinh'   => true,
+            'sin'   => true,
+            'sinh'   => true,
+            'sqrt'  => true,
+            'srand' => true,
+            'atan'   => true,
+            'atanh'   => true,
+            'tan'   => true,
+            'tanh'   => true
+        );
+
     // be sure equation parameter is present
-    if (empty($params['equation'])) {
-        $smarty->trigger_error("math: missing equation parameter");
+    if (empty($params[ 'equation' ])) {
+        trigger_error("math: missing equation parameter", E_USER_WARNING);
         return;
     }
+    $equation = $params[ 'equation' ];
+
+    // Remove whitespaces
+    $equation = preg_replace('/\s+/', '', $equation);
 
-    // strip out backticks, not necessary for math
-    $equation = str_replace('`','',$params['equation']);
+    // Adapted from https://www.php.net/manual/en/function.eval.php#107377
+    $number = '(?:\d+(?:[,.]\d+)?|pi|)'; // What is a number
+    $functionsOrVars = '((?:0x[a-fA-F0-9]+)|([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*))';
+    $operators = '[,+\/*\^%-]'; // Allowed math operators
+    $regexp = '/^(('.$number.'|'.$functionsOrVars.'|('.$functionsOrVars.'\s*\((?1)*\)|\((?1)*\)))(?:'.$operators.'(?1))?)+$/';
+
+    if (!preg_match($regexp, $equation)) {
+        trigger_error("math: illegal characters", E_USER_WARNING);
+        return;
+    }
 
     // make sure parenthesis are balanced
-    if (substr_count($equation,"(") != substr_count($equation,")")) {
-        $smarty->trigger_error("math: unbalanced parenthesis");
+    if (substr_count($equation, '(') !== substr_count($equation, ')')) {
+        trigger_error("math: unbalanced parenthesis", E_USER_WARNING);
         return;
     }
 
-    // match all vars in equation, make sure all are passed
-    preg_match_all("!(?:0x[a-fA-F0-9]+)|([a-zA-Z][a-zA-Z0-9_]*)!",$equation, $match);
-    $allowed_funcs = array('int','abs','ceil','cos','exp','floor','log','log10',
-                           'max','min','pi','pow','rand','round','sin','sqrt','srand','tan');
-    
-    foreach($match[1] as $curr_var) {
-        if ($curr_var && !in_array($curr_var, array_keys($params)) && !in_array($curr_var, $allowed_funcs)) {
-            $smarty->trigger_error("math: function call $curr_var not allowed");
-            return;
-        }
+    // disallow backticks
+    if (strpos($equation, '`') !== false) {
+        trigger_error("math: backtick character not allowed in equation", E_USER_WARNING);
+        return;
     }
 
-    foreach($params as $key => $val) {
-        if ($key != "equation" && $key != "format" && $key != "assign") {
+    // also disallow dollar signs
+    if (strpos($equation, '$') !== false) {
+        trigger_error("math: dollar signs not allowed in equation", E_USER_WARNING);
+        return;
+    }
+    foreach ($params as $key => $val) {
+        if ($key !== 'equation' && $key !== 'format' && $key !== 'assign') {
             // make sure value is not empty
-            if (strlen($val)==0) {
-                $smarty->trigger_error("math: parameter $key is empty");
+            if (strlen($val) === 0) {
+                trigger_error("math: parameter '{$key}' is empty", E_USER_WARNING);
                 return;
             }
             if (!is_numeric($val)) {
-                $smarty->trigger_error("math: parameter $key: is not numeric");
+                trigger_error("math: parameter '{$key}' is not numeric", E_USER_WARNING);
                 return;
             }
+        }
+    }
+    // match all vars in equation, make sure all are passed
+    preg_match_all('!(?:0x[a-fA-F0-9]+)|([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)!', $equation, $match);
+    foreach ($match[ 1 ] as $curr_var) {
+        if ($curr_var && !isset($params[ $curr_var ]) && !isset($_allowed_funcs[ $curr_var ])) {
+            trigger_error(
+                "math: function call '{$curr_var}' not allowed, or missing parameter '{$curr_var}'",
+                E_USER_WARNING
+            );
+            return;
+        }
+    }
+    foreach ($params as $key => $val) {
+        if ($key !== 'equation' && $key !== 'format' && $key !== 'assign') {
             $equation = preg_replace("/\b$key\b/", " \$params['$key'] ", $equation);
         }
     }
+    $smarty_math_result = null;
+    eval("\$smarty_math_result = " . $equation . ";");
 
-    eval("\$smarty_math_result = ".$equation.";");
-
-    if (empty($params['format'])) {
-        if (empty($params['assign'])) {
+    if (empty($params[ 'format' ])) {
+        if (empty($params[ 'assign' ])) {
             return $smarty_math_result;
         } else {
-            $smarty->assign($params['assign'],$smarty_math_result);
+            $template->assign($params[ 'assign' ], $smarty_math_result);
         }
     } else {
-        if (empty($params['assign'])){
-            printf($params['format'],$smarty_math_result);
+        if (empty($params[ 'assign' ])) {
+            printf($params[ 'format' ], $smarty_math_result);
         } else {
-            $smarty->assign($params['assign'],sprintf($params['format'],$smarty_math_result));
+            $template->assign($params[ 'assign' ], sprintf($params[ 'format' ], $smarty_math_result));
         }
     }
 }
-
-/* vim: set expandtab: */
-
-?>
\ 
diff -urN a/epgrec/Smarty/plugins/function.popup.php b/epgrec/Smarty/plugins/function.popup.php
--- a/epgrec/Smarty/plugins/function.popup.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.popup.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,119 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty {popup} function plugin
- *
- * Type:     function<br>
- * Name:     popup<br>
- * Purpose:  make text pop up in windows via overlib
- * @link http://smarty.php.net/manual/en/language.function.popup.php {popup}
- *          (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param array
- * @param Smarty
- * @return string
- */
-function smarty_function_popup($params, &$smarty)
-{
-    $append = '';
-    foreach ($params as $_key=>$_value) {
-        switch ($_key) {
-            case 'text':
-            case 'trigger':
-            case 'function':
-            case 'inarray':
-                $$_key = (string)$_value;
-                if ($_key == 'function' || $_key == 'inarray')
-                    $append .= ',' . strtoupper($_key) . ",'$_value'";
-                break;
-
-            case 'caption':
-            case 'closetext':
-            case 'status':
-                $append .= ',' . strtoupper($_key) . ",'" . str_replace("'","\'",$_value) . "'";
-                break;
-
-            case 'fgcolor':
-            case 'bgcolor':
-            case 'textcolor':
-            case 'capcolor':
-            case 'closecolor':
-            case 'textfont':
-            case 'captionfont':
-            case 'closefont':
-            case 'fgbackground':
-            case 'bgbackground':
-            case 'caparray':
-            case 'capicon':
-            case 'background':
-            case 'frame':
-                $append .= ',' . strtoupper($_key) . ",'$_value'";
-                break;
-
-            case 'textsize':
-            case 'captionsize':
-            case 'closesize':
-            case 'width':
-            case 'height':
-            case 'border':
-            case 'offsetx':
-            case 'offsety':
-            case 'snapx':
-            case 'snapy':
-            case 'fixx':
-            case 'fixy':
-            case 'padx':
-            case 'pady':
-            case 'timeout':
-            case 'delay':
-                $append .= ',' . strtoupper($_key) . ",$_value";
-                break;
-
-            case 'sticky':
-            case 'left':
-            case 'right':
-            case 'center':
-            case 'above':
-            case 'below':
-            case 'noclose':
-            case 'autostatus':
-            case 'autostatuscap':
-            case 'fullhtml':
-            case 'hauto':
-            case 'vauto':
-            case 'mouseoff':
-            case 'followmouse':
-            case 'closeclick':
-                if ($_value) $append .= ',' . strtoupper($_key);
-                break;
-
-            default:
-                $smarty->trigger_error("[popup] unknown parameter $_key", E_USER_WARNING);
-        }
-    }
-
-    if (empty($text) && !isset($inarray) && empty($function)) {
-        $smarty->trigger_error("overlib: attribute 'text' or 'inarray' or 'function' required");
-        return false;
-    }
-
-    if (empty($trigger)) { $trigger = "onmouseover"; }
-
-    $retval = $trigger . '="return overlib(\''.preg_replace(array("!'!","![\r\n]!"),array("\'",'\r'),$text).'\'';
-    $retval .= $append . ');"';
-    if ($trigger == 'onmouseover')
-       $retval .= ' onmouseout="nd();"';
-
-
-    return $retval;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/function.popup_init.php b/epgrec/Smarty/plugins/function.popup_init.php
--- a/epgrec/Smarty/plugins/function.popup_init.php	2022-12-13 18:30:29.452561000 +0900
+++ b/epgrec/Smarty/plugins/function.popup_init.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,40 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty {popup_init} function plugin
- *
- * Type:     function<br>
- * Name:     popup_init<br>
- * Purpose:  initialize overlib
- * @link http://smarty.php.net/manual/en/language.function.popup.init.php {popup_init}
- *          (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param array
- * @param Smarty
- * @return string
- */
-function smarty_function_popup_init($params, &$smarty)
-{
-    $zindex = 1000;
-    
-    if (!empty($params['zindex'])) {
-        $zindex = $params['zindex'];
-    }
-    
-    if (!empty($params['src'])) {
-        return '<div id="overDiv" style="position:absolute; visibility:hidden; z-index:'.$zindex.';"></div>' . "\n"
-         . '<script type="text/javascript" language="JavaScript" src="'.$params['src'].'"></script>' . "\n";
-    } else {
-        $smarty->trigger_error("popup_init: missing src parameter");
-    }
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.capitalize.php b/epgrec/Smarty/plugins/modifier.capitalize.php
--- a/epgrec/Smarty/plugins/modifier.capitalize.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.capitalize.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,43 +1,145 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
  */
-
-
 /**
  * Smarty capitalize modifier plugin
- *
- * Type:     modifier<br>
- * Name:     capitalize<br>
+ * Type:     modifier
+ * Name:     capitalize
  * Purpose:  capitalize words in the string
- * @link http://smarty.php.net/manual/en/language.modifiers.php#LANGUAGE.MODIFIER.CAPITALIZE
- *      capitalize (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
+ * {@internal {$string|capitalize:true:true} is the fastest option for MBString enabled systems }}
+ *
+ * @param string  $string    string to capitalize
+ * @param boolean $uc_digits also capitalize "x123" to "X123"
+ * @param boolean $lc_rest   capitalize first letters, lowercase all following letters "aAa" to "Aaa"
+ *
+ * @return string capitalized string
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @author Rodney Rehm
+ */
+function smarty_modifier_capitalize($string, $uc_digits = false, $lc_rest = false)
+{
+    if (Smarty::$_MBSTRING) {
+        if ($lc_rest) {
+            // uppercase (including hyphenated words)
+            $upper_string = mb_convert_case($string, MB_CASE_TITLE, Smarty::$_CHARSET);
+        } else {
+            // uppercase word breaks
+            $upper_string = preg_replace_callback(
+                "!(^|[^\p{L}'])([\p{Ll}])!S" . Smarty::$_UTF8_MODIFIER,
+                'smarty_mod_cap_mbconvert_cb',
+                $string
+            );
+        }
+        // check uc_digits case
+        if (!$uc_digits) {
+            if (preg_match_all(
+                "!\b([\p{L}]*[\p{N}]+[\p{L}]*)\b!" . Smarty::$_UTF8_MODIFIER,
+                $string,
+                $matches,
+                PREG_OFFSET_CAPTURE
+            )
+            ) {
+                foreach ($matches[ 1 ] as $match) {
+                    $upper_string =
+                        substr_replace(
+                            $upper_string,
+                            mb_strtolower($match[ 0 ], Smarty::$_CHARSET),
+                            $match[ 1 ],
+                            strlen($match[ 0 ])
+                        );
+                }
+            }
+        }
+        $upper_string =
+            preg_replace_callback(
+                "!((^|\s)['\"])(\w)!" . Smarty::$_UTF8_MODIFIER,
+                'smarty_mod_cap_mbconvert2_cb',
+                $upper_string
+            );
+        return $upper_string;
+    }
+    // lowercase first
+    if ($lc_rest) {
+        $string = strtolower($string);
+    }
+    // uppercase (including hyphenated words)
+    $upper_string =
+        preg_replace_callback(
+            "!(^|[^\p{L}'])([\p{Ll}])!S" . Smarty::$_UTF8_MODIFIER,
+            'smarty_mod_cap_ucfirst_cb',
+            $string
+        );
+    // check uc_digits case
+    if (!$uc_digits) {
+        if (preg_match_all(
+            "!\b([\p{L}]*[\p{N}]+[\p{L}]*)\b!" . Smarty::$_UTF8_MODIFIER,
+            $string,
+            $matches,
+            PREG_OFFSET_CAPTURE
+        )
+        ) {
+            foreach ($matches[ 1 ] as $match) {
+                $upper_string =
+                    substr_replace($upper_string, strtolower($match[ 0 ]), $match[ 1 ], strlen($match[ 0 ]));
+            }
+        }
+    }
+    $upper_string = preg_replace_callback(
+        "!((^|\s)['\"])(\w)!" . Smarty::$_UTF8_MODIFIER,
+        'smarty_mod_cap_ucfirst2_cb',
+        $upper_string
+    );
+    return $upper_string;
+}
+
+/**
+ *
+ * Bug: create_function() use exhausts memory when used in long loops
+ * Fix: use declared functions for callbacks instead of using create_function()
+ * Note: This can be fixed using anonymous functions instead, but that requires PHP >= 5.3
+ *
+ * @author Kyle Renfrow
+ */
+/**
+ * @param $matches
+ *
  * @return string
  */
-function smarty_modifier_capitalize($string, $uc_digits = false)
+function smarty_mod_cap_mbconvert_cb($matches)
 {
-    smarty_modifier_capitalize_ucfirst(null, $uc_digits);
-    return preg_replace_callback('!\'?\b\w(\w|\')*\b!', 'smarty_modifier_capitalize_ucfirst', $string);
+    return stripslashes($matches[ 1 ]) . mb_convert_case(stripslashes($matches[ 2 ]), MB_CASE_UPPER, Smarty::$_CHARSET);
 }
 
-function smarty_modifier_capitalize_ucfirst($string, $uc_digits = null)
+/**
+ * @param $matches
+ *
+ * @return string
+ */
+function smarty_mod_cap_mbconvert2_cb($matches)
 {
-    static $_uc_digits = false;
-    
-    if(isset($uc_digits)) {
-        $_uc_digits = $uc_digits;
-        return;
-    }
-    
-    if(substr($string[0],0,1) != "'" && !preg_match("!\d!",$string[0]) || $_uc_digits)
-        return ucfirst($string[0]);
-    else
-        return $string[0];
+    return stripslashes($matches[ 1 ]) . mb_convert_case(stripslashes($matches[ 3 ]), MB_CASE_UPPER, Smarty::$_CHARSET);
 }
 
+/**
+ * @param $matches
+ *
+ * @return string
+ */
+function smarty_mod_cap_ucfirst_cb($matches)
+{
+    return stripslashes($matches[ 1 ]) . ucfirst(stripslashes($matches[ 2 ]));
+}
 
-?>
+/**
+ * @param $matches
+ *
+ * @return string
+ */
+function smarty_mod_cap_ucfirst2_cb($matches)
+{
+    return stripslashes($matches[ 1 ]) . ucfirst(stripslashes($matches[ 3 ]));
+}
diff -urN a/epgrec/Smarty/plugins/modifier.cat.php b/epgrec/Smarty/plugins/modifier.cat.php
--- a/epgrec/Smarty/plugins/modifier.cat.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.cat.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,33 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty cat modifier plugin
- *
- * Type:     modifier<br>
- * Name:     cat<br>
- * Date:     Feb 24, 2003
- * Purpose:  catenate a value to a variable
- * Input:    string to catenate
- * Example:  {$var|cat:"foo"}
- * @link http://smarty.php.net/manual/en/language.modifier.cat.php cat
- *          (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @version 1.0
- * @param string
- * @param string
- * @return string
- */
-function smarty_modifier_cat($string, $cat)
-{
-    return $string . $cat;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.count_characters.php b/epgrec/Smarty/plugins/modifier.count_characters.php
--- a/epgrec/Smarty/plugins/modifier.count_characters.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.count_characters.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,32 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty count_characters modifier plugin
- *
- * Type:     modifier<br>
- * Name:     count_characteres<br>
- * Purpose:  count the number of characters in a text
- * @link http://smarty.php.net/manual/en/language.modifier.count.characters.php
- *          count_characters (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param boolean include whitespace in the character count
- * @return integer
- */
-function smarty_modifier_count_characters($string, $include_spaces = false)
-{
-    if ($include_spaces)
-       return(strlen($string));
-
-    return preg_match_all("/[^\s]/",$string, $match);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.count_paragraphs.php b/epgrec/Smarty/plugins/modifier.count_paragraphs.php
--- a/epgrec/Smarty/plugins/modifier.count_paragraphs.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.count_paragraphs.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,29 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty count_paragraphs modifier plugin
- *
- * Type:     modifier<br>
- * Name:     count_paragraphs<br>
- * Purpose:  count the number of paragraphs in a text
- * @link http://smarty.php.net/manual/en/language.modifier.count.paragraphs.php
- *          count_paragraphs (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @return integer
- */
-function smarty_modifier_count_paragraphs($string)
-{
-    // count \r or \n characters
-    return count(preg_split('/[\r\n]+/', $string));
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.count_sentences.php b/epgrec/Smarty/plugins/modifier.count_sentences.php
--- a/epgrec/Smarty/plugins/modifier.count_sentences.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.count_sentences.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,29 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty count_sentences modifier plugin
- *
- * Type:     modifier<br>
- * Name:     count_sentences
- * Purpose:  count the number of sentences in a text
- * @link http://smarty.php.net/manual/en/language.modifier.count.paragraphs.php
- *          count_sentences (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @return integer
- */
-function smarty_modifier_count_sentences($string)
-{
-    // find periods with a word before but not after.
-    return preg_match_all('/[^\s]\.(?!\w)/', $string, $match);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.count_words.php b/epgrec/Smarty/plugins/modifier.count_words.php
--- a/epgrec/Smarty/plugins/modifier.count_words.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.count_words.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,33 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty count_words modifier plugin
- *
- * Type:     modifier<br>
- * Name:     count_words<br>
- * Purpose:  count the number of words in a text
- * @link http://smarty.php.net/manual/en/language.modifier.count.words.php
- *          count_words (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @return integer
- */
-function smarty_modifier_count_words($string)
-{
-    // split text by ' ',\r,\n,\f,\t
-    $split_array = preg_split('/\s+/',$string);
-    // count matches that contain alphanumerics
-    $word_count = preg_grep('/[a-zA-Z0-9\\x80-\\xff]/', $split_array);
-
-    return count($word_count);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.date_format.php b/epgrec/Smarty/plugins/modifier.date_format.php
--- a/epgrec/Smarty/plugins/modifier.date_format.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.date_format.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,58 +1,85 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-/**
- * Include the {@link shared.make_timestamp.php} plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
  */
-require_once $smarty->_get_plugin_filepath('shared', 'make_timestamp');
 /**
  * Smarty date_format modifier plugin
+ * Type:     modifier
+ * Name:     date_format
+ * Purpose:  format datestamps via strftime
+ * Input:
+ *          - string: input date string
+ *          - format: strftime format for output
+ *          - default_date: default date if $string is empty
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.date.format.php date_format (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ *
+ * @param string $string       input date string
+ * @param string $format       strftime format for output
+ * @param string $default_date default date if $string is empty
+ * @param string $formatter    either 'strftime' or 'auto'
  *
- * Type:     modifier<br>
- * Name:     date_format<br>
- * Purpose:  format datestamps via strftime<br>
- * Input:<br>
- *         - string: input date string
- *         - format: strftime format for output
- *         - default_date: default date if $string is empty
- * @link http://smarty.php.net/manual/en/language.modifier.date.format.php
- *          date_format (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param string
- * @param string
- * @return string|void
- * @uses smarty_make_timestamp()
+ * @return string |void
+ * @uses   smarty_make_timestamp()
  */
-function smarty_modifier_date_format($string, $format = '%b %e, %Y', $default_date = '')
+function smarty_modifier_date_format($string, $format = null, $default_date = '', $formatter = 'auto')
 {
-    if ($string != '') {
+    if ($format === null) {
+        $format = Smarty::$_DATE_FORMAT;
+    }
+    /**
+     * require_once the {@link shared.make_timestamp.php} plugin
+     */
+    static $is_loaded = false;
+    if (!$is_loaded) {
+        if (!is_callable('smarty_make_timestamp')) {
+            include_once SMARTY_PLUGINS_DIR . 'shared.make_timestamp.php';
+        }
+        $is_loaded = true;
+    }
+    if (!empty($string) && $string !== '0000-00-00' && $string !== '0000-00-00 00:00:00') {
         $timestamp = smarty_make_timestamp($string);
-    } elseif ($default_date != '') {
+    } elseif (!empty($default_date)) {
         $timestamp = smarty_make_timestamp($default_date);
     } else {
         return;
     }
-    if (DIRECTORY_SEPARATOR == '\\') {
-        $_win_from = array('%D',       '%h', '%n', '%r',          '%R',    '%t', '%T');
-        $_win_to   = array('%m/%d/%y', '%b', "\n", '%I:%M:%S %p', '%H:%M', "\t", '%H:%M:%S');
-        if (strpos($format, '%e') !== false) {
-            $_win_from[] = '%e';
-            $_win_to[]   = sprintf('%\' 2d', date('j', $timestamp));
+    if ($formatter === 'strftime' || ($formatter === 'auto' && strpos($format, '%') !== false)) {
+        if (Smarty::$_IS_WINDOWS) {
+            $_win_from = array(
+                '%D',
+                '%h',
+                '%n',
+                '%r',
+                '%R',
+                '%t',
+                '%T'
+            );
+            $_win_to = array(
+                '%m/%d/%y',
+                '%b',
+                "\n",
+                '%I:%M:%S %p',
+                '%H:%M',
+                "\t",
+                '%H:%M:%S'
+            );
+            if (strpos($format, '%e') !== false) {
+                $_win_from[] = '%e';
+                $_win_to[] = sprintf('%\' 2d', date('j', $timestamp));
+            }
+            if (strpos($format, '%l') !== false) {
+                $_win_from[] = '%l';
+                $_win_to[] = sprintf('%\' 2d', date('h', $timestamp));
+            }
+            $format = str_replace($_win_from, $_win_to, $format);
         }
-        if (strpos($format, '%l') !== false) {
-            $_win_from[] = '%l';
-            $_win_to[]   = sprintf('%\' 2d', date('h', $timestamp));
-        }
-        $format = str_replace($_win_from, $_win_to, $format);
+        return strftime($format, $timestamp);
+    } else {
+        return date($format, $timestamp);
     }
-    return strftime($format, $timestamp);
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.debug_print_var.php b/epgrec/Smarty/plugins/modifier.debug_print_var.php
--- a/epgrec/Smarty/plugins/modifier.debug_print_var.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.debug_print_var.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,56 +1,62 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage Debug
  */
-
-
 /**
  * Smarty debug_print_var modifier plugin
- *
- * Type:     modifier<br>
- * Name:     debug_print_var<br>
+ * Type:     modifier
+ * Name:     debug_print_var
  * Purpose:  formats variable contents for display in the console
- * @link http://smarty.php.net/manual/en/language.modifier.debug.print.var.php
- *          debug_print_var (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param array|object
- * @param integer
- * @param integer
+ *
+ * @author Monte Ohrt <monte at ohrt dot com>
+ *
+ * @param array|object $var     variable to be formatted
+ * @param int          $max     maximum recursion depth if $var is an array or object
+ * @param int          $length  maximum string length if $var is a string
+ * @param int          $depth   actual recursion depth
+ * @param array        $objects processed objects in actual depth to prevent recursive object processing
+ *
  * @return string
  */
-function smarty_modifier_debug_print_var($var, $depth = 0, $length = 40)
+function smarty_modifier_debug_print_var($var, $max = 10, $length = 40, $depth = 0, $objects = array())
 {
-    $_replace = array(
-        "\n" => '<i>\n</i>',
-        "\r" => '<i>\r</i>',
-        "\t" => '<i>\t</i>'
-    );
-
+    $_replace = array("\n" => '\n', "\r" => '\r', "\t" => '\t');
     switch (gettype($var)) {
-        case 'array' :
+        case 'array':
             $results = '<b>Array (' . count($var) . ')</b>';
+            if ($depth === $max) {
+                break;
+            }
             foreach ($var as $curr_key => $curr_val) {
-                $results .= '<br>' . str_repeat('&nbsp;', $depth * 2)
-                    . '<b>' . strtr($curr_key, $_replace) . '</b> =&gt; '
-                    . smarty_modifier_debug_print_var($curr_val, ++$depth, $length);
-                    $depth--;
+                $results .= '<br>' . str_repeat('&nbsp;', $depth * 2) . '<b>' . strtr($curr_key, $_replace) .
+                            '</b> =&gt; ' .
+                            smarty_modifier_debug_print_var($curr_val, $max, $length, ++$depth, $objects);
+                $depth--;
             }
             break;
-        case 'object' :
+        case 'object':
             $object_vars = get_object_vars($var);
             $results = '<b>' . get_class($var) . ' Object (' . count($object_vars) . ')</b>';
+            if (in_array($var, $objects)) {
+                $results .= ' called recursive';
+                break;
+            }
+            if ($depth === $max) {
+                break;
+            }
+            $objects[] = $var;
             foreach ($object_vars as $curr_key => $curr_val) {
-                $results .= '<br>' . str_repeat('&nbsp;', $depth * 2)
-                    . '<b> -&gt;' . strtr($curr_key, $_replace) . '</b> = '
-                    . smarty_modifier_debug_print_var($curr_val, ++$depth, $length);
-                    $depth--;
+                $results .= '<br>' . str_repeat('&nbsp;', $depth * 2) . '<b> -&gt;' . strtr($curr_key, $_replace) .
+                            '</b> = ' . smarty_modifier_debug_print_var($curr_val, $max, $length, ++$depth, $objects);
+                $depth--;
             }
             break;
-        case 'boolean' :
-        case 'NULL' :
-        case 'resource' :
+        case 'boolean':
+        case 'NULL':
+        case 'resource':
             if (true === $var) {
                 $results = 'true';
             } elseif (false === $var) {
@@ -58,33 +64,40 @@
             } elseif (null === $var) {
                 $results = 'null';
             } else {
-                $results = htmlspecialchars((string) $var);
+                $results = htmlspecialchars((string)$var);
             }
             $results = '<i>' . $results . '</i>';
             break;
-        case 'integer' :
-        case 'float' :
-            $results = htmlspecialchars((string) $var);
+        case 'integer':
+        case 'float':
+            $results = htmlspecialchars((string)$var);
             break;
-        case 'string' :
+        case 'string':
             $results = strtr($var, $_replace);
-            if (strlen($var) > $length ) {
-                $results = substr($var, 0, $length - 3) . '...';
+            if (Smarty::$_MBSTRING) {
+                if (mb_strlen($var, Smarty::$_CHARSET) > $length) {
+                    $results = mb_substr($var, 0, $length - 3, Smarty::$_CHARSET) . '...';
+                }
+            } else {
+                if (isset($var[ $length ])) {
+                    $results = substr($var, 0, $length - 3) . '...';
+                }
             }
-            $results = htmlspecialchars('"' . $results . '"');
+            $results = htmlspecialchars('"' . $results . '"', ENT_QUOTES, Smarty::$_CHARSET);
             break;
-        case 'unknown type' :
-        default :
-            $results = strtr((string) $var, $_replace);
-            if (strlen($results) > $length ) {
-                $results = substr($results, 0, $length - 3) . '...';
+        case 'unknown type':
+        default:
+            $results = strtr((string)$var, $_replace);
+            if (Smarty::$_MBSTRING) {
+                if (mb_strlen($results, Smarty::$_CHARSET) > $length) {
+                    $results = mb_substr($results, 0, $length - 3, Smarty::$_CHARSET) . '...';
+                }
+            } else {
+                if (strlen($results) > $length) {
+                    $results = substr($results, 0, $length - 3) . '...';
+                }
             }
-            $results = htmlspecialchars($results);
+            $results = htmlspecialchars($results, ENT_QUOTES, Smarty::$_CHARSET);
     }
-
     return $results;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.default.php b/epgrec/Smarty/plugins/modifier.default.php
--- a/epgrec/Smarty/plugins/modifier.default.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.default.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,32 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty default modifier plugin
- *
- * Type:     modifier<br>
- * Name:     default<br>
- * Purpose:  designate default value for empty variables
- * @link http://smarty.php.net/manual/en/language.modifier.default.php
- *          default (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param string
- * @return string
- */
-function smarty_modifier_default($string, $default = '')
-{
-    if (!isset($string) || $string === '')
-        return $default;
-    else
-        return $string;
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.escape.php b/epgrec/Smarty/plugins/modifier.escape.php
--- a/epgrec/Smarty/plugins/modifier.escape.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.escape.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,93 +1,260 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
  */
-
-
 /**
  * Smarty escape modifier plugin
+ * Type:     modifier
+ * Name:     escape
+ * Purpose:  escape string for output
+ *
+ * @link   http://www.smarty.net/docs/en/language.modifier.escape
+ * @author Monte Ohrt <monte at ohrt dot com>
  *
- * Type:     modifier<br>
- * Name:     escape<br>
- * Purpose:  Escape the string according to escapement type
- * @link http://smarty.php.net/manual/en/language.modifier.escape.php
- *          escape (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param html|htmlall|url|quotes|hex|hexentity|javascript
- * @return string
+ * @param string  $string        input string
+ * @param string  $esc_type      escape type
+ * @param string  $char_set      character set, used for htmlspecialchars() or htmlentities()
+ * @param boolean $double_encode encode already encoded entitites again, used for htmlspecialchars() or htmlentities()
+ *
+ * @return string escaped input string
  */
-function smarty_modifier_escape($string, $esc_type = 'html', $char_set = 'ISO-8859-1')
+function smarty_modifier_escape($string, $esc_type = 'html', $char_set = null, $double_encode = true)
 {
+    static $_double_encode = null;
+    static $is_loaded_1 = false;
+    static $is_loaded_2 = false;
+    if ($_double_encode === null) {
+        $_double_encode = version_compare(PHP_VERSION, '5.2.3', '>=');
+    }
+    if (!$char_set) {
+        $char_set = Smarty::$_CHARSET;
+    }
     switch ($esc_type) {
         case 'html':
-            return htmlspecialchars($string, ENT_QUOTES, $char_set);
-
+            if ($_double_encode) {
+                // php >=5.3.2 - go native
+                return htmlspecialchars($string, ENT_QUOTES, $char_set, $double_encode);
+            } else {
+                if ($double_encode) {
+                    // php <5.2.3 - only handle double encoding
+                    return htmlspecialchars($string, ENT_QUOTES, $char_set);
+                } else {
+                    // php <5.2.3 - prevent double encoding
+                    $string = preg_replace('!&(#?\w+);!', '%%%SMARTY_START%%%\\1%%%SMARTY_END%%%', $string);
+                    $string = htmlspecialchars($string, ENT_QUOTES, $char_set);
+                    $string = str_replace(
+                        array(
+                            '%%%SMARTY_START%%%',
+                            '%%%SMARTY_END%%%'
+                        ),
+                        array(
+                            '&',
+                            ';'
+                        ),
+                        $string
+                    );
+                    return $string;
+                }
+            }
+        // no break
         case 'htmlall':
-            return htmlentities($string, ENT_QUOTES, $char_set);
-
+            if (Smarty::$_MBSTRING) {
+                // mb_convert_encoding ignores htmlspecialchars()
+                if ($_double_encode) {
+                    // php >=5.3.2 - go native
+                    $string = htmlspecialchars($string, ENT_QUOTES, $char_set, $double_encode);
+                } else {
+                    if ($double_encode) {
+                        // php <5.2.3 - only handle double encoding
+                        $string = htmlspecialchars($string, ENT_QUOTES, $char_set);
+                    } else {
+                        // php <5.2.3 - prevent double encoding
+                        $string = preg_replace('!&(#?\w+);!', '%%%SMARTY_START%%%\\1%%%SMARTY_END%%%', $string);
+                        $string = htmlspecialchars($string, ENT_QUOTES, $char_set);
+                        $string =
+                            str_replace(
+                                array(
+                                    '%%%SMARTY_START%%%',
+                                    '%%%SMARTY_END%%%'
+                                ),
+                                array(
+                                    '&',
+                                    ';'
+                                ),
+                                $string
+                            );
+                        return $string;
+                    }
+                }
+                // htmlentities() won't convert everything, so use mb_convert_encoding
+                return mb_convert_encoding($string, 'HTML-ENTITIES', $char_set);
+            }
+            // no MBString fallback
+            if ($_double_encode) {
+                return htmlentities($string, ENT_QUOTES, $char_set, $double_encode);
+            } else {
+                if ($double_encode) {
+                    return htmlentities($string, ENT_QUOTES, $char_set);
+                } else {
+                    $string = preg_replace('!&(#?\w+);!', '%%%SMARTY_START%%%\\1%%%SMARTY_END%%%', $string);
+                    $string = htmlentities($string, ENT_QUOTES, $char_set);
+                    $string = str_replace(
+                        array(
+                            '%%%SMARTY_START%%%',
+                            '%%%SMARTY_END%%%'
+                        ),
+                        array(
+                            '&',
+                            ';'
+                        ),
+                        $string
+                    );
+                    return $string;
+                }
+            }
+        // no break
         case 'url':
             return rawurlencode($string);
-
         case 'urlpathinfo':
-            return str_replace('%2F','/',rawurlencode($string));
-            
+            return str_replace('%2F', '/', rawurlencode($string));
         case 'quotes':
             // escape unescaped single quotes
             return preg_replace("%(?<!\\\\)'%", "\\'", $string);
-
         case 'hex':
-            // escape every character into hex
+            // escape every byte into hex
+            // Note that the UTF-8 encoded character  will be represented as %c3%a4
             $return = '';
-            for ($x=0; $x < strlen($string); $x++) {
-                $return .= '%' . bin2hex($string[$x]);
+            $_length = strlen($string);
+            for ($x = 0; $x < $_length; $x++) {
+                $return .= '%' . bin2hex($string[ $x ]);
             }
             return $return;
-            
         case 'hexentity':
             $return = '';
-            for ($x=0; $x < strlen($string); $x++) {
-                $return .= '&#x' . bin2hex($string[$x]) . ';';
+            if (Smarty::$_MBSTRING) {
+                if (!$is_loaded_1) {
+                    if (!is_callable('smarty_mb_to_unicode')) {
+                        include_once SMARTY_PLUGINS_DIR . 'shared.mb_unicode.php';
+                    }
+                    $is_loaded_1 = true;
+                }
+                $return = '';
+                foreach (smarty_mb_to_unicode($string, Smarty::$_CHARSET) as $unicode) {
+                    $return .= '&#x' . strtoupper(dechex($unicode)) . ';';
+                }
+                return $return;
+            }
+            // no MBString fallback
+            $_length = strlen($string);
+            for ($x = 0; $x < $_length; $x++) {
+                $return .= '&#x' . bin2hex($string[ $x ]) . ';';
             }
             return $return;
-
         case 'decentity':
             $return = '';
-            for ($x=0; $x < strlen($string); $x++) {
-                $return .= '&#' . ord($string[$x]) . ';';
+            if (Smarty::$_MBSTRING) {
+                if (!$is_loaded_1) {
+                    if (!is_callable('smarty_mb_to_unicode')) {
+                        include_once SMARTY_PLUGINS_DIR . 'shared.mb_unicode.php';
+                    }
+                    $is_loaded_1 = true;
+                }
+                $return = '';
+                foreach (smarty_mb_to_unicode($string, Smarty::$_CHARSET) as $unicode) {
+                    $return .= '&#' . $unicode . ';';
+                }
+                return $return;
+            }
+            // no MBString fallback
+            $_length = strlen($string);
+            for ($x = 0; $x < $_length; $x++) {
+                $return .= '&#' . ord($string[ $x ]) . ';';
             }
             return $return;
-
         case 'javascript':
             // escape quotes and backslashes, newlines, etc.
-            return strtr($string, array('\\'=>'\\\\',"'"=>"\\'",'"'=>'\\"',"\r"=>'\\r',"\n"=>'\\n','</'=>'<\/'));
-            
+            return strtr(
+                $string,
+                array(
+                    '\\' => '\\\\',
+                    "'"  => "\\'",
+                    '"'  => '\\"',
+                    "\r" => '\\r',
+                    "\n" => '\\n',
+                    '</' => '<\/',
+                    // see https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements
+                    '<!--' => '<\!--',
+                    '<s'   => '<\s',
+                    '<S'   => '<\S'
+                )
+            );
         case 'mail':
-            // safe way to display e-mail address on a web page
-            return str_replace(array('@', '.'),array(' [AT] ', ' [DOT] '), $string);
-            
+            if (Smarty::$_MBSTRING) {
+                if (!$is_loaded_2) {
+                    if (!is_callable('smarty_mb_str_replace')) {
+                        include_once SMARTY_PLUGINS_DIR . 'shared.mb_str_replace.php';
+                    }
+                    $is_loaded_2 = true;
+                }
+                return smarty_mb_str_replace(
+                    array(
+                        '@',
+                        '.'
+                    ),
+                    array(
+                        ' [AT] ',
+                        ' [DOT] '
+                    ),
+                    $string
+                );
+            }
+            // no MBString fallback
+            return str_replace(
+                array(
+                    '@',
+                    '.'
+                ),
+                array(
+                    ' [AT] ',
+                    ' [DOT] '
+                ),
+                $string
+            );
         case 'nonstd':
-           // escape non-standard chars, such as ms document quotes
-           $_res = '';
-           for($_i = 0, $_len = strlen($string); $_i < $_len; $_i++) {
-               $_ord = ord(substr($string, $_i, 1));
-               // non-standard char, escape it
-               if($_ord >= 126){
-                   $_res .= '&#' . $_ord . ';';
-               }
-               else {
-                   $_res .= substr($string, $_i, 1);
-               }
-           }
-           return $_res;
-
+            // escape non-standard chars, such as ms document quotes
+            $return = '';
+            if (Smarty::$_MBSTRING) {
+                if (!$is_loaded_1) {
+                    if (!is_callable('smarty_mb_to_unicode')) {
+                        include_once SMARTY_PLUGINS_DIR . 'shared.mb_unicode.php';
+                    }
+                    $is_loaded_1 = true;
+                }
+                foreach (smarty_mb_to_unicode($string, Smarty::$_CHARSET) as $unicode) {
+                    if ($unicode >= 126) {
+                        $return .= '&#' . $unicode . ';';
+                    } else {
+                        $return .= chr($unicode);
+                    }
+                }
+                return $return;
+            }
+            $_length = strlen($string);
+            for ($_i = 0; $_i < $_length; $_i++) {
+                $_ord = ord(substr($string, $_i, 1));
+                // non-standard char, escape it
+                if ($_ord >= 126) {
+                    $return .= '&#' . $_ord . ';';
+                } else {
+                    $return .= substr($string, $_i, 1);
+                }
+            }
+            return $return;
         default:
+            trigger_error("escape: unsupported type: $esc_type - returning unmodified string", E_USER_NOTICE);
             return $string;
     }
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.indent.php b/epgrec/Smarty/plugins/modifier.indent.php
--- a/epgrec/Smarty/plugins/modifier.indent.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.indent.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,28 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty indent modifier plugin
- *
- * Type:     modifier<br>
- * Name:     indent<br>
- * Purpose:  indent lines of text
- * @link http://smarty.php.net/manual/en/language.modifier.indent.php
- *          indent (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param integer
- * @param string
- * @return string
- */
-function smarty_modifier_indent($string,$chars=4,$char=" ")
-{
-    return preg_replace('!^!m',str_repeat($char,$chars),$string);
-}
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.lower.php b/epgrec/Smarty/plugins/modifier.lower.php
--- a/epgrec/Smarty/plugins/modifier.lower.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.lower.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,26 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty lower modifier plugin
- *
- * Type:     modifier<br>
- * Name:     lower<br>
- * Purpose:  convert string to lowercase
- * @link http://smarty.php.net/manual/en/language.modifier.lower.php
- *          lower (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @return string
- */
-function smarty_modifier_lower($string)
-{
-    return strtolower($string);
-}
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.mb_wordwrap.php b/epgrec/Smarty/plugins/modifier.mb_wordwrap.php
--- a/epgrec/Smarty/plugins/modifier.mb_wordwrap.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifier.mb_wordwrap.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,71 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
+ */
+/**
+ * Smarty wordwrap modifier plugin
+ * Type:     modifier
+ * Name:     mb_wordwrap
+ * Purpose:  Wrap a string to a given number of characters
+ *
+ * @link   http://php.net/manual/en/function.wordwrap.php for similarity
+ *
+ * @param string  $str   the string to wrap
+ * @param int     $width the width of the output
+ * @param string  $break the character used to break the line
+ * @param boolean $cut   ignored parameter, just for the sake of
+ *
+ * @return string  wrapped string
+ * @author Rodney Rehm
+ */
+function smarty_modifier_mb_wordwrap($str, $width = 75, $break = "\n", $cut = false)
+{
+    // break words into tokens using white space as a delimiter
+    $tokens = preg_split('!(\s)!S' . Smarty::$_UTF8_MODIFIER, $str, -1, PREG_SPLIT_NO_EMPTY + PREG_SPLIT_DELIM_CAPTURE);
+    $length = 0;
+    $t = '';
+    $_previous = false;
+    $_space = false;
+    foreach ($tokens as $_token) {
+        $token_length = mb_strlen($_token, Smarty::$_CHARSET);
+        $_tokens = array($_token);
+        if ($token_length > $width) {
+            if ($cut) {
+                $_tokens = preg_split(
+                    '!(.{' . $width . '})!S' . Smarty::$_UTF8_MODIFIER,
+                    $_token,
+                    -1,
+                    PREG_SPLIT_NO_EMPTY + PREG_SPLIT_DELIM_CAPTURE
+                );
+            }
+        }
+        foreach ($_tokens as $token) {
+            $_space = !!preg_match('!^\s$!S' . Smarty::$_UTF8_MODIFIER, $token);
+            $token_length = mb_strlen($token, Smarty::$_CHARSET);
+            $length += $token_length;
+            if ($length > $width) {
+                // remove space before inserted break
+                if ($_previous) {
+                    $t = mb_substr($t, 0, -1, Smarty::$_CHARSET);
+                }
+                if (!$_space) {
+                    // add the break before the token
+                    if (!empty($t)) {
+                        $t .= $break;
+                    }
+                    $length = $token_length;
+                }
+            } elseif ($token === "\n") {
+                // hard break must reset counters
+                $length = 0;
+            }
+            $_previous = $_space;
+            // add the token
+            $t .= $token;
+        }
+    }
+    return $t;
+}
diff -urN a/epgrec/Smarty/plugins/modifier.nl2br.php b/epgrec/Smarty/plugins/modifier.nl2br.php
--- a/epgrec/Smarty/plugins/modifier.nl2br.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.nl2br.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,35 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty plugin
- *
- * Type:     modifier<br>
- * Name:     nl2br<br>
- * Date:     Feb 26, 2003
- * Purpose:  convert \r\n, \r or \n to <<br>>
- * Input:<br>
- *         - contents = contents to replace
- *         - preceed_test = if true, includes preceeding break tags
- *           in replacement
- * Example:  {$text|nl2br}
- * @link http://smarty.php.net/manual/en/language.modifier.nl2br.php
- *          nl2br (Smarty online manual)
- * @version  1.0
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @return string
- */
-function smarty_modifier_nl2br($string)
-{
-    return nl2br($string);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.regex_replace.php b/epgrec/Smarty/plugins/modifier.regex_replace.php
--- a/epgrec/Smarty/plugins/modifier.regex_replace.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.regex_replace.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,48 +1,55 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
  */
-
-
 /**
  * Smarty regex_replace modifier plugin
- *
- * Type:     modifier<br>
- * Name:     regex_replace<br>
+ * Type:     modifier
+ * Name:     regex_replace
  * Purpose:  regular expression search/replace
- * @link http://smarty.php.net/manual/en/language.modifier.regex.replace.php
+ *
+ * @link   http://smarty.php.net/manual/en/language.modifier.regex.replace.php
  *          regex_replace (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param string|array
- * @param string|array
+ * @author Monte Ohrt <monte at ohrt dot com>
+ *
+ * @param string       $string  input string
+ * @param string|array $search  regular expression(s) to search for
+ * @param string|array $replace string(s) that should be replaced
+ * @param int          $limit   the maximum number of replacements
+ *
  * @return string
  */
-function smarty_modifier_regex_replace($string, $search, $replace)
+function smarty_modifier_regex_replace($string, $search, $replace, $limit = -1)
 {
-    if(is_array($search)) {
-      foreach($search as $idx => $s)
-        $search[$idx] = _smarty_regex_replace_check($s);
+    if (is_array($search)) {
+        foreach ($search as $idx => $s) {
+            $search[ $idx ] = _smarty_regex_replace_check($s);
+        }
     } else {
-      $search = _smarty_regex_replace_check($search);
-    }       
-
-    return preg_replace($search, $replace, $string);
+        $search = _smarty_regex_replace_check($search);
+    }
+    return preg_replace($search, $replace, $string, $limit);
 }
 
+/**
+ * @param  string $search string(s) that should be replaced
+ *
+ * @return string
+ * @ignore
+ */
 function _smarty_regex_replace_check($search)
 {
-    if (($pos = strpos($search,"\0")) !== false)
-      $search = substr($search,0,$pos);
-    if (preg_match('!([a-zA-Z\s]+)$!s', $search, $match) && (strpos($match[1], 'e') !== false)) {
-        /* remove eval-modifier from $search */
-        $search = substr($search, 0, -strlen($match[1])) . preg_replace('![e\s]+!', '', $match[1]);
+    // null-byte injection detection
+    // anything behind the first null-byte is ignored
+    if (($pos = strpos($search, "\0")) !== false) {
+        $search = substr($search, 0, $pos);
+    }
+    // remove eval-modifier from $search
+    if (preg_match('!([a-zA-Z\s]+)$!s', $search, $match) && (strpos($match[ 1 ], 'e') !== false)) {
+        $search = substr($search, 0, -strlen($match[ 1 ])) . preg_replace('![e\s]+!', '', $match[ 1 ]);
     }
     return $search;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.replace.php b/epgrec/Smarty/plugins/modifier.replace.php
--- a/epgrec/Smarty/plugins/modifier.replace.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.replace.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,30 +1,37 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
  */
-
-
 /**
  * Smarty replace modifier plugin
- *
- * Type:     modifier<br>
- * Name:     replace<br>
+ * Type:     modifier
+ * Name:     replace
  * Purpose:  simple search/replace
- * @link http://smarty.php.net/manual/en/language.modifier.replace.php
- *          replace (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param string
- * @param string
+ *
+ * @link   http://smarty.php.net/manual/en/language.modifier.replace.php replace (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @author Uwe Tews
+ *
+ * @param string $string  input string
+ * @param string $search  text to search for
+ * @param string $replace replacement text
+ *
  * @return string
  */
 function smarty_modifier_replace($string, $search, $replace)
 {
+    static $is_loaded = false;
+    if (Smarty::$_MBSTRING) {
+        if (!$is_loaded) {
+            if (!is_callable('smarty_mb_str_replace')) {
+                include_once SMARTY_PLUGINS_DIR . 'shared.mb_str_replace.php';
+            }
+            $is_loaded = true;
+        }
+        return smarty_mb_str_replace($search, $replace, $string);
+    }
     return str_replace($search, $replace, $string);
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.spacify.php b/epgrec/Smarty/plugins/modifier.spacify.php
--- a/epgrec/Smarty/plugins/modifier.spacify.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.spacify.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,30 +1,26 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
  */
-
-
 /**
  * Smarty spacify modifier plugin
- *
- * Type:     modifier<br>
- * Name:     spacify<br>
+ * Type:     modifier
+ * Name:     spacify
  * Purpose:  add spaces between characters in a string
- * @link http://smarty.php.net/manual/en/language.modifier.spacify.php
- *          spacify (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param string
+ *
+ * @link   http://smarty.php.net/manual/en/language.modifier.spacify.php spacify (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ *
+ * @param string $string       input string
+ * @param string $spacify_char string to insert between characters.
+ *
  * @return string
  */
 function smarty_modifier_spacify($string, $spacify_char = ' ')
 {
-    return implode($spacify_char,
-                   preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY));
+    // well what about charsets besides latin and UTF-8?
+    return implode($spacify_char, preg_split('//' . Smarty::$_UTF8_MODIFIER, $string, -1, PREG_SPLIT_NO_EMPTY));
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.string_format.php b/epgrec/Smarty/plugins/modifier.string_format.php
--- a/epgrec/Smarty/plugins/modifier.string_format.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.string_format.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,29 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty string_format modifier plugin
- *
- * Type:     modifier<br>
- * Name:     string_format<br>
- * Purpose:  format strings via sprintf
- * @link http://smarty.php.net/manual/en/language.modifier.string.format.php
- *          string_format (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param string
- * @return string
- */
-function smarty_modifier_string_format($string, $format)
-{
-    return sprintf($format, $string);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.strip.php b/epgrec/Smarty/plugins/modifier.strip.php
--- a/epgrec/Smarty/plugins/modifier.strip.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.strip.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,33 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty strip modifier plugin
- *
- * Type:     modifier<br>
- * Name:     strip<br>
- * Purpose:  Replace all repeated spaces, newlines, tabs
- *           with a single space or supplied replacement string.<br>
- * Example:  {$var|strip} {$var|strip:"&nbsp;"}
- * Date:     September 25th, 2002
- * @link http://smarty.php.net/manual/en/language.modifier.strip.php
- *          strip (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @version  1.0
- * @param string
- * @param string
- * @return string
- */
-function smarty_modifier_strip($text, $replace = ' ')
-{
-    return preg_replace('!\s+!', $replace, $text);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.strip_tags.php b/epgrec/Smarty/plugins/modifier.strip_tags.php
--- a/epgrec/Smarty/plugins/modifier.strip_tags.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.strip_tags.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,32 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty strip_tags modifier plugin
- *
- * Type:     modifier<br>
- * Name:     strip_tags<br>
- * Purpose:  strip html tags from text
- * @link http://smarty.php.net/manual/en/language.modifier.strip.tags.php
- *          strip_tags (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param boolean
- * @return string
- */
-function smarty_modifier_strip_tags($string, $replace_with_space = true)
-{
-    if ($replace_with_space)
-        return preg_replace('!<[^>]*?>!', ' ', $string);
-    else
-        return strip_tags($string);
-}
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.truncate.php b/epgrec/Smarty/plugins/modifier.truncate.php
--- a/epgrec/Smarty/plugins/modifier.truncate.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.truncate.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,50 +1,62 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifier
  */
-
-
 /**
  * Smarty truncate modifier plugin
- *
- * Type:     modifier<br>
- * Name:     truncate<br>
+ * Type:     modifier
+ * Name:     truncate
  * Purpose:  Truncate a string to a certain length if necessary,
- *           optionally splitting in the middle of a word, and
- *           appending the $etc string or inserting $etc into the middle.
- * @link http://smarty.php.net/manual/en/language.modifier.truncate.php
- *          truncate (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param integer
- * @param string
- * @param boolean
- * @param boolean
- * @return string
+ *               optionally splitting in the middle of a word, and
+ *               appending the $etc string or inserting $etc into the middle.
+ *
+ * @link   http://smarty.php.net/manual/en/language.modifier.truncate.php truncate (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ *
+ * @param string  $string      input string
+ * @param integer $length      length of truncated text
+ * @param string  $etc         end string
+ * @param boolean $break_words truncate at word boundary
+ * @param boolean $middle      truncate in the middle of text
+ *
+ * @return string truncated string
  */
-function smarty_modifier_truncate($string, $length = 80, $etc = '...',
-                                  $break_words = false, $middle = false)
+function smarty_modifier_truncate($string, $length = 80, $etc = '...', $break_words = false, $middle = false)
 {
-    if ($length == 0)
+    if ($length === 0) {
         return '';
-
-    if (strlen($string) > $length) {
+    }
+    if (Smarty::$_MBSTRING) {
+        if (mb_strlen($string, Smarty::$_CHARSET) > $length) {
+            $length -= min($length, mb_strlen($etc, Smarty::$_CHARSET));
+            if (!$break_words && !$middle) {
+                $string = preg_replace(
+                    '/\s+?(\S+)?$/' . Smarty::$_UTF8_MODIFIER,
+                    '',
+                    mb_substr($string, 0, $length + 1, Smarty::$_CHARSET)
+                );
+            }
+            if (!$middle) {
+                return mb_substr($string, 0, $length, Smarty::$_CHARSET) . $etc;
+            }
+            return mb_substr($string, 0, $length / 2, Smarty::$_CHARSET) . $etc .
+                   mb_substr($string, -$length / 2, $length, Smarty::$_CHARSET);
+        }
+        return $string;
+    }
+    // no MBString fallback
+    if (isset($string[ $length ])) {
         $length -= min($length, strlen($etc));
         if (!$break_words && !$middle) {
-            $string = preg_replace('/\s+?(\S+)?$/', '', substr($string, 0, $length+1));
+            $string = preg_replace('/\s+?(\S+)?$/', '', substr($string, 0, $length + 1));
         }
-        if(!$middle) {
+        if (!$middle) {
             return substr($string, 0, $length) . $etc;
-        } else {
-            return substr($string, 0, $length/2) . $etc . substr($string, -$length/2);
         }
-    } else {
-        return $string;
+        return substr($string, 0, $length / 2) . $etc . substr($string, -$length / 2);
     }
+    return $string;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.upper.php b/epgrec/Smarty/plugins/modifier.upper.php
--- a/epgrec/Smarty/plugins/modifier.upper.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.upper.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,26 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty upper modifier plugin
- *
- * Type:     modifier<br>
- * Name:     upper<br>
- * Purpose:  convert string to uppercase
- * @link http://smarty.php.net/manual/en/language.modifier.upper.php
- *          upper (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @return string
- */
-function smarty_modifier_upper($string)
-{
-    return strtoupper($string);
-}
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifier.wordwrap.php b/epgrec/Smarty/plugins/modifier.wordwrap.php
--- a/epgrec/Smarty/plugins/modifier.wordwrap.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/modifier.wordwrap.php	1970-01-01 09:00:00.000000000 +0900
@@ -1,29 +0,0 @@
-<?php
-/**
- * Smarty plugin
- * @package Smarty
- * @subpackage plugins
- */
-
-
-/**
- * Smarty wordwrap modifier plugin
- *
- * Type:     modifier<br>
- * Name:     wordwrap<br>
- * Purpose:  wrap a string of text at a given length
- * @link http://smarty.php.net/manual/en/language.modifier.wordwrap.php
- *          wordwrap (Smarty online manual)
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @param integer
- * @param string
- * @param boolean
- * @return string
- */
-function smarty_modifier_wordwrap($string,$length=80,$break="\n",$cut=false)
-{
-    return wordwrap($string,$length,$break,$cut);
-}
-
-?>
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.cat.php b/epgrec/Smarty/plugins/modifiercompiler.cat.php
--- a/epgrec/Smarty/plugins/modifiercompiler.cat.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.cat.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,28 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty cat modifier plugin
+ * Type:     modifier
+ * Name:     cat
+ * Date:     Feb 24, 2003
+ * Purpose:  catenate a value to a variable
+ * Input:    string to catenate
+ * Example:  {$var|cat:"foo"}
+ *
+ * @link   http://smarty.php.net/manual/en/language.modifier.cat.php cat
+ *           (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_cat($params)
+{
+    return '(' . implode(').(', $params) . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.count_characters.php b/epgrec/Smarty/plugins/modifiercompiler.count_characters.php
--- a/epgrec/Smarty/plugins/modifiercompiler.count_characters.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.count_characters.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,32 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty count_characters modifier plugin
+ * Type:     modifier
+ * Name:     count_characters
+ * Purpose:  count the number of characters in a text
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.count.characters.php count_characters (Smarty online
+ *         manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_count_characters($params)
+{
+    if (!isset($params[ 1 ]) || $params[ 1 ] !== 'true') {
+        return 'preg_match_all(\'/[^\s]/' . Smarty::$_UTF8_MODIFIER . '\',' . $params[ 0 ] . ', $tmp)';
+    }
+    if (Smarty::$_MBSTRING) {
+        return 'mb_strlen(' . $params[ 0 ] . ', \'' . addslashes(Smarty::$_CHARSET) . '\')';
+    }
+    // no MBString fallback
+    return 'strlen(' . $params[ 0 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.count_paragraphs.php b/epgrec/Smarty/plugins/modifiercompiler.count_paragraphs.php
--- a/epgrec/Smarty/plugins/modifiercompiler.count_paragraphs.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.count_paragraphs.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,26 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty count_paragraphs modifier plugin
+ * Type:     modifier
+ * Name:     count_paragraphs
+ * Purpose:  count the number of paragraphs in a text
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.count.paragraphs.php
+ *          count_paragraphs (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_count_paragraphs($params)
+{
+    // count \r or \n characters
+    return '(preg_match_all(\'#[\r\n]+#\', ' . $params[ 0 ] . ', $tmp)+1)';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.count_sentences.php b/epgrec/Smarty/plugins/modifiercompiler.count_sentences.php
--- a/epgrec/Smarty/plugins/modifiercompiler.count_sentences.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.count_sentences.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,26 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty count_sentences modifier plugin
+ * Type:     modifier
+ * Name:     count_sentences
+ * Purpose:  count the number of sentences in a text
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.count.paragraphs.php
+ *          count_sentences (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_count_sentences($params)
+{
+    // find periods, question marks, exclamation marks with a word before but not after.
+    return 'preg_match_all("#\w[\.\?\!](\W|$)#S' . Smarty::$_UTF8_MODIFIER . '", ' . $params[ 0 ] . ', $tmp)';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.count_words.php b/epgrec/Smarty/plugins/modifiercompiler.count_words.php
--- a/epgrec/Smarty/plugins/modifiercompiler.count_words.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.count_words.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,31 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty count_words modifier plugin
+ * Type:     modifier
+ * Name:     count_words
+ * Purpose:  count the number of words in a text
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.count.words.php count_words (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_count_words($params)
+{
+    if (Smarty::$_MBSTRING) {
+        // return 'preg_match_all(\'#[\w\pL]+#' . Smarty::$_UTF8_MODIFIER . '\', ' . $params[0] . ', $tmp)';
+        // expression taken from http://de.php.net/manual/en/function.str-word-count.php#85592
+        return 'preg_match_all(\'/\p{L}[\p{L}\p{Mn}\p{Pd}\\\'\x{2019}]*/' . Smarty::$_UTF8_MODIFIER . '\', ' .
+               $params[ 0 ] . ', $tmp)';
+    }
+    // no MBString fallback
+    return 'str_word_count(' . $params[ 0 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.default.php b/epgrec/Smarty/plugins/modifiercompiler.default.php
--- a/epgrec/Smarty/plugins/modifiercompiler.default.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.default.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,32 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty default modifier plugin
+ * Type:     modifier
+ * Name:     default
+ * Purpose:  designate default value for empty variables
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.default.php default (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_default($params)
+{
+    $output = $params[ 0 ];
+    if (!isset($params[ 1 ])) {
+        $params[ 1 ] = "''";
+    }
+    array_shift($params);
+    foreach ($params as $param) {
+        $output = '(($tmp = @' . $output . ')===null||$tmp===\'\' ? ' . $param . ' : $tmp)';
+    }
+    return $output;
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.escape.php b/epgrec/Smarty/plugins/modifiercompiler.escape.php
--- a/epgrec/Smarty/plugins/modifiercompiler.escape.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.escape.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,113 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty escape modifier plugin
+ * Type:     modifier
+ * Name:     escape
+ * Purpose:  escape string for output
+ *
+ * @link   http://www.smarty.net/docsv2/en/language.modifier.escape count_characters (Smarty online manual)
+ * @author Rodney Rehm
+ *
+ * @param array                                $params parameters
+ * @param Smarty_Internal_TemplateCompilerBase $compiler
+ *
+ * @return string with compiled code
+ * @throws \SmartyException
+ */
+function smarty_modifiercompiler_escape($params, Smarty_Internal_TemplateCompilerBase $compiler)
+{
+    static $_double_encode = null;
+    static $is_loaded = false;
+    $compiler->template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_literal_compiler_param',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.literal_compiler_param.php'
+            )
+        )
+    );
+    if ($_double_encode === null) {
+        $_double_encode = version_compare(PHP_VERSION, '5.2.3', '>=');
+    }
+    try {
+        $esc_type = smarty_literal_compiler_param($params, 1, 'html');
+        $char_set = smarty_literal_compiler_param($params, 2, Smarty::$_CHARSET);
+        $double_encode = smarty_literal_compiler_param($params, 3, true);
+        if (!$char_set) {
+            $char_set = Smarty::$_CHARSET;
+        }
+        switch ($esc_type) {
+            case 'html':
+                if ($_double_encode) {
+                    return 'htmlspecialchars(' . $params[ 0 ] . ', ENT_QUOTES, ' . var_export($char_set, true) . ', ' .
+                           var_export($double_encode, true) . ')';
+                } elseif ($double_encode) {
+                    return 'htmlspecialchars(' . $params[ 0 ] . ', ENT_QUOTES, ' . var_export($char_set, true) . ')';
+                } else {
+                    // fall back to modifier.escape.php
+                }
+            // no break
+            case 'htmlall':
+                if (Smarty::$_MBSTRING) {
+                    if ($_double_encode) {
+                        // php >=5.2.3 - go native
+                        return 'mb_convert_encoding(htmlspecialchars(' . $params[ 0 ] . ', ENT_QUOTES, ' .
+                               var_export($char_set, true) . ', ' . var_export($double_encode, true) .
+                               '), "HTML-ENTITIES", ' . var_export($char_set, true) . ')';
+                    } elseif ($double_encode) {
+                        // php <5.2.3 - only handle double encoding
+                        return 'mb_convert_encoding(htmlspecialchars(' . $params[ 0 ] . ', ENT_QUOTES, ' .
+                               var_export($char_set, true) . '), "HTML-ENTITIES", ' . var_export($char_set, true) . ')';
+                    } else {
+                        // fall back to modifier.escape.php
+                    }
+                }
+                // no MBString fallback
+                if ($_double_encode) {
+                    // php >=5.2.3 - go native
+                    return 'htmlentities(' . $params[ 0 ] . ', ENT_QUOTES, ' . var_export($char_set, true) . ', ' .
+                           var_export($double_encode, true) . ')';
+                } elseif ($double_encode) {
+                    // php <5.2.3 - only handle double encoding
+                    return 'htmlentities(' . $params[ 0 ] . ', ENT_QUOTES, ' . var_export($char_set, true) . ')';
+                } else {
+                    // fall back to modifier.escape.php
+                }
+            // no break
+            case 'url':
+                return 'rawurlencode(' . $params[ 0 ] . ')';
+            case 'urlpathinfo':
+                return 'str_replace("%2F", "/", rawurlencode(' . $params[ 0 ] . '))';
+            case 'quotes':
+                // escape unescaped single quotes
+                return 'preg_replace("%(?<!\\\\\\\\)\'%", "\\\'",' . $params[ 0 ] . ')';
+            case 'javascript':
+                // escape quotes and backslashes, newlines, etc.
+                // see https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements
+                return 'strtr(' .
+                       $params[ 0 ] .
+                       ', array("\\\\" => "\\\\\\\\", "\'" => "\\\\\'", "\"" => "\\\\\"", "\\r" => "\\\\r", "\\n" => "\\\n", "</" => "<\/", "<!--" => "<\!--", "<s" => "<\s", "<S" => "<\S" ))';
+        }
+    } catch (SmartyException $e) {
+        // pass through to regular plugin fallback
+    }
+    // could not optimize |escape call, so fallback to regular plugin
+    if ($compiler->template->caching && ($compiler->tag_nocache | $compiler->nocache)) {
+        $compiler->required_plugins[ 'nocache' ][ 'escape' ][ 'modifier' ][ 'file' ] =
+            SMARTY_PLUGINS_DIR . 'modifier.escape.php';
+        $compiler->required_plugins[ 'nocache' ][ 'escape' ][ 'modifier' ][ 'function' ] =
+            'smarty_modifier_escape';
+    } else {
+        $compiler->required_plugins[ 'compiled' ][ 'escape' ][ 'modifier' ][ 'file' ] =
+            SMARTY_PLUGINS_DIR . 'modifier.escape.php';
+        $compiler->required_plugins[ 'compiled' ][ 'escape' ][ 'modifier' ][ 'function' ] =
+            'smarty_modifier_escape';
+    }
+    return 'smarty_modifier_escape(' . join(', ', $params) . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.from_charset.php b/epgrec/Smarty/plugins/modifiercompiler.from_charset.php
--- a/epgrec/Smarty/plugins/modifiercompiler.from_charset.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.from_charset.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,30 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty from_charset modifier plugin
+ * Type:     modifier
+ * Name:     from_charset
+ * Purpose:  convert character encoding from $charset to internal encoding
+ *
+ * @author Rodney Rehm
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_from_charset($params)
+{
+    if (!Smarty::$_MBSTRING) {
+        // FIXME: (rodneyrehm) shouldn't this throw an error?
+        return $params[ 0 ];
+    }
+    if (!isset($params[ 1 ])) {
+        $params[ 1 ] = '"ISO-8859-1"';
+    }
+    return 'mb_convert_encoding(' . $params[ 0 ] . ', "' . addslashes(Smarty::$_CHARSET) . '", ' . $params[ 1 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.indent.php b/epgrec/Smarty/plugins/modifiercompiler.indent.php
--- a/epgrec/Smarty/plugins/modifiercompiler.indent.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.indent.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,30 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty indent modifier plugin
+ * Type:     modifier
+ * Name:     indent
+ * Purpose:  indent lines of text
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.indent.php indent (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_indent($params)
+{
+    if (!isset($params[ 1 ])) {
+        $params[ 1 ] = 4;
+    }
+    if (!isset($params[ 2 ])) {
+        $params[ 2 ] = "' '";
+    }
+    return 'preg_replace(\'!^!m\',str_repeat(' . $params[ 2 ] . ',' . $params[ 1 ] . '),' . $params[ 0 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.lower.php b/epgrec/Smarty/plugins/modifiercompiler.lower.php
--- a/epgrec/Smarty/plugins/modifiercompiler.lower.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.lower.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,29 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty lower modifier plugin
+ * Type:     modifier
+ * Name:     lower
+ * Purpose:  convert string to lowercase
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.lower.php lower (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_lower($params)
+{
+    if (Smarty::$_MBSTRING) {
+        return 'mb_strtolower(' . $params[ 0 ] . ', \'' . addslashes(Smarty::$_CHARSET) . '\')';
+    }
+    // no MBString fallback
+    return 'strtolower(' . $params[ 0 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.noprint.php b/epgrec/Smarty/plugins/modifiercompiler.noprint.php
--- a/epgrec/Smarty/plugins/modifiercompiler.noprint.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.noprint.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,20 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty noprint modifier plugin
+ * Type:     modifier
+ * Name:     noprint
+ * Purpose:  return an empty string
+ *
+ * @author Uwe Tews
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_noprint()
+{
+    return "''";
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.string_format.php b/epgrec/Smarty/plugins/modifiercompiler.string_format.php
--- a/epgrec/Smarty/plugins/modifiercompiler.string_format.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.string_format.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,24 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty string_format modifier plugin
+ * Type:     modifier
+ * Name:     string_format
+ * Purpose:  format strings via sprintf
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.string.format.php string_format (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_string_format($params)
+{
+    return 'sprintf(' . $params[ 1 ] . ',' . $params[ 0 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.strip.php b/epgrec/Smarty/plugins/modifiercompiler.strip.php
--- a/epgrec/Smarty/plugins/modifiercompiler.strip.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.strip.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,30 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty strip modifier plugin
+ * Type:     modifier
+ * Name:     strip
+ * Purpose:  Replace all repeated spaces, newlines, tabs
+ *              with a single space or supplied replacement string.
+ * Example:  {$var|strip} {$var|strip:"&nbsp;"}
+ * Date:     September 25th, 2002
+ *
+ * @link   http://www.smarty.net/manual/en/language.modifier.strip.php strip (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_strip($params)
+{
+    if (!isset($params[ 1 ])) {
+        $params[ 1 ] = "' '";
+    }
+    return "preg_replace('!\s+!" . Smarty::$_UTF8_MODIFIER . "', {$params[1]},{$params[0]})";
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.strip_tags.php b/epgrec/Smarty/plugins/modifiercompiler.strip_tags.php
--- a/epgrec/Smarty/plugins/modifiercompiler.strip_tags.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.strip_tags.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,28 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty strip_tags modifier plugin
+ * Type:     modifier
+ * Name:     strip_tags
+ * Purpose:  strip html tags from text
+ *
+ * @link   http://www.smarty.net/docs/en/language.modifier.strip.tags.tpl strip_tags (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_strip_tags($params)
+{
+    if (!isset($params[ 1 ]) || $params[ 1 ] === true || trim($params[ 1 ], '"') === 'true') {
+        return "preg_replace('!<[^>]*?>!', ' ', {$params[0]})";
+    } else {
+        return 'strip_tags(' . $params[ 0 ] . ')';
+    }
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.to_charset.php b/epgrec/Smarty/plugins/modifiercompiler.to_charset.php
--- a/epgrec/Smarty/plugins/modifiercompiler.to_charset.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.to_charset.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,30 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty to_charset modifier plugin
+ * Type:     modifier
+ * Name:     to_charset
+ * Purpose:  convert character encoding from internal encoding to $charset
+ *
+ * @author Rodney Rehm
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_to_charset($params)
+{
+    if (!Smarty::$_MBSTRING) {
+        // FIXME: (rodneyrehm) shouldn't this throw an error?
+        return $params[ 0 ];
+    }
+    if (!isset($params[ 1 ])) {
+        $params[ 1 ] = '"ISO-8859-1"';
+    }
+    return 'mb_convert_encoding(' . $params[ 0 ] . ', ' . $params[ 1 ] . ', "' . addslashes(Smarty::$_CHARSET) . '")';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.unescape.php b/epgrec/Smarty/plugins/modifiercompiler.unescape.php
--- a/epgrec/Smarty/plugins/modifiercompiler.unescape.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.unescape.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,52 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty unescape modifier plugin
+ * Type:     modifier
+ * Name:     unescape
+ * Purpose:  unescape html entities
+ *
+ * @author Rodney Rehm
+ *
+ * @param array $params parameters
+ * @param Smarty_Internal_TemplateCompilerBase $compiler
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_unescape($params, Smarty_Internal_TemplateCompilerBase $compiler)
+{
+    $compiler->template->_checkPlugins(
+        array(
+            array(
+                'function' => 'smarty_literal_compiler_param',
+                'file'     => SMARTY_PLUGINS_DIR . 'shared.literal_compiler_param.php'
+            )
+        )
+    );
+
+    $esc_type = smarty_literal_compiler_param($params, 1, 'html');
+
+    if (!isset($params[ 2 ])) {
+        $params[ 2 ] = '\'' . addslashes(Smarty::$_CHARSET) . '\'';
+    }
+
+    switch ($esc_type) {
+        case 'entity':
+        case 'htmlall':
+            if (Smarty::$_MBSTRING) {
+                return 'mb_convert_encoding(' . $params[ 0 ] . ', ' . $params[ 2 ] . ', \'HTML-ENTITIES\')';
+            }
+            return 'html_entity_decode(' . $params[ 0 ] . ', ENT_NOQUOTES, ' . $params[ 2 ] . ')';
+        case 'html':
+            return 'htmlspecialchars_decode(' . $params[ 0 ] . ', ENT_QUOTES)';
+        case 'url':
+            return 'rawurldecode(' . $params[ 0 ] . ')';
+        default:
+            return $params[ 0 ];
+    }
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.upper.php b/epgrec/Smarty/plugins/modifiercompiler.upper.php
--- a/epgrec/Smarty/plugins/modifiercompiler.upper.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.upper.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,28 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty upper modifier plugin
+ * Type:     modifier
+ * Name:     lower
+ * Purpose:  convert string to uppercase
+ *
+ * @link   http://smarty.php.net/manual/en/language.modifier.upper.php lower (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array $params parameters
+ *
+ * @return string with compiled code
+ */
+function smarty_modifiercompiler_upper($params)
+{
+    if (Smarty::$_MBSTRING) {
+        return 'mb_strtoupper(' . $params[ 0 ] . ', \'' . addslashes(Smarty::$_CHARSET) . '\')';
+    }
+    // no MBString fallback
+    return 'strtoupper(' . $params[ 0 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/modifiercompiler.wordwrap.php b/epgrec/Smarty/plugins/modifiercompiler.wordwrap.php
--- a/epgrec/Smarty/plugins/modifiercompiler.wordwrap.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/modifiercompiler.wordwrap.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,39 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsModifierCompiler
+ */
+/**
+ * Smarty wordwrap modifier plugin
+ * Type:     modifier
+ * Name:     wordwrap
+ * Purpose:  wrap a string of text at a given length
+ *
+ * @link   http://smarty.php.net/manual/en/language.modifier.wordwrap.php wordwrap (Smarty online manual)
+ * @author Uwe Tews
+ *
+ * @param array                                 $params parameters
+ * @param \Smarty_Internal_TemplateCompilerBase $compiler
+ *
+ * @return string with compiled code
+ * @throws \SmartyException
+ */
+function smarty_modifiercompiler_wordwrap($params, Smarty_Internal_TemplateCompilerBase $compiler)
+{
+    if (!isset($params[ 1 ])) {
+        $params[ 1 ] = 80;
+    }
+    if (!isset($params[ 2 ])) {
+        $params[ 2 ] = '"\n"';
+    }
+    if (!isset($params[ 3 ])) {
+        $params[ 3 ] = 'false';
+    }
+    $function = 'wordwrap';
+    if (Smarty::$_MBSTRING) {
+        $function = $compiler->getPlugin('mb_wordwrap', 'modifier');
+    }
+    return $function . '(' . $params[ 0 ] . ',' . $params[ 1 ] . ',' . $params[ 2 ] . ',' . $params[ 3 ] . ')';
+}
diff -urN a/epgrec/Smarty/plugins/outputfilter.trimwhitespace.php b/epgrec/Smarty/plugins/outputfilter.trimwhitespace.php
--- a/epgrec/Smarty/plugins/outputfilter.trimwhitespace.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/outputfilter.trimwhitespace.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,75 +1,89 @@
 <?php
 /**
  * Smarty plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsFilter
  */
-
 /**
  * Smarty trimwhitespace outputfilter plugin
+ * Trim unnecessary whitespace from HTML markup.
+ *
+ * @author Rodney Rehm
  *
- * File:     outputfilter.trimwhitespace.php<br>
- * Type:     outputfilter<br>
- * Name:     trimwhitespace<br>
- * Date:     Jan 25, 2003<br>
- * Purpose:  trim leading white space and blank lines from
- *           template source after it gets interpreted, cleaning
- *           up code and saving bandwidth. Does not affect
- *           <<PRE>></PRE> and <SCRIPT></SCRIPT> blocks.<br>
- * Install:  Drop into the plugin directory, call
- *           <code>$smarty->load_filter('output','trimwhitespace');</code>
- *           from application.
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @author Contributions from Lars Noschinski <lars@usenet.noschinski.de>
- * @version  1.3
- * @param string
- * @param Smarty
+ * @param string $source input string
+ *
+ * @return string filtered output
+ * @todo   substr_replace() is not overloaded by mbstring.func_overload - so this function might fail!
  */
-function smarty_outputfilter_trimwhitespace($source, &$smarty)
+function smarty_outputfilter_trimwhitespace($source)
 {
-    // Pull out the script blocks
-    preg_match_all("!<script[^>]*?>.*?</script>!is", $source, $match);
-    $_script_blocks = $match[0];
-    $source = preg_replace("!<script[^>]*?>.*?</script>!is",
-                           '@@@SMARTY:TRIM:SCRIPT@@@', $source);
-
-    // Pull out the pre blocks
-    preg_match_all("!<pre[^>]*?>.*?</pre>!is", $source, $match);
-    $_pre_blocks = $match[0];
-    $source = preg_replace("!<pre[^>]*?>.*?</pre>!is",
-                           '@@@SMARTY:TRIM:PRE@@@', $source);
-    
-    // Pull out the textarea blocks
-    preg_match_all("!<textarea[^>]*?>.*?</textarea>!is", $source, $match);
-    $_textarea_blocks = $match[0];
-    $source = preg_replace("!<textarea[^>]*?>.*?</textarea>!is",
-                           '@@@SMARTY:TRIM:TEXTAREA@@@', $source);
-
-    // remove all leading spaces, tabs and carriage returns NOT
-    // preceeded by a php close tag.
-    $source = trim(preg_replace('/((?<!\?>)\n)[\s]+/m', '\1', $source));
-
-    // replace textarea blocks
-    smarty_outputfilter_trimwhitespace_replace("@@@SMARTY:TRIM:TEXTAREA@@@",$_textarea_blocks, $source);
-
-    // replace pre blocks
-    smarty_outputfilter_trimwhitespace_replace("@@@SMARTY:TRIM:PRE@@@",$_pre_blocks, $source);
-
-    // replace script blocks
-    smarty_outputfilter_trimwhitespace_replace("@@@SMARTY:TRIM:SCRIPT@@@",$_script_blocks, $source);
-
+    $store = array();
+    $_store = 0;
+    $_offset = 0;
+    // Unify Line-Breaks to \n
+    $source = preg_replace('/\015\012|\015|\012/', "\n", $source);
+    // capture Internet Explorer and KnockoutJS Conditional Comments
+    if (preg_match_all(
+        '#<!--((\[[^\]]+\]>.*?<!\[[^\]]+\])|(\s*/?ko\s+.+))-->#is',
+        $source,
+        $matches,
+        PREG_OFFSET_CAPTURE | PREG_SET_ORDER
+    )
+    ) {
+        foreach ($matches as $match) {
+            $store[] = $match[ 0 ][ 0 ];
+            $_length = strlen($match[ 0 ][ 0 ]);
+            $replace = '@!@SMARTY:' . $_store . ':SMARTY@!@';
+            $source = substr_replace($source, $replace, $match[ 0 ][ 1 ] - $_offset, $_length);
+            $_offset += $_length - strlen($replace);
+            $_store++;
+        }
+    }
+    // Strip all HTML-Comments
+    // yes, even the ones in <script> - see http://stackoverflow.com/a/808850/515124
+    $source = preg_replace('#<!--.*?-->#ms', '', $source);
+    // capture html elements not to be messed with
+    $_offset = 0;
+    if (preg_match_all(
+        '#(<script[^>]*>.*?</script[^>]*>)|(<textarea[^>]*>.*?</textarea[^>]*>)|(<pre[^>]*>.*?</pre[^>]*>)#is',
+        $source,
+        $matches,
+        PREG_OFFSET_CAPTURE | PREG_SET_ORDER
+    )
+    ) {
+        foreach ($matches as $match) {
+            $store[] = $match[ 0 ][ 0 ];
+            $_length = strlen($match[ 0 ][ 0 ]);
+            $replace = '@!@SMARTY:' . $_store . ':SMARTY@!@';
+            $source = substr_replace($source, $replace, $match[ 0 ][ 1 ] - $_offset, $_length);
+            $_offset += $_length - strlen($replace);
+            $_store++;
+        }
+    }
+    $expressions = array(// replace multiple spaces between tags by a single space
+                         // can't remove them entirely, becaue that might break poorly implemented CSS display:inline-block elements
+                         '#(:SMARTY@!@|>)\s+(?=@!@SMARTY:|<)#s'                                    => '\1 \2',
+                         // remove spaces between attributes (but not in attribute values!)
+                         '#(([a-z0-9]\s*=\s*("[^"]*?")|(\'[^\']*?\'))|<[a-z0-9_]+)\s+([a-z/>])#is' => '\1 \5',
+                         // note: for some very weird reason trim() seems to remove spaces inside attributes.
+                         // maybe a \0 byte or something is interfering?
+                         '#^\s+<#Ss'                                                               => '<',
+                         '#>\s+$#Ss'                                                               => '>',
+    );
+    $source = preg_replace(array_keys($expressions), array_values($expressions), $source);
+    // note: for some very weird reason trim() seems to remove spaces inside attributes.
+    // maybe a \0 byte or something is interfering?
+    // $source = trim( $source );
+    $_offset = 0;
+    if (preg_match_all('#@!@SMARTY:([0-9]+):SMARTY@!@#is', $source, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER)) {
+        foreach ($matches as $match) {
+            $_length = strlen($match[ 0 ][ 0 ]);
+            $replace = $store[ $match[ 1 ][ 0 ] ];
+            $source = substr_replace($source, $replace, $match[ 0 ][ 1 ] + $_offset, $_length);
+            $_offset += strlen($replace) - $_length;
+            $_store++;
+        }
+    }
     return $source;
 }
-
-function smarty_outputfilter_trimwhitespace_replace($search_str, $replace, &$subject) {
-    $_len = strlen($search_str);
-    $_pos = 0;
-    for ($_i=0, $_count=count($replace); $_i<$_count; $_i++)
-        if (($_pos=strpos($subject, $search_str, $_pos))!==false)
-            $subject = substr_replace($subject, $replace[$_i], $_pos, $_len);
-        else
-            break;
-
-}
-
-?>
diff -urN a/epgrec/Smarty/plugins/shared.escape_special_chars.php b/epgrec/Smarty/plugins/shared.escape_special_chars.php
--- a/epgrec/Smarty/plugins/shared.escape_special_chars.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/shared.escape_special_chars.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,31 +1,32 @@
 <?php
 /**
  * Smarty shared plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsShared
  */
-
-
 /**
  * escape_special_chars common function
- *
- * Function: smarty_function_escape_special_chars<br>
+ * Function: smarty_function_escape_special_chars
  * Purpose:  used by other smarty functions to escape
  *           special chars except for already escaped ones
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
+ *
+ * @author Monte Ohrt <monte at ohrt dot com>
+ *
+ * @param string $string text that should by escaped
+ *
  * @return string
  */
 function smarty_function_escape_special_chars($string)
 {
-    if(!is_array($string)) {
-        $string = preg_replace('!&(#?\w+);!', '%%%SMARTY_START%%%\\1%%%SMARTY_END%%%', $string);
-        $string = htmlspecialchars($string);
-        $string = str_replace(array('%%%SMARTY_START%%%','%%%SMARTY_END%%%'), array('&',';'), $string);
+    if (!is_array($string)) {
+        if (version_compare(PHP_VERSION, '5.2.3', '>=')) {
+            $string = htmlspecialchars($string, ENT_COMPAT, Smarty::$_CHARSET, false);
+        } else {
+            $string = preg_replace('!&(#?\w+);!', '%%%SMARTY_START%%%\\1%%%SMARTY_END%%%', $string);
+            $string = htmlspecialchars($string);
+            $string = str_replace(array('%%%SMARTY_START%%%', '%%%SMARTY_END%%%'), array('&', ';'), $string);
+        }
     }
     return $string;
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/shared.literal_compiler_param.php b/epgrec/Smarty/plugins/shared.literal_compiler_param.php
--- a/epgrec/Smarty/plugins/shared.literal_compiler_param.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/shared.literal_compiler_param.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,35 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsShared
+ */
+/**
+ * evaluate compiler parameter
+ *
+ * @param array   $params  parameter array as given to the compiler function
+ * @param integer $index   array index of the parameter to convert
+ * @param mixed   $default value to be returned if the parameter is not present
+ *
+ * @return mixed evaluated value of parameter or $default
+ * @throws SmartyException if parameter is not a literal (but an expression, variable, )
+ * @author Rodney Rehm
+ */
+function smarty_literal_compiler_param($params, $index, $default = null)
+{
+    // not set, go default
+    if (!isset($params[ $index ])) {
+        return $default;
+    }
+    // test if param is a literal
+    if (!preg_match('/^([\'"]?)[a-zA-Z0-9-]+(\\1)$/', $params[ $index ])) {
+        throw new SmartyException(
+            '$param[' . $index .
+            '] is not a literal and is thus not evaluatable at compile time'
+        );
+    }
+    $t = null;
+    eval("\$t = " . $params[ $index ] . ";");
+    return $t;
+}
diff -urN a/epgrec/Smarty/plugins/shared.make_timestamp.php b/epgrec/Smarty/plugins/shared.make_timestamp.php
--- a/epgrec/Smarty/plugins/shared.make_timestamp.php	2022-12-13 18:30:29.456561000 +0900
+++ b/epgrec/Smarty/plugins/shared.make_timestamp.php	2022-09-14 20:29:00.000000000 +0900
@@ -1,46 +1,49 @@
 <?php
 /**
  * Smarty shared plugin
- * @package Smarty
- * @subpackage plugins
+ *
+ * @package    Smarty
+ * @subpackage PluginsShared
  */
-
-
 /**
- * Function: smarty_make_timestamp<br>
- * Purpose:  used by other smarty functions to make a timestamp
- *           from a string.
- * @author   Monte Ohrt <monte at ohrt dot com>
- * @param string
- * @return string
+ * Function: smarty_make_timestamp
+ * Purpose:  used by other smarty functions to make a timestamp from a string.
+ *
+ * @author Monte Ohrt <monte at ohrt dot com>
+ *
+ * @param DateTime|int|string $string date object, timestamp or string that can be converted using strtotime()
+ *
+ * @return int
  */
 function smarty_make_timestamp($string)
 {
-    if(empty($string)) {
+    if (empty($string)) {
         // use "now":
-        $time = time();
-
-    } elseif (preg_match('/^\d{14}$/', $string)) {
-        // it is mysql timestamp format of YYYYMMDDHHMMSS?            
-        $time = mktime(substr($string, 8, 2),substr($string, 10, 2),substr($string, 12, 2),
-                       substr($string, 4, 2),substr($string, 6, 2),substr($string, 0, 4));
-        
+        return time();
+    } elseif ($string instanceof DateTime
+              || (interface_exists('DateTimeInterface', false) && $string instanceof DateTimeInterface)
+    ) {
+        return (int)$string->format('U'); // PHP 5.2 BC
+    } elseif (strlen($string) === 14 && ctype_digit($string)) {
+        // it is mysql timestamp format of YYYYMMDDHHMMSS?
+        return mktime(
+            substr($string, 8, 2),
+            substr($string, 10, 2),
+            substr($string, 12, 2),
+            substr($string, 4, 2),
+            substr($string, 6, 2),
+            substr($string, 0, 4)
+        );
     } elseif (is_numeric($string)) {
         // it is a numeric string, we handle it as timestamp
-        $time = (int)$string;
-        
+        return (int)$string;
     } else {
         // strtotime should handle it
         $time = strtotime($string);
-        if ($time == -1 || $time === false) {
+        if ($time === -1 || $time === false) {
             // strtotime() was not able to parse $string, use "now":
-            $time = time();
+            return time();
         }
+        return $time;
     }
-    return $time;
-
 }
-
-/* vim: set expandtab: */
-
-?>
diff -urN a/epgrec/Smarty/plugins/shared.mb_str_replace.php b/epgrec/Smarty/plugins/shared.mb_str_replace.php
--- a/epgrec/Smarty/plugins/shared.mb_str_replace.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/shared.mb_str_replace.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,87 @@
+<?php
+/**
+ * Smarty shared plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsShared
+ */
+if (!function_exists('smarty_mb_str_replace')) {
+    /**
+     * Multibyte string replace
+     *
+     * @param string|string[] $search  the string to be searched
+     * @param string|string[] $replace the replacement string
+     * @param string          $subject the source string
+     * @param int             &$count  number of matches found
+     *
+     * @return string replaced string
+     * @author Rodney Rehm
+     */
+    function smarty_mb_str_replace($search, $replace, $subject, &$count = 0)
+    {
+        if (!is_array($search) && is_array($replace)) {
+            return false;
+        }
+        if (is_array($subject)) {
+            // call mb_replace for each single string in $subject
+            foreach ($subject as &$string) {
+                $string = smarty_mb_str_replace($search, $replace, $string, $c);
+                $count += $c;
+            }
+        } elseif (is_array($search)) {
+            if (!is_array($replace)) {
+                foreach ($search as &$string) {
+                    $subject = smarty_mb_str_replace($string, $replace, $subject, $c);
+                    $count += $c;
+                }
+            } else {
+                $n = max(count($search), count($replace));
+                while ($n--) {
+                    $subject = smarty_mb_str_replace(current($search), current($replace), $subject, $c);
+                    $count += $c;
+                    next($search);
+                    next($replace);
+                }
+            }
+        } else {
+            $mb_reg_charset = mb_regex_encoding();
+            // Check if mbstring regex is using UTF-8
+            $reg_is_unicode = !strcasecmp($mb_reg_charset, "UTF-8");
+            if(!$reg_is_unicode) {
+                // ...and set to UTF-8 if not
+                mb_regex_encoding("UTF-8");
+            }
+
+            // See if charset used by Smarty is matching one used by regex...
+            $current_charset = mb_regex_encoding();
+            $convert_result = (bool)strcasecmp(Smarty::$_CHARSET, $current_charset);
+            if($convert_result) {
+                // ...convert to it if not.
+                $subject = mb_convert_encoding($subject, $current_charset, Smarty::$_CHARSET);
+                $search = mb_convert_encoding($search, $current_charset, Smarty::$_CHARSET);
+                $replace = mb_convert_encoding($replace, $current_charset, Smarty::$_CHARSET);
+            }
+
+            $parts = mb_split(preg_quote($search), $subject);
+            // If original regex encoding was not unicode...
+            if(!$reg_is_unicode) {
+                // ...restore original regex encoding to avoid breaking the system.
+                mb_regex_encoding($mb_reg_charset);
+            }
+            if($parts === false) {
+                // This exception is thrown if call to mb_split failed.
+                // Usually it happens, when $search or $replace are not valid for given mb_regex_encoding().
+                // There may be other cases for it to fail, please file an issue if you find a reproducible one.
+                throw new SmartyException("Source string is not a valid $current_charset sequence (probably)");
+            }
+
+            $count = count($parts) - 1;
+            $subject = implode($replace, $parts);
+            // Convert results back to charset used by Smarty, if needed.
+            if($convert_result) {
+                $subject = mb_convert_encoding($subject, Smarty::$_CHARSET, $current_charset);
+            }
+        }
+        return $subject;
+    }
+}
diff -urN a/epgrec/Smarty/plugins/shared.mb_unicode.php b/epgrec/Smarty/plugins/shared.mb_unicode.php
--- a/epgrec/Smarty/plugins/shared.mb_unicode.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/shared.mb_unicode.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,51 @@
+<?php
+/**
+ * Smarty shared plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsShared
+ */
+/**
+ * convert characters to their decimal unicode equivalents
+ *
+ * @link   http://www.ibm.com/developerworks/library/os-php-unicode/index.html#listing3 for inspiration
+ *
+ * @param string $string   characters to calculate unicode of
+ * @param string $encoding encoding of $string, if null mb_internal_encoding() is used
+ *
+ * @return array sequence of unicodes
+ * @author Rodney Rehm
+ */
+function smarty_mb_to_unicode($string, $encoding = null)
+{
+    if ($encoding) {
+        $expanded = mb_convert_encoding($string, 'UTF-32BE', $encoding);
+    } else {
+        $expanded = mb_convert_encoding($string, 'UTF-32BE');
+    }
+    return unpack('N*', $expanded);
+}
+
+/**
+ * convert unicodes to the character of given encoding
+ *
+ * @link   http://www.ibm.com/developerworks/library/os-php-unicode/index.html#listing3 for inspiration
+ *
+ * @param integer|array $unicode  single unicode or list of unicodes to convert
+ * @param string        $encoding encoding of returned string, if null mb_internal_encoding() is used
+ *
+ * @return string unicode as character sequence in given $encoding
+ * @author Rodney Rehm
+ */
+function smarty_mb_from_unicode($unicode, $encoding = null)
+{
+    $t = '';
+    if (!$encoding) {
+        $encoding = mb_internal_encoding();
+    }
+    foreach ((array)$unicode as $utf32be) {
+        $character = pack('N*', $utf32be);
+        $t .= mb_convert_encoding($character, $encoding, 'UTF-32BE');
+    }
+    return $t;
+}
diff -urN a/epgrec/Smarty/plugins/variablefilter.htmlspecialchars.php b/epgrec/Smarty/plugins/variablefilter.htmlspecialchars.php
--- a/epgrec/Smarty/plugins/variablefilter.htmlspecialchars.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/plugins/variablefilter.htmlspecialchars.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,19 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsFilter
+ */
+/**
+ * Smarty htmlspecialchars variablefilter plugin
+ *
+ * @param string                    $source input string
+ * @param \Smarty_Internal_Template $template
+ *
+ * @return string filtered output
+ */
+function smarty_variablefilter_htmlspecialchars($source, Smarty_Internal_Template $template)
+{
+    return htmlspecialchars($source, ENT_QUOTES, Smarty::$_CHARSET);
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_cacheresource.php b/epgrec/Smarty/sysplugins/smarty_cacheresource.php
--- a/epgrec/Smarty/sysplugins/smarty_cacheresource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_cacheresource.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,219 @@
+<?php
+/**
+ * Smarty Internal Plugin
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ */
+
+/**
+ * Cache Handler API
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ * @author     Rodney Rehm
+ */
+abstract class Smarty_CacheResource
+{
+    /**
+     * resource types provided by the core
+     *
+     * @var array
+     */
+    protected static $sysplugins = array('file' => 'smarty_internal_cacheresource_file.php',);
+
+    /**
+     * populate Cached Object with meta data from Resource
+     *
+     * @param \Smarty_Template_Cached  $cached    cached object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    abstract public function populate(\Smarty_Template_Cached $cached, Smarty_Internal_Template $_template);
+
+    /**
+     * populate Cached Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Cached $cached
+     *
+     * @return void
+     */
+    abstract public function populateTimestamp(Smarty_Template_Cached $cached);
+
+    /**
+     * Read the cached template and process header
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param Smarty_Template_Cached   $cached    cached object
+     * @param boolean                  $update    flag if called because cache update
+     *
+     * @return boolean true or false if the cached content does not exist
+     */
+    abstract public function process(
+        Smarty_Internal_Template $_template,
+        Smarty_Template_Cached $cached = null,
+        $update = false
+    );
+
+    /**
+     * Write the rendered template output to cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param string                   $content   content to cache
+     *
+     * @return boolean success
+     */
+    abstract public function writeCachedContent(Smarty_Internal_Template $_template, $content);
+
+    /**
+     * Read cached template from cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return string  content
+     */
+    abstract public function readCachedContent(Smarty_Internal_Template $_template);
+
+    /**
+     * Return cached content
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return null|string
+     */
+    public function getCachedContent(Smarty_Internal_Template $_template)
+    {
+        if ($_template->cached->handler->process($_template)) {
+            ob_start();
+            $unifunc = $_template->cached->unifunc;
+            $unifunc($_template);
+            return ob_get_clean();
+        }
+        return null;
+    }
+
+    /**
+     * Empty cache
+     *
+     * @param Smarty  $smarty   Smarty object
+     * @param integer $exp_time expiration time (number of seconds, not timestamp)
+     *
+     * @return integer number of cache files deleted
+     */
+    abstract public function clearAll(Smarty $smarty, $exp_time = null);
+
+    /**
+     * Empty cache for a specific template
+     *
+     * @param Smarty  $smarty        Smarty object
+     * @param string  $resource_name template name
+     * @param string  $cache_id      cache id
+     * @param string  $compile_id    compile id
+     * @param integer $exp_time      expiration time (number of seconds, not timestamp)
+     *
+     * @return integer number of cache files deleted
+     */
+    abstract public function clear(Smarty $smarty, $resource_name, $cache_id, $compile_id, $exp_time);
+
+    /**
+     * @param Smarty                 $smarty
+     * @param Smarty_Template_Cached $cached
+     *
+     * @return bool|null
+     */
+    public function locked(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        // theoretically locking_timeout should be checked against time_limit (max_execution_time)
+        $start = microtime(true);
+        $hadLock = null;
+        while ($this->hasLock($smarty, $cached)) {
+            $hadLock = true;
+            if (microtime(true) - $start > $smarty->locking_timeout) {
+                // abort waiting for lock release
+                return false;
+            }
+            sleep(1);
+        }
+        return $hadLock;
+    }
+
+    /**
+     * Check is cache is locked for this template
+     *
+     * @param Smarty                 $smarty
+     * @param Smarty_Template_Cached $cached
+     *
+     * @return bool
+     */
+    public function hasLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        // check if lock exists
+        return false;
+    }
+
+    /**
+     * Lock cache for this template
+     *
+     * @param Smarty                 $smarty
+     * @param Smarty_Template_Cached $cached
+     *
+     * @return bool
+     */
+    public function acquireLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        // create lock
+        return true;
+    }
+
+    /**
+     * Unlock cache for this template
+     *
+     * @param Smarty                 $smarty
+     * @param Smarty_Template_Cached $cached
+     *
+     * @return bool
+     */
+    public function releaseLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        // release lock
+        return true;
+    }
+
+    /**
+     * Load Cache Resource Handler
+     *
+     * @param Smarty $smarty Smarty object
+     * @param string $type   name of the cache resource
+     *
+     * @throws SmartyException
+     * @return Smarty_CacheResource Cache Resource Handler
+     */
+    public static function load(Smarty $smarty, $type = null)
+    {
+        if (!isset($type)) {
+            $type = $smarty->caching_type;
+        }
+        // try smarty's cache
+        if (isset($smarty->_cache[ 'cacheresource_handlers' ][ $type ])) {
+            return $smarty->_cache[ 'cacheresource_handlers' ][ $type ];
+        }
+        // try registered resource
+        if (isset($smarty->registered_cache_resources[ $type ])) {
+            // do not cache these instances as they may vary from instance to instance
+            return $smarty->_cache[ 'cacheresource_handlers' ][ $type ] = $smarty->registered_cache_resources[ $type ];
+        }
+        // try sysplugins dir
+        if (isset(self::$sysplugins[ $type ])) {
+            $cache_resource_class = 'Smarty_Internal_CacheResource_' . ucfirst($type);
+            return $smarty->_cache[ 'cacheresource_handlers' ][ $type ] = new $cache_resource_class();
+        }
+        // try plugins dir
+        $cache_resource_class = 'Smarty_CacheResource_' . ucfirst($type);
+        if ($smarty->loadPlugin($cache_resource_class)) {
+            return $smarty->_cache[ 'cacheresource_handlers' ][ $type ] = new $cache_resource_class();
+        }
+        // give up
+        throw new SmartyException("Unable to load cache resource '{$type}'");
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_cacheresource_custom.php b/epgrec/Smarty/sysplugins/smarty_cacheresource_custom.php
--- a/epgrec/Smarty/sysplugins/smarty_cacheresource_custom.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_cacheresource_custom.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,297 @@
+<?php
+/**
+ * Smarty Internal Plugin
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ */
+
+/**
+ * Cache Handler API
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ * @author     Rodney Rehm
+ */
+abstract class Smarty_CacheResource_Custom extends Smarty_CacheResource
+{
+    /**
+     * fetch cached content and its modification time from data source
+     *
+     * @param string  $id         unique cache content identifier
+     * @param string  $name       template name
+     * @param string  $cache_id   cache id
+     * @param string  $compile_id compile id
+     * @param string  $content    cached content
+     * @param integer $mtime      cache modification timestamp (epoch)
+     *
+     * @return void
+     */
+    abstract protected function fetch($id, $name, $cache_id, $compile_id, &$content, &$mtime);
+
+    /**
+     * Fetch cached content's modification timestamp from data source
+     * {@internal implementing this method is optional.
+     *  Only implement it if modification times can be accessed faster than loading the complete cached content.}}
+     *
+     * @param string $id         unique cache content identifier
+     * @param string $name       template name
+     * @param string $cache_id   cache id
+     * @param string $compile_id compile id
+     *
+     * @return integer|boolean timestamp (epoch) the template was modified, or false if not found
+     */
+    protected function fetchTimestamp($id, $name, $cache_id, $compile_id)
+    {
+        return false;
+    }
+
+    /**
+     * Save content to cache
+     *
+     * @param string       $id         unique cache content identifier
+     * @param string       $name       template name
+     * @param string       $cache_id   cache id
+     * @param string       $compile_id compile id
+     * @param integer|null $exp_time   seconds till expiration or null
+     * @param string       $content    content to cache
+     *
+     * @return boolean      success
+     */
+    abstract protected function save($id, $name, $cache_id, $compile_id, $exp_time, $content);
+
+    /**
+     * Delete content from cache
+     *
+     * @param string|null  $name       template name
+     * @param string|null  $cache_id   cache id
+     * @param string|null  $compile_id compile id
+     * @param integer|null $exp_time   seconds till expiration time in seconds or null
+     *
+     * @return integer      number of deleted caches
+     */
+    abstract protected function delete($name, $cache_id, $compile_id, $exp_time);
+
+    /**
+     * populate Cached Object with meta data from Resource
+     *
+     * @param Smarty_Template_Cached   $cached    cached object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populate(Smarty_Template_Cached $cached, Smarty_Internal_Template $_template)
+    {
+        $_cache_id = isset($cached->cache_id) ? preg_replace('![^\w\|]+!', '_', $cached->cache_id) : null;
+        $_compile_id = isset($cached->compile_id) ? preg_replace('![^\w]+!', '_', $cached->compile_id) : null;
+        $path = $cached->source->uid . $_cache_id . $_compile_id;
+        $cached->filepath = sha1($path);
+        if ($_template->smarty->cache_locking) {
+            $cached->lock_id = sha1('lock.' . $path);
+        }
+        $this->populateTimestamp($cached);
+    }
+
+    /**
+     * populate Cached Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Cached $cached
+     *
+     * @return void
+     */
+    public function populateTimestamp(Smarty_Template_Cached $cached)
+    {
+        $mtime =
+            $this->fetchTimestamp($cached->filepath, $cached->source->name, $cached->cache_id, $cached->compile_id);
+        if ($mtime !== null) {
+            $cached->timestamp = $mtime;
+            $cached->exists = !!$cached->timestamp;
+            return;
+        }
+        $timestamp = null;
+        $this->fetch(
+            $cached->filepath,
+            $cached->source->name,
+            $cached->cache_id,
+            $cached->compile_id,
+            $cached->content,
+            $timestamp
+        );
+        $cached->timestamp = isset($timestamp) ? $timestamp : false;
+        $cached->exists = !!$cached->timestamp;
+    }
+
+    /**
+     * Read the cached template and process the header
+     *
+     * @param \Smarty_Internal_Template $_smarty_tpl do not change variable name, is used by compiled template
+     * @param Smarty_Template_Cached    $cached      cached object
+     * @param boolean                   $update      flag if called because cache update
+     *
+     * @return boolean                 true or false if the cached content does not exist
+     */
+    public function process(
+        Smarty_Internal_Template $_smarty_tpl,
+        Smarty_Template_Cached $cached = null,
+        $update = false
+    ) {
+        if (!$cached) {
+            $cached = $_smarty_tpl->cached;
+        }
+        $content = $cached->content ? $cached->content : null;
+        $timestamp = $cached->timestamp ? $cached->timestamp : null;
+        if ($content === null || !$timestamp) {
+            $this->fetch(
+                $_smarty_tpl->cached->filepath,
+                $_smarty_tpl->source->name,
+                $_smarty_tpl->cache_id,
+                $_smarty_tpl->compile_id,
+                $content,
+                $timestamp
+            );
+        }
+        if (isset($content)) {
+            eval('?>' . $content);
+            $cached->content = null;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Write the rendered template output to cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param string                   $content   content to cache
+     *
+     * @return boolean                  success
+     */
+    public function writeCachedContent(Smarty_Internal_Template $_template, $content)
+    {
+        return $this->save(
+            $_template->cached->filepath,
+            $_template->source->name,
+            $_template->cache_id,
+            $_template->compile_id,
+            $_template->cache_lifetime,
+            $content
+        );
+    }
+
+    /**
+     * Read cached template from cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return string|boolean  content
+     */
+    public function readCachedContent(Smarty_Internal_Template $_template)
+    {
+        $content = $_template->cached->content ? $_template->cached->content : null;
+        $timestamp = null;
+        if ($content === null) {
+            $timestamp = null;
+            $this->fetch(
+                $_template->cached->filepath,
+                $_template->source->name,
+                $_template->cache_id,
+                $_template->compile_id,
+                $content,
+                $timestamp
+            );
+        }
+        if (isset($content)) {
+            return $content;
+        }
+        return false;
+    }
+
+    /**
+     * Empty cache
+     *
+     * @param Smarty  $smarty   Smarty object
+     * @param integer $exp_time expiration time (number of seconds, not timestamp)
+     *
+     * @return integer number of cache files deleted
+     */
+    public function clearAll(Smarty $smarty, $exp_time = null)
+    {
+        return $this->delete(null, null, null, $exp_time);
+    }
+
+    /**
+     * Empty cache for a specific template
+     *
+     * @param Smarty  $smarty        Smarty object
+     * @param string  $resource_name template name
+     * @param string  $cache_id      cache id
+     * @param string  $compile_id    compile id
+     * @param integer $exp_time      expiration time (number of seconds, not timestamp)
+     *
+     * @return int number of cache files deleted
+     * @throws \SmartyException
+     */
+    public function clear(Smarty $smarty, $resource_name, $cache_id, $compile_id, $exp_time)
+    {
+        $cache_name = null;
+        if (isset($resource_name)) {
+            $source = Smarty_Template_Source::load(null, $smarty, $resource_name);
+            if ($source->exists) {
+                $cache_name = $source->name;
+            } else {
+                return 0;
+            }
+        }
+        return $this->delete($cache_name, $cache_id, $compile_id, $exp_time);
+    }
+
+    /**
+     * Check is cache is locked for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return boolean               true or false if cache is locked
+     */
+    public function hasLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $id = $cached->lock_id;
+        $name = $cached->source->name . '.lock';
+        $mtime = $this->fetchTimestamp($id, $name, $cached->cache_id, $cached->compile_id);
+        if ($mtime === null) {
+            $this->fetch($id, $name, $cached->cache_id, $cached->compile_id, $content, $mtime);
+        }
+        return $mtime && ($t = time()) - $mtime < $smarty->locking_timeout;
+    }
+
+    /**
+     * Lock cache for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return bool|void
+     */
+    public function acquireLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $cached->is_locked = true;
+        $id = $cached->lock_id;
+        $name = $cached->source->name . '.lock';
+        $this->save($id, $name, $cached->cache_id, $cached->compile_id, $smarty->locking_timeout, '');
+    }
+
+    /**
+     * Unlock cache for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return bool|void
+     */
+    public function releaseLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $cached->is_locked = false;
+        $name = $cached->source->name . '.lock';
+        $this->delete($name, $cached->cache_id, $cached->compile_id, null);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_cacheresource_keyvaluestore.php b/epgrec/Smarty/sysplugins/smarty_cacheresource_keyvaluestore.php
--- a/epgrec/Smarty/sysplugins/smarty_cacheresource_keyvaluestore.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_cacheresource_keyvaluestore.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,538 @@
+<?php
+/**
+ * Smarty Internal Plugin
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ */
+
+/**
+ * Smarty Cache Handler Base for Key/Value Storage Implementations
+ * This class implements the functionality required to use simple key/value stores
+ * for hierarchical cache groups. key/value stores like memcache or APC do not support
+ * wildcards in keys, therefore a cache group cannot be cleared like "a|*" - which
+ * is no problem to filesystem and RDBMS implementations.
+ * This implementation is based on the concept of invalidation. While one specific cache
+ * can be identified and cleared, any range of caches cannot be identified. For this reason
+ * each level of the cache group hierarchy can have its own value in the store. These values
+ * are nothing but microtimes, telling us when a particular cache group was cleared for the
+ * last time. These keys are evaluated for every cache read to determine if the cache has
+ * been invalidated since it was created and should hence be treated as inexistent.
+ * Although deep hierarchies are possible, they are not recommended. Try to keep your
+ * cache groups as shallow as possible. Anything up 3-5 parents should be ok. So
+ * a|b|c is a good depth where a|b|c|d|e|f|g|h|i|j|k isn't. Try to join correlating
+ * cache groups: if your cache groups look somewhat like a|b|$page|$items|$whatever
+ * consider using a|b|c|$page-$items-$whatever instead.
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ * @author     Rodney Rehm
+ */
+abstract class Smarty_CacheResource_KeyValueStore extends Smarty_CacheResource
+{
+    /**
+     * cache for contents
+     *
+     * @var array
+     */
+    protected $contents = array();
+
+    /**
+     * cache for timestamps
+     *
+     * @var array
+     */
+    protected $timestamps = array();
+
+    /**
+     * populate Cached Object with meta data from Resource
+     *
+     * @param Smarty_Template_Cached   $cached    cached object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populate(Smarty_Template_Cached $cached, Smarty_Internal_Template $_template)
+    {
+        $cached->filepath = $_template->source->uid . '#' . $this->sanitize($cached->source->resource) . '#' .
+                            $this->sanitize($cached->cache_id) . '#' . $this->sanitize($cached->compile_id);
+        $this->populateTimestamp($cached);
+    }
+
+    /**
+     * populate Cached Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return void
+     */
+    public function populateTimestamp(Smarty_Template_Cached $cached)
+    {
+        if (!$this->fetch(
+            $cached->filepath,
+            $cached->source->name,
+            $cached->cache_id,
+            $cached->compile_id,
+            $content,
+            $timestamp,
+            $cached->source->uid
+        )
+        ) {
+            return;
+        }
+        $cached->content = $content;
+        $cached->timestamp = (int)$timestamp;
+        $cached->exists = !!$cached->timestamp;
+    }
+
+    /**
+     * Read the cached template and process the header
+     *
+     * @param \Smarty_Internal_Template $_smarty_tpl do not change variable name, is used by compiled template
+     * @param Smarty_Template_Cached    $cached      cached object
+     * @param boolean                   $update      flag if called because cache update
+     *
+     * @return boolean                 true or false if the cached content does not exist
+     */
+    public function process(
+        Smarty_Internal_Template $_smarty_tpl,
+        Smarty_Template_Cached $cached = null,
+        $update = false
+    ) {
+        if (!$cached) {
+            $cached = $_smarty_tpl->cached;
+        }
+        $content = $cached->content ? $cached->content : null;
+        $timestamp = $cached->timestamp ? $cached->timestamp : null;
+        if ($content === null || !$timestamp) {
+            if (!$this->fetch(
+                $_smarty_tpl->cached->filepath,
+                $_smarty_tpl->source->name,
+                $_smarty_tpl->cache_id,
+                $_smarty_tpl->compile_id,
+                $content,
+                $timestamp,
+                $_smarty_tpl->source->uid
+            )
+            ) {
+                return false;
+            }
+        }
+        if (isset($content)) {
+            eval('?>' . $content);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Write the rendered template output to cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param string                   $content   content to cache
+     *
+     * @return boolean                  success
+     */
+    public function writeCachedContent(Smarty_Internal_Template $_template, $content)
+    {
+        $this->addMetaTimestamp($content);
+        return $this->write(array($_template->cached->filepath => $content), $_template->cache_lifetime);
+    }
+
+    /**
+     * Read cached template from cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return string|false  content
+     */
+    public function readCachedContent(Smarty_Internal_Template $_template)
+    {
+        $content = $_template->cached->content ? $_template->cached->content : null;
+        $timestamp = null;
+        if ($content === null) {
+            if (!$this->fetch(
+                $_template->cached->filepath,
+                $_template->source->name,
+                $_template->cache_id,
+                $_template->compile_id,
+                $content,
+                $timestamp,
+                $_template->source->uid
+            )
+            ) {
+                return false;
+            }
+        }
+        if (isset($content)) {
+            return $content;
+        }
+        return false;
+    }
+
+    /**
+     * Empty cache
+     * {@internal the $exp_time argument is ignored altogether }}
+     *
+     * @param Smarty  $smarty   Smarty object
+     * @param integer $exp_time expiration time [being ignored]
+     *
+     * @return integer number of cache files deleted [always -1]
+     * @uses   purge() to clear the whole store
+     * @uses   invalidate() to mark everything outdated if purge() is inapplicable
+     */
+    public function clearAll(Smarty $smarty, $exp_time = null)
+    {
+        if (!$this->purge()) {
+            $this->invalidate(null);
+        }
+        return -1;
+    }
+
+    /**
+     * Empty cache for a specific template
+     * {@internal the $exp_time argument is ignored altogether}}
+     *
+     * @param Smarty  $smarty        Smarty object
+     * @param string  $resource_name template name
+     * @param string  $cache_id      cache id
+     * @param string  $compile_id    compile id
+     * @param integer $exp_time      expiration time [being ignored]
+     *
+     * @return int number of cache files deleted [always -1]
+     * @throws \SmartyException
+     * @uses   buildCachedFilepath() to generate the CacheID
+     * @uses   invalidate() to mark CacheIDs parent chain as outdated
+     * @uses   delete() to remove CacheID from cache
+     */
+    public function clear(Smarty $smarty, $resource_name, $cache_id, $compile_id, $exp_time)
+    {
+        $uid = $this->getTemplateUid($smarty, $resource_name);
+        $cid = $uid . '#' . $this->sanitize($resource_name) . '#' . $this->sanitize($cache_id) . '#' .
+               $this->sanitize($compile_id);
+        $this->delete(array($cid));
+        $this->invalidate($cid, $resource_name, $cache_id, $compile_id, $uid);
+        return -1;
+    }
+
+    /**
+     * Get template's unique ID
+     *
+     * @param Smarty $smarty        Smarty object
+     * @param string $resource_name template name
+     *
+     * @return string filepath of cache file
+     * @throws \SmartyException
+     */
+    protected function getTemplateUid(Smarty $smarty, $resource_name)
+    {
+        if (isset($resource_name)) {
+            $source = Smarty_Template_Source::load(null, $smarty, $resource_name);
+            if ($source->exists) {
+                return $source->uid;
+            }
+        }
+        return '';
+    }
+
+    /**
+     * Sanitize CacheID components
+     *
+     * @param string $string CacheID component to sanitize
+     *
+     * @return string sanitized CacheID component
+     */
+    protected function sanitize($string)
+    {
+        $string = trim($string, '|');
+        if (!$string) {
+            return '';
+        }
+        return preg_replace('#[^\w\|]+#S', '_', $string);
+    }
+
+    /**
+     * Fetch and prepare a cache object.
+     *
+     * @param string  $cid           CacheID to fetch
+     * @param string  $resource_name template name
+     * @param string  $cache_id      cache id
+     * @param string  $compile_id    compile id
+     * @param string  $content       cached content
+     * @param integer &$timestamp    cached timestamp (epoch)
+     * @param string  $resource_uid  resource's uid
+     *
+     * @return boolean success
+     */
+    protected function fetch(
+        $cid,
+        $resource_name = null,
+        $cache_id = null,
+        $compile_id = null,
+        &$content = null,
+        &$timestamp = null,
+        $resource_uid = null
+    ) {
+        $t = $this->read(array($cid));
+        $content = !empty($t[ $cid ]) ? $t[ $cid ] : null;
+        $timestamp = null;
+        if ($content && ($timestamp = $this->getMetaTimestamp($content))) {
+            $invalidated =
+                $this->getLatestInvalidationTimestamp($cid, $resource_name, $cache_id, $compile_id, $resource_uid);
+            if ($invalidated > $timestamp) {
+                $timestamp = null;
+                $content = null;
+            }
+        }
+        return !!$content;
+    }
+
+    /**
+     * Add current microtime to the beginning of $cache_content
+     * {@internal the header uses 8 Bytes, the first 4 Bytes are the seconds, the second 4 Bytes are the microseconds}}
+     *
+     * @param string &$content the content to be cached
+     */
+    protected function addMetaTimestamp(&$content)
+    {
+        $mt = explode(' ', microtime());
+        $ts = pack('NN', $mt[ 1 ], (int)($mt[ 0 ] * 100000000));
+        $content = $ts . $content;
+    }
+
+    /**
+     * Extract the timestamp the $content was cached
+     *
+     * @param string &$content the cached content
+     *
+     * @return float  the microtime the content was cached
+     */
+    protected function getMetaTimestamp(&$content)
+    {
+        extract(unpack('N1s/N1m/a*content', $content));
+        /**
+         * @var  int $s
+         * @var  int $m
+         */
+        return $s + ($m / 100000000);
+    }
+
+    /**
+     * Invalidate CacheID
+     *
+     * @param string $cid           CacheID
+     * @param string $resource_name template name
+     * @param string $cache_id      cache id
+     * @param string $compile_id    compile id
+     * @param string $resource_uid  source's uid
+     *
+     * @return void
+     */
+    protected function invalidate(
+        $cid = null,
+        $resource_name = null,
+        $cache_id = null,
+        $compile_id = null,
+        $resource_uid = null
+    ) {
+        $now = microtime(true);
+        $key = null;
+        // invalidate everything
+        if (!$resource_name && !$cache_id && !$compile_id) {
+            $key = 'IVK#ALL';
+        } // invalidate all caches by template
+        else {
+            if ($resource_name && !$cache_id && !$compile_id) {
+                $key = 'IVK#TEMPLATE#' . $resource_uid . '#' . $this->sanitize($resource_name);
+            } // invalidate all caches by cache group
+            else {
+                if (!$resource_name && $cache_id && !$compile_id) {
+                    $key = 'IVK#CACHE#' . $this->sanitize($cache_id);
+                } // invalidate all caches by compile id
+                else {
+                    if (!$resource_name && !$cache_id && $compile_id) {
+                        $key = 'IVK#COMPILE#' . $this->sanitize($compile_id);
+                    } // invalidate by combination
+                    else {
+                        $key = 'IVK#CID#' . $cid;
+                    }
+                }
+            }
+        }
+        $this->write(array($key => $now));
+    }
+
+    /**
+     * Determine the latest timestamp known to the invalidation chain
+     *
+     * @param string $cid           CacheID to determine latest invalidation timestamp of
+     * @param string $resource_name template name
+     * @param string $cache_id      cache id
+     * @param string $compile_id    compile id
+     * @param string $resource_uid  source's filepath
+     *
+     * @return float  the microtime the CacheID was invalidated
+     */
+    protected function getLatestInvalidationTimestamp(
+        $cid,
+        $resource_name = null,
+        $cache_id = null,
+        $compile_id = null,
+        $resource_uid = null
+    ) {
+        // abort if there is no CacheID
+        if (false && !$cid) {
+            return 0;
+        }
+        // abort if there are no InvalidationKeys to check
+        if (!($_cid = $this->listInvalidationKeys($cid, $resource_name, $cache_id, $compile_id, $resource_uid))) {
+            return 0;
+        }
+        // there are no InValidationKeys
+        if (!($values = $this->read($_cid))) {
+            return 0;
+        }
+        // make sure we're dealing with floats
+        $values = array_map('floatval', $values);
+        return max($values);
+    }
+
+    /**
+     * Translate a CacheID into the list of applicable InvalidationKeys.
+     * Splits 'some|chain|into|an|array' into array( '#clearAll#', 'some', 'some|chain', 'some|chain|into', ... )
+     *
+     * @param string $cid           CacheID to translate
+     * @param string $resource_name template name
+     * @param string $cache_id      cache id
+     * @param string $compile_id    compile id
+     * @param string $resource_uid  source's filepath
+     *
+     * @return array  list of InvalidationKeys
+     * @uses   $invalidationKeyPrefix to prepend to each InvalidationKey
+     */
+    protected function listInvalidationKeys(
+        $cid,
+        $resource_name = null,
+        $cache_id = null,
+        $compile_id = null,
+        $resource_uid = null
+    ) {
+        $t = array('IVK#ALL');
+        $_name = $_compile = '#';
+        if ($resource_name) {
+            $_name .= $resource_uid . '#' . $this->sanitize($resource_name);
+            $t[] = 'IVK#TEMPLATE' . $_name;
+        }
+        if ($compile_id) {
+            $_compile .= $this->sanitize($compile_id);
+            $t[] = 'IVK#COMPILE' . $_compile;
+        }
+        $_name .= '#';
+        $cid = trim($cache_id, '|');
+        if (!$cid) {
+            return $t;
+        }
+        $i = 0;
+        while (true) {
+            // determine next delimiter position
+            $i = strpos($cid, '|', $i);
+            // add complete CacheID if there are no more delimiters
+            if ($i === false) {
+                $t[] = 'IVK#CACHE#' . $cid;
+                $t[] = 'IVK#CID' . $_name . $cid . $_compile;
+                $t[] = 'IVK#CID' . $_name . $_compile;
+                break;
+            }
+            $part = substr($cid, 0, $i);
+            // add slice to list
+            $t[] = 'IVK#CACHE#' . $part;
+            $t[] = 'IVK#CID' . $_name . $part . $_compile;
+            // skip past delimiter position
+            $i++;
+        }
+        return $t;
+    }
+
+    /**
+     * Check is cache is locked for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return boolean               true or false if cache is locked
+     */
+    public function hasLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $key = 'LOCK#' . $cached->filepath;
+        $data = $this->read(array($key));
+        return $data && time() - $data[ $key ] < $smarty->locking_timeout;
+    }
+
+    /**
+     * Lock cache for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return bool|void
+     */
+    public function acquireLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $cached->is_locked = true;
+        $key = 'LOCK#' . $cached->filepath;
+        $this->write(array($key => time()), $smarty->locking_timeout);
+    }
+
+    /**
+     * Unlock cache for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return bool|void
+     */
+    public function releaseLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $cached->is_locked = false;
+        $key = 'LOCK#' . $cached->filepath;
+        $this->delete(array($key));
+    }
+
+    /**
+     * Read values for a set of keys from cache
+     *
+     * @param array $keys list of keys to fetch
+     *
+     * @return array list of values with the given keys used as indexes
+     */
+    abstract protected function read(array $keys);
+
+    /**
+     * Save values for a set of keys to cache
+     *
+     * @param array $keys   list of values to save
+     * @param int   $expire expiration time
+     *
+     * @return boolean true on success, false on failure
+     */
+    abstract protected function write(array $keys, $expire = null);
+
+    /**
+     * Remove values from cache
+     *
+     * @param array $keys list of keys to delete
+     *
+     * @return boolean true on success, false on failure
+     */
+    abstract protected function delete(array $keys);
+
+    /**
+     * Remove *all* values from cache
+     *
+     * @return boolean true on success, false on failure
+     */
+    protected function purge()
+    {
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_data.php b/epgrec/Smarty/sysplugins/smarty_data.php
--- a/epgrec/Smarty/sysplugins/smarty_data.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_data.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,68 @@
+<?php
+/**
+ * Smarty Plugin Data
+ * This file contains the data object
+ *
+ * @package    Smarty
+ * @subpackage Template
+ * @author     Uwe Tews
+ */
+
+/**
+ * class for the Smarty data object
+ * The Smarty data object will hold Smarty variables in the current scope
+ *
+ * @package    Smarty
+ * @subpackage Template
+ */
+class Smarty_Data extends Smarty_Internal_Data
+{
+    /**
+     * Counter
+     *
+     * @var int
+     */
+    public static $count = 0;
+
+    /**
+     * Data block name
+     *
+     * @var string
+     */
+    public $dataObjectName = '';
+
+    /**
+     * Smarty object
+     *
+     * @var Smarty
+     */
+    public $smarty = null;
+
+    /**
+     * create Smarty data object
+     *
+     * @param Smarty|array                    $_parent parent template
+     * @param Smarty|Smarty_Internal_Template $smarty  global smarty instance
+     * @param string                          $name    optional data block name
+     *
+     * @throws SmartyException
+     */
+    public function __construct($_parent = null, $smarty = null, $name = null)
+    {
+        parent::__construct();
+        self::$count++;
+        $this->dataObjectName = 'Data_object ' . (isset($name) ? "'{$name}'" : self::$count);
+        $this->smarty = $smarty;
+        if (is_object($_parent)) {
+            // when object set up back pointer
+            $this->parent = $_parent;
+        } elseif (is_array($_parent)) {
+            // set up variable values
+            foreach ($_parent as $_key => $_val) {
+                $this->tpl_vars[ $_key ] = new Smarty_Variable($_val);
+            }
+        } elseif ($_parent !== null) {
+            throw new SmartyException('Wrong type for template variables');
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_block.php b/epgrec/Smarty/sysplugins/smarty_internal_block.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_block.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_block.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,90 @@
+<?php
+
+/**
+ * Smarty {block} tag class
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Block
+{
+    /**
+     * Block name
+     *
+     * @var string
+     */
+    public $name = '';
+
+    /**
+     * Hide attribute
+     *
+     * @var bool
+     */
+    public $hide = false;
+
+    /**
+     * Append attribute
+     *
+     * @var bool
+     */
+    public $append = false;
+
+    /**
+     * prepend attribute
+     *
+     * @var bool
+     */
+    public $prepend = false;
+
+    /**
+     * Block calls $smarty.block.child
+     *
+     * @var bool
+     */
+    public $callsChild = false;
+
+    /**
+     * Inheritance child block
+     *
+     * @var Smarty_Internal_Block|null
+     */
+    public $child = null;
+
+    /**
+     * Inheritance calling parent block
+     *
+     * @var Smarty_Internal_Block|null
+     */
+    public $parent = null;
+
+    /**
+     * Inheritance Template index
+     *
+     * @var int
+     */
+    public $tplIndex = 0;
+
+    /**
+     * Smarty_Internal_Block constructor.
+     * - if outer level {block} of child template ($state === 1) save it as child root block
+     * - otherwise process inheritance and render
+     *
+     * @param string   $name     block name
+     * @param int|null $tplIndex index of outer level {block} if nested
+     */
+    public function __construct($name, $tplIndex)
+    {
+        $this->name = $name;
+        $this->tplIndex = $tplIndex;
+    }
+
+    /**
+     * Compiled block code overloaded by {block} class
+     *
+     * @param \Smarty_Internal_Template $tpl
+     */
+    public function callBlock(Smarty_Internal_Template $tpl)
+    {
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_cacheresource_file.php b/epgrec/Smarty/sysplugins/smarty_internal_cacheresource_file.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_cacheresource_file.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_cacheresource_file.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,239 @@
+<?php
+/**
+ * Smarty Internal Plugin CacheResource File
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+
+/**
+ * This class does contain all necessary methods for the HTML cache on file system
+ * Implements the file system as resource for the HTML cache Version ussing nocache inserts.
+ *
+ * @package    Smarty
+ * @subpackage Cacher
+ */
+class Smarty_Internal_CacheResource_File extends Smarty_CacheResource
+{
+    /**
+     * populate Cached Object with meta data from Resource
+     *
+     * @param Smarty_Template_Cached   $cached    cached object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populate(Smarty_Template_Cached $cached, Smarty_Internal_Template $_template)
+    {
+        $source = &$_template->source;
+        $smarty = &$_template->smarty;
+        $_compile_dir_sep = $smarty->use_sub_dirs ? DIRECTORY_SEPARATOR : '^';
+        $_filepath = sha1($source->uid . $smarty->_joined_template_dir);
+        $cached->filepath = $smarty->getCacheDir();
+        if (isset($_template->cache_id)) {
+            $cached->filepath .= preg_replace(
+                                     array(
+                                         '![^\w|]+!',
+                                         '![|]+!'
+                                     ),
+                                     array(
+                                         '_',
+                                         $_compile_dir_sep
+                                     ),
+                                     $_template->cache_id
+                                 ) . $_compile_dir_sep;
+        }
+        if (isset($_template->compile_id)) {
+            $cached->filepath .= preg_replace('![^\w]+!', '_', $_template->compile_id) . $_compile_dir_sep;
+        }
+        // if use_sub_dirs, break file into directories
+        if ($smarty->use_sub_dirs) {
+            $cached->filepath .= $_filepath[ 0 ] . $_filepath[ 1 ] . DIRECTORY_SEPARATOR . $_filepath[ 2 ] .
+                                 $_filepath[ 3 ] .
+                                 DIRECTORY_SEPARATOR .
+                                 $_filepath[ 4 ] . $_filepath[ 5 ] . DIRECTORY_SEPARATOR;
+        }
+        $cached->filepath .= $_filepath;
+        $basename = $source->handler->getBasename($source);
+        if (!empty($basename)) {
+            $cached->filepath .= '.' . $basename;
+        }
+        if ($smarty->cache_locking) {
+            $cached->lock_id = $cached->filepath . '.lock';
+        }
+        $cached->filepath .= '.php';
+        $cached->timestamp = $cached->exists = is_file($cached->filepath);
+        if ($cached->exists) {
+            $cached->timestamp = filemtime($cached->filepath);
+        }
+    }
+
+    /**
+     * populate Cached Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return void
+     */
+    public function populateTimestamp(Smarty_Template_Cached $cached)
+    {
+        $cached->timestamp = $cached->exists = is_file($cached->filepath);
+        if ($cached->exists) {
+            $cached->timestamp = filemtime($cached->filepath);
+        }
+    }
+
+    /**
+     * Read the cached template and process its header
+     *
+     * @param \Smarty_Internal_Template $_smarty_tpl do not change variable name, is used by compiled template
+     * @param Smarty_Template_Cached    $cached      cached object
+     * @param bool                      $update      flag if called because cache update
+     *
+     * @return boolean true or false if the cached content does not exist
+     */
+    public function process(
+        Smarty_Internal_Template $_smarty_tpl,
+        Smarty_Template_Cached $cached = null,
+        $update = false
+    ) {
+        $_smarty_tpl->cached->valid = false;
+        if ($update && defined('HHVM_VERSION')) {
+            eval('?>' . file_get_contents($_smarty_tpl->cached->filepath));
+            return true;
+        } else {
+            return @include $_smarty_tpl->cached->filepath;
+        }
+    }
+
+    /**
+     * Write the rendered template output to cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param string                   $content   content to cache
+     *
+     * @return bool success
+     * @throws \SmartyException
+     */
+    public function writeCachedContent(Smarty_Internal_Template $_template, $content)
+    {
+        if ($_template->smarty->ext->_writeFile->writeFile(
+                $_template->cached->filepath,
+                $content,
+                $_template->smarty
+            ) === true
+        ) {
+            if (function_exists('opcache_invalidate')
+                && (!function_exists('ini_get') || strlen(ini_get('opcache.restrict_api'))) < 1
+            ) {
+                opcache_invalidate($_template->cached->filepath, true);
+            } elseif (function_exists('apc_compile_file')) {
+                apc_compile_file($_template->cached->filepath);
+            }
+            $cached = $_template->cached;
+            $cached->timestamp = $cached->exists = is_file($cached->filepath);
+            if ($cached->exists) {
+                $cached->timestamp = filemtime($cached->filepath);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Read cached template from cache
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return string  content
+     */
+    public function readCachedContent(Smarty_Internal_Template $_template)
+    {
+        if (is_file($_template->cached->filepath)) {
+            return file_get_contents($_template->cached->filepath);
+        }
+        return false;
+    }
+
+    /**
+     * Empty cache
+     *
+     * @param Smarty  $smarty
+     * @param integer $exp_time expiration time (number of seconds, not timestamp)
+     *
+     * @return integer number of cache files deleted
+     */
+    public function clearAll(Smarty $smarty, $exp_time = null)
+    {
+        return $smarty->ext->_cacheResourceFile->clear($smarty, null, null, null, $exp_time);
+    }
+
+    /**
+     * Empty cache for a specific template
+     *
+     * @param Smarty  $smarty
+     * @param string  $resource_name template name
+     * @param string  $cache_id      cache id
+     * @param string  $compile_id    compile id
+     * @param integer $exp_time      expiration time (number of seconds, not timestamp)
+     *
+     * @return integer number of cache files deleted
+     */
+    public function clear(Smarty $smarty, $resource_name, $cache_id, $compile_id, $exp_time)
+    {
+        return $smarty->ext->_cacheResourceFile->clear($smarty, $resource_name, $cache_id, $compile_id, $exp_time);
+    }
+
+    /**
+     * Check is cache is locked for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return boolean true or false if cache is locked
+     */
+    public function hasLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        if (version_compare(PHP_VERSION, '5.3.0', '>=')) {
+            clearstatcache(true, $cached->lock_id);
+        } else {
+            clearstatcache();
+        }
+        if (is_file($cached->lock_id)) {
+            $t = filemtime($cached->lock_id);
+            return $t && (time() - $t < $smarty->locking_timeout);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Lock cache for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return bool|void
+     */
+    public function acquireLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $cached->is_locked = true;
+        touch($cached->lock_id);
+    }
+
+    /**
+     * Unlock cache for this template
+     *
+     * @param Smarty                 $smarty Smarty object
+     * @param Smarty_Template_Cached $cached cached object
+     *
+     * @return bool|void
+     */
+    public function releaseLock(Smarty $smarty, Smarty_Template_Cached $cached)
+    {
+        $cached->is_locked = false;
+        @unlink($cached->lock_id);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_append.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_append.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_append.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_append.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,52 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Append
+ * Compiles the {append} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Append Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Append extends Smarty_Internal_Compile_Assign
+{
+    /**
+     * Compiles code for the {append} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // the following must be assigned at runtime because it will be overwritten in parent class
+        $this->required_attributes = array('var', 'value');
+        $this->shorttag_order = array('var', 'value');
+        $this->optional_attributes = array('scope', 'index');
+        $this->mapCache = array();
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        // map to compile assign attributes
+        if (isset($_attr[ 'index' ])) {
+            $_params[ 'smarty_internal_index' ] = '[' . $_attr[ 'index' ] . ']';
+            unset($_attr[ 'index' ]);
+        } else {
+            $_params[ 'smarty_internal_index' ] = '[]';
+        }
+        $_new_attr = array();
+        foreach ($_attr as $key => $value) {
+            $_new_attr[] = array($key => $value);
+        }
+        // call compile assign
+        return parent::compile($_new_attr, $compiler, $_params);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_assign.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_assign.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_assign.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_assign.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,96 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Assign
+ * Compiles the {assign} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Assign Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Assign extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $option_flags = array('nocache', 'noscope');
+
+    /**
+     * Valid scope names
+     *
+     * @var array
+     */
+    public $valid_scopes = array(
+        'local'    => Smarty::SCOPE_LOCAL, 'parent' => Smarty::SCOPE_PARENT,
+        'root'     => Smarty::SCOPE_ROOT, 'global' => Smarty::SCOPE_GLOBAL,
+        'tpl_root' => Smarty::SCOPE_TPL_ROOT, 'smarty' => Smarty::SCOPE_SMARTY
+    );
+
+    /**
+     * Compiles code for the {assign} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // the following must be assigned at runtime because it will be overwritten in Smarty_Internal_Compile_Append
+        $this->required_attributes = array('var', 'value');
+        $this->shorttag_order = array('var', 'value');
+        $this->optional_attributes = array('scope');
+        $this->mapCache = array();
+        $_nocache = false;
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        // nocache ?
+        if ($_var = $compiler->getId($_attr[ 'var' ])) {
+            $_var = "'{$_var}'";
+        } else {
+            $_var = $_attr[ 'var' ];
+        }
+        if ($compiler->tag_nocache || $compiler->nocache) {
+            $_nocache = true;
+            // create nocache var to make it know for further compiling
+            $compiler->setNocacheInVariable($_attr[ 'var' ]);
+        }
+        // scope setup
+        if ($_attr[ 'noscope' ]) {
+            $_scope = -1;
+        } else {
+            $_scope = $compiler->convertScope($_attr, $this->valid_scopes);
+        }
+        // optional parameter
+        $_params = '';
+        if ($_nocache || $_scope) {
+            $_params .= ' ,' . var_export($_nocache, true);
+        }
+        if ($_scope) {
+            $_params .= ' ,' . $_scope;
+        }
+        if (isset($parameter[ 'smarty_internal_index' ])) {
+            $output =
+                "<?php \$_tmp_array = isset(\$_smarty_tpl->tpl_vars[{$_var}]) ? \$_smarty_tpl->tpl_vars[{$_var}]->value : array();\n";
+            $output .= "if (!(is_array(\$_tmp_array) || \$_tmp_array instanceof ArrayAccess)) {\n";
+            $output .= "settype(\$_tmp_array, 'array');\n";
+            $output .= "}\n";
+            $output .= "\$_tmp_array{$parameter['smarty_internal_index']} = {$_attr['value']};\n";
+            $output .= "\$_smarty_tpl->_assignInScope({$_var}, \$_tmp_array{$_params});?>";
+        } else {
+            $output = "<?php \$_smarty_tpl->_assignInScope({$_var}, {$_attr['value']}{$_params});?>";
+        }
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_block.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_block.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_block.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_block.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,189 @@
+<?php
+/**
+ * This file is part of Smarty.
+ *
+ * (c) 2015 Uwe Tews
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * Smarty Internal Plugin Compile Block Class
+ *
+ * @author Uwe Tews <uwe.tews@googlemail.com>
+ */
+class Smarty_Internal_Compile_Block extends Smarty_Internal_Compile_Shared_Inheritance
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $option_flags = array('hide', 'nocache');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('assign');
+
+    /**
+     * Compiles code for the {block} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        if (!isset($compiler->_cache[ 'blockNesting' ])) {
+            $compiler->_cache[ 'blockNesting' ] = 0;
+        }
+        if ($compiler->_cache[ 'blockNesting' ] === 0) {
+            // make sure that inheritance gets initialized in template code
+            $this->registerInit($compiler);
+            $this->option_flags = array('hide', 'nocache', 'append', 'prepend');
+        } else {
+            $this->option_flags = array('hide', 'nocache');
+        }
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        ++$compiler->_cache[ 'blockNesting' ];
+        $_className = 'Block_' . preg_replace('![^\w]+!', '_', uniqid(mt_rand(), true));
+        $compiler->_cache[ 'blockName' ][ $compiler->_cache[ 'blockNesting' ] ] = $_attr[ 'name' ];
+        $compiler->_cache[ 'blockClass' ][ $compiler->_cache[ 'blockNesting' ] ] = $_className;
+        $compiler->_cache[ 'blockParams' ][ $compiler->_cache[ 'blockNesting' ] ] = array();
+        $compiler->_cache[ 'blockParams' ][ 1 ][ 'subBlocks' ][ trim($_attr[ 'name' ], '"\'') ][] = $_className;
+        $this->openTag(
+            $compiler,
+            'block',
+            array(
+                $_attr, $compiler->nocache, $compiler->parser->current_buffer,
+                $compiler->template->compiled->has_nocache_code,
+                $compiler->template->caching
+            )
+        );
+        $compiler->saveRequiredPlugins(true);
+        $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        $compiler->parser->current_buffer = new Smarty_Internal_ParseTree_Template();
+        $compiler->template->compiled->has_nocache_code = false;
+        $compiler->suppressNocacheProcessing = true;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile BlockClose Class
+ */
+class Smarty_Internal_Compile_Blockclose extends Smarty_Internal_Compile_Shared_Inheritance
+{
+    /**
+     * Compiles code for the {/block} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return bool true
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        list($_attr, $_nocache, $_buffer, $_has_nocache_code, $_caching) = $this->closeTag($compiler, array('block'));
+        // init block parameter
+        $_block = $compiler->_cache[ 'blockParams' ][ $compiler->_cache[ 'blockNesting' ] ];
+        unset($compiler->_cache[ 'blockParams' ][ $compiler->_cache[ 'blockNesting' ] ]);
+        $_name = $_attr[ 'name' ];
+        $_assign = isset($_attr[ 'assign' ]) ? $_attr[ 'assign' ] : null;
+        unset($_attr[ 'assign' ], $_attr[ 'name' ]);
+        foreach ($_attr as $name => $stat) {
+            if ((is_bool($stat) && $stat !== false) || (!is_bool($stat) && $stat !== 'false')) {
+                $_block[ $name ] = 'true';
+            }
+        }
+        $_className = $compiler->_cache[ 'blockClass' ][ $compiler->_cache[ 'blockNesting' ] ];
+        // get compiled block code
+        $_functionCode = $compiler->parser->current_buffer;
+        // setup buffer for template function code
+        $compiler->parser->current_buffer = new Smarty_Internal_ParseTree_Template();
+        $output = "<?php\n";
+        $output .= $compiler->cStyleComment(" {block {$_name}} ") . "\n";
+        $output .= "class {$_className} extends Smarty_Internal_Block\n";
+        $output .= "{\n";
+        foreach ($_block as $property => $value) {
+            $output .= "public \${$property} = " . var_export($value, true) . ";\n";
+        }
+        $output .= "public function callBlock(Smarty_Internal_Template \$_smarty_tpl) {\n";
+        $output .= $compiler->compileRequiredPlugins();
+        $compiler->restoreRequiredPlugins();
+        if ($compiler->template->compiled->has_nocache_code) {
+            $output .= "\$_smarty_tpl->cached->hashes['{$compiler->template->compiled->nocache_hash}'] = true;\n";
+        }
+        if (isset($_assign)) {
+            $output .= "ob_start();\n";
+        }
+        $output .= "?>\n";
+        $compiler->parser->current_buffer->append_subtree(
+            $compiler->parser,
+            new Smarty_Internal_ParseTree_Tag(
+                $compiler->parser,
+                $output
+            )
+        );
+        $compiler->parser->current_buffer->append_subtree($compiler->parser, $_functionCode);
+        $output = "<?php\n";
+        if (isset($_assign)) {
+            $output .= "\$_smarty_tpl->assign({$_assign}, ob_get_clean());\n";
+        }
+        $output .= "}\n";
+        $output .= "}\n";
+        $output .= $compiler->cStyleComment(" {/block {$_name}} ") . "\n\n";
+        $output .= "?>\n";
+        $compiler->parser->current_buffer->append_subtree(
+            $compiler->parser,
+            new Smarty_Internal_ParseTree_Tag(
+                $compiler->parser,
+                $output
+            )
+        );
+        $compiler->blockOrFunctionCode .= $compiler->parser->current_buffer->to_smarty_php($compiler->parser);
+        $compiler->parser->current_buffer = new Smarty_Internal_ParseTree_Template();
+        // restore old status
+        $compiler->template->compiled->has_nocache_code = $_has_nocache_code;
+        $compiler->tag_nocache = $compiler->nocache;
+        $compiler->nocache = $_nocache;
+        $compiler->parser->current_buffer = $_buffer;
+        $output = "<?php \n";
+        if ($compiler->_cache[ 'blockNesting' ] === 1) {
+            $output .= "\$_smarty_tpl->inheritance->instanceBlock(\$_smarty_tpl, '$_className', $_name);\n";
+        } else {
+            $output .= "\$_smarty_tpl->inheritance->instanceBlock(\$_smarty_tpl, '$_className', $_name, \$this->tplIndex);\n";
+        }
+        $output .= "?>\n";
+        --$compiler->_cache[ 'blockNesting' ];
+        if ($compiler->_cache[ 'blockNesting' ] === 0) {
+            unset($compiler->_cache[ 'blockNesting' ]);
+        }
+        $compiler->has_code = true;
+        $compiler->suppressNocacheProcessing = true;
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_block_child.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_block_child.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_block_child.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_block_child.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,24 @@
+<?php
+/**
+ * This file is part of Smarty.
+ *
+ * (c) 2015 Uwe Tews
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * Smarty Internal Plugin Compile Block Child Class
+ *
+ * @author Uwe Tews <uwe.tews@googlemail.com>
+ */
+class Smarty_Internal_Compile_Block_Child extends Smarty_Internal_Compile_Child
+{
+    /**
+     * Tag name
+     *
+     * @var string
+     */
+    public $tag = 'block_child';
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_block_parent.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_block_parent.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_block_parent.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_block_parent.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,31 @@
+<?php
+/**
+ * This file is part of Smarty.
+ *
+ * (c) 2015 Uwe Tews
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * Smarty Internal Plugin Compile Block Parent Class
+ *
+ * @author Uwe Tews <uwe.tews@googlemail.com>
+ */
+class Smarty_Internal_Compile_Block_Parent extends Smarty_Internal_Compile_Child
+{
+    /**
+     * Tag name
+     *
+     * @var string
+     */
+    public $tag = 'block_parent';
+
+    /**
+     * Block type
+     *
+     * @var string
+     */
+    public $blockType = 'Parent';
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_break.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_break.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_break.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_break.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,117 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Break
+ * Compiles the {break} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Break Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Break extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('levels');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('levels');
+
+    /**
+     * Tag name may be overloaded by Smarty_Internal_Compile_Continue
+     *
+     * @var string
+     */
+    public $tag = 'break';
+
+    /**
+     * Compiles code for the {break} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        list($levels, $foreachLevels) = $this->checkLevels($args, $compiler);
+        $output = "<?php ";
+        if ($foreachLevels > 0 && $this->tag === 'continue') {
+            $foreachLevels--;
+        }
+        if ($foreachLevels > 0) {
+            /* @var Smarty_Internal_Compile_Foreach $foreachCompiler */
+            $foreachCompiler = $compiler->getTagCompiler('foreach');
+            $output .= $foreachCompiler->compileRestore($foreachLevels);
+        }
+        $output .= "{$this->tag} {$levels};?>";
+        return $output;
+    }
+
+    /**
+     * check attributes and return array of break and foreach levels
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return array
+     * @throws \SmartyCompilerException
+     */
+    public function checkLevels($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        static $_is_loopy = array('for' => true, 'foreach' => true, 'while' => true, 'section' => true);
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        if ($_attr[ 'nocache' ] === true) {
+            $compiler->trigger_template_error('nocache option not allowed', null, true);
+        }
+        if (isset($_attr[ 'levels' ])) {
+            if (!is_numeric($_attr[ 'levels' ])) {
+                $compiler->trigger_template_error('level attribute must be a numeric constant', null, true);
+            }
+            $levels = $_attr[ 'levels' ];
+        } else {
+            $levels = 1;
+        }
+        $level_count = $levels;
+        $stack_count = count($compiler->_tag_stack) - 1;
+        $foreachLevels = 0;
+        $lastTag = '';
+        while ($level_count > 0 && $stack_count >= 0) {
+            if (isset($_is_loopy[ $compiler->_tag_stack[ $stack_count ][ 0 ] ])) {
+                $lastTag = $compiler->_tag_stack[ $stack_count ][ 0 ];
+                if ($level_count === 0) {
+                    break;
+                }
+                $level_count--;
+                if ($compiler->_tag_stack[ $stack_count ][ 0 ] === 'foreach') {
+                    $foreachLevels++;
+                }
+            }
+            $stack_count--;
+        }
+        if ($level_count !== 0) {
+            $compiler->trigger_template_error("cannot {$this->tag} {$levels} level(s)", null, true);
+        }
+        if ($lastTag === 'foreach' && $this->tag === 'break' && $foreachLevels > 0) {
+            $foreachLevels--;
+        }
+        return array($levels, $foreachLevels);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_call.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_call.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_call.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_call.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,89 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Function_Call
+ * Compiles the calls of user defined tags defined by {function}
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Function_Call Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Call extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * Compiles the calls of user defined tags defined by {function}
+     *
+     * @param array  $args     array with attributes from parser
+     * @param object $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        // save possible attributes
+        if (isset($_attr[ 'assign' ])) {
+            // output will be stored in a smarty variable instead of being displayed
+            $_assign = $_attr[ 'assign' ];
+        }
+        //$_name = trim($_attr['name'], "''");
+        $_name = $_attr[ 'name' ];
+        unset($_attr[ 'name' ], $_attr[ 'assign' ], $_attr[ 'nocache' ]);
+        // set flag (compiled code of {function} must be included in cache file
+        if (!$compiler->template->caching || $compiler->nocache || $compiler->tag_nocache) {
+            $_nocache = 'true';
+        } else {
+            $_nocache = 'false';
+        }
+        $_paramsArray = array();
+        foreach ($_attr as $_key => $_value) {
+            if (is_int($_key)) {
+                $_paramsArray[] = "$_key=>$_value";
+            } else {
+                $_paramsArray[] = "'$_key'=>$_value";
+            }
+        }
+        $_params = 'array(' . implode(',', $_paramsArray) . ')';
+        //$compiler->suppressNocacheProcessing = true;
+        // was there an assign attribute
+        if (isset($_assign)) {
+            $_output =
+                "<?php ob_start();\n\$_smarty_tpl->smarty->ext->_tplFunction->callTemplateFunction(\$_smarty_tpl, {$_name}, {$_params}, {$_nocache});\n\$_smarty_tpl->assign({$_assign}, ob_get_clean());?>\n";
+        } else {
+            $_output =
+                "<?php \$_smarty_tpl->smarty->ext->_tplFunction->callTemplateFunction(\$_smarty_tpl, {$_name}, {$_params}, {$_nocache});?>\n";
+        }
+        return $_output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_capture.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_capture.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_capture.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_capture.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,105 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Capture
+ * Compiles the {capture} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Capture Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Capture extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('name', 'assign', 'append');
+
+    /**
+     * Compiles code for the {$smarty.capture.xxx}
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     */
+    public static function compileSpecialVariable(
+        $args,
+        Smarty_Internal_TemplateCompilerBase $compiler,
+        $parameter = null
+    ) {
+        return '$_smarty_tpl->smarty->ext->_capture->getBuffer($_smarty_tpl' .
+               (isset($parameter[ 1 ]) ? ", {$parameter[ 1 ]})" : ')');
+    }
+
+    /**
+     * Compiles code for the {capture} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     * @param null                                  $parameter
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter = null)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args, $parameter, 'capture');
+        $buffer = isset($_attr[ 'name' ]) ? $_attr[ 'name' ] : "'default'";
+        $assign = isset($_attr[ 'assign' ]) ? $_attr[ 'assign' ] : 'null';
+        $append = isset($_attr[ 'append' ]) ? $_attr[ 'append' ] : 'null';
+        $compiler->_cache[ 'capture_stack' ][] = array($compiler->nocache);
+        // maybe nocache because of nocache variables
+        $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        $_output = "<?php \$_smarty_tpl->smarty->ext->_capture->open(\$_smarty_tpl, $buffer, $assign, $append);?>";
+        return $_output;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Captureclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_CaptureClose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/capture} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     * @param null                                  $parameter
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args, $parameter, '/capture');
+        // must endblock be nocache?
+        if ($compiler->nocache) {
+            $compiler->tag_nocache = true;
+        }
+        list($compiler->nocache) = array_pop($compiler->_cache[ 'capture_stack' ]);
+        return "<?php \$_smarty_tpl->smarty->ext->_capture->close(\$_smarty_tpl);?>";
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_child.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_child.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_child.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_child.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,79 @@
+<?php
+/**
+ * This file is part of Smarty.
+ *
+ * (c) 2015 Uwe Tews
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * Smarty Internal Plugin Compile Child Class
+ *
+ * @author Uwe Tews <uwe.tews@googlemail.com>
+ */
+class Smarty_Internal_Compile_Child extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('assign');
+
+    /**
+     * Tag name
+     *
+     * @var string
+     */
+    public $tag = 'child';
+
+    /**
+     * Block type
+     *
+     * @var string
+     */
+    public $blockType = 'Child';
+
+    /**
+     * Compiles code for the {child} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $tag = isset($parameter[ 0 ]) ? "'{$parameter[0]}'" : "'{{$this->tag}}'";
+        if (!isset($compiler->_cache[ 'blockNesting' ])) {
+            $compiler->trigger_template_error(
+                "{$tag} used outside {block} tags ",
+                $compiler->parser->lex->taglineno
+            );
+        }
+        $compiler->has_code = true;
+        $compiler->suppressNocacheProcessing = true;
+        if ($this->blockType === 'Child') {
+            $compiler->_cache[ 'blockParams' ][ $compiler->_cache[ 'blockNesting' ] ][ 'callsChild' ] = 'true';
+        }
+        $_assign = isset($_attr[ 'assign' ]) ? $_attr[ 'assign' ] : null;
+        $output = "<?php \n";
+        if (isset($_assign)) {
+            $output .= "ob_start();\n";
+        }
+        $output .= '$_smarty_tpl->inheritance->call' . $this->blockType . '($_smarty_tpl, $this' .
+                   ($this->blockType === 'Child' ? '' : ", {$tag}") . ");\n";
+        if (isset($_assign)) {
+            $output .= "\$_smarty_tpl->assign({$_assign}, ob_get_clean());\n";
+        }
+        $output .= "?>\n";
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_config_load.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_config_load.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_config_load.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_config_load.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,96 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Config Load
+ * Compiles the {config load} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Config Load Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Config_Load extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('file');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('file', 'section');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('section', 'scope');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $option_flags = array('nocache', 'noscope');
+
+    /**
+     * Valid scope names
+     *
+     * @var array
+     */
+    public $valid_scopes = array(
+        'local'  => Smarty::SCOPE_LOCAL, 'parent' => Smarty::SCOPE_PARENT,
+        'root'   => Smarty::SCOPE_ROOT, 'tpl_root' => Smarty::SCOPE_TPL_ROOT,
+        'smarty' => Smarty::SCOPE_SMARTY, 'global' => Smarty::SCOPE_SMARTY
+    );
+
+    /**
+     * Compiles code for the {config_load} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        if ($_attr[ 'nocache' ] === true) {
+            $compiler->trigger_template_error('nocache option not allowed', null, true);
+        }
+        // save possible attributes
+        $conf_file = $_attr[ 'file' ];
+        if (isset($_attr[ 'section' ])) {
+            $section = $_attr[ 'section' ];
+        } else {
+            $section = 'null';
+        }
+        // scope setup
+        if ($_attr[ 'noscope' ]) {
+            $_scope = -1;
+        } else {
+            $_scope = $compiler->convertScope($_attr, $this->valid_scopes);
+        }
+        // create config object
+        $_output =
+            "<?php\n\$_smarty_tpl->smarty->ext->configLoad->_loadConfigFile(\$_smarty_tpl, {$conf_file}, {$section}, {$_scope});\n?>\n";
+        return $_output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_continue.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_continue.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_continue.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_continue.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,25 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Continue
+ * Compiles the {continue} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Continue Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Continue extends Smarty_Internal_Compile_Break
+{
+    /**
+     * Tag name
+     *
+     * @var string
+     */
+    public $tag = 'continue';
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_debug.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_debug.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_debug.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_debug.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,40 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Debug
+ * Compiles the {debug} tag.
+ * It opens a window the the Smarty Debugging Console.
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Debug Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Debug extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {debug} tag
+     *
+     * @param array  $args     array with attributes from parser
+     * @param object $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        // compile always as nocache
+        $compiler->tag_nocache = true;
+        // display debug template
+        $_output =
+            "<?php \$_smarty_debug = new Smarty_Internal_Debug;\n \$_smarty_debug->display_debug(\$_smarty_tpl);\n";
+        $_output .= "unset(\$_smarty_debug);\n?>";
+        return $_output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_eval.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_eval.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_eval.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_eval.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,70 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Eval
+ * Compiles the {eval} tag.
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Eval Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Eval extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('var');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('assign');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('var', 'assign');
+
+    /**
+     * Compiles code for the {eval} tag
+     *
+     * @param array  $args     array with attributes from parser
+     * @param object $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        if (isset($_attr[ 'assign' ])) {
+            // output will be stored in a smarty variable instead of being displayed
+            $_assign = $_attr[ 'assign' ];
+        }
+        // create template object
+        $_output =
+            "\$_template = new {$compiler->smarty->template_class}('eval:'.{$_attr[ 'var' ]}, \$_smarty_tpl->smarty, \$_smarty_tpl);";
+        //was there an assign attribute?
+        if (isset($_assign)) {
+            $_output .= "\$_smarty_tpl->assign($_assign,\$_template->fetch());";
+        } else {
+            $_output .= 'echo $_template->fetch();';
+        }
+        return "<?php $_output ?>";
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_extends.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_extends.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_extends.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_extends.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,158 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile extend
+ * Compiles the {extends} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile extend Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Extends extends Smarty_Internal_Compile_Shared_Inheritance
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('file');
+
+    /**
+     * Array of names of optional attribute required by tag
+     * use array('_any') if there is no restriction of attributes names
+     *
+     * @var array
+     */
+    public $optional_attributes = array('extends_resource');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('file');
+
+    /**
+     * Compiles code for the {extends} tag extends: resource
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        if ($_attr[ 'nocache' ] === true) {
+            $compiler->trigger_template_error('nocache option not allowed', $compiler->parser->lex->line - 1);
+        }
+        if (strpos($_attr[ 'file' ], '$_tmp') !== false) {
+            $compiler->trigger_template_error('illegal value for file attribute', $compiler->parser->lex->line - 1);
+        }
+        // add code to initialize inheritance
+        $this->registerInit($compiler, true);
+        $file = trim($_attr[ 'file' ], '\'"');
+        if (strlen($file) > 8 && substr($file, 0, 8) === 'extends:') {
+            // generate code for each template
+            $files = array_reverse(explode('|', substr($file, 8)));
+            $i = 0;
+            foreach ($files as $file) {
+                if ($file[ 0 ] === '"') {
+                    $file = trim($file, '".');
+                } else {
+                    $file = "'{$file}'";
+                }
+                $i++;
+                if ($i === count($files) && isset($_attr[ 'extends_resource' ])) {
+                    $this->compileEndChild($compiler);
+                }
+                $this->compileInclude($compiler, $file);
+            }
+            if (!isset($_attr[ 'extends_resource' ])) {
+                $this->compileEndChild($compiler);
+            }
+        } else {
+            $this->compileEndChild($compiler, $_attr[ 'file' ]);
+        }
+        $compiler->has_code = false;
+        return '';
+    }
+
+    /**
+     * Add code for inheritance endChild() method to end of template
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     * @param null|string                           $template optional inheritance parent template
+     *
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    private function compileEndChild(Smarty_Internal_TemplateCompilerBase $compiler, $template = null)
+    {
+        $inlineUids = '';
+        if (isset($template) && $compiler->smarty->merge_compiled_includes) {
+            $code = $compiler->compileTag('include', array($template, array('scope' => 'parent')));
+            if (preg_match('/([,][\s]*[\'][a-z0-9]+[\'][,][\s]*[\']content.*[\'])[)]/', $code, $match)) {
+                $inlineUids = $match[ 1 ];
+            }
+        }
+        $compiler->parser->template_postfix[] = new Smarty_Internal_ParseTree_Tag(
+            $compiler->parser,
+            '<?php $_smarty_tpl->inheritance->endChild($_smarty_tpl' .
+            (isset($template) ?
+                ", {$template}{$inlineUids}" :
+                '') . ");\n?>"
+        );
+    }
+
+    /**
+     * Add code for including subtemplate to end of template
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     * @param string                                $template subtemplate name
+     *
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    private function compileInclude(Smarty_Internal_TemplateCompilerBase $compiler, $template)
+    {
+        $compiler->parser->template_postfix[] = new Smarty_Internal_ParseTree_Tag(
+            $compiler->parser,
+            $compiler->compileTag(
+                'include',
+                array(
+                    $template,
+                    array('scope' => 'parent')
+                )
+            )
+        );
+    }
+
+    /**
+     * Create source code for {extends} from source components array
+     *
+     * @param \Smarty_Internal_Template $template
+     *
+     * @return string
+     */
+    public static function extendsSourceArrayCode(Smarty_Internal_Template $template)
+    {
+        $resources = array();
+        foreach ($template->source->components as $source) {
+            $resources[] = $source->resource;
+        }
+        return $template->smarty->left_delimiter . 'extends file=\'extends:' . join('|', $resources) .
+               '\' extends_resource=true' . $template->smarty->right_delimiter;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_for.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_for.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_for.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_for.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,164 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile For
+ * Compiles the {for} {forelse} {/for} tags
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile For Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_For extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {for} tag
+     * Smarty 3 does implement two different syntax's:
+     * - {for $var in $array}
+     * For looping over arrays or iterators
+     * - {for $x=0; $x<$y; $x++}
+     * For general loops
+     * The parser is generating different sets of attribute by which this compiler can
+     * determine which syntax is used.
+     *
+     * @param array  $args      array with attributes from parser
+     * @param object $compiler  compiler object
+     * @param array  $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     */
+    public function compile($args, $compiler, $parameter)
+    {
+        $compiler->loopNesting++;
+        if ($parameter === 0) {
+            $this->required_attributes = array('start', 'to');
+            $this->optional_attributes = array('max', 'step');
+        } else {
+            $this->required_attributes = array('start', 'ifexp', 'var', 'step');
+            $this->optional_attributes = array();
+        }
+        $this->mapCache = array();
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $output = "<?php\n";
+        if ($parameter === 1) {
+            foreach ($_attr[ 'start' ] as $_statement) {
+                if (is_array($_statement[ 'var' ])) {
+                    $var = $_statement[ 'var' ][ 'var' ];
+                    $index = $_statement[ 'var' ][ 'smarty_internal_index' ];
+                } else {
+                    $var = $_statement[ 'var' ];
+                    $index = '';
+                }
+                $output .= "\$_smarty_tpl->tpl_vars[$var] = new Smarty_Variable(null, \$_smarty_tpl->isRenderingCache);\n";
+                $output .= "\$_smarty_tpl->tpl_vars[$var]->value{$index} = {$_statement['value']};\n";
+            }
+            if (is_array($_attr[ 'var' ])) {
+                $var = $_attr[ 'var' ][ 'var' ];
+                $index = $_attr[ 'var' ][ 'smarty_internal_index' ];
+            } else {
+                $var = $_attr[ 'var' ];
+                $index = '';
+            }
+            $output .= "if ($_attr[ifexp]) {\nfor (\$_foo=true;$_attr[ifexp]; \$_smarty_tpl->tpl_vars[$var]->value{$index}$_attr[step]) {\n";
+        } else {
+            $_statement = $_attr[ 'start' ];
+            if (is_array($_statement[ 'var' ])) {
+                $var = $_statement[ 'var' ][ 'var' ];
+                $index = $_statement[ 'var' ][ 'smarty_internal_index' ];
+            } else {
+                $var = $_statement[ 'var' ];
+                $index = '';
+            }
+            $output .= "\$_smarty_tpl->tpl_vars[$var] = new Smarty_Variable(null, \$_smarty_tpl->isRenderingCache);";
+            if (isset($_attr[ 'step' ])) {
+                $output .= "\$_smarty_tpl->tpl_vars[$var]->step = $_attr[step];";
+            } else {
+                $output .= "\$_smarty_tpl->tpl_vars[$var]->step = 1;";
+            }
+            if (isset($_attr[ 'max' ])) {
+                $output .= "\$_smarty_tpl->tpl_vars[$var]->total = (int) min(ceil((\$_smarty_tpl->tpl_vars[$var]->step > 0 ? $_attr[to]+1 - ($_statement[value]) : $_statement[value]-($_attr[to])+1)/abs(\$_smarty_tpl->tpl_vars[$var]->step)),$_attr[max]);\n";
+            } else {
+                $output .= "\$_smarty_tpl->tpl_vars[$var]->total = (int) ceil((\$_smarty_tpl->tpl_vars[$var]->step > 0 ? $_attr[to]+1 - ($_statement[value]) : $_statement[value]-($_attr[to])+1)/abs(\$_smarty_tpl->tpl_vars[$var]->step));\n";
+            }
+            $output .= "if (\$_smarty_tpl->tpl_vars[$var]->total > 0) {\n";
+            $output .= "for (\$_smarty_tpl->tpl_vars[$var]->value{$index} = $_statement[value], \$_smarty_tpl->tpl_vars[$var]->iteration = 1;\$_smarty_tpl->tpl_vars[$var]->iteration <= \$_smarty_tpl->tpl_vars[$var]->total;\$_smarty_tpl->tpl_vars[$var]->value{$index} += \$_smarty_tpl->tpl_vars[$var]->step, \$_smarty_tpl->tpl_vars[$var]->iteration++) {\n";
+            $output .= "\$_smarty_tpl->tpl_vars[$var]->first = \$_smarty_tpl->tpl_vars[$var]->iteration === 1;";
+            $output .= "\$_smarty_tpl->tpl_vars[$var]->last = \$_smarty_tpl->tpl_vars[$var]->iteration === \$_smarty_tpl->tpl_vars[$var]->total;";
+        }
+        $output .= '?>';
+        $this->openTag($compiler, 'for', array('for', $compiler->nocache));
+        // maybe nocache because of nocache variables
+        $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        // return compiled code
+        return $output;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Forelse Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Forelse extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {forelse} tag
+     *
+     * @param array  $args      array with attributes from parser
+     * @param object $compiler  compiler object
+     * @param array  $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     */
+    public function compile($args, $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        list($openTag, $nocache) = $this->closeTag($compiler, array('for'));
+        $this->openTag($compiler, 'forelse', array('forelse', $nocache));
+        return "<?php }} else { ?>";
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Forclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Forclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/for} tag
+     *
+     * @param array  $args      array with attributes from parser
+     * @param object $compiler  compiler object
+     * @param array  $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     */
+    public function compile($args, $compiler, $parameter)
+    {
+        $compiler->loopNesting--;
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        // must endblock be nocache?
+        if ($compiler->nocache) {
+            $compiler->tag_nocache = true;
+        }
+        list($openTag, $compiler->nocache) = $this->closeTag($compiler, array('for', 'forelse'));
+        $output = "<?php }\n";
+        if ($openTag !== 'forelse') {
+            $output .= "}\n";
+        }
+        $output .= "?>";
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_foreach.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_foreach.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_foreach.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_foreach.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,343 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Foreach
+ * Compiles the {foreach} {foreachelse} {/foreach} tags
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Foreach Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Foreach extends Smarty_Internal_Compile_Private_ForeachSection
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('from', 'item');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('name', 'key', 'properties');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('from', 'item', 'key', 'name');
+
+    /**
+     * counter
+     *
+     * @var int
+     */
+    public $counter = 0;
+
+    /**
+     * Name of this tag
+     *
+     * @var string
+     */
+    public $tagName = 'foreach';
+
+    /**
+     * Valid properties of $smarty.foreach.name.xxx variable
+     *
+     * @var array
+     */
+    public $nameProperties = array('first', 'last', 'index', 'iteration', 'show', 'total');
+
+    /**
+     * Valid properties of $item@xxx variable
+     *
+     * @var array
+     */
+    public $itemProperties = array('first', 'last', 'index', 'iteration', 'show', 'total', 'key');
+
+    /**
+     * Flag if tag had name attribute
+     *
+     * @var bool
+     */
+    public $isNamed = false;
+
+    /**
+     * Compiles code for the {foreach} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $compiler->loopNesting++;
+        // init
+        $this->isNamed = false;
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $from = $_attr[ 'from' ];
+        $item = $compiler->getId($_attr[ 'item' ]);
+        if ($item === false) {
+            $item = $compiler->getVariableName($_attr[ 'item' ]);
+        }
+        $key = $name = null;
+        $attributes = array('item' => $item);
+        if (isset($_attr[ 'key' ])) {
+            $key = $compiler->getId($_attr[ 'key' ]);
+            if ($key === false) {
+                $key = $compiler->getVariableName($_attr[ 'key' ]);
+            }
+            $attributes[ 'key' ] = $key;
+        }
+        if (isset($_attr[ 'name' ])) {
+            $this->isNamed = true;
+            $name = $attributes[ 'name' ] = $compiler->getId($_attr[ 'name' ]);
+        }
+        foreach ($attributes as $a => $v) {
+            if ($v === false) {
+                $compiler->trigger_template_error("'{$a}' attribute/variable has illegal value", null, true);
+            }
+        }
+        $fromName = $compiler->getVariableName($_attr[ 'from' ]);
+        if ($fromName) {
+            foreach (array('item', 'key') as $a) {
+                if (isset($attributes[ $a ]) && $attributes[ $a ] === $fromName) {
+                    $compiler->trigger_template_error(
+                        "'{$a}' and 'from' may not have same variable name '{$fromName}'",
+                        null,
+                        true
+                    );
+                }
+            }
+        }
+        $itemVar = "\$_smarty_tpl->tpl_vars['{$item}']";
+        $local = '$__foreach_' . $attributes[ 'item' ] . '_' . $this->counter++ . '_';
+        // search for used tag attributes
+        $itemAttr = array();
+        $namedAttr = array();
+        $this->scanForProperties($attributes, $compiler);
+        if (!empty($this->matchResults[ 'item' ])) {
+            $itemAttr = $this->matchResults[ 'item' ];
+        }
+        if (!empty($this->matchResults[ 'named' ])) {
+            $namedAttr = $this->matchResults[ 'named' ];
+        }
+        if (isset($_attr[ 'properties' ]) && preg_match_all('/[\'](.*?)[\']/', $_attr[ 'properties' ], $match)) {
+            foreach ($match[ 1 ] as $prop) {
+                if (in_array($prop, $this->itemProperties)) {
+                    $itemAttr[ $prop ] = true;
+                } else {
+                    $compiler->trigger_template_error("Invalid property '{$prop}'", null, true);
+                }
+            }
+            if ($this->isNamed) {
+                foreach ($match[ 1 ] as $prop) {
+                    if (in_array($prop, $this->nameProperties)) {
+                        $nameAttr[ $prop ] = true;
+                    } else {
+                        $compiler->trigger_template_error("Invalid property '{$prop}'", null, true);
+                    }
+                }
+            }
+        }
+        if (isset($itemAttr[ 'first' ])) {
+            $itemAttr[ 'index' ] = true;
+        }
+        if (isset($namedAttr[ 'first' ])) {
+            $namedAttr[ 'index' ] = true;
+        }
+        if (isset($namedAttr[ 'last' ])) {
+            $namedAttr[ 'iteration' ] = true;
+            $namedAttr[ 'total' ] = true;
+        }
+        if (isset($itemAttr[ 'last' ])) {
+            $itemAttr[ 'iteration' ] = true;
+            $itemAttr[ 'total' ] = true;
+        }
+        if (isset($namedAttr[ 'show' ])) {
+            $namedAttr[ 'total' ] = true;
+        }
+        if (isset($itemAttr[ 'show' ])) {
+            $itemAttr[ 'total' ] = true;
+        }
+        $keyTerm = '';
+        if (isset($attributes[ 'key' ])) {
+            $keyTerm = "\$_smarty_tpl->tpl_vars['{$key}']->value => ";
+        }
+        if (isset($itemAttr[ 'key' ])) {
+            $keyTerm = "{$itemVar}->key => ";
+        }
+        if ($this->isNamed) {
+            $foreachVar = "\$_smarty_tpl->tpl_vars['__smarty_foreach_{$attributes['name']}']";
+        }
+        $needTotal = isset($itemAttr[ 'total' ]);
+        // Register tag
+        $this->openTag(
+            $compiler,
+            'foreach',
+            array('foreach', $compiler->nocache, $local, $itemVar, empty($itemAttr) ? 1 : 2)
+        );
+        // maybe nocache because of nocache variables
+        $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        // generate output code
+        $output = "<?php\n";
+        $output .= "\$_from = \$_smarty_tpl->smarty->ext->_foreach->init(\$_smarty_tpl, $from, " .
+                   var_export($item, true);
+        if ($name || $needTotal || $key) {
+            $output .= ', ' . var_export($needTotal, true);
+        }
+        if ($name || $key) {
+            $output .= ', ' . var_export($key, true);
+        }
+        if ($name) {
+            $output .= ', ' . var_export($name, true) . ', ' . var_export($namedAttr, true);
+        }
+        $output .= ");\n";
+        if (isset($itemAttr[ 'show' ])) {
+            $output .= "{$itemVar}->show = ({$itemVar}->total > 0);\n";
+        }
+        if (isset($itemAttr[ 'iteration' ])) {
+            $output .= "{$itemVar}->iteration = 0;\n";
+        }
+        if (isset($itemAttr[ 'index' ])) {
+            $output .= "{$itemVar}->index = -1;\n";
+        }
+	    $output .= "{$itemVar}->do_else = true;\n";
+        $output .= "if (\$_from !== null) foreach (\$_from as {$keyTerm}{$itemVar}->value) {\n";
+	    $output .= "{$itemVar}->do_else = false;\n";
+        if (isset($attributes[ 'key' ]) && isset($itemAttr[ 'key' ])) {
+            $output .= "\$_smarty_tpl->tpl_vars['{$key}']->value = {$itemVar}->key;\n";
+        }
+        if (isset($itemAttr[ 'iteration' ])) {
+            $output .= "{$itemVar}->iteration++;\n";
+        }
+        if (isset($itemAttr[ 'index' ])) {
+            $output .= "{$itemVar}->index++;\n";
+        }
+        if (isset($itemAttr[ 'first' ])) {
+            $output .= "{$itemVar}->first = !{$itemVar}->index;\n";
+        }
+        if (isset($itemAttr[ 'last' ])) {
+            $output .= "{$itemVar}->last = {$itemVar}->iteration === {$itemVar}->total;\n";
+        }
+        if (isset($foreachVar)) {
+            if (isset($namedAttr[ 'iteration' ])) {
+                $output .= "{$foreachVar}->value['iteration']++;\n";
+            }
+            if (isset($namedAttr[ 'index' ])) {
+                $output .= "{$foreachVar}->value['index']++;\n";
+            }
+            if (isset($namedAttr[ 'first' ])) {
+                $output .= "{$foreachVar}->value['first'] = !{$foreachVar}->value['index'];\n";
+            }
+            if (isset($namedAttr[ 'last' ])) {
+                $output .= "{$foreachVar}->value['last'] = {$foreachVar}->value['iteration'] === {$foreachVar}->value['total'];\n";
+            }
+        }
+        if (!empty($itemAttr)) {
+            $output .= "{$local}saved = {$itemVar};\n";
+        }
+        $output .= '?>';
+        return $output;
+    }
+
+    /**
+     * Compiles code for to restore saved template variables
+     *
+     * @param int $levels number of levels to restore
+     *
+     * @return string compiled code
+     */
+    public function compileRestore($levels)
+    {
+        return "\$_smarty_tpl->smarty->ext->_foreach->restore(\$_smarty_tpl, {$levels});";
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Foreachelse Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Foreachelse extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {foreachelse} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        list($openTag, $nocache, $local, $itemVar, $restore) = $this->closeTag($compiler, array('foreach'));
+        $this->openTag($compiler, 'foreachelse', array('foreachelse', $nocache, $local, $itemVar, 0));
+        $output = "<?php\n";
+        if ($restore === 2) {
+            $output .= "{$itemVar} = {$local}saved;\n";
+        }
+        $output .= "}\nif ({$itemVar}->do_else) {\n?>";
+        return $output;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Foreachclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Foreachclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/foreach} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $compiler->loopNesting--;
+        // must endblock be nocache?
+        if ($compiler->nocache) {
+            $compiler->tag_nocache = true;
+        }
+        list(
+            $openTag, $compiler->nocache, $local, $itemVar, $restore
+            ) = $this->closeTag($compiler, array('foreach', 'foreachelse'));
+        $output = "<?php\n";
+        if ($restore === 2) {
+            $output .= "{$itemVar} = {$local}saved;\n";
+        }
+        $output .= "}\n";
+        /* @var Smarty_Internal_Compile_Foreach $foreachCompiler */
+        $foreachCompiler = $compiler->getTagCompiler('foreach');
+        $output .= $foreachCompiler->compileRestore(1);
+        $output .= "?>";
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_function.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_function.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_function.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_function.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,236 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Function
+ * Compiles the {function} {/function} tags
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Function Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Function extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * Compiles code for the {function} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return bool true
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        if ($_attr[ 'nocache' ] === true) {
+            $compiler->trigger_template_error('nocache option not allowed', null, true);
+        }
+        unset($_attr[ 'nocache' ]);
+        $_name = trim($_attr[ 'name' ], '\'"');
+
+        if (!preg_match('/^[a-zA-Z0-9_\x80-\xff]+$/', $_name)) {
+	        $compiler->trigger_template_error("Function name contains invalid characters: {$_name}", null, true);
+        }
+
+        $compiler->parent_compiler->tpl_function[ $_name ] = array();
+        $save = array(
+            $_attr, $compiler->parser->current_buffer, $compiler->template->compiled->has_nocache_code,
+            $compiler->template->caching
+        );
+        $this->openTag($compiler, 'function', $save);
+        // Init temporary context
+        $compiler->parser->current_buffer = new Smarty_Internal_ParseTree_Template();
+        $compiler->template->compiled->has_nocache_code = false;
+        $compiler->saveRequiredPlugins(true);
+        return true;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Functionclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Functionclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiler object
+     *
+     * @var object
+     */
+    private $compiler = null;
+
+    /**
+     * Compiles code for the {/function} tag
+     *
+     * @param array                                        $args     array with attributes from parser
+     * @param object|\Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return bool true
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $this->compiler = $compiler;
+        $saved_data = $this->closeTag($compiler, array('function'));
+        $_attr = $saved_data[ 0 ];
+        $_name = trim($_attr[ 'name' ], '\'"');
+        $compiler->parent_compiler->tpl_function[ $_name ][ 'compiled_filepath' ] =
+            $compiler->parent_compiler->template->compiled->filepath;
+        $compiler->parent_compiler->tpl_function[ $_name ][ 'uid' ] = $compiler->template->source->uid;
+        $_parameter = $_attr;
+        unset($_parameter[ 'name' ]);
+        // default parameter
+        $_paramsArray = array();
+        foreach ($_parameter as $_key => $_value) {
+            if (is_int($_key)) {
+                $_paramsArray[] = "$_key=>$_value";
+            } else {
+                $_paramsArray[] = "'$_key'=>$_value";
+            }
+        }
+        if (!empty($_paramsArray)) {
+            $_params = 'array(' . implode(',', $_paramsArray) . ')';
+            $_paramsCode = "\$params = array_merge($_params, \$params);\n";
+        } else {
+            $_paramsCode = '';
+        }
+        $_functionCode = $compiler->parser->current_buffer;
+        // setup buffer for template function code
+        $compiler->parser->current_buffer = new Smarty_Internal_ParseTree_Template();
+        $_funcName = "smarty_template_function_{$_name}_{$compiler->template->compiled->nocache_hash}";
+        $_funcNameCaching = $_funcName . '_nocache';
+        if ($compiler->template->compiled->has_nocache_code) {
+            $compiler->parent_compiler->tpl_function[ $_name ][ 'call_name_caching' ] = $_funcNameCaching;
+            $output = "<?php\n";
+            $output .= $compiler->cStyleComment(" {$_funcNameCaching} ") . "\n";
+            $output .= "if (!function_exists('{$_funcNameCaching}')) {\n";
+            $output .= "function {$_funcNameCaching} (Smarty_Internal_Template \$_smarty_tpl,\$params) {\n";
+            $output .= "ob_start();\n";
+            $output .= $compiler->compileRequiredPlugins();
+            $output .= "\$_smarty_tpl->compiled->has_nocache_code = true;\n";
+            $output .= $_paramsCode;
+            $output .= "foreach (\$params as \$key => \$value) {\n\$_smarty_tpl->tpl_vars[\$key] = new Smarty_Variable(\$value, \$_smarty_tpl->isRenderingCache);\n}\n";
+            $output .= "\$params = var_export(\$params, true);\n";
+            $output .= "echo \"/*%%SmartyNocache:{$compiler->template->compiled->nocache_hash}%%*/<?php ";
+            $output .= "\\\$_smarty_tpl->smarty->ext->_tplFunction->saveTemplateVariables(\\\$_smarty_tpl, '{$_name}');\nforeach (\$params as \\\$key => \\\$value) {\n\\\$_smarty_tpl->tpl_vars[\\\$key] = new Smarty_Variable(\\\$value, \\\$_smarty_tpl->isRenderingCache);\n}\n?>";
+            $output .= "/*/%%SmartyNocache:{$compiler->template->compiled->nocache_hash}%%*/\";?>";
+            $compiler->parser->current_buffer->append_subtree(
+                $compiler->parser,
+                new Smarty_Internal_ParseTree_Tag(
+                    $compiler->parser,
+                    $output
+                )
+            );
+            $compiler->parser->current_buffer->append_subtree($compiler->parser, $_functionCode);
+            $output = "<?php echo \"/*%%SmartyNocache:{$compiler->template->compiled->nocache_hash}%%*/<?php ";
+            $output .= "\\\$_smarty_tpl->smarty->ext->_tplFunction->restoreTemplateVariables(\\\$_smarty_tpl, '{$_name}');?>\n";
+            $output .= "/*/%%SmartyNocache:{$compiler->template->compiled->nocache_hash}%%*/\";\n?>";
+            $output .= "<?php echo str_replace('{$compiler->template->compiled->nocache_hash}', \$_smarty_tpl->compiled->nocache_hash, ob_get_clean());\n";
+            $output .= "}\n}\n";
+            $output .= $compiler->cStyleComment("/ {$_funcName}_nocache ") . "\n\n";
+            $output .= "?>\n";
+            $compiler->parser->current_buffer->append_subtree(
+                $compiler->parser,
+                new Smarty_Internal_ParseTree_Tag(
+                    $compiler->parser,
+                    $output
+                )
+            );
+            $_functionCode = new Smarty_Internal_ParseTree_Tag(
+                $compiler->parser,
+                preg_replace_callback(
+                    "/((<\?php )?echo '\/\*%%SmartyNocache:{$compiler->template->compiled->nocache_hash}%%\*\/([\S\s]*?)\/\*\/%%SmartyNocache:{$compiler->template->compiled->nocache_hash}%%\*\/';(\?>\n)?)/",
+                    array($this, 'removeNocache'),
+                    $_functionCode->to_smarty_php($compiler->parser)
+                )
+            );
+        }
+        $compiler->parent_compiler->tpl_function[ $_name ][ 'call_name' ] = $_funcName;
+        $output = "<?php\n";
+        $output .= $compiler->cStyleComment(" {$_funcName} ") . "\n";
+        $output .= "if (!function_exists('{$_funcName}')) {\n";
+        $output .= "function {$_funcName}(Smarty_Internal_Template \$_smarty_tpl,\$params) {\n";
+        $output .= $_paramsCode;
+        $output .= "foreach (\$params as \$key => \$value) {\n\$_smarty_tpl->tpl_vars[\$key] = new Smarty_Variable(\$value, \$_smarty_tpl->isRenderingCache);\n}\n";
+        $output .= $compiler->compileCheckPlugins(array_merge($compiler->required_plugins[ 'compiled' ],
+            $compiler->required_plugins[ 'nocache' ]));
+        $output .= "?>\n";
+        $compiler->parser->current_buffer->append_subtree(
+            $compiler->parser,
+            new Smarty_Internal_ParseTree_Tag(
+                $compiler->parser,
+                $output
+            )
+        );
+        $compiler->parser->current_buffer->append_subtree($compiler->parser, $_functionCode);
+        $output = "<?php\n}}\n";
+        $output .= $compiler->cStyleComment("/ {$_funcName} ") . "\n\n";
+        $output .= "?>\n";
+        $compiler->parser->current_buffer->append_subtree(
+            $compiler->parser,
+            new Smarty_Internal_ParseTree_Tag(
+                $compiler->parser,
+                $output
+            )
+        );
+        $compiler->parent_compiler->blockOrFunctionCode .= $compiler->parser->current_buffer->to_smarty_php($compiler->parser);
+        // restore old buffer
+        $compiler->parser->current_buffer = $saved_data[ 1 ];
+        // restore old status
+        $compiler->restoreRequiredPlugins();
+        $compiler->template->compiled->has_nocache_code = $saved_data[ 2 ];
+        $compiler->template->caching = $saved_data[ 3 ];
+        return true;
+    }
+
+    /**
+     * Remove nocache code
+     *
+     * @param $match
+     *
+     * @return string
+     */
+    public function removeNocache($match)
+    {
+        $code =
+            preg_replace(
+                "/((<\?php )?echo '\/\*%%SmartyNocache:{$this->compiler->template->compiled->nocache_hash}%%\*\/)|(\/\*\/%%SmartyNocache:{$this->compiler->template->compiled->nocache_hash}%%\*\/';(\?>\n)?)/",
+                '',
+                $match[ 0 ]
+            );
+        $code = str_replace(array('\\\'', '\\\\\''), array('\'', '\\\''), $code);
+        return $code;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_if.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_if.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_if.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_if.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,207 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile If
+ * Compiles the {if} {else} {elseif} {/if} tags
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile If Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_If extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {if} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $this->openTag($compiler, 'if', array(1, $compiler->nocache));
+        // must whole block be nocache ?
+        $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        if (!isset($parameter[ 'if condition' ])) {
+            $compiler->trigger_template_error('missing if condition', null, true);
+        }
+        if (is_array($parameter[ 'if condition' ])) {
+            if (is_array($parameter[ 'if condition' ][ 'var' ])) {
+                $var = $parameter[ 'if condition' ][ 'var' ][ 'var' ];
+            } else {
+                $var = $parameter[ 'if condition' ][ 'var' ];
+            }
+            if ($compiler->nocache) {
+                // create nocache var to make it know for further compiling
+                $compiler->setNocacheInVariable($var);
+            }
+            $prefixVar = $compiler->getNewPrefixVariable();
+            $_output = "<?php {$prefixVar} = {$parameter[ 'if condition' ][ 'value' ]};?>\n";
+            $assignAttr = array();
+            $assignAttr[][ 'value' ] = $prefixVar;
+            $assignCompiler = new Smarty_Internal_Compile_Assign();
+            if (is_array($parameter[ 'if condition' ][ 'var' ])) {
+                $assignAttr[][ 'var' ] = $parameter[ 'if condition' ][ 'var' ][ 'var' ];
+                $_output .= $assignCompiler->compile(
+                    $assignAttr,
+                    $compiler,
+                    array('smarty_internal_index' => $parameter[ 'if condition' ][ 'var' ][ 'smarty_internal_index' ])
+                );
+            } else {
+                $assignAttr[][ 'var' ] = $parameter[ 'if condition' ][ 'var' ];
+                $_output .= $assignCompiler->compile($assignAttr, $compiler, array());
+            }
+            $_output .= "<?php if ({$prefixVar}) {?>";
+            return $_output;
+        } else {
+            return "<?php if ({$parameter['if condition']}) {?>";
+        }
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Else Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Else extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {else} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        list($nesting, $compiler->tag_nocache) = $this->closeTag($compiler, array('if', 'elseif'));
+        $this->openTag($compiler, 'else', array($nesting, $compiler->tag_nocache));
+        return '<?php } else { ?>';
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile ElseIf Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Elseif extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {elseif} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        list($nesting, $compiler->tag_nocache) = $this->closeTag($compiler, array('if', 'elseif'));
+        if (!isset($parameter[ 'if condition' ])) {
+            $compiler->trigger_template_error('missing elseif condition', null, true);
+        }
+        $assignCode = '';
+        $var = '';
+        if (is_array($parameter[ 'if condition' ])) {
+            $condition_by_assign = true;
+            if (is_array($parameter[ 'if condition' ][ 'var' ])) {
+                $var = $parameter[ 'if condition' ][ 'var' ][ 'var' ];
+            } else {
+                $var = $parameter[ 'if condition' ][ 'var' ];
+            }
+            if ($compiler->nocache) {
+                // create nocache var to make it know for further compiling
+                $compiler->setNocacheInVariable($var);
+            }
+            $prefixVar = $compiler->getNewPrefixVariable();
+            $assignCode = "<?php {$prefixVar} = {$parameter[ 'if condition' ][ 'value' ]};?>\n";
+            $assignCompiler = new Smarty_Internal_Compile_Assign();
+            $assignAttr = array();
+            $assignAttr[][ 'value' ] = $prefixVar;
+            if (is_array($parameter[ 'if condition' ][ 'var' ])) {
+                $assignAttr[][ 'var' ] = $parameter[ 'if condition' ][ 'var' ][ 'var' ];
+                $assignCode .= $assignCompiler->compile(
+                    $assignAttr,
+                    $compiler,
+                    array('smarty_internal_index' => $parameter[ 'if condition' ][ 'var' ][ 'smarty_internal_index' ])
+                );
+            } else {
+                $assignAttr[][ 'var' ] = $parameter[ 'if condition' ][ 'var' ];
+                $assignCode .= $assignCompiler->compile($assignAttr, $compiler, array());
+            }
+        } else {
+            $condition_by_assign = false;
+        }
+        $prefixCode = $compiler->getPrefixCode();
+        if (empty($prefixCode)) {
+            if ($condition_by_assign) {
+                $this->openTag($compiler, 'elseif', array($nesting + 1, $compiler->tag_nocache));
+                $_output = $compiler->appendCode("<?php } else {\n?>", $assignCode);
+                return $compiler->appendCode($_output, "<?php if ({$prefixVar}) {?>");
+            } else {
+                $this->openTag($compiler, 'elseif', array($nesting, $compiler->tag_nocache));
+                return "<?php } elseif ({$parameter['if condition']}) {?>";
+            }
+        } else {
+            $_output = $compiler->appendCode("<?php } else {\n?>", $prefixCode);
+            $this->openTag($compiler, 'elseif', array($nesting + 1, $compiler->tag_nocache));
+            if ($condition_by_assign) {
+                $_output = $compiler->appendCode($_output, $assignCode);
+                return $compiler->appendCode($_output, "<?php if ({$prefixVar}) {?>");
+            } else {
+                return $compiler->appendCode($_output, "<?php if ({$parameter['if condition']}) {?>");
+            }
+        }
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Ifclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Ifclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/if} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // must endblock be nocache?
+        if ($compiler->nocache) {
+            $compiler->tag_nocache = true;
+        }
+        list($nesting, $compiler->nocache) = $this->closeTag($compiler, array('if', 'else', 'elseif'));
+        $tmp = '';
+        for ($i = 0; $i < $nesting; $i++) {
+            $tmp .= '}';
+        }
+        return "<?php {$tmp}?>";
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_include.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_include.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_include.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_include.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,347 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Include
+ * Compiles the {include} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Include Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Include extends Smarty_Internal_CompileBase
+{
+    /**
+     * caching mode to create nocache code but no cache file
+     */
+    const CACHING_NOCACHE_CODE = 9999;
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('file');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('file');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $option_flags = array('nocache', 'inline', 'caching');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * Valid scope names
+     *
+     * @var array
+     */
+    public $valid_scopes = array(
+        'parent' => Smarty::SCOPE_PARENT, 'root' => Smarty::SCOPE_ROOT,
+        'global' => Smarty::SCOPE_GLOBAL, 'tpl_root' => Smarty::SCOPE_TPL_ROOT,
+        'smarty' => Smarty::SCOPE_SMARTY
+    );
+
+    /**
+     * Compiles code for the {include} tag
+     *
+     * @param array                                  $args     array with attributes from parser
+     * @param Smarty_Internal_SmartyTemplateCompiler $compiler compiler object
+     *
+     * @return string
+     * @throws \Exception
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_SmartyTemplateCompiler $compiler)
+    {
+        $uid = $t_hash = null;
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $fullResourceName = $source_resource = $_attr[ 'file' ];
+        $variable_template = false;
+        $cache_tpl = false;
+        // parse resource_name
+        if (preg_match('/^([\'"])(([A-Za-z0-9_\-]{2,})[:])?(([^$()]+)|(.+))\1$/', $source_resource, $match)) {
+            $type = !empty($match[ 3 ]) ? $match[ 3 ] : $compiler->template->smarty->default_resource_type;
+            $name = !empty($match[ 5 ]) ? $match[ 5 ] : $match[ 6 ];
+            $handler = Smarty_Resource::load($compiler->smarty, $type);
+            if ($handler->recompiled || $handler->uncompiled) {
+                $variable_template = true;
+            }
+            if (!$variable_template) {
+                if ($type !== 'string') {
+                    $fullResourceName = "{$type}:{$name}";
+                    $compiled = $compiler->parent_compiler->template->compiled;
+                    if (isset($compiled->includes[ $fullResourceName ])) {
+                        $compiled->includes[ $fullResourceName ]++;
+                        $cache_tpl = true;
+                    } else {
+                        if ("{$compiler->template->source->type}:{$compiler->template->source->name}" ==
+                            $fullResourceName
+                        ) {
+                            // recursive call of current template
+                            $compiled->includes[ $fullResourceName ] = 2;
+                            $cache_tpl = true;
+                        } else {
+                            $compiled->includes[ $fullResourceName ] = 1;
+                        }
+                    }
+                    $fullResourceName = $match[ 1 ] . $fullResourceName . $match[ 1 ];
+                }
+            }
+            if (empty($match[ 5 ])) {
+                $variable_template = true;
+            }
+        } else {
+            $variable_template = true;
+        }
+        // scope setup
+        $_scope = $compiler->convertScope($_attr, $this->valid_scopes);
+        // set flag to cache subtemplate object when called within loop or template name is variable.
+        if ($cache_tpl || $variable_template || $compiler->loopNesting > 0) {
+            $_cache_tpl = 'true';
+        } else {
+            $_cache_tpl = 'false';
+        }
+        // assume caching is off
+        $_caching = Smarty::CACHING_OFF;
+        $call_nocache = $compiler->tag_nocache || $compiler->nocache;
+        // caching was on and {include} is not in nocache mode
+        if ($compiler->template->caching && !$compiler->nocache && !$compiler->tag_nocache) {
+            $_caching = self::CACHING_NOCACHE_CODE;
+        }
+        // flag if included template code should be merged into caller
+        $merge_compiled_includes = ($compiler->smarty->merge_compiled_includes || $_attr[ 'inline' ] === true) &&
+                                   !$compiler->template->source->handler->recompiled;
+        if ($merge_compiled_includes) {
+            // variable template name ?
+            if ($variable_template) {
+                $merge_compiled_includes = false;
+            }
+            // variable compile_id?
+            if (isset($_attr[ 'compile_id' ]) && $compiler->isVariable($_attr[ 'compile_id' ])) {
+                $merge_compiled_includes = false;
+            }
+        }
+        /*
+        * if the {include} tag provides individual parameter for caching or compile_id
+        * the subtemplate must not be included into the common cache file and is treated like
+        * a call in nocache mode.
+        *
+        */
+        if ($_attr[ 'nocache' ] !== true && $_attr[ 'caching' ]) {
+            $_caching = $_new_caching = (int)$_attr[ 'caching' ];
+            $call_nocache = true;
+        } else {
+            $_new_caching = Smarty::CACHING_LIFETIME_CURRENT;
+        }
+        if (isset($_attr[ 'cache_lifetime' ])) {
+            $_cache_lifetime = $_attr[ 'cache_lifetime' ];
+            $call_nocache = true;
+            $_caching = $_new_caching;
+        } else {
+            $_cache_lifetime = '$_smarty_tpl->cache_lifetime';
+        }
+        if (isset($_attr[ 'cache_id' ])) {
+            $_cache_id = $_attr[ 'cache_id' ];
+            $call_nocache = true;
+            $_caching = $_new_caching;
+        } else {
+            $_cache_id = '$_smarty_tpl->cache_id';
+        }
+        if (isset($_attr[ 'compile_id' ])) {
+            $_compile_id = $_attr[ 'compile_id' ];
+        } else {
+            $_compile_id = '$_smarty_tpl->compile_id';
+        }
+        // if subtemplate will be called in nocache mode do not merge
+        if ($compiler->template->caching && $call_nocache) {
+            $merge_compiled_includes = false;
+        }
+        // assign attribute
+        if (isset($_attr[ 'assign' ])) {
+            // output will be stored in a smarty variable instead of being displayed
+            if ($_assign = $compiler->getId($_attr[ 'assign' ])) {
+                $_assign = "'{$_assign}'";
+                if ($compiler->tag_nocache || $compiler->nocache || $call_nocache) {
+                    // create nocache var to make it know for further compiling
+                    $compiler->setNocacheInVariable($_attr[ 'assign' ]);
+                }
+            } else {
+                $_assign = $_attr[ 'assign' ];
+            }
+        }
+        $has_compiled_template = false;
+        if ($merge_compiled_includes) {
+            $c_id = isset($_attr[ 'compile_id' ]) ? $_attr[ 'compile_id' ] : $compiler->template->compile_id;
+            // we must observe different compile_id and caching
+            $t_hash = sha1($c_id . ($_caching ? '--caching' : '--nocaching'));
+            $compiler->smarty->allow_ambiguous_resources = true;
+            /* @var Smarty_Internal_Template $tpl */
+            $tpl = new $compiler->smarty->template_class(
+                trim($fullResourceName, '"\''),
+                $compiler->smarty,
+                $compiler->template,
+                $compiler->template->cache_id,
+                $c_id,
+                $_caching
+            );
+            $uid = $tpl->source->type . $tpl->source->uid;
+            if (!isset($compiler->parent_compiler->mergedSubTemplatesData[ $uid ][ $t_hash ])) {
+                $has_compiled_template = $this->compileInlineTemplate($compiler, $tpl, $t_hash);
+            } else {
+                $has_compiled_template = true;
+            }
+            unset($tpl);
+        }
+        // delete {include} standard attributes
+        unset($_attr[ 'file' ], $_attr[ 'assign' ], $_attr[ 'cache_id' ], $_attr[ 'compile_id' ], $_attr[ 'cache_lifetime' ], $_attr[ 'nocache' ], $_attr[ 'caching' ], $_attr[ 'scope' ], $_attr[ 'inline' ]);
+        // remaining attributes must be assigned as smarty variable
+        $_vars = 'array()';
+        if (!empty($_attr)) {
+            $_pairs = array();
+            // create variables
+            foreach ($_attr as $key => $value) {
+                $_pairs[] = "'$key'=>$value";
+            }
+            $_vars = 'array(' . join(',', $_pairs) . ')';
+        }
+        $update_compile_id = $compiler->template->caching && !$compiler->tag_nocache && !$compiler->nocache &&
+                             $_compile_id !== '$_smarty_tpl->compile_id';
+        if ($has_compiled_template && !$call_nocache) {
+            $_output = "<?php\n";
+            if ($update_compile_id) {
+                $_output .= $compiler->makeNocacheCode("\$_compile_id_save[] = \$_smarty_tpl->compile_id;\n\$_smarty_tpl->compile_id = {$_compile_id};\n");
+            }
+            if (!empty($_attr) && $_caching === 9999 && $compiler->template->caching) {
+                $_vars_nc = "foreach ($_vars as \$ik => \$iv) {\n";
+                $_vars_nc .= "\$_smarty_tpl->tpl_vars[\$ik] =  new Smarty_Variable(\$iv);\n";
+                $_vars_nc .= "}\n";
+                $_output .= substr($compiler->processNocacheCode('<?php ' . $_vars_nc . "?>\n", true), 6, -3);
+            }
+            if (isset($_assign)) {
+                $_output .= "ob_start();\n";
+            }
+            $_output .= "\$_smarty_tpl->_subTemplateRender({$fullResourceName}, {$_cache_id}, {$_compile_id}, {$_caching}, {$_cache_lifetime}, {$_vars}, {$_scope}, {$_cache_tpl}, '{$compiler->parent_compiler->mergedSubTemplatesData[$uid][$t_hash]['uid']}', '{$compiler->parent_compiler->mergedSubTemplatesData[$uid][$t_hash]['func']}');\n";
+            if (isset($_assign)) {
+                $_output .= "\$_smarty_tpl->assign({$_assign}, ob_get_clean());\n";
+            }
+            if ($update_compile_id) {
+                $_output .= $compiler->makeNocacheCode("\$_smarty_tpl->compile_id = array_pop(\$_compile_id_save);\n");
+            }
+            $_output .= "?>";
+            return $_output;
+        }
+        if ($call_nocache) {
+            $compiler->tag_nocache = true;
+        }
+        $_output = "<?php ";
+        if ($update_compile_id) {
+            $_output .= "\$_compile_id_save[] = \$_smarty_tpl->compile_id;\n\$_smarty_tpl->compile_id = {$_compile_id};\n";
+        }
+        // was there an assign attribute
+        if (isset($_assign)) {
+            $_output .= "ob_start();\n";
+        }
+        $_output .= "\$_smarty_tpl->_subTemplateRender({$fullResourceName}, $_cache_id, $_compile_id, $_caching, $_cache_lifetime, $_vars, $_scope, {$_cache_tpl});\n";
+        if (isset($_assign)) {
+            $_output .= "\$_smarty_tpl->assign({$_assign}, ob_get_clean());\n";
+        }
+        if ($update_compile_id) {
+            $_output .= "\$_smarty_tpl->compile_id = array_pop(\$_compile_id_save);\n";
+        }
+        $_output .= "?>";
+        return $_output;
+    }
+
+    /**
+     * Compile inline sub template
+     *
+     * @param \Smarty_Internal_SmartyTemplateCompiler $compiler
+     * @param \Smarty_Internal_Template               $tpl
+     * @param string                                  $t_hash
+     *
+     * @return bool
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function compileInlineTemplate(
+        Smarty_Internal_SmartyTemplateCompiler $compiler,
+        Smarty_Internal_Template $tpl,
+        $t_hash
+    ) {
+        $uid = $tpl->source->type . $tpl->source->uid;
+        if (!($tpl->source->handler->uncompiled) && $tpl->source->exists) {
+            $compiler->parent_compiler->mergedSubTemplatesData[ $uid ][ $t_hash ][ 'uid' ] = $tpl->source->uid;
+            if (isset($compiler->template->inheritance)) {
+                $tpl->inheritance = clone $compiler->template->inheritance;
+            }
+            $tpl->compiled = new Smarty_Template_Compiled();
+            $tpl->compiled->nocache_hash = $compiler->parent_compiler->template->compiled->nocache_hash;
+            $tpl->loadCompiler();
+            // save unique function name
+            $compiler->parent_compiler->mergedSubTemplatesData[ $uid ][ $t_hash ][ 'func' ] =
+            $tpl->compiled->unifunc = 'content_' . str_replace(array('.', ','), '_', uniqid('', true));
+            // make sure whole chain gets compiled
+            $tpl->mustCompile = true;
+            $compiler->parent_compiler->mergedSubTemplatesData[ $uid ][ $t_hash ][ 'nocache_hash' ] =
+                $tpl->compiled->nocache_hash;
+            if ($tpl->source->type === 'file') {
+                $sourceInfo = $tpl->source->filepath;
+            } else {
+                $basename = $tpl->source->handler->getBasename($tpl->source);
+                $sourceInfo = $tpl->source->type . ':' .
+                              ($basename ? $basename : $tpl->source->name);
+            }
+            // get compiled code
+            $compiled_code = "<?php\n\n";
+            $compiled_code .= $compiler->cStyleComment(" Start inline template \"{$sourceInfo}\" =============================") . "\n";
+            $compiled_code .= "function {$tpl->compiled->unifunc} (Smarty_Internal_Template \$_smarty_tpl) {\n";
+            $compiled_code .= "?>\n" . $tpl->compiler->compileTemplateSource($tpl, null, $compiler->parent_compiler);
+            $compiled_code .= "<?php\n";
+            $compiled_code .= "}\n?>\n";
+            $compiled_code .= $tpl->compiler->postFilter($tpl->compiler->blockOrFunctionCode);
+            $compiled_code .= "<?php\n\n";
+            $compiled_code .= $compiler->cStyleComment(" End inline template \"{$sourceInfo}\" =============================") . "\n";
+            $compiled_code .= '?>';
+            unset($tpl->compiler);
+            if ($tpl->compiled->has_nocache_code) {
+                // replace nocache_hash
+                $compiled_code =
+                    str_replace(
+                        "{$tpl->compiled->nocache_hash}",
+                        $compiler->template->compiled->nocache_hash,
+                        $compiled_code
+                    );
+                $compiler->template->compiled->has_nocache_code = true;
+            }
+            $compiler->parent_compiler->mergedSubTemplatesCode[ $tpl->compiled->unifunc ] = $compiled_code;
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_include_php.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_include_php.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_include_php.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_include_php.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,110 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Include PHP
+ * Compiles the {include_php} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Insert Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Include_Php extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('file');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('file');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('once', 'assign');
+
+    /**
+     * Compiles code for the {include_php} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        if (!($compiler->smarty instanceof SmartyBC)) {
+            throw new SmartyException("{include_php} is deprecated, use SmartyBC class to enable");
+        }
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        /**
+         *
+         *
+         * @var Smarty_Internal_Template $_smarty_tpl
+         * used in evaluated code
+         */
+        $_smarty_tpl = $compiler->template;
+        $_filepath = false;
+        $_file = null;
+        eval('$_file = @' . $_attr[ 'file' ] . ';');
+        if (!isset($compiler->smarty->security_policy) && file_exists($_file)) {
+            $_filepath = $compiler->smarty->_realpath($_file, true);
+        } else {
+            if (isset($compiler->smarty->security_policy)) {
+                $_dir = $compiler->smarty->security_policy->trusted_dir;
+            } else {
+                $_dir = $compiler->smarty->trusted_dir;
+            }
+            if (!empty($_dir)) {
+                foreach ((array)$_dir as $_script_dir) {
+                    $_path = $compiler->smarty->_realpath($_script_dir . DIRECTORY_SEPARATOR . $_file, true);
+                    if (file_exists($_path)) {
+                        $_filepath = $_path;
+                        break;
+                    }
+                }
+            }
+        }
+        if ($_filepath === false) {
+            $compiler->trigger_template_error("{include_php} file '{$_file}' is not readable", null, true);
+        }
+        if (isset($compiler->smarty->security_policy)) {
+            $compiler->smarty->security_policy->isTrustedPHPDir($_filepath);
+        }
+        if (isset($_attr[ 'assign' ])) {
+            // output will be stored in a smarty variable instead of being displayed
+            $_assign = $_attr[ 'assign' ];
+        }
+        $_once = '_once';
+        if (isset($_attr[ 'once' ])) {
+            if ($_attr[ 'once' ] === 'false') {
+                $_once = '';
+            }
+        }
+        if (isset($_assign)) {
+            return "<?php ob_start();\ninclude{$_once} ('{$_filepath}');\n\$_smarty_tpl->assign({$_assign},ob_get_clean());\n?>";
+        } else {
+            return "<?php include{$_once} ('{$_filepath}');?>\n";
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_insert.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_insert.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_insert.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_insert.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,157 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Insert
+ * Compiles the {insert} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Insert Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Insert extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('name');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * Compiles code for the {insert} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $nocacheParam = $compiler->template->caching && ($compiler->tag_nocache || $compiler->nocache);
+        if (!$nocacheParam) {
+            // do not compile as nocache code
+            $compiler->suppressNocacheProcessing = true;
+        }
+        $compiler->tag_nocache = true;
+        $_smarty_tpl = $compiler->template;
+        $_name = null;
+        $_script = null;
+        $_output = '<?php ';
+        // save possible attributes
+        eval('$_name = @' . $_attr[ 'name' ] . ';');
+        if (isset($_attr[ 'assign' ])) {
+            // output will be stored in a smarty variable instead of being displayed
+            $_assign = $_attr[ 'assign' ];
+            // create variable to make sure that the compiler knows about its nocache status
+            $var = trim($_attr[ 'assign' ], '\'');
+            if (isset($compiler->template->tpl_vars[ $var ])) {
+                $compiler->template->tpl_vars[ $var ]->nocache = true;
+            } else {
+                $compiler->template->tpl_vars[ $var ] = new Smarty_Variable(null, true);
+            }
+        }
+        if (isset($_attr[ 'script' ])) {
+            // script which must be included
+            $_function = "smarty_insert_{$_name}";
+            $_smarty_tpl = $compiler->template;
+            $_filepath = false;
+            eval('$_script = @' . $_attr[ 'script' ] . ';');
+            if (!isset($compiler->smarty->security_policy) && file_exists($_script)) {
+                $_filepath = $_script;
+            } else {
+                if (isset($compiler->smarty->security_policy)) {
+                    $_dir = $compiler->smarty->security_policy->trusted_dir;
+                } else {
+                    $_dir = $compiler->smarty instanceof SmartyBC ? $compiler->smarty->trusted_dir : null;
+                }
+                if (!empty($_dir)) {
+                    foreach ((array)$_dir as $_script_dir) {
+                        $_script_dir = rtrim($_script_dir, '/\\') . DIRECTORY_SEPARATOR;
+                        if (file_exists($_script_dir . $_script)) {
+                            $_filepath = $_script_dir . $_script;
+                            break;
+                        }
+                    }
+                }
+            }
+            if ($_filepath === false) {
+                $compiler->trigger_template_error("{insert} missing script file '{$_script}'", null, true);
+            }
+            // code for script file loading
+            $_output .= "require_once '{$_filepath}' ;";
+            include_once $_filepath;
+            if (!is_callable($_function)) {
+                $compiler->trigger_template_error(
+                    " {insert} function '{$_function}' is not callable in script file '{$_script}'",
+                    null,
+                    true
+                );
+            }
+        } else {
+            $_filepath = 'null';
+            $_function = "insert_{$_name}";
+            // function in PHP script ?
+            if (!is_callable($_function)) {
+                // try plugin
+                if (!$_function = $compiler->getPlugin($_name, 'insert')) {
+                    $compiler->trigger_template_error(
+                        "{insert} no function or plugin found for '{$_name}'",
+                        null,
+                        true
+                    );
+                }
+            }
+        }
+        // delete {insert} standard attributes
+        unset($_attr[ 'name' ], $_attr[ 'assign' ], $_attr[ 'script' ], $_attr[ 'nocache' ]);
+        // convert attributes into parameter array string
+        $_paramsArray = array();
+        foreach ($_attr as $_key => $_value) {
+            $_paramsArray[] = "'$_key' => $_value";
+        }
+        $_params = 'array(' . implode(", ", $_paramsArray) . ')';
+        // call insert
+        if (isset($_assign)) {
+            if ($_smarty_tpl->caching && !$nocacheParam) {
+                $_output .= "echo Smarty_Internal_Nocache_Insert::compile ('{$_function}',{$_params}, \$_smarty_tpl, '{$_filepath}',{$_assign});?>";
+            } else {
+                $_output .= "\$_smarty_tpl->assign({$_assign} , {$_function} ({$_params},\$_smarty_tpl), true);?>";
+            }
+        } else {
+            if ($_smarty_tpl->caching && !$nocacheParam) {
+                $_output .= "echo Smarty_Internal_Nocache_Insert::compile ('{$_function}',{$_params}, \$_smarty_tpl, '{$_filepath}');?>";
+            } else {
+                $_output .= "echo {$_function}({$_params},\$_smarty_tpl);?>";
+            }
+        }
+        $compiler->template->compiled->has_nocache_code = true;
+        return $_output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_ldelim.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_ldelim.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_ldelim.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_ldelim.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,37 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Ldelim
+ * Compiles the {ldelim} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Ldelim Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Ldelim extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {ldelim} tag
+     * This tag does output the left delimiter
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $_attr = $this->getAttributes($compiler, $args);
+        if ($_attr[ 'nocache' ] === true) {
+            $compiler->trigger_template_error('nocache option not allowed', null, true);
+        }
+        return $compiler->smarty->left_delimiter;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_make_nocache.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_make_nocache.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_make_nocache.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_make_nocache.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,62 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Make_Nocache
+ * Compiles the {make_nocache} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Make_Nocache Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Make_Nocache extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $option_flags = array();
+
+    /**
+     * Array of names of required attribute required by tag
+     *
+     * @var array
+     */
+    public $required_attributes = array('var');
+
+    /**
+     * Shorttag attribute order defined by its names
+     *
+     * @var array
+     */
+    public $shorttag_order = array('var');
+
+    /**
+     * Compiles code for the {make_nocache} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        if ($compiler->template->caching) {
+            $output = "<?php \$_smarty_tpl->smarty->ext->_make_nocache->save(\$_smarty_tpl, {$_attr[ 'var' ]});\n?>\n";
+            $compiler->template->compiled->has_nocache_code = true;
+            $compiler->suppressNocacheProcessing = true;
+            return $output;
+        } else {
+            return true;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_nocache.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_nocache.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_nocache.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_nocache.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,73 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Nocache
+ * Compiles the {nocache} {/nocache} tags.
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Nocache Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Nocache extends Smarty_Internal_CompileBase
+{
+    /**
+     * Array of names of valid option flags
+     *
+     * @var array
+     */
+    public $option_flags = array();
+
+    /**
+     * Compiles code for the {nocache} tag
+     * This tag does not generate compiled output. It only sets a compiler flag.
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return bool
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $_attr = $this->getAttributes($compiler, $args);
+        $this->openTag($compiler, 'nocache', array($compiler->nocache));
+        // enter nocache mode
+        $compiler->nocache = true;
+        // this tag does not return compiled code
+        $compiler->has_code = false;
+        return true;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Nocacheclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Nocacheclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/nocache} tag
+     * This tag does not generate compiled output. It only sets a compiler flag.
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return bool
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $_attr = $this->getAttributes($compiler, $args);
+        // leave nocache mode
+        list($compiler->nocache) = $this->closeTag($compiler, array('nocache'));
+        // this tag does not return compiled code
+        $compiler->has_code = false;
+        return true;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_parent.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_parent.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_parent.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_parent.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,31 @@
+<?php
+/**
+ * This file is part of Smarty.
+ *
+ * (c) 2015 Uwe Tews
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * Smarty Internal Plugin Compile Parent Class
+ *
+ * @author Uwe Tews <uwe.tews@googlemail.com>
+ */
+class Smarty_Internal_Compile_Parent extends Smarty_Internal_Compile_Child
+{
+    /**
+     * Tag name
+     *
+     * @var string
+     */
+    public $tag = 'parent';
+
+    /**
+     * Block type
+     *
+     * @var string
+     */
+    public $blockType = 'Parent';
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_block_plugin.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_block_plugin.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_block_plugin.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_block_plugin.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,124 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Block Plugin
+ * Compiles code for the execution of block plugin
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Block Plugin Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Block_Plugin extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * nesting level
+     *
+     * @var int
+     */
+    public $nesting = 0;
+
+    /**
+     * Compiles code for the execution of block plugin
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     * @param string                                $tag       name of block plugin
+     * @param string                                $function  PHP function name
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter, $tag, $function = null)
+    {
+        if (!isset($tag[ 5 ]) || substr($tag, -5) !== 'close') {
+            // opening tag of block plugin
+            // check and get attributes
+            $_attr = $this->getAttributes($compiler, $args);
+            $this->nesting++;
+            unset($_attr[ 'nocache' ]);
+            list($callback, $_paramsArray, $callable) = $this->setup($compiler, $_attr, $tag, $function);
+            $_params = 'array(' . implode(',', $_paramsArray) . ')';
+            // compile code
+            $output = "<?php ";
+            if (is_array($callback)) {
+                $output .= "\$_block_plugin{$this->nesting} = isset({$callback[0]}) ? {$callback[0]} : null;\n";
+                $callback = "\$_block_plugin{$this->nesting}{$callback[1]}";
+            }
+            if (isset($callable)) {
+                $output .= "if (!is_callable({$callable})) {\nthrow new SmartyException('block tag \'{$tag}\' not callable or registered');\n}\n";
+            }
+            $output .= "\$_smarty_tpl->smarty->_cache['_tag_stack'][] = array('{$tag}', {$_params});\n";
+            $output .= "\$_block_repeat=true;\necho {$callback}({$_params}, null, \$_smarty_tpl, \$_block_repeat);\nwhile (\$_block_repeat) {\nob_start();?>";
+            $this->openTag($compiler, $tag, array($_params, $compiler->nocache, $callback));
+            // maybe nocache because of nocache variables or nocache plugin
+            $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        } else {
+            // must endblock be nocache?
+            if ($compiler->nocache) {
+                $compiler->tag_nocache = true;
+            }
+            // closing tag of block plugin, restore nocache
+            list($_params, $compiler->nocache, $callback) = $this->closeTag($compiler, substr($tag, 0, -5));
+            // compile code
+            if (!isset($parameter[ 'modifier_list' ])) {
+                $mod_pre = $mod_post = $mod_content = '';
+                $mod_content2 = 'ob_get_clean()';
+            } else {
+                $mod_content2 = "\$_block_content{$this->nesting}";
+                $mod_content = "\$_block_content{$this->nesting} = ob_get_clean();\n";
+                $mod_pre = "ob_start();\n";
+                $mod_post = 'echo ' . $compiler->compileTag(
+                        'private_modifier',
+                        array(),
+                        array(
+                            'modifierlist' => $parameter[ 'modifier_list' ],
+                            'value'        => 'ob_get_clean()'
+                        )
+                    ) . ";\n";
+            }
+            $output =
+                "<?php {$mod_content}\$_block_repeat=false;\n{$mod_pre}echo {$callback}({$_params}, {$mod_content2}, \$_smarty_tpl, \$_block_repeat);\n{$mod_post}}\n";
+            $output .= 'array_pop($_smarty_tpl->smarty->_cache[\'_tag_stack\']);?>';
+        }
+        return $output;
+    }
+
+    /**
+     * Setup callback and parameter array
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     * @param array                                 $_attr attributes
+     * @param string                                $tag
+     * @param string                                $function
+     *
+     * @return array
+     */
+    public function setup(Smarty_Internal_TemplateCompilerBase $compiler, $_attr, $tag, $function)
+    {
+        $_paramsArray = array();
+        foreach ($_attr as $_key => $_value) {
+            if (is_int($_key)) {
+                $_paramsArray[] = "$_key=>$_value";
+            } else {
+                $_paramsArray[] = "'$_key'=>$_value";
+            }
+        }
+        return array($function, $_paramsArray, null);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_foreachsection.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_foreachsection.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_foreachsection.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_foreachsection.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,228 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile ForeachSection
+ * Shared methods for {foreach} {section} tags
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile ForeachSection Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_ForeachSection extends Smarty_Internal_CompileBase
+{
+    /**
+     * Name of this tag
+     *
+     * @var string
+     */
+    public $tagName = '';
+
+    /**
+     * Valid properties of $smarty.xxx variable
+     *
+     * @var array
+     */
+    public $nameProperties = array();
+
+    /**
+     * {section} tag has no item properties
+     *
+     * @var array
+     */
+    public $itemProperties = null;
+
+    /**
+     * {section} tag has always name attribute
+     *
+     * @var bool
+     */
+    public $isNamed = true;
+
+    /**
+     * @var array
+     */
+    public $matchResults = array();
+
+    /**
+     * Preg search pattern
+     *
+     * @var string
+     */
+    private $propertyPreg = '';
+
+    /**
+     * Offsets in preg match result
+     *
+     * @var array
+     */
+    private $resultOffsets = array();
+
+    /**
+     * Start offset
+     *
+     * @var int
+     */
+    private $startOffset = 0;
+
+    /**
+     * Scan sources for used tag attributes
+     *
+     * @param array                                 $attributes
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     *
+     * @throws \SmartyException
+     */
+    public function scanForProperties($attributes, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $this->propertyPreg = '~(';
+        $this->startOffset = 1;
+        $this->resultOffsets = array();
+        $this->matchResults = array('named' => array(), 'item' => array());
+        if (isset($attributes[ 'name' ])) {
+            $this->buildPropertyPreg(true, $attributes);
+        }
+        if (isset($this->itemProperties)) {
+            if ($this->isNamed) {
+                $this->propertyPreg .= '|';
+            }
+            $this->buildPropertyPreg(false, $attributes);
+        }
+        $this->propertyPreg .= ')\W~i';
+        // Template source
+        $this->matchTemplateSource($compiler);
+        // Parent template source
+        $this->matchParentTemplateSource($compiler);
+        // {block} source
+        $this->matchBlockSource($compiler);
+    }
+
+    /**
+     * Build property preg string
+     *
+     * @param bool  $named
+     * @param array $attributes
+     */
+    public function buildPropertyPreg($named, $attributes)
+    {
+        if ($named) {
+            $this->resultOffsets[ 'named' ] = $this->startOffset = $this->startOffset + 3;
+            $this->propertyPreg .= "(([\$]smarty[.]{$this->tagName}[.]" .
+                                   ($this->tagName === 'section' ? "|[\[]\s*" : '') .
+                                   "){$attributes['name']}[.](";
+            $properties = $this->nameProperties;
+        } else {
+            $this->resultOffsets[ 'item' ] = $this->startOffset = $this->startOffset + 2;
+            $this->propertyPreg .= "([\$]{$attributes['item']}[@](";
+            $properties = $this->itemProperties;
+        }
+        $propName = reset($properties);
+        while ($propName) {
+            $this->propertyPreg .= "{$propName}";
+            $propName = next($properties);
+            if ($propName) {
+                $this->propertyPreg .= '|';
+            }
+        }
+        $this->propertyPreg .= '))';
+    }
+
+    /**
+     * Find matches in source string
+     *
+     * @param string $source
+     */
+    public function matchProperty($source)
+    {
+        preg_match_all($this->propertyPreg, $source, $match);
+        foreach ($this->resultOffsets as $key => $offset) {
+            foreach ($match[ $offset ] as $m) {
+                if (!empty($m)) {
+                    $this->matchResults[ $key ][ strtolower($m) ] = true;
+                }
+            }
+        }
+    }
+
+    /**
+     * Find matches in template source
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     */
+    public function matchTemplateSource(Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $this->matchProperty($compiler->parser->lex->data);
+    }
+
+    /**
+     * Find matches in all parent template source
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     *
+     * @throws \SmartyException
+     */
+    public function matchParentTemplateSource(Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // search parent compiler template source
+        $nextCompiler = $compiler;
+        while ($nextCompiler !== $nextCompiler->parent_compiler) {
+            $nextCompiler = $nextCompiler->parent_compiler;
+            if ($compiler !== $nextCompiler) {
+                // get template source
+                $_content = $nextCompiler->template->source->getContent();
+                if ($_content !== '') {
+                    // run pre filter if required
+                    if ((isset($nextCompiler->smarty->autoload_filters[ 'pre' ]) ||
+                         isset($nextCompiler->smarty->registered_filters[ 'pre' ]))
+                    ) {
+                        $_content = $nextCompiler->smarty->ext->_filterHandler->runFilter(
+                            'pre',
+                            $_content,
+                            $nextCompiler->template
+                        );
+                    }
+                    $this->matchProperty($_content);
+                }
+            }
+        }
+    }
+
+    /**
+     * Find matches in {block} tag source
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     */
+    public function matchBlockSource(Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+    }
+
+    /**
+     * Compiles code for the {$smarty.foreach.xxx} or {$smarty.section.xxx}tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compileSpecialVariable($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        $tag = strtolower(trim($parameter[ 0 ], '"\''));
+        $name = isset($parameter[ 1 ]) ? $compiler->getId($parameter[ 1 ]) : false;
+        if (!$name) {
+            $compiler->trigger_template_error("missing or illegal \$smarty.{$tag} name attribute", null, true);
+        }
+        $property = isset($parameter[ 2 ]) ? strtolower($compiler->getId($parameter[ 2 ])) : false;
+        if (!$property || !in_array($property, $this->nameProperties)) {
+            $compiler->trigger_template_error("missing or illegal \$smarty.{$tag} property attribute", null, true);
+        }
+        $tagVar = "'__smarty_{$tag}_{$name}'";
+        return "(isset(\$_smarty_tpl->tpl_vars[{$tagVar}]->value['{$property}']) ? \$_smarty_tpl->tpl_vars[{$tagVar}]->value['{$property}'] : null)";
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_function_plugin.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_function_plugin.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_function_plugin.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_function_plugin.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,78 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Function Plugin
+ * Compiles code for the execution of function plugin
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Function Plugin Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Function_Plugin extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array();
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * Compiles code for the execution of function plugin
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     * @param string                                $tag       name of function plugin
+     * @param string                                $function  PHP function name
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter, $tag, $function)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        unset($_attr[ 'nocache' ]);
+        // convert attributes into parameter array string
+        $_paramsArray = array();
+        foreach ($_attr as $_key => $_value) {
+            if (is_int($_key)) {
+                $_paramsArray[] = "$_key=>$_value";
+            } else {
+                $_paramsArray[] = "'$_key'=>$_value";
+            }
+        }
+        $_params = 'array(' . implode(',', $_paramsArray) . ')';
+        // compile code
+        $output = "{$function}({$_params},\$_smarty_tpl)";
+        if (!empty($parameter[ 'modifierlist' ])) {
+            $output = $compiler->compileTag(
+                'private_modifier',
+                array(),
+                array(
+                    'modifierlist' => $parameter[ 'modifierlist' ],
+                    'value'        => $output
+                )
+            );
+        }
+        $output = "<?php echo {$output};?>\n";
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_modifier.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_modifier.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_modifier.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_modifier.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,158 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Modifier
+ * Compiles code for modifier execution
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Modifier Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Modifier extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for modifier execution
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $output = $parameter[ 'value' ];
+        // loop over list of modifiers
+        foreach ($parameter[ 'modifierlist' ] as $single_modifier) {
+            /* @var string $modifier */
+            $modifier = $single_modifier[ 0 ];
+            $single_modifier[ 0 ] = $output;
+            $params = implode(',', $single_modifier);
+            // check if we know already the type of modifier
+            if (isset($compiler->known_modifier_type[ $modifier ])) {
+                $modifier_types = array($compiler->known_modifier_type[ $modifier ]);
+            } else {
+                $modifier_types = array(1, 2, 3, 4, 5, 6);
+            }
+            foreach ($modifier_types as $type) {
+                switch ($type) {
+                    case 1:
+                        // registered modifier
+                        if (isset($compiler->smarty->registered_plugins[ Smarty::PLUGIN_MODIFIER ][ $modifier ])) {
+                            if (is_callable($compiler->smarty->registered_plugins[ Smarty::PLUGIN_MODIFIER ][ $modifier ][ 0 ])) {
+                                $output =
+                                    sprintf(
+                                        'call_user_func_array($_smarty_tpl->registered_plugins[ \'%s\' ][ %s ][ 0 ], array( %s ))',
+                                        Smarty::PLUGIN_MODIFIER,
+                                        var_export($modifier, true),
+                                        $params
+                                    );
+                                $compiler->known_modifier_type[ $modifier ] = $type;
+                                break 2;
+                            }
+                        }
+                        break;
+                    case 2:
+                        // registered modifier compiler
+                        if (isset($compiler->smarty->registered_plugins[ Smarty::PLUGIN_MODIFIERCOMPILER ][ $modifier ][ 0 ])) {
+                            $output =
+                                call_user_func(
+                                    $compiler->smarty->registered_plugins[ Smarty::PLUGIN_MODIFIERCOMPILER ][ $modifier ][ 0 ],
+                                    $single_modifier,
+                                    $compiler->smarty
+                                );
+                            $compiler->known_modifier_type[ $modifier ] = $type;
+                            break 2;
+                        }
+                        break;
+                    case 3:
+                        // modifiercompiler plugin
+                        if ($compiler->smarty->loadPlugin('smarty_modifiercompiler_' . $modifier)) {
+                            // check if modifier allowed
+                            if (!is_object($compiler->smarty->security_policy)
+                                || $compiler->smarty->security_policy->isTrustedModifier($modifier, $compiler)
+                            ) {
+                                $plugin = 'smarty_modifiercompiler_' . $modifier;
+                                $output = $plugin($single_modifier, $compiler);
+                            }
+                            $compiler->known_modifier_type[ $modifier ] = $type;
+                            break 2;
+                        }
+                        break;
+                    case 4:
+                        // modifier plugin
+                        if ($function = $compiler->getPlugin($modifier, Smarty::PLUGIN_MODIFIER)) {
+                            // check if modifier allowed
+                            if (!is_object($compiler->smarty->security_policy)
+                                || $compiler->smarty->security_policy->isTrustedModifier($modifier, $compiler)
+                            ) {
+                                $output = "{$function}({$params})";
+                            }
+                            $compiler->known_modifier_type[ $modifier ] = $type;
+                            break 2;
+                        }
+                        break;
+                    case 5:
+                        // PHP function
+                        if (is_callable($modifier)) {
+                            // check if modifier allowed
+                            if (!is_object($compiler->smarty->security_policy)
+                                || $compiler->smarty->security_policy->isTrustedPhpModifier($modifier, $compiler)
+                            ) {
+                                $output = "{$modifier}({$params})";
+                            }
+                            $compiler->known_modifier_type[ $modifier ] = $type;
+                            break 2;
+                        }
+                        break;
+                    case 6:
+                        // default plugin handler
+                        if (isset($compiler->default_handler_plugins[ Smarty::PLUGIN_MODIFIER ][ $modifier ])
+                            || (is_callable($compiler->smarty->default_plugin_handler_func)
+                                && $compiler->getPluginFromDefaultHandler($modifier, Smarty::PLUGIN_MODIFIER))
+                        ) {
+                            $function = $compiler->default_handler_plugins[ Smarty::PLUGIN_MODIFIER ][ $modifier ][ 0 ];
+                            // check if modifier allowed
+                            if (!is_object($compiler->smarty->security_policy)
+                                || $compiler->smarty->security_policy->isTrustedModifier($modifier, $compiler)
+                            ) {
+                                if (!is_array($function)) {
+                                    $output = "{$function}({$params})";
+                                } else {
+                                    if (is_object($function[ 0 ])) {
+                                        $output = $function[ 0 ] . '->' . $function[ 1 ] . '(' . $params . ')';
+                                    } else {
+                                        $output = $function[ 0 ] . '::' . $function[ 1 ] . '(' . $params . ')';
+                                    }
+                                }
+                            }
+                            if (isset($compiler->required_plugins[ 'nocache' ][ $modifier ][ Smarty::PLUGIN_MODIFIER ][ 'file' ])
+                                ||
+                                isset($compiler->required_plugins[ 'compiled' ][ $modifier ][ Smarty::PLUGIN_MODIFIER ][ 'file' ])
+                            ) {
+                                // was a plugin
+                                $compiler->known_modifier_type[ $modifier ] = 4;
+                            } else {
+                                $compiler->known_modifier_type[ $modifier ] = $type;
+                            }
+                            break 2;
+                        }
+                }
+            }
+            if (!isset($compiler->known_modifier_type[ $modifier ])) {
+                $compiler->trigger_template_error("unknown modifier '{$modifier}'", null, true);
+            }
+        }
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_block_function.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_block_function.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_block_function.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_block_function.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,42 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Object Block Function
+ * Compiles code for registered objects as block function
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Object Block Function Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Object_Block_Function extends Smarty_Internal_Compile_Private_Block_Plugin
+{
+    /**
+     * Setup callback and parameter array
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     * @param array                                 $_attr attributes
+     * @param string                                $tag
+     * @param string                                $method
+     *
+     * @return array
+     */
+    public function setup(Smarty_Internal_TemplateCompilerBase $compiler, $_attr, $tag, $method)
+    {
+        $_paramsArray = array();
+        foreach ($_attr as $_key => $_value) {
+            if (is_int($_key)) {
+                $_paramsArray[] = "$_key=>$_value";
+            } else {
+                $_paramsArray[] = "'$_key'=>$_value";
+            }
+        }
+        $callback = array("\$_smarty_tpl->smarty->registered_objects['{$tag}'][0]", "->{$method}");
+        return array($callback, $_paramsArray, "array(\$_block_plugin{$this->nesting}, '{$method}')");
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_function.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_function.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_function.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_object_function.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,85 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Object Function
+ * Compiles code for registered objects as function
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Object Function Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Object_Function extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * Compiles code for the execution of function plugin
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     * @param string                                $tag       name of function
+     * @param string                                $method    name of method to call
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter, $tag, $method)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        unset($_attr[ 'nocache' ]);
+        $_assign = null;
+        if (isset($_attr[ 'assign' ])) {
+            $_assign = $_attr[ 'assign' ];
+            unset($_attr[ 'assign' ]);
+        }
+        // method or property ?
+        if (is_callable(array($compiler->smarty->registered_objects[ $tag ][ 0 ], $method))) {
+            // convert attributes into parameter array string
+            if ($compiler->smarty->registered_objects[ $tag ][ 2 ]) {
+                $_paramsArray = array();
+                foreach ($_attr as $_key => $_value) {
+                    if (is_int($_key)) {
+                        $_paramsArray[] = "$_key=>$_value";
+                    } else {
+                        $_paramsArray[] = "'$_key'=>$_value";
+                    }
+                }
+                $_params = 'array(' . implode(',', $_paramsArray) . ')';
+                $output = "\$_smarty_tpl->smarty->registered_objects['{$tag}'][0]->{$method}({$_params},\$_smarty_tpl)";
+            } else {
+                $_params = implode(',', $_attr);
+                $output = "\$_smarty_tpl->smarty->registered_objects['{$tag}'][0]->{$method}({$_params})";
+            }
+        } else {
+            // object property
+            $output = "\$_smarty_tpl->smarty->registered_objects['{$tag}'][0]->{$method}";
+        }
+        if (!empty($parameter[ 'modifierlist' ])) {
+            $output = $compiler->compileTag(
+                'private_modifier',
+                array(),
+                array('modifierlist' => $parameter[ 'modifierlist' ], 'value' => $output)
+            );
+        }
+        if (empty($_assign)) {
+            return "<?php echo {$output};?>\n";
+        } else {
+            return "<?php \$_smarty_tpl->assign({$_assign},{$output});?>\n";
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_php.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_php.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_php.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_php.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,253 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile PHP Expression
+ * Compiles any tag which will output an expression or variable
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile PHP Expression Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Php extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('code', 'type');
+
+    /**
+     * Compiles code for generating output from any expression
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $compiler->has_code = false;
+        if ($_attr[ 'type' ] === 'xml') {
+            $compiler->tag_nocache = true;
+            $output = addcslashes($_attr[ 'code' ], "'\\");
+            $compiler->parser->current_buffer->append_subtree(
+                $compiler->parser,
+                new Smarty_Internal_ParseTree_Tag(
+                    $compiler->parser,
+                    $compiler->processNocacheCode(
+                        "<?php echo '{$output}';?>\n",
+                        true
+                    )
+                )
+            );
+            return '';
+        }
+        if ($_attr[ 'type' ] !== 'tag') {
+            if ($compiler->php_handling === Smarty::PHP_REMOVE) {
+                return '';
+            } elseif ($compiler->php_handling === Smarty::PHP_QUOTE) {
+                $output =
+                    preg_replace_callback(
+                        '#(<\?(?:php|=)?)|(<%)|(<script\s+language\s*=\s*["\']?\s*php\s*["\']?\s*>)|(\?>)|(%>)|(<\/script>)#i',
+                        array($this, 'quote'),
+                        $_attr[ 'code' ]
+                    );
+                $compiler->parser->current_buffer->append_subtree(
+                    $compiler->parser,
+                    new Smarty_Internal_ParseTree_Text($output)
+                );
+                return '';
+            } elseif ($compiler->php_handling === Smarty::PHP_PASSTHRU || $_attr[ 'type' ] === 'unmatched') {
+                $compiler->tag_nocache = true;
+                $output = addcslashes($_attr[ 'code' ], "'\\");
+                $compiler->parser->current_buffer->append_subtree(
+                    $compiler->parser,
+                    new Smarty_Internal_ParseTree_Tag(
+                        $compiler->parser,
+                        $compiler->processNocacheCode(
+                            "<?php echo '{$output}';?>\n",
+                            true
+                        )
+                    )
+                );
+                return '';
+            } elseif ($compiler->php_handling === Smarty::PHP_ALLOW) {
+                if (!($compiler->smarty instanceof SmartyBC)) {
+                    $compiler->trigger_template_error(
+                        '$smarty->php_handling PHP_ALLOW not allowed. Use SmartyBC to enable it',
+                        null,
+                        true
+                    );
+                }
+                $compiler->has_code = true;
+                return $_attr[ 'code' ];
+            } else {
+                $compiler->trigger_template_error('Illegal $smarty->php_handling value', null, true);
+            }
+        } else {
+            $compiler->has_code = true;
+            if (!($compiler->smarty instanceof SmartyBC)) {
+                $compiler->trigger_template_error(
+                    '{php}{/php} tags not allowed. Use SmartyBC to enable them',
+                    null,
+                    true
+                );
+            }
+            $ldel = preg_quote($compiler->smarty->left_delimiter, '#');
+            $rdel = preg_quote($compiler->smarty->right_delimiter, '#');
+            preg_match("#^({$ldel}php\\s*)((.)*?)({$rdel})#", $_attr[ 'code' ], $match);
+            if (!empty($match[ 2 ])) {
+                if ('nocache' === trim($match[ 2 ])) {
+                    $compiler->tag_nocache = true;
+                } else {
+                    $compiler->trigger_template_error("illegal value of option flag '{$match[2]}'", null, true);
+                }
+            }
+            return preg_replace(
+                array("#^{$ldel}\\s*php\\s*(.)*?{$rdel}#", "#{$ldel}\\s*/\\s*php\\s*{$rdel}$#"),
+                array('<?php ', '?>'),
+                $_attr[ 'code' ]
+            );
+        }
+    }
+
+    /**
+     * Lexer code for PHP tags
+     *
+     * This code has been moved from lexer here fo easier debugging and maintenance
+     *
+     * @param Smarty_Internal_Templatelexer $lex
+     *
+     * @throws \SmartyCompilerException
+     */
+    public function parsePhp(Smarty_Internal_Templatelexer $lex)
+    {
+        $lex->token = Smarty_Internal_Templateparser::TP_PHP;
+        $close = 0;
+        $lex->taglineno = $lex->line;
+        $closeTag = '?>';
+        if (strpos($lex->value, '<?xml') === 0) {
+            $lex->is_xml = true;
+            $lex->phpType = 'xml';
+            return;
+        } elseif (strpos($lex->value, '<?') === 0) {
+            $lex->phpType = 'php';
+        } elseif (strpos($lex->value, '<%') === 0) {
+            $lex->phpType = 'asp';
+            $closeTag = '%>';
+        } elseif (strpos($lex->value, '%>') === 0) {
+            $lex->phpType = 'unmatched';
+        } elseif (strpos($lex->value, '?>') === 0) {
+            if ($lex->is_xml) {
+                $lex->is_xml = false;
+                $lex->phpType = 'xml';
+                return;
+            }
+            $lex->phpType = 'unmatched';
+        } elseif (strpos($lex->value, '<s') === 0) {
+            $lex->phpType = 'script';
+            $closeTag = '</script>';
+        } elseif (strpos($lex->value, $lex->smarty->left_delimiter) === 0) {
+            if ($lex->isAutoLiteral()) {
+                $lex->token = Smarty_Internal_Templateparser::TP_TEXT;
+                return;
+            }
+            $closeTag = "{$lex->smarty->left_delimiter}/php{$lex->smarty->right_delimiter}";
+            if ($lex->value === $closeTag) {
+                $lex->compiler->trigger_template_error("unexpected closing tag '{$closeTag}'");
+            }
+            $lex->phpType = 'tag';
+        }
+        if ($lex->phpType === 'unmatched') {
+            return;
+        }
+        if (($lex->phpType === 'php' || $lex->phpType === 'asp')
+            &&
+            ($lex->compiler->php_handling === Smarty::PHP_PASSTHRU ||
+             $lex->compiler->php_handling === Smarty::PHP_QUOTE)
+        ) {
+            return;
+        }
+        $start = $lex->counter + strlen($lex->value);
+        $body = true;
+        if (preg_match('~' . preg_quote($closeTag, '~') . '~i', $lex->data, $match, PREG_OFFSET_CAPTURE, $start)) {
+            $close = $match[ 0 ][ 1 ];
+        } else {
+            $lex->compiler->trigger_template_error("missing closing tag '{$closeTag}'");
+        }
+        while ($body) {
+            if (preg_match(
+                '~([/][*])|([/][/][^\n]*)|(\'[^\'\\\\]*(?:\\.[^\'\\\\]*)*\')|("[^"\\\\]*(?:\\.[^"\\\\]*)*")~',
+                $lex->data,
+                $match,
+                PREG_OFFSET_CAPTURE,
+                $start
+            )
+            ) {
+                $value = $match[ 0 ][ 0 ];
+                $from = $pos = $match[ 0 ][ 1 ];
+                if ($pos > $close) {
+                    $body = false;
+                } else {
+                    $start = $pos + strlen($value);
+                    $phpCommentStart = $value === '/*';
+                    if ($phpCommentStart) {
+                        $phpCommentEnd = preg_match('~([*][/])~', $lex->data, $match, PREG_OFFSET_CAPTURE, $start);
+                        if ($phpCommentEnd) {
+                            $pos2 = $match[ 0 ][ 1 ];
+                            $start = $pos2 + strlen($match[ 0 ][ 0 ]);
+                        }
+                    }
+                    while ($close > $pos && $close < $start) {
+                        if (preg_match(
+                            '~' . preg_quote($closeTag, '~') . '~i',
+                            $lex->data,
+                            $match,
+                            PREG_OFFSET_CAPTURE,
+                            $from
+                        )
+                        ) {
+                            $close = $match[ 0 ][ 1 ];
+                            $from = $close + strlen($match[ 0 ][ 0 ]);
+                        } else {
+                            $lex->compiler->trigger_template_error("missing closing tag '{$closeTag}'");
+                        }
+                    }
+                    if ($phpCommentStart && (!$phpCommentEnd || $pos2 > $close)) {
+                        $lex->taglineno = $lex->line + substr_count(substr($lex->data, $lex->counter, $start), "\n");
+                        $lex->compiler->trigger_template_error("missing PHP comment closing tag '*/'");
+                    }
+                }
+            } else {
+                $body = false;
+            }
+        }
+        $lex->value = substr($lex->data, $lex->counter, $close + strlen($closeTag) - $lex->counter);
+    }
+
+    /*
+     * Call back function for $php_handling = PHP_QUOTE
+     *
+     */
+    /**
+     * @param $match
+     *
+     * @return string
+     */
+    private function quote($match)
+    {
+        return htmlspecialchars($match[ 0 ], ENT_QUOTES);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_print_expression.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_print_expression.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_print_expression.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_print_expression.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,161 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Print Expression
+ * Compiles any tag which will output an expression or variable
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Print Expression Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Print_Expression extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('assign');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $option_flags = array('nocache', 'nofilter');
+
+    /**
+     * Compiles code for generating output from any expression
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $output = $parameter[ 'value' ];
+        // tag modifier
+        if (!empty($parameter[ 'modifierlist' ])) {
+            $output = $compiler->compileTag(
+                'private_modifier',
+                array(),
+                array(
+                    'modifierlist' => $parameter[ 'modifierlist' ],
+                    'value'        => $output
+                )
+            );
+        }
+        if (isset($_attr[ 'assign' ])) {
+            // assign output to variable
+            return "<?php \$_smarty_tpl->assign({$_attr['assign']},{$output});?>";
+        } else {
+            // display value
+            if (!$_attr[ 'nofilter' ]) {
+                // default modifier
+                if (!empty($compiler->smarty->default_modifiers)) {
+                    if (empty($compiler->default_modifier_list)) {
+                        $modifierlist = array();
+                        foreach ($compiler->smarty->default_modifiers as $key => $single_default_modifier) {
+                            preg_match_all(
+                                '/(\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'|"[^"\\\\]*(?:\\\\.[^"\\\\]*)*"|:|[^:]+)/',
+                                $single_default_modifier,
+                                $mod_array
+                            );
+                            for ($i = 0, $count = count($mod_array[ 0 ]); $i < $count; $i++) {
+                                if ($mod_array[ 0 ][ $i ] !== ':') {
+                                    $modifierlist[ $key ][] = $mod_array[ 0 ][ $i ];
+                                }
+                            }
+                        }
+                        $compiler->default_modifier_list = $modifierlist;
+                    }
+                    $output = $compiler->compileTag(
+                        'private_modifier',
+                        array(),
+                        array(
+                            'modifierlist' => $compiler->default_modifier_list,
+                            'value'        => $output
+                        )
+                    );
+                }
+                // autoescape html
+                if ($compiler->template->smarty->escape_html) {
+                    $output = "htmlspecialchars({$output}, ENT_QUOTES, '" . addslashes(Smarty::$_CHARSET) . "')";
+                }
+                // loop over registered filters
+                if (!empty($compiler->template->smarty->registered_filters[ Smarty::FILTER_VARIABLE ])) {
+                    foreach ($compiler->template->smarty->registered_filters[ Smarty::FILTER_VARIABLE ] as $key =>
+                        $function) {
+                        if (!is_array($function)) {
+                            $output = "{$function}({$output},\$_smarty_tpl)";
+                        } elseif (is_object($function[ 0 ])) {
+                            $output =
+                                "\$_smarty_tpl->smarty->registered_filters[Smarty::FILTER_VARIABLE]['{$key}'][0]->{$function[1]}({$output},\$_smarty_tpl)";
+                        } else {
+                            $output = "{$function[0]}::{$function[1]}({$output},\$_smarty_tpl)";
+                        }
+                    }
+                }
+                // auto loaded filters
+                if (isset($compiler->smarty->autoload_filters[ Smarty::FILTER_VARIABLE ])) {
+                    foreach ((array)$compiler->template->smarty->autoload_filters[ Smarty::FILTER_VARIABLE ] as $name) {
+                        $result = $this->compile_variable_filter($compiler, $name, $output);
+                        if ($result !== false) {
+                            $output = $result;
+                        } else {
+                            // not found, throw exception
+                            throw new SmartyException("Unable to load variable filter '{$name}'");
+                        }
+                    }
+                }
+                foreach ($compiler->variable_filters as $filter) {
+                    if (count($filter) === 1
+                        && ($result = $this->compile_variable_filter($compiler, $filter[ 0 ], $output)) !== false
+                    ) {
+                        $output = $result;
+                    } else {
+                        $output = $compiler->compileTag(
+                            'private_modifier',
+                            array(),
+                            array('modifierlist' => array($filter), 'value' => $output)
+                        );
+                    }
+                }
+            }
+            $output = "<?php echo {$output};?>\n";
+        }
+        return $output;
+    }
+
+    /**
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     * @param string                                $name     name of variable filter
+     * @param string                                $output   embedded output
+     *
+     * @return string
+     * @throws \SmartyException
+     */
+    private function compile_variable_filter(Smarty_Internal_TemplateCompilerBase $compiler, $name, $output)
+    {
+        $function = $compiler->getPlugin($name, 'variablefilter');
+        if ($function) {
+            return "{$function}({$output},\$_smarty_tpl)";
+        } else {
+            // not found
+            return false;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_block.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_block.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_block.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_block.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,72 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Registered Block
+ * Compiles code for the execution of a registered block function
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Registered Block Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Registered_Block extends Smarty_Internal_Compile_Private_Block_Plugin
+{
+    /**
+     * Setup callback, parameter array and nocache mode
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     * @param array                                 $_attr attributes
+     * @param string                                $tag
+     * @param null                                  $function
+     *
+     * @return array
+     */
+    public function setup(Smarty_Internal_TemplateCompilerBase $compiler, $_attr, $tag, $function)
+    {
+        if (isset($compiler->smarty->registered_plugins[ Smarty::PLUGIN_BLOCK ][ $tag ])) {
+            $tag_info = $compiler->smarty->registered_plugins[ Smarty::PLUGIN_BLOCK ][ $tag ];
+            $callback = $tag_info[ 0 ];
+            if (is_array($callback)) {
+                if (is_object($callback[ 0 ])) {
+                    $callable = "array(\$_block_plugin{$this->nesting}, '{$callback[1]}')";
+                    $callback =
+                        array("\$_smarty_tpl->smarty->registered_plugins['block']['{$tag}'][0][0]", "->{$callback[1]}");
+                } else {
+                    $callable = "array(\$_block_plugin{$this->nesting}, '{$callback[1]}')";
+                    $callback =
+                        array("\$_smarty_tpl->smarty->registered_plugins['block']['{$tag}'][0][0]", "::{$callback[1]}");
+                }
+            } else {
+                $callable = "\$_block_plugin{$this->nesting}";
+                $callback = array("\$_smarty_tpl->smarty->registered_plugins['block']['{$tag}'][0]", '');
+            }
+        } else {
+            $tag_info = $compiler->default_handler_plugins[ Smarty::PLUGIN_BLOCK ][ $tag ];
+            $callback = $tag_info[ 0 ];
+            if (is_array($callback)) {
+                $callable = "array('{$callback[0]}', '{$callback[1]}')";
+                $callback = "{$callback[1]}::{$callback[1]}";
+            } else {
+                $callable = null;
+            }
+        }
+        $compiler->tag_nocache = !$tag_info[ 1 ] | $compiler->tag_nocache;
+        $_paramsArray = array();
+        foreach ($_attr as $_key => $_value) {
+            if (is_int($_key)) {
+                $_paramsArray[] = "$_key=>$_value";
+            } elseif ($compiler->template->caching && in_array($_key, $tag_info[ 2 ])) {
+                $_value = str_replace('\'', "^#^", $_value);
+                $_paramsArray[] = "'$_key'=>^#^.var_export($_value,true).^#^";
+            } else {
+                $_paramsArray[] = "'$_key'=>$_value";
+            }
+        }
+        return array($callback, $_paramsArray, $callable);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_function.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_function.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_function.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_registered_function.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,91 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Registered Function
+ * Compiles code for the execution of a registered function
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Registered Function Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Registered_Function extends Smarty_Internal_CompileBase
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('_any');
+
+    /**
+     * Compiles code for the execution of a registered function
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     * @param string                                $tag       name of function
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter, $tag)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        unset($_attr[ 'nocache' ]);
+        if (isset($compiler->smarty->registered_plugins[ Smarty::PLUGIN_FUNCTION ][ $tag ])) {
+            $tag_info = $compiler->smarty->registered_plugins[ Smarty::PLUGIN_FUNCTION ][ $tag ];
+            $is_registered = true;
+        } else {
+            $tag_info = $compiler->default_handler_plugins[ Smarty::PLUGIN_FUNCTION ][ $tag ];
+            $is_registered = false;
+        }
+        // not cacheable?
+        $compiler->tag_nocache = $compiler->tag_nocache || !$tag_info[ 1 ];
+        // convert attributes into parameter array string
+        $_paramsArray = array();
+        foreach ($_attr as $_key => $_value) {
+            if (is_int($_key)) {
+                $_paramsArray[] = "$_key=>$_value";
+            } elseif ($compiler->template->caching && in_array($_key, $tag_info[ 2 ])) {
+                $_value = str_replace('\'', "^#^", $_value);
+                $_paramsArray[] = "'$_key'=>^#^.var_export($_value,true).^#^";
+            } else {
+                $_paramsArray[] = "'$_key'=>$_value";
+            }
+        }
+        $_params = 'array(' . implode(',', $_paramsArray) . ')';
+        // compile code
+        if ($is_registered) {
+            $output =
+                "call_user_func_array( \$_smarty_tpl->smarty->registered_plugins[Smarty::PLUGIN_FUNCTION]['{$tag}'][0], array( {$_params},\$_smarty_tpl ) )";
+        } else {
+            $function = $tag_info[ 0 ];
+            if (!is_array($function)) {
+                $output = "{$function}({$_params},\$_smarty_tpl)";
+            } else {
+                $output = "{$function[0]}::{$function[1]}({$_params},\$_smarty_tpl)";
+            }
+        }
+        if (!empty($parameter[ 'modifierlist' ])) {
+            $output = $compiler->compileTag(
+                'private_modifier',
+                array(),
+                array(
+                    'modifierlist' => $parameter[ 'modifierlist' ],
+                    'value'        => $output
+                )
+            );
+        }
+        $output = "<?php echo {$output};?>\n";
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_special_variable.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_special_variable.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_private_special_variable.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_private_special_variable.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,130 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Special Smarty Variable
+ * Compiles the special $smarty variables
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile special Smarty Variable Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Private_Special_Variable extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the special $smarty variables
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     * @param                                       $parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        $_index = preg_split("/\]\[/", substr($parameter, 1, strlen($parameter) - 2));
+        $variable = strtolower($compiler->getId($_index[ 0 ]));
+        if ($variable === false) {
+            $compiler->trigger_template_error("special \$Smarty variable name index can not be variable", null, true);
+        }
+        if (!isset($compiler->smarty->security_policy)
+            || $compiler->smarty->security_policy->isTrustedSpecialSmartyVar($variable, $compiler)
+        ) {
+            switch ($variable) {
+                case 'foreach':
+                case 'section':
+                    if (!isset(Smarty_Internal_TemplateCompilerBase::$_tag_objects[ $variable ])) {
+                        $class = 'Smarty_Internal_Compile_' . ucfirst($variable);
+                        Smarty_Internal_TemplateCompilerBase::$_tag_objects[ $variable ] = new $class;
+                    }
+                    return Smarty_Internal_TemplateCompilerBase::$_tag_objects[ $variable ]->compileSpecialVariable(
+                        array(),
+                        $compiler,
+                        $_index
+                    );
+                case 'capture':
+                    if (class_exists('Smarty_Internal_Compile_Capture')) {
+                        return Smarty_Internal_Compile_Capture::compileSpecialVariable(array(), $compiler, $_index);
+                    }
+                    return '';
+                case 'now':
+                    return 'time()';
+                case 'cookies':
+                    if (isset($compiler->smarty->security_policy)
+                        && !$compiler->smarty->security_policy->allow_super_globals
+                    ) {
+                        $compiler->trigger_template_error("(secure mode) super globals not permitted");
+                        break;
+                    }
+                    $compiled_ref = '$_COOKIE';
+                    break;
+                case 'get':
+                case 'post':
+                case 'env':
+                case 'server':
+                case 'session':
+                case 'request':
+                    if (isset($compiler->smarty->security_policy)
+                        && !$compiler->smarty->security_policy->allow_super_globals
+                    ) {
+                        $compiler->trigger_template_error("(secure mode) super globals not permitted");
+                        break;
+                    }
+                    $compiled_ref = '$_' . strtoupper($variable);
+                    break;
+                case 'template':
+                    return 'basename($_smarty_tpl->source->filepath)';
+                case 'template_object':
+                    if (isset($compiler->smarty->security_policy)) {
+                        $compiler->trigger_template_error("(secure mode) template_object not permitted");
+                        break;
+                    }
+                    return '$_smarty_tpl';
+                case 'current_dir':
+                    return 'dirname($_smarty_tpl->source->filepath)';
+                case 'version':
+                    return "Smarty::SMARTY_VERSION";
+                case 'const':
+                    if (isset($compiler->smarty->security_policy)
+                        && !$compiler->smarty->security_policy->allow_constants
+                    ) {
+                        $compiler->trigger_template_error("(secure mode) constants not permitted");
+                        break;
+                    }
+                    if (strpos($_index[ 1 ], '$') === false && strpos($_index[ 1 ], '\'') === false) {
+                        return "(defined('{$_index[1]}') ? constant('{$_index[1]}') : null)";
+                    } else {
+                        return "(defined({$_index[1]}) ? constant({$_index[1]}) : null)";
+                    }
+                // no break
+                case 'config':
+                    if (isset($_index[ 2 ])) {
+                        return "(is_array(\$tmp = \$_smarty_tpl->smarty->ext->configload->_getConfigVariable(\$_smarty_tpl, $_index[1])) ? \$tmp[$_index[2]] : null)";
+                    } else {
+                        return "\$_smarty_tpl->smarty->ext->configload->_getConfigVariable(\$_smarty_tpl, $_index[1])";
+                    }
+                // no break
+                case 'ldelim':
+                    return "\$_smarty_tpl->smarty->left_delimiter";
+                case 'rdelim':
+                    return "\$_smarty_tpl->smarty->right_delimiter";
+                default:
+                    $compiler->trigger_template_error('$smarty.' . trim($_index[ 0 ], "'") . ' is not defined');
+                    break;
+            }
+            if (isset($_index[ 1 ])) {
+                array_shift($_index);
+                foreach ($_index as $_ind) {
+                    $compiled_ref = $compiled_ref . "[$_ind]";
+                }
+            }
+            return $compiled_ref;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_rdelim.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_rdelim.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_rdelim.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_rdelim.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,34 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Rdelim
+ * Compiles the {rdelim} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Rdelim Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Rdelim extends Smarty_Internal_Compile_Ldelim
+{
+    /**
+     * Compiles code for the {rdelim} tag
+     * This tag does output the right delimiter.
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        parent::compile($args, $compiler);
+        return $compiler->smarty->right_delimiter;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_section.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_section.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_section.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_section.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,462 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Section
+ * Compiles the {section} {sectionelse} {/section} tags
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Section Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Section extends Smarty_Internal_Compile_Private_ForeachSection
+{
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $required_attributes = array('name', 'loop');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $shorttag_order = array('name', 'loop');
+
+    /**
+     * Attribute definition: Overwrites base class.
+     *
+     * @var array
+     * @see Smarty_Internal_CompileBase
+     */
+    public $optional_attributes = array('start', 'step', 'max', 'show', 'properties');
+
+    /**
+     * counter
+     *
+     * @var int
+     */
+    public $counter = 0;
+
+    /**
+     * Name of this tag
+     *
+     * @var string
+     */
+    public $tagName = 'section';
+
+    /**
+     * Valid properties of $smarty.section.name.xxx variable
+     *
+     * @var array
+     */
+    public $nameProperties = array(
+        'first', 'last', 'index', 'iteration', 'show', 'total', 'rownum', 'index_prev',
+        'index_next', 'loop'
+    );
+
+    /**
+     * {section} tag has no item properties
+     *
+     * @var array
+     */
+    public $itemProperties = null;
+
+    /**
+     * {section} tag has always name attribute
+     *
+     * @var bool
+     */
+    public $isNamed = true;
+
+    /**
+     * Compiles code for the {section} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     * @throws \SmartyException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $compiler->loopNesting++;
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $attributes = array('name' => $compiler->getId($_attr[ 'name' ]));
+        unset($_attr[ 'name' ]);
+        foreach ($attributes as $a => $v) {
+            if ($v === false) {
+                $compiler->trigger_template_error("'{$a}' attribute/variable has illegal value", null, true);
+            }
+        }
+        $local = "\$__section_{$attributes['name']}_" . $this->counter++ . '_';
+        $sectionVar = "\$_smarty_tpl->tpl_vars['__smarty_section_{$attributes['name']}']";
+        $this->openTag($compiler, 'section', array('section', $compiler->nocache, $local, $sectionVar));
+        // maybe nocache because of nocache variables
+        $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        $initLocal = array();
+        $initNamedProperty = array();
+        $initFor = array();
+        $incFor = array();
+        $cmpFor = array();
+        $propValue = array(
+            'index'     => "{$sectionVar}->value['index']", 'show' => 'true', 'step' => 1,
+            'iteration' => "{$local}iteration",
+        );
+        $propType = array('index' => 2, 'iteration' => 2, 'show' => 0, 'step' => 0,);
+        // search for used tag attributes
+        $this->scanForProperties($attributes, $compiler);
+        if (!empty($this->matchResults[ 'named' ])) {
+            $namedAttr = $this->matchResults[ 'named' ];
+        }
+        if (isset($_attr[ 'properties' ]) && preg_match_all("/['](.*?)[']/", $_attr[ 'properties' ], $match)) {
+            foreach ($match[ 1 ] as $prop) {
+                if (in_array($prop, $this->nameProperties)) {
+                    $namedAttr[ $prop ] = true;
+                } else {
+                    $compiler->trigger_template_error("Invalid property '{$prop}'", null, true);
+                }
+            }
+        }
+        $namedAttr[ 'index' ] = true;
+        $output = "<?php\n";
+        foreach ($_attr as $attr_name => $attr_value) {
+            switch ($attr_name) {
+                case 'loop':
+                    if (is_numeric($attr_value)) {
+                        $v = (int)$attr_value;
+                        $t = 0;
+                    } else {
+                        $v = "(is_array(@\$_loop=$attr_value) ? count(\$_loop) : max(0, (int) \$_loop))";
+                        $t = 1;
+                    }
+                    if ($t === 1) {
+                        $initLocal[ 'loop' ] = $v;
+                        $v = "{$local}loop";
+                    }
+                    break;
+                case 'show':
+                    if (is_bool($attr_value)) {
+                        $v = $attr_value ? 'true' : 'false';
+                        $t = 0;
+                    } else {
+                        $v = "(bool) $attr_value";
+                        $t = 3;
+                    }
+                    break;
+                case 'step':
+                    if (is_numeric($attr_value)) {
+                        $v = (int)$attr_value;
+                        $v = ($v === 0) ? 1 : $v;
+                        $t = 0;
+                        break;
+                    }
+                    $initLocal[ 'step' ] = "((int)@$attr_value) === 0 ? 1 : (int)@$attr_value";
+                    $v = "{$local}step";
+                    $t = 2;
+                    break;
+                case 'max':
+                case 'start':
+                    if (is_numeric($attr_value)) {
+                        $v = (int)$attr_value;
+                        $t = 0;
+                        break;
+                    }
+                    $v = "(int)@$attr_value";
+                    $t = 3;
+                    break;
+            }
+            if ($t === 3 && $compiler->getId($attr_value)) {
+                $t = 1;
+            }
+            $propValue[ $attr_name ] = $v;
+            $propType[ $attr_name ] = $t;
+        }
+        if (isset($namedAttr[ 'step' ])) {
+            $initNamedProperty[ 'step' ] = $propValue[ 'step' ];
+        }
+        if (isset($namedAttr[ 'iteration' ])) {
+            $propValue[ 'iteration' ] = "{$sectionVar}->value['iteration']";
+        }
+        $incFor[ 'iteration' ] = "{$propValue['iteration']}++";
+        $initFor[ 'iteration' ] = "{$propValue['iteration']} = 1";
+        if ($propType[ 'step' ] === 0) {
+            if ($propValue[ 'step' ] === 1) {
+                $incFor[ 'index' ] = "{$sectionVar}->value['index']++";
+            } elseif ($propValue[ 'step' ] > 1) {
+                $incFor[ 'index' ] = "{$sectionVar}->value['index'] += {$propValue['step']}";
+            } else {
+                $incFor[ 'index' ] = "{$sectionVar}->value['index'] -= " . -$propValue[ 'step' ];
+            }
+        } else {
+            $incFor[ 'index' ] = "{$sectionVar}->value['index'] += {$propValue['step']}";
+        }
+        if (!isset($propValue[ 'max' ])) {
+            $propValue[ 'max' ] = $propValue[ 'loop' ];
+            $propType[ 'max' ] = $propType[ 'loop' ];
+        } elseif ($propType[ 'max' ] !== 0) {
+            $propValue[ 'max' ] = "{$propValue['max']} < 0 ? {$propValue['loop']} : {$propValue['max']}";
+            $propType[ 'max' ] = 1;
+        } else {
+            if ($propValue[ 'max' ] < 0) {
+                $propValue[ 'max' ] = $propValue[ 'loop' ];
+                $propType[ 'max' ] = $propType[ 'loop' ];
+            }
+        }
+        if (!isset($propValue[ 'start' ])) {
+            $start_code =
+                array(1 => "{$propValue['step']} > 0 ? ", 2 => '0', 3 => ' : ', 4 => $propValue[ 'loop' ], 5 => ' - 1');
+            if ($propType[ 'loop' ] === 0) {
+                $start_code[ 5 ] = '';
+                $start_code[ 4 ] = $propValue[ 'loop' ] - 1;
+            }
+            if ($propType[ 'step' ] === 0) {
+                if ($propValue[ 'step' ] > 0) {
+                    $start_code = array(1 => '0');
+                    $propType[ 'start' ] = 0;
+                } else {
+                    $start_code[ 1 ] = $start_code[ 2 ] = $start_code[ 3 ] = '';
+                    $propType[ 'start' ] = $propType[ 'loop' ];
+                }
+            } else {
+                $propType[ 'start' ] = 1;
+            }
+            $propValue[ 'start' ] = join('', $start_code);
+        } else {
+            $start_code =
+                array(
+                    1  => "{$propValue['start']} < 0 ? ", 2 => 'max(', 3 => "{$propValue['step']} > 0 ? ", 4 => '0',
+                    5  => ' : ', 6 => '-1', 7 => ', ', 8 => "{$propValue['start']} + {$propValue['loop']}", 10 => ')',
+                    11 => ' : ', 12 => 'min(', 13 => $propValue[ 'start' ], 14 => ', ',
+                    15 => "{$propValue['step']} > 0 ? ", 16 => $propValue[ 'loop' ], 17 => ' : ',
+                    18 => $propType[ 'loop' ] === 0 ? $propValue[ 'loop' ] - 1 : "{$propValue['loop']} - 1",
+                    19 => ')'
+                );
+            if ($propType[ 'step' ] === 0) {
+                $start_code[ 3 ] = $start_code[ 5 ] = $start_code[ 15 ] = $start_code[ 17 ] = '';
+                if ($propValue[ 'step' ] > 0) {
+                    $start_code[ 6 ] = $start_code[ 18 ] = '';
+                } else {
+                    $start_code[ 4 ] = $start_code[ 16 ] = '';
+                }
+            }
+            if ($propType[ 'start' ] === 0) {
+                if ($propType[ 'loop' ] === 0) {
+                    $start_code[ 8 ] = $propValue[ 'start' ] + $propValue[ 'loop' ];
+                }
+                $propType[ 'start' ] = $propType[ 'step' ] + $propType[ 'loop' ];
+                $start_code[ 1 ] = '';
+                if ($propValue[ 'start' ] < 0) {
+                    for ($i = 11; $i <= 19; $i++) {
+                        $start_code[ $i ] = '';
+                    }
+                    if ($propType[ 'start' ] === 0) {
+                        $start_code = array(
+                            max(
+                                $propValue[ 'step' ] > 0 ? 0 : -1,
+                                $propValue[ 'start' ] + $propValue[ 'loop' ]
+                            )
+                        );
+                    }
+                } else {
+                    for ($i = 1; $i <= 11; $i++) {
+                        $start_code[ $i ] = '';
+                    }
+                    if ($propType[ 'start' ] === 0) {
+                        $start_code =
+                            array(
+                                min(
+                                    $propValue[ 'step' ] > 0 ? $propValue[ 'loop' ] : $propValue[ 'loop' ] - 1,
+                                    $propValue[ 'start' ]
+                                )
+                            );
+                    }
+                }
+            }
+            $propValue[ 'start' ] = join('', $start_code);
+        }
+        if ($propType[ 'start' ] !== 0) {
+            $initLocal[ 'start' ] = $propValue[ 'start' ];
+            $propValue[ 'start' ] = "{$local}start";
+        }
+        $initFor[ 'index' ] = "{$sectionVar}->value['index'] = {$propValue['start']}";
+        if (!isset($_attr[ 'start' ]) && !isset($_attr[ 'step' ]) && !isset($_attr[ 'max' ])) {
+            $propValue[ 'total' ] = $propValue[ 'loop' ];
+            $propType[ 'total' ] = $propType[ 'loop' ];
+        } else {
+            $propType[ 'total' ] =
+                $propType[ 'start' ] + $propType[ 'loop' ] + $propType[ 'step' ] + $propType[ 'max' ];
+            if ($propType[ 'total' ] === 0) {
+                $propValue[ 'total' ] =
+                    min(
+                        ceil(
+                            ($propValue[ 'step' ] > 0 ? $propValue[ 'loop' ] - $propValue[ 'start' ] :
+                                (int)$propValue[ 'start' ] + 1) / abs($propValue[ 'step' ])
+                        ),
+                        $propValue[ 'max' ]
+                    );
+            } else {
+                $total_code = array(
+                    1  => 'min(', 2 => 'ceil(', 3 => '(', 4 => "{$propValue['step']} > 0 ? ",
+                    5  => $propValue[ 'loop' ], 6 => ' - ', 7 => $propValue[ 'start' ], 8 => ' : ',
+                    9  => $propValue[ 'start' ], 10 => '+ 1', 11 => ')', 12 => '/ ', 13 => 'abs(',
+                    14 => $propValue[ 'step' ], 15 => ')', 16 => ')', 17 => ", {$propValue['max']})",
+                );
+                if (!isset($propValue[ 'max' ])) {
+                    $total_code[ 1 ] = $total_code[ 17 ] = '';
+                }
+                if ($propType[ 'loop' ] + $propType[ 'start' ] === 0) {
+                    $total_code[ 5 ] = $propValue[ 'loop' ] - $propValue[ 'start' ];
+                    $total_code[ 6 ] = $total_code[ 7 ] = '';
+                }
+                if ($propType[ 'start' ] === 0) {
+                    $total_code[ 9 ] = (int)$propValue[ 'start' ] + 1;
+                    $total_code[ 10 ] = '';
+                }
+                if ($propType[ 'step' ] === 0) {
+                    $total_code[ 13 ] = $total_code[ 15 ] = '';
+                    if ($propValue[ 'step' ] === 1 || $propValue[ 'step' ] === -1) {
+                        $total_code[ 2 ] = $total_code[ 12 ] = $total_code[ 14 ] = $total_code[ 16 ] = '';
+                    } elseif ($propValue[ 'step' ] < 0) {
+                        $total_code[ 14 ] = -$propValue[ 'step' ];
+                    }
+                    $total_code[ 4 ] = '';
+                    if ($propValue[ 'step' ] > 0) {
+                        $total_code[ 8 ] = $total_code[ 9 ] = $total_code[ 10 ] = '';
+                    } else {
+                        $total_code[ 5 ] = $total_code[ 6 ] = $total_code[ 7 ] = $total_code[ 8 ] = '';
+                    }
+                }
+                $propValue[ 'total' ] = join('', $total_code);
+            }
+        }
+        if (isset($namedAttr[ 'loop' ])) {
+            $initNamedProperty[ 'loop' ] = "'loop' => {$propValue['loop']}";
+        }
+        if (isset($namedAttr[ 'total' ])) {
+            $initNamedProperty[ 'total' ] = "'total' => {$propValue['total']}";
+            if ($propType[ 'total' ] > 0) {
+                $propValue[ 'total' ] = "{$sectionVar}->value['total']";
+            }
+        } elseif ($propType[ 'total' ] > 0) {
+            $initLocal[ 'total' ] = $propValue[ 'total' ];
+            $propValue[ 'total' ] = "{$local}total";
+        }
+        $cmpFor[ 'iteration' ] = "{$propValue['iteration']} <= {$propValue['total']}";
+        foreach ($initLocal as $key => $code) {
+            $output .= "{$local}{$key} = {$code};\n";
+        }
+        $_vars = 'array(' . join(', ', $initNamedProperty) . ')';
+        $output .= "{$sectionVar} = new Smarty_Variable({$_vars});\n";
+        $cond_code = "{$propValue['total']} !== 0";
+        if ($propType[ 'total' ] === 0) {
+            if ($propValue[ 'total' ] === 0) {
+                $cond_code = 'false';
+            } else {
+                $cond_code = 'true';
+            }
+        }
+        if ($propType[ 'show' ] > 0) {
+            $output .= "{$local}show = {$propValue['show']} ? {$cond_code} : false;\n";
+            $output .= "if ({$local}show) {\n";
+        } elseif ($propValue[ 'show' ] === 'true') {
+            $output .= "if ({$cond_code}) {\n";
+        } else {
+            $output .= "if (false) {\n";
+        }
+        $jinit = join(', ', $initFor);
+        $jcmp = join(', ', $cmpFor);
+        $jinc = join(', ', $incFor);
+        $output .= "for ({$jinit}; {$jcmp}; {$jinc}){\n";
+        if (isset($namedAttr[ 'rownum' ])) {
+            $output .= "{$sectionVar}->value['rownum'] = {$propValue['iteration']};\n";
+        }
+        if (isset($namedAttr[ 'index_prev' ])) {
+            $output .= "{$sectionVar}->value['index_prev'] = {$propValue['index']} - {$propValue['step']};\n";
+        }
+        if (isset($namedAttr[ 'index_next' ])) {
+            $output .= "{$sectionVar}->value['index_next'] = {$propValue['index']} + {$propValue['step']};\n";
+        }
+        if (isset($namedAttr[ 'first' ])) {
+            $output .= "{$sectionVar}->value['first'] = ({$propValue['iteration']} === 1);\n";
+        }
+        if (isset($namedAttr[ 'last' ])) {
+            $output .= "{$sectionVar}->value['last'] = ({$propValue['iteration']} === {$propValue['total']});\n";
+        }
+        $output .= '?>';
+        return $output;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Sectionelse Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Sectionelse extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {sectionelse} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        list($openTag, $nocache, $local, $sectionVar) = $this->closeTag($compiler, array('section'));
+        $this->openTag($compiler, 'sectionelse', array('sectionelse', $nocache, $local, $sectionVar));
+        return "<?php }} else {\n ?>";
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Sectionclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Sectionclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/section} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $compiler->loopNesting--;
+        // must endblock be nocache?
+        if ($compiler->nocache) {
+            $compiler->tag_nocache = true;
+        }
+        list($openTag, $compiler->nocache, $local, $sectionVar) =
+            $this->closeTag($compiler, array('section', 'sectionelse'));
+        $output = "<?php\n";
+        if ($openTag === 'sectionelse') {
+            $output .= "}\n";
+        } else {
+            $output .= "}\n}\n";
+        }
+        $output .= '?>';
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_setfilter.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_setfilter.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_setfilter.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_setfilter.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,68 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Setfilter
+ * Compiles code for setfilter tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Setfilter Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Setfilter extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for setfilter tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        $compiler->variable_filter_stack[] = $compiler->variable_filters;
+        $compiler->variable_filters = $parameter[ 'modifier_list' ];
+        // this tag does not return compiled code
+        $compiler->has_code = false;
+        return true;
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Setfilterclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Setfilterclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/setfilter} tag
+     * This tag does not generate compiled output. It resets variable filter.
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $_attr = $this->getAttributes($compiler, $args);
+        // reset variable filter to previous state
+        if (count($compiler->variable_filter_stack)) {
+            $compiler->variable_filters = array_pop($compiler->variable_filter_stack);
+        } else {
+            $compiler->variable_filters = array();
+        }
+        // this tag does not return compiled code
+        $compiler->has_code = false;
+        return true;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_shared_inheritance.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_shared_inheritance.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_shared_inheritance.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_shared_inheritance.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,49 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile Shared Inheritance
+ * Shared methods for {extends} and {block} tags
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Shared Inheritance Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Shared_Inheritance extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compile inheritance initialization code as prefix
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     * @param bool|false                            $initChildSequence if true force child template
+     */
+    public static function postCompile(Smarty_Internal_TemplateCompilerBase $compiler, $initChildSequence = false)
+    {
+        $compiler->prefixCompiledCode .= "<?php \$_smarty_tpl->_loadInheritance();\n\$_smarty_tpl->inheritance->init(\$_smarty_tpl, " .
+                                         var_export($initChildSequence, true) . ");\n?>\n";
+    }
+
+    /**
+     * Register post compile callback to compile inheritance initialization code
+     *
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     * @param bool|false                            $initChildSequence if true force child template
+     */
+    public function registerInit(Smarty_Internal_TemplateCompilerBase $compiler, $initChildSequence = false)
+    {
+        if ($initChildSequence || !isset($compiler->_cache[ 'inheritanceInit' ])) {
+            $compiler->registerPostCompileCallback(
+                array('Smarty_Internal_Compile_Shared_Inheritance', 'postCompile'),
+                array($initChildSequence),
+                'inheritanceInit',
+                $initChildSequence
+            );
+            $compiler->_cache[ 'inheritanceInit' ] = true;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compile_while.php b/epgrec/Smarty/sysplugins/smarty_internal_compile_while.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compile_while.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compile_while.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,100 @@
+<?php
+/**
+ * Smarty Internal Plugin Compile While
+ * Compiles the {while} tag
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile While Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_While extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {while} tag
+     *
+     * @param array                                 $args      array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler  compiler object
+     * @param array                                 $parameter array with compilation parameter
+     *
+     * @return string compiled code
+     * @throws \SmartyCompilerException
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler, $parameter)
+    {
+        $compiler->loopNesting++;
+        // check and get attributes
+        $_attr = $this->getAttributes($compiler, $args);
+        $this->openTag($compiler, 'while', $compiler->nocache);
+        if (!array_key_exists('if condition', $parameter)) {
+            $compiler->trigger_template_error('missing while condition', null, true);
+        }
+        // maybe nocache because of nocache variables
+        $compiler->nocache = $compiler->nocache | $compiler->tag_nocache;
+        if (is_array($parameter[ 'if condition' ])) {
+            if ($compiler->nocache) {
+                // create nocache var to make it know for further compiling
+                if (is_array($parameter[ 'if condition' ][ 'var' ])) {
+                    $var = $parameter[ 'if condition' ][ 'var' ][ 'var' ];
+                } else {
+                    $var = $parameter[ 'if condition' ][ 'var' ];
+                }
+                $compiler->setNocacheInVariable($var);
+            }
+            $prefixVar = $compiler->getNewPrefixVariable();
+            $assignCompiler = new Smarty_Internal_Compile_Assign();
+            $assignAttr = array();
+            $assignAttr[][ 'value' ] = $prefixVar;
+            if (is_array($parameter[ 'if condition' ][ 'var' ])) {
+                $assignAttr[][ 'var' ] = $parameter[ 'if condition' ][ 'var' ][ 'var' ];
+                $_output = "<?php while ({$prefixVar} = {$parameter[ 'if condition' ][ 'value' ]}) {?>";
+                $_output .= $assignCompiler->compile(
+                    $assignAttr,
+                    $compiler,
+                    array('smarty_internal_index' => $parameter[ 'if condition' ][ 'var' ][ 'smarty_internal_index' ])
+                );
+            } else {
+                $assignAttr[][ 'var' ] = $parameter[ 'if condition' ][ 'var' ];
+                $_output = "<?php while ({$prefixVar} = {$parameter[ 'if condition' ][ 'value' ]}) {?>";
+                $_output .= $assignCompiler->compile($assignAttr, $compiler, array());
+            }
+            return $_output;
+        } else {
+            return "<?php\n while ({$parameter['if condition']}) {?>";
+        }
+    }
+}
+
+/**
+ * Smarty Internal Plugin Compile Whileclose Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Compile_Whileclose extends Smarty_Internal_CompileBase
+{
+    /**
+     * Compiles code for the {/while} tag
+     *
+     * @param array                                 $args     array with attributes from parser
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler compiler object
+     *
+     * @return string compiled code
+     */
+    public function compile($args, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $compiler->loopNesting--;
+        // must endblock be nocache?
+        if ($compiler->nocache) {
+            $compiler->tag_nocache = true;
+        }
+        $compiler->nocache = $this->closeTag($compiler, array('while'));
+        return "<?php }?>\n";
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_compilebase.php b/epgrec/Smarty/sysplugins/smarty_internal_compilebase.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_compilebase.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_compilebase.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,203 @@
+<?php
+/**
+ * Smarty Internal Plugin CompileBase
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * This class does extend all internal compile plugins
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+abstract class Smarty_Internal_CompileBase
+{
+    /**
+     * Array of names of required attribute required by tag
+     *
+     * @var array
+     */
+    public $required_attributes = array();
+
+    /**
+     * Array of names of optional attribute required by tag
+     * use array('_any') if there is no restriction of attributes names
+     *
+     * @var array
+     */
+    public $optional_attributes = array();
+
+    /**
+     * Shorttag attribute order defined by its names
+     *
+     * @var array
+     */
+    public $shorttag_order = array();
+
+    /**
+     * Array of names of valid option flags
+     *
+     * @var array
+     */
+    public $option_flags = array('nocache');
+
+    /**
+     * Mapping array for boolean option value
+     *
+     * @var array
+     */
+    public $optionMap = array(1 => true, 0 => false, 'true' => true, 'false' => false);
+
+    /**
+     * Mapping array with attributes as key
+     *
+     * @var array
+     */
+    public $mapCache = array();
+
+    /**
+     * This function checks if the attributes passed are valid
+     * The attributes passed for the tag to compile are checked against the list of required and
+     * optional attributes. Required attributes must be present. Optional attributes are check against
+     * the corresponding list. The keyword '_any' specifies that any attribute will be accepted
+     * as valid
+     *
+     * @param object $compiler   compiler object
+     * @param array  $attributes attributes applied to the tag
+     *
+     * @return array  of mapped attributes for further processing
+     */
+    public function getAttributes($compiler, $attributes)
+    {
+        $_indexed_attr = array();
+        if (!isset($this->mapCache[ 'option' ])) {
+            $this->mapCache[ 'option' ] = array_fill_keys($this->option_flags, true);
+        }
+        foreach ($attributes as $key => $mixed) {
+            // shorthand ?
+            if (!is_array($mixed)) {
+                // option flag ?
+                if (isset($this->mapCache[ 'option' ][ trim($mixed, '\'"') ])) {
+                    $_indexed_attr[ trim($mixed, '\'"') ] = true;
+                    // shorthand attribute ?
+                } elseif (isset($this->shorttag_order[ $key ])) {
+                    $_indexed_attr[ $this->shorttag_order[ $key ] ] = $mixed;
+                } else {
+                    // too many shorthands
+                    $compiler->trigger_template_error('too many shorthand attributes', null, true);
+                }
+                // named attribute
+            } else {
+                foreach ($mixed as $k => $v) {
+                    // option flag?
+                    if (isset($this->mapCache[ 'option' ][ $k ])) {
+                        if (is_bool($v)) {
+                            $_indexed_attr[ $k ] = $v;
+                        } else {
+                            if (is_string($v)) {
+                                $v = trim($v, '\'" ');
+                            }
+                            if (isset($this->optionMap[ $v ])) {
+                                $_indexed_attr[ $k ] = $this->optionMap[ $v ];
+                            } else {
+                                $compiler->trigger_template_error(
+                                    "illegal value '" . var_export($v, true) .
+                                    "' for option flag '{$k}'",
+                                    null,
+                                    true
+                                );
+                            }
+                        }
+                        // must be named attribute
+                    } else {
+                        $_indexed_attr[ $k ] = $v;
+                    }
+                }
+            }
+        }
+        // check if all required attributes present
+        foreach ($this->required_attributes as $attr) {
+            if (!isset($_indexed_attr[ $attr ])) {
+                $compiler->trigger_template_error("missing '{$attr}' attribute", null, true);
+            }
+        }
+        // check for not allowed attributes
+        if ($this->optional_attributes !== array('_any')) {
+            if (!isset($this->mapCache[ 'all' ])) {
+                $this->mapCache[ 'all' ] =
+                    array_fill_keys(
+                        array_merge(
+                            $this->required_attributes,
+                            $this->optional_attributes,
+                            $this->option_flags
+                        ),
+                        true
+                    );
+            }
+            foreach ($_indexed_attr as $key => $dummy) {
+                if (!isset($this->mapCache[ 'all' ][ $key ]) && $key !== 0) {
+                    $compiler->trigger_template_error("unexpected '{$key}' attribute", null, true);
+                }
+            }
+        }
+        // default 'false' for all option flags not set
+        foreach ($this->option_flags as $flag) {
+            if (!isset($_indexed_attr[ $flag ])) {
+                $_indexed_attr[ $flag ] = false;
+            }
+        }
+        if (isset($_indexed_attr[ 'nocache' ]) && $_indexed_attr[ 'nocache' ]) {
+            $compiler->tag_nocache = true;
+        }
+        return $_indexed_attr;
+    }
+
+    /**
+     * Push opening tag name on stack
+     * Optionally additional data can be saved on stack
+     *
+     * @param object $compiler compiler object
+     * @param string $openTag  the opening tag's name
+     * @param mixed  $data     optional data saved
+     */
+    public function openTag($compiler, $openTag, $data = null)
+    {
+        array_push($compiler->_tag_stack, array($openTag, $data));
+    }
+
+    /**
+     * Pop closing tag
+     * Raise an error if this stack-top doesn't match with expected opening tags
+     *
+     * @param object       $compiler    compiler object
+     * @param array|string $expectedTag the expected opening tag names
+     *
+     * @return mixed        any type the opening tag's name or saved data
+     */
+    public function closeTag($compiler, $expectedTag)
+    {
+        if (count($compiler->_tag_stack) > 0) {
+            // get stacked info
+            list($_openTag, $_data) = array_pop($compiler->_tag_stack);
+            // open tag must match with the expected ones
+            if (in_array($_openTag, (array)$expectedTag)) {
+                if (is_null($_data)) {
+                    // return opening tag
+                    return $_openTag;
+                } else {
+                    // return restored data
+                    return $_data;
+                }
+            }
+            // wrong nesting of tags
+            $compiler->trigger_template_error("unclosed '{$compiler->smarty->left_delimiter}{$_openTag}{$compiler->smarty->right_delimiter}' tag");
+            return;
+        }
+        // wrong nesting of tags
+        $compiler->trigger_template_error('unexpected closing tag', null, true);
+        return;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_config_file_compiler.php b/epgrec/Smarty/sysplugins/smarty_internal_config_file_compiler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_config_file_compiler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_config_file_compiler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,211 @@
+<?php
+/**
+ * Smarty Internal Plugin Config File Compiler
+ * This is the config file compiler class. It calls the lexer and parser to
+ * perform the compiling.
+ *
+ * @package    Smarty
+ * @subpackage Config
+ * @author     Uwe Tews
+ */
+
+/**
+ * Main config file compiler class
+ *
+ * @package    Smarty
+ * @subpackage Config
+ */
+class Smarty_Internal_Config_File_Compiler
+{
+    /**
+     * Lexer class name
+     *
+     * @var string
+     */
+    public $lexer_class;
+
+    /**
+     * Parser class name
+     *
+     * @var string
+     */
+    public $parser_class;
+
+    /**
+     * Lexer object
+     *
+     * @var object
+     */
+    public $lex;
+
+    /**
+     * Parser object
+     *
+     * @var object
+     */
+    public $parser;
+
+    /**
+     * Smarty object
+     *
+     * @var Smarty object
+     */
+    public $smarty;
+
+    /**
+     * Smarty object
+     *
+     * @var Smarty_Internal_Template object
+     */
+    public $template;
+
+    /**
+     * Compiled config data sections and variables
+     *
+     * @var array
+     */
+    public $config_data = array();
+
+    /**
+     * compiled config data must always be written
+     *
+     * @var bool
+     */
+    public $write_compiled_code = true;
+
+    /**
+     * Initialize compiler
+     *
+     * @param string $lexer_class  class name
+     * @param string $parser_class class name
+     * @param Smarty $smarty       global instance
+     */
+    public function __construct($lexer_class, $parser_class, Smarty $smarty)
+    {
+        $this->smarty = $smarty;
+        // get required plugins
+        $this->lexer_class = $lexer_class;
+        $this->parser_class = $parser_class;
+        $this->smarty = $smarty;
+        $this->config_data[ 'sections' ] = array();
+        $this->config_data[ 'vars' ] = array();
+    }
+
+    /**
+     * Method to compile Smarty config source.
+     *
+     * @param Smarty_Internal_Template $template
+     *
+     * @return bool true if compiling succeeded, false if it failed
+     * @throws \SmartyException
+     */
+    public function compileTemplate(Smarty_Internal_Template $template)
+    {
+        $this->template = $template;
+        $this->template->compiled->file_dependency[ $this->template->source->uid ] =
+            array(
+                $this->template->source->filepath,
+                $this->template->source->getTimeStamp(),
+                $this->template->source->type
+            );
+        if ($this->smarty->debugging) {
+            if (!isset($this->smarty->_debug)) {
+                $this->smarty->_debug = new Smarty_Internal_Debug();
+            }
+            $this->smarty->_debug->start_compile($this->template);
+        }
+        // init the lexer/parser to compile the config file
+        /* @var Smarty_Internal_ConfigFileLexer $this->lex */
+        $this->lex = new $this->lexer_class(
+            str_replace(
+                array(
+                    "\r\n",
+                    "\r"
+                ),
+                "\n",
+                $template->source->getContent()
+            ) . "\n",
+            $this
+        );
+        /* @var Smarty_Internal_ConfigFileParser $this->parser */
+        $this->parser = new $this->parser_class($this->lex, $this);
+        if (function_exists('mb_internal_encoding')
+            && function_exists('ini_get')
+            && ((int)ini_get('mbstring.func_overload')) & 2
+        ) {
+            $mbEncoding = mb_internal_encoding();
+            mb_internal_encoding('ASCII');
+        } else {
+            $mbEncoding = null;
+        }
+        if ($this->smarty->_parserdebug) {
+            $this->parser->PrintTrace();
+        }
+        // get tokens from lexer and parse them
+        while ($this->lex->yylex()) {
+            if ($this->smarty->_parserdebug) {
+                echo "<br>Parsing  {$this->parser->yyTokenName[$this->lex->token]} Token {$this->lex->value} Line {$this->lex->line} \n";
+            }
+            $this->parser->doParse($this->lex->token, $this->lex->value);
+        }
+        // finish parsing process
+        $this->parser->doParse(0, 0);
+        if ($mbEncoding) {
+            mb_internal_encoding($mbEncoding);
+        }
+        if ($this->smarty->debugging) {
+            $this->smarty->_debug->end_compile($this->template);
+        }
+        // template header code
+        $template_header = sprintf(
+            "<?php /* Smarty version %s, created on %s\n         compiled from '%s' */ ?>\n",
+            Smarty::SMARTY_VERSION,
+            date("Y-m-d H:i:s"),
+            str_replace('*/', '* /' , $this->template->source->filepath)
+        );
+        $code = '<?php $_smarty_tpl->smarty->ext->configLoad->_loadConfigVars($_smarty_tpl, ' .
+                var_export($this->config_data, true) . '); ?>';
+        return $template_header . $this->template->smarty->ext->_codeFrame->create($this->template, $code);
+    }
+
+    /**
+     * display compiler error messages without dying
+     * If parameter $args is empty it is a parser detected syntax error.
+     * In this case the parser is called to obtain information about expected tokens.
+     * If parameter $args contains a string this is used as error message
+     *
+     * @param string $args individual error message or null
+     *
+     * @throws SmartyCompilerException
+     */
+    public function trigger_config_file_error($args = null)
+    {
+        // get config source line which has error
+        $line = $this->lex->line;
+        if (isset($args)) {
+            // $line--;
+        }
+        $match = preg_split("/\n/", $this->lex->data);
+        $error_text =
+            "Syntax error in config file '{$this->template->source->filepath}' on line {$line} '{$match[$line - 1]}' ";
+        if (isset($args)) {
+            // individual error message
+            $error_text .= $args;
+        } else {
+            // expected token from parser
+            foreach ($this->parser->yy_get_expected_tokens($this->parser->yymajor) as $token) {
+                $exp_token = $this->parser->yyTokenName[ $token ];
+                if (isset($this->lex->smarty_token_names[ $exp_token ])) {
+                    // token type from lexer
+                    $expect[] = '"' . $this->lex->smarty_token_names[ $exp_token ] . '"';
+                } else {
+                    // otherwise internal token name
+                    $expect[] = $this->parser->yyTokenName[ $token ];
+                }
+            }
+            // output parser error message
+            $error_text .= ' - Unexpected "' . $this->lex->value . '", expected one of: ' . implode(' , ', $expect);
+        }
+        throw new SmartyCompilerException($error_text);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_configfilelexer.php b/epgrec/Smarty/sysplugins/smarty_internal_configfilelexer.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_configfilelexer.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_configfilelexer.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,739 @@
+<?php
+/**
+ * Smarty Internal Plugin Configfilelexer
+ *
+ * This is the lexer to break the config file source into tokens
+ *
+ * @package    Smarty
+ * @subpackage Config
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty_Internal_Configfilelexer
+ *
+ * This is the config file lexer.
+ * It is generated from the smarty_internal_configfilelexer.plex file
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Configfilelexer
+{
+    const START              = 1;
+    const VALUE              = 2;
+    const NAKED_STRING_VALUE = 3;
+    const COMMENT            = 4;
+    const SECTION            = 5;
+    const TRIPPLE            = 6;
+
+    /**
+     * Source
+     *
+     * @var string
+     */
+    public $data;
+
+    /**
+     * Source length
+     *
+     * @var int
+     */
+    public $dataLength = null;
+
+    /**
+     * byte counter
+     *
+     * @var int
+     */
+    public $counter;
+
+    /**
+     * token number
+     *
+     * @var int
+     */
+    public $token;
+
+    /**
+     * token value
+     *
+     * @var string
+     */
+    public $value;
+
+    /**
+     * current line
+     *
+     * @var int
+     */
+    public $line;
+
+    /**
+     * state number
+     *
+     * @var int
+     */
+    public $state = 1;
+
+    /**
+     * Smarty object
+     *
+     * @var Smarty
+     */
+    public $smarty = null;
+
+    /**
+     * trace file
+     *
+     * @var resource
+     */
+    public $yyTraceFILE;
+
+    /**
+     * trace prompt
+     *
+     * @var string
+     */
+    public $yyTracePrompt;
+
+    /**
+     * state names
+     *
+     * @var array
+     */
+    public $state_name = array(
+        1 => 'START', 2 => 'VALUE', 3 => 'NAKED_STRING_VALUE', 4 => 'COMMENT', 5 => 'SECTION', 6 => 'TRIPPLE'
+    );
+
+    /**
+     * token names
+     *
+     * @var array
+     */
+    public $smarty_token_names = array(        // Text for parser error messages
+    );
+
+    /**
+     * compiler object
+     *
+     * @var Smarty_Internal_Config_File_Compiler
+     */
+    private $compiler = null;
+
+    /**
+     * copy of config_booleanize
+     *
+     * @var bool
+     */
+    private $configBooleanize = false;
+
+    /**
+     * storage for assembled token patterns
+     *
+     * @var string
+     */
+    private $yy_global_pattern1 = null;
+
+    private $yy_global_pattern2 = null;
+
+    private $yy_global_pattern3 = null;
+
+    private $yy_global_pattern4 = null;
+
+    private $yy_global_pattern5 = null;
+
+    private $yy_global_pattern6 = null;
+
+    private $_yy_state          = 1;
+
+    private $_yy_stack          = array();
+
+    /**
+     * constructor
+     *
+     * @param   string                             $data template source
+     * @param Smarty_Internal_Config_File_Compiler $compiler
+     */
+    public function __construct($data, Smarty_Internal_Config_File_Compiler $compiler)
+    {
+        $this->data = $data . "\n"; //now all lines are \n-terminated
+        $this->dataLength = strlen($data);
+        $this->counter = 0;
+        if (preg_match('/^\xEF\xBB\xBF/', $this->data, $match)) {
+            $this->counter += strlen($match[ 0 ]);
+        }
+        $this->line = 1;
+        $this->compiler = $compiler;
+        $this->smarty = $compiler->smarty;
+        $this->configBooleanize = $this->smarty->config_booleanize;
+    }
+
+    public function replace($input)
+    {
+        return $input;
+    } // end function
+
+    public function PrintTrace()
+    {
+        $this->yyTraceFILE = fopen('php://output', 'w');
+        $this->yyTracePrompt = '<br>';
+    }
+
+    public function yylex()
+    {
+        return $this->{'yylex' . $this->_yy_state}();
+    }
+
+    public function yypushstate($state)
+    {
+        if ($this->yyTraceFILE) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%sState push %s\n",
+                $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state
+            );
+        }
+        array_push($this->_yy_stack, $this->_yy_state);
+        $this->_yy_state = $state;
+        if ($this->yyTraceFILE) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%snew State %s\n",
+                $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state
+            );
+        }
+    }
+
+    public function yypopstate()
+    {
+        if ($this->yyTraceFILE) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%sState pop %s\n",
+                $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state
+            );
+        }
+        $this->_yy_state = array_pop($this->_yy_stack);
+        if ($this->yyTraceFILE) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%snew State %s\n",
+                $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state
+            );
+        }
+    }
+
+    public function yybegin($state)
+    {
+        $this->_yy_state = $state;
+        if ($this->yyTraceFILE) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%sState set %s\n",
+                $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state
+            );
+        }
+    }
+
+    public function yylex1()
+    {
+        if (!isset($this->yy_global_pattern1)) {
+            $this->yy_global_pattern1 =
+                $this->replace("/\G(#|;)|\G(\\[)|\G(\\])|\G(=)|\G([ \t\r]+)|\G(\n)|\G([0-9]*[a-zA-Z_]\\w*)|\G([\S\s])/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern1, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr(
+                                            $this->data,
+                                            $this->counter,
+                                            5
+                                        ) . '... state START');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r1_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r1_1()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_COMMENTSTART;
+        $this->yypushstate(self::COMMENT);
+    }
+
+    public function yy_r1_2()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_OPENB;
+        $this->yypushstate(self::SECTION);
+    }
+
+    public function yy_r1_3()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_CLOSEB;
+    }
+
+    public function yy_r1_4()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_EQUAL;
+        $this->yypushstate(self::VALUE);
+    } // end function
+
+    public function yy_r1_5()
+    {
+        return false;
+    }
+
+    public function yy_r1_6()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_NEWLINE;
+    }
+
+    public function yy_r1_7()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_ID;
+    }
+
+    public function yy_r1_8()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_OTHER;
+    }
+
+    public function yylex2()
+    {
+        if (!isset($this->yy_global_pattern2)) {
+            $this->yy_global_pattern2 =
+                $this->replace("/\G([ \t\r]+)|\G(\\d+\\.\\d+(?=[ \t\r]*[\n#;]))|\G(\\d+(?=[ \t\r]*[\n#;]))|\G(\"\"\")|\G('[^'\\\\]*(?:\\\\.[^'\\\\]*)*'(?=[ \t\r]*[\n#;]))|\G(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"(?=[ \t\r]*[\n#;]))|\G([a-zA-Z]+(?=[ \t\r]*[\n#;]))|\G([^\n]+?(?=[ \t\r]*\n))|\G(\n)/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern2, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr(
+                                            $this->data,
+                                            $this->counter,
+                                            5
+                                        ) . '... state VALUE');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r2_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r2_1()
+    {
+        return false;
+    }
+
+    public function yy_r2_2()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_FLOAT;
+        $this->yypopstate();
+    }
+
+    public function yy_r2_3()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_INT;
+        $this->yypopstate();
+    }
+
+    public function yy_r2_4()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_TRIPPLE_QUOTES;
+        $this->yypushstate(self::TRIPPLE);
+    }
+
+    public function yy_r2_5()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_SINGLE_QUOTED_STRING;
+        $this->yypopstate();
+    }
+
+    public function yy_r2_6()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_DOUBLE_QUOTED_STRING;
+        $this->yypopstate();
+    } // end function
+
+    public function yy_r2_7()
+    {
+        if (!$this->configBooleanize ||
+            !in_array(strtolower($this->value), array('true', 'false', 'on', 'off', 'yes', 'no'))) {
+            $this->yypopstate();
+            $this->yypushstate(self::NAKED_STRING_VALUE);
+            return true; //reprocess in new state
+        } else {
+            $this->token = Smarty_Internal_Configfileparser::TPC_BOOL;
+            $this->yypopstate();
+        }
+    }
+
+    public function yy_r2_8()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_NAKED_STRING;
+        $this->yypopstate();
+    }
+
+    public function yy_r2_9()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_NAKED_STRING;
+        $this->value = '';
+        $this->yypopstate();
+    } // end function
+
+    public function yylex3()
+    {
+        if (!isset($this->yy_global_pattern3)) {
+            $this->yy_global_pattern3 = $this->replace("/\G([^\n]+?(?=[ \t\r]*\n))/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern3, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr(
+                                            $this->data,
+                                            $this->counter,
+                                            5
+                                        ) . '... state NAKED_STRING_VALUE');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r3_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r3_1()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_NAKED_STRING;
+        $this->yypopstate();
+    }
+
+    public function yylex4()
+    {
+        if (!isset($this->yy_global_pattern4)) {
+            $this->yy_global_pattern4 = $this->replace("/\G([ \t\r]+)|\G([^\n]+?(?=[ \t\r]*\n))|\G(\n)/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern4, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr(
+                                            $this->data,
+                                            $this->counter,
+                                            5
+                                        ) . '... state COMMENT');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r4_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r4_1()
+    {
+        return false;
+    }
+
+    public function yy_r4_2()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_NAKED_STRING;
+    } // end function
+
+    public function yy_r4_3()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_NEWLINE;
+        $this->yypopstate();
+    }
+
+    public function yylex5()
+    {
+        if (!isset($this->yy_global_pattern5)) {
+            $this->yy_global_pattern5 = $this->replace("/\G(\\.)|\G(.*?(?=[\.=[\]\r\n]))/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern5, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr(
+                                            $this->data,
+                                            $this->counter,
+                                            5
+                                        ) . '... state SECTION');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r5_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r5_1()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_DOT;
+    }
+
+    public function yy_r5_2()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_SECTION;
+        $this->yypopstate();
+    } // end function
+
+    public function yylex6()
+    {
+        if (!isset($this->yy_global_pattern6)) {
+            $this->yy_global_pattern6 = $this->replace("/\G(\"\"\"(?=[ \t\r]*[\n#;]))|\G([\S\s])/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern6, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr(
+                                            $this->data,
+                                            $this->counter,
+                                            5
+                                        ) . '... state TRIPPLE');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r6_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r6_1()
+    {
+        $this->token = Smarty_Internal_Configfileparser::TPC_TRIPPLE_QUOTES_END;
+        $this->yypopstate();
+        $this->yypushstate(self::START);
+    }
+
+    public function yy_r6_2()
+    {
+        $to = strlen($this->data);
+        preg_match("/\"\"\"[ \t\r]*[\n#;]/", $this->data, $match, PREG_OFFSET_CAPTURE, $this->counter);
+        if (isset($match[ 0 ][ 1 ])) {
+            $to = $match[ 0 ][ 1 ];
+        } else {
+            $this->compiler->trigger_config_file_error('missing or misspelled literal closing tag');
+        }
+        $this->value = substr($this->data, $this->counter, $to - $this->counter);
+        $this->token = Smarty_Internal_Configfileparser::TPC_TRIPPLE_TEXT;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_configfileparser.php b/epgrec/Smarty/sysplugins/smarty_internal_configfileparser.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_configfileparser.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_configfileparser.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,1046 @@
+<?php
+
+class TPC_yyStackEntry
+{
+    public $stateno;       /* The state-number */
+    public $major;         /* The major token value.  This is the code
+                     ** number for the token at this stack level */
+    public $minor; /* The user-supplied minor token value.  This
+                     ** is the value of the token  */
+}
+
+// line 12 "../smarty/lexer/smarty_internal_configfileparser.y"
+
+/**
+ * Smarty Internal Plugin Configfileparse
+ *
+ * This is the config file parser.
+ * It is generated from the smarty_internal_configfileparser.y file
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Configfileparser
+{
+    // line 25 "../smarty/lexer/smarty_internal_configfileparser.y"
+    const TPC_OPENB                = 1;
+    const TPC_SECTION              = 2;
+    const TPC_CLOSEB               = 3;
+    const TPC_DOT                  = 4;
+    const TPC_ID                   = 5;
+    const TPC_EQUAL                = 6;
+    const TPC_FLOAT                = 7;
+    const TPC_INT                  = 8;
+    const TPC_BOOL                 = 9;
+    const TPC_SINGLE_QUOTED_STRING = 10;
+    const TPC_DOUBLE_QUOTED_STRING = 11;
+    const TPC_TRIPPLE_QUOTES       = 12;
+    const TPC_TRIPPLE_TEXT         = 13;
+    const TPC_TRIPPLE_QUOTES_END   = 14;
+    const TPC_NAKED_STRING         = 15;
+    const TPC_OTHER                = 16;
+    const TPC_NEWLINE              = 17;
+    const TPC_COMMENTSTART         = 18;
+    const YY_NO_ACTION             = 60;
+    const YY_ACCEPT_ACTION         = 59;
+    const YY_ERROR_ACTION          = 58;
+    const YY_SZ_ACTTAB             = 38;
+    const YY_SHIFT_USE_DFLT        = -8;
+    const YY_SHIFT_MAX             = 19;
+    const YY_REDUCE_USE_DFLT       = -17;
+    const YY_REDUCE_MAX            = 10;
+    const YYNOCODE                 = 29;
+    const YYSTACKDEPTH             = 100;
+    const YYNSTATE                 = 36;
+    const YYNRULE                  = 22;
+    const YYERRORSYMBOL            = 19;
+    const YYERRSYMDT               = 'yy0';
+    const YYFALLBACK               = 0;
+
+    public static $yy_action        = array(
+        32, 31, 30, 29, 35, 13, 19, 3, 24, 26,
+        59, 9, 14, 1, 16, 25, 11, 28, 25, 11,
+        17, 27, 34, 20, 18, 15, 23, 5, 6, 22,
+        10, 8, 4, 12, 2, 33, 7, 21,
+    );
+
+    public static $yy_lookahead     = array(
+        7, 8, 9, 10, 11, 12, 5, 23, 15, 16,
+        20, 21, 2, 23, 4, 17, 18, 14, 17, 18,
+        13, 14, 25, 26, 15, 2, 17, 3, 3, 17,
+        25, 25, 6, 1, 23, 27, 22, 24,
+    );
+
+    public static $yy_shift_ofst    = array(
+        -8, 1, 1, 1, -7, -2, -2, 32, -8, -8,
+        -8, 9, 10, 7, 25, 24, 23, 3, 12, 26,
+    );
+
+    public static $yy_reduce_ofst   = array(
+        -10, -3, -3, -3, 8, 6, 5, 13, 11, 14,
+        -16,
+    );
+
+    public static $yyExpectedTokens = array(
+        array(),
+        array(5, 17, 18,),
+        array(5, 17, 18,),
+        array(5, 17, 18,),
+        array(7, 8, 9, 10, 11, 12, 15, 16,),
+        array(17, 18,),
+        array(17, 18,),
+        array(1,),
+        array(),
+        array(),
+        array(),
+        array(15, 17,),
+        array(2, 4,),
+        array(13, 14,),
+        array(3,),
+        array(3,),
+        array(2,),
+        array(14,),
+        array(17,),
+        array(6,),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+    );
+
+    public static $yy_default       = array(
+        44, 37, 41, 40, 58, 58, 58, 36, 44, 39,
+        44, 58, 58, 58, 58, 58, 58, 58, 58, 58,
+        43, 38, 57, 56, 53, 55, 54, 52, 51, 49,
+        48, 47, 46, 45, 42, 50,
+    );
+
+    public static $yyFallback       = array();
+
+    public static $yyRuleName       = array(
+        'start ::= global_vars sections',
+        'global_vars ::= var_list',
+        'sections ::= sections section',
+        'sections ::=',
+        'section ::= OPENB SECTION CLOSEB newline var_list',
+        'section ::= OPENB DOT SECTION CLOSEB newline var_list',
+        'var_list ::= var_list newline',
+        'var_list ::= var_list var',
+        'var_list ::=',
+        'var ::= ID EQUAL value',
+        'value ::= FLOAT',
+        'value ::= INT',
+        'value ::= BOOL',
+        'value ::= SINGLE_QUOTED_STRING',
+        'value ::= DOUBLE_QUOTED_STRING',
+        'value ::= TRIPPLE_QUOTES TRIPPLE_TEXT TRIPPLE_QUOTES_END',
+        'value ::= TRIPPLE_QUOTES TRIPPLE_QUOTES_END',
+        'value ::= NAKED_STRING',
+        'value ::= OTHER',
+        'newline ::= NEWLINE',
+        'newline ::= COMMENTSTART NEWLINE',
+        'newline ::= COMMENTSTART NAKED_STRING NEWLINE',
+    );
+
+    public static $yyRuleInfo       = array(
+        array(0 => 20, 1 => 2),
+        array(0 => 21, 1 => 1),
+        array(0 => 22, 1 => 2),
+        array(0 => 22, 1 => 0),
+        array(0 => 24, 1 => 5),
+        array(0 => 24, 1 => 6),
+        array(0 => 23, 1 => 2),
+        array(0 => 23, 1 => 2),
+        array(0 => 23, 1 => 0),
+        array(0 => 26, 1 => 3),
+        array(0 => 27, 1 => 1),
+        array(0 => 27, 1 => 1),
+        array(0 => 27, 1 => 1),
+        array(0 => 27, 1 => 1),
+        array(0 => 27, 1 => 1),
+        array(0 => 27, 1 => 3),
+        array(0 => 27, 1 => 2),
+        array(0 => 27, 1 => 1),
+        array(0 => 27, 1 => 1),
+        array(0 => 25, 1 => 1),
+        array(0 => 25, 1 => 2),
+        array(0 => 25, 1 => 3),
+    );
+
+    public static $yyReduceMap      = array(
+        0  => 0,
+        2  => 0,
+        3  => 0,
+        19 => 0,
+        20 => 0,
+        21 => 0,
+        1  => 1,
+        4  => 4,
+        5  => 5,
+        6  => 6,
+        7  => 7,
+        8  => 8,
+        9  => 9,
+        10 => 10,
+        11 => 11,
+        12 => 12,
+        13 => 13,
+        14 => 14,
+        15 => 15,
+        16 => 16,
+        17 => 17,
+        18 => 17,
+    );
+
+    /**
+     * helper map
+     *
+     * @var array
+     */
+    private static $escapes_single = array(
+        '\\' => '\\',
+        '\'' => '\''
+    );
+
+    /**
+     * result status
+     *
+     * @var bool
+     */
+    public $successful = true;
+
+    /**
+     * return value
+     *
+     * @var mixed
+     */
+    public $retvalue = 0;
+
+    /**
+     * @var
+     */
+    public $yymajor;
+
+    /**
+     * compiler object
+     *
+     * @var Smarty_Internal_Config_File_Compiler
+     */
+    public $compiler = null;
+
+    /**
+     * smarty object
+     *
+     * @var Smarty
+     */
+    public $smarty      = null;
+
+    public $yyTraceFILE;
+
+    public $yyTracePrompt;
+
+    public $yyidx;
+
+    public $yyerrcnt;
+
+    public $yystack     = array();
+
+    public $yyTokenName = array(
+        '$', 'OPENB', 'SECTION', 'CLOSEB',
+        'DOT', 'ID', 'EQUAL', 'FLOAT',
+        'INT', 'BOOL', 'SINGLE_QUOTED_STRING', 'DOUBLE_QUOTED_STRING',
+        'TRIPPLE_QUOTES', 'TRIPPLE_TEXT', 'TRIPPLE_QUOTES_END', 'NAKED_STRING',
+        'OTHER', 'NEWLINE', 'COMMENTSTART', 'error',
+        'start', 'global_vars', 'sections', 'var_list',
+        'section', 'newline', 'var', 'value',
+    );
+
+    /**
+     * lexer object
+     *
+     * @var Smarty_Internal_Configfilelexer
+     */
+    private $lex;
+
+    /**
+     * internal error flag
+     *
+     * @var bool
+     */
+    private $internalError = false;
+
+    /**
+     * copy of config_overwrite property
+     *
+     * @var bool
+     */
+    private $configOverwrite = false;
+
+    /**
+     * copy of config_read_hidden property
+     *
+     * @var bool
+     */
+    private $configReadHidden = false;
+
+    private $_retvalue;
+
+    /**
+     * constructor
+     *
+     * @param Smarty_Internal_Configfilelexer      $lex
+     * @param Smarty_Internal_Config_File_Compiler $compiler
+     */
+    public function __construct(Smarty_Internal_Configfilelexer $lex, Smarty_Internal_Config_File_Compiler $compiler)
+    {
+        $this->lex = $lex;
+        $this->smarty = $compiler->smarty;
+        $this->compiler = $compiler;
+        $this->configOverwrite = $this->smarty->config_overwrite;
+        $this->configReadHidden = $this->smarty->config_read_hidden;
+    }
+
+    public static function yy_destructor($yymajor, $yypminor)
+    {
+        switch ($yymajor) {
+            default:
+                break;   /* If no destructor action specified: do nothing */
+        }
+    }
+
+    /**
+     * parse single quoted string
+     *  remove outer quotes
+     *  unescape inner quotes
+     *
+     * @param string $qstr
+     *
+     * @return string
+     */
+    private static function parse_single_quoted_string($qstr)
+    {
+        $escaped_string = substr($qstr, 1, strlen($qstr) - 2); //remove outer quotes
+        $ss = preg_split('/(\\\\.)/', $escaped_string, -1, PREG_SPLIT_DELIM_CAPTURE);
+        $str = '';
+        foreach ($ss as $s) {
+            if (strlen($s) === 2 && $s[ 0 ] === '\\') {
+                if (isset(self::$escapes_single[ $s[ 1 ] ])) {
+                    $s = self::$escapes_single[ $s[ 1 ] ];
+                }
+            }
+            $str .= $s;
+        }
+        return $str;
+    }                    /* Index of top element in stack */
+    /**
+     * parse double quoted string
+     *
+     * @param string $qstr
+     *
+     * @return string
+     */
+    private static function parse_double_quoted_string($qstr)
+    {
+        $inner_str = substr($qstr, 1, strlen($qstr) - 2);
+        return stripcslashes($inner_str);
+    }                 /* Shifts left before out of the error */
+    /**
+     * parse triple quoted string
+     *
+     * @param string $qstr
+     *
+     * @return string
+     */
+    private static function parse_tripple_double_quoted_string($qstr)
+    {
+        return stripcslashes($qstr);
+    }  /* The parser's stack */
+    public function Trace($TraceFILE, $zTracePrompt)
+    {
+        if (!$TraceFILE) {
+            $zTracePrompt = 0;
+        } elseif (!$zTracePrompt) {
+            $TraceFILE = 0;
+        }
+        $this->yyTraceFILE = $TraceFILE;
+        $this->yyTracePrompt = $zTracePrompt;
+    }
+
+    public function PrintTrace()
+    {
+        $this->yyTraceFILE = fopen('php://output', 'w');
+        $this->yyTracePrompt = '<br>';
+    }
+
+    public function tokenName($tokenType)
+    {
+        if ($tokenType === 0) {
+            return 'End of Input';
+        }
+        if ($tokenType > 0 && $tokenType < count($this->yyTokenName)) {
+            return $this->yyTokenName[ $tokenType ];
+        } else {
+            return 'Unknown';
+        }
+    }
+
+    public function yy_pop_parser_stack()
+    {
+        if (empty($this->yystack)) {
+            return;
+        }
+        $yytos = array_pop($this->yystack);
+        if ($this->yyTraceFILE && $this->yyidx >= 0) {
+            fwrite(
+                $this->yyTraceFILE,
+                $this->yyTracePrompt . 'Popping ' . $this->yyTokenName[ $yytos->major ] .
+                "\n"
+            );
+        }
+        $yymajor = $yytos->major;
+        self::yy_destructor($yymajor, $yytos->minor);
+        $this->yyidx--;
+        return $yymajor;
+    }
+
+    public function __destruct()
+    {
+        while ($this->yystack !== array()) {
+            $this->yy_pop_parser_stack();
+        }
+        if (is_resource($this->yyTraceFILE)) {
+            fclose($this->yyTraceFILE);
+        }
+    }
+
+    public function yy_get_expected_tokens($token)
+    {
+        static $res3 = array();
+        static $res4 = array();
+        $state = $this->yystack[ $this->yyidx ]->stateno;
+        $expected = self::$yyExpectedTokens[ $state ];
+        if (isset($res3[ $state ][ $token ])) {
+            if ($res3[ $state ][ $token ]) {
+                return $expected;
+            }
+        } else {
+            if ($res3[ $state ][ $token ] = in_array($token, self::$yyExpectedTokens[ $state ], true)) {
+                return $expected;
+            }
+        }
+        $stack = $this->yystack;
+        $yyidx = $this->yyidx;
+        do {
+            $yyact = $this->yy_find_shift_action($token);
+            if ($yyact >= self::YYNSTATE && $yyact < self::YYNSTATE + self::YYNRULE) {
+                // reduce action
+                $done = 0;
+                do {
+                    if ($done++ === 100) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // too much recursion prevents proper detection
+                        // so give up
+                        return array_unique($expected);
+                    }
+                    $yyruleno = $yyact - self::YYNSTATE;
+                    $this->yyidx -= self::$yyRuleInfo[ $yyruleno ][ 1 ];
+                    $nextstate = $this->yy_find_reduce_action(
+                        $this->yystack[ $this->yyidx ]->stateno,
+                        self::$yyRuleInfo[ $yyruleno ][ 0 ]
+                    );
+                    if (isset(self::$yyExpectedTokens[ $nextstate ])) {
+                        $expected = array_merge($expected, self::$yyExpectedTokens[ $nextstate ]);
+                        if (isset($res4[ $nextstate ][ $token ])) {
+                            if ($res4[ $nextstate ][ $token ]) {
+                                $this->yyidx = $yyidx;
+                                $this->yystack = $stack;
+                                return array_unique($expected);
+                            }
+                        } else {
+                            if ($res4[ $nextstate ][ $token ] =
+                                in_array($token, self::$yyExpectedTokens[ $nextstate ], true)) {
+                                $this->yyidx = $yyidx;
+                                $this->yystack = $stack;
+                                return array_unique($expected);
+                            }
+                        }
+                    }
+                    if ($nextstate < self::YYNSTATE) {
+                        // we need to shift a non-terminal
+                        $this->yyidx++;
+                        $x = new TPC_yyStackEntry;
+                        $x->stateno = $nextstate;
+                        $x->major = self::$yyRuleInfo[ $yyruleno ][ 0 ];
+                        $this->yystack[ $this->yyidx ] = $x;
+                        continue 2;
+                    } elseif ($nextstate === self::YYNSTATE + self::YYNRULE + 1) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // the last token was just ignored, we can't accept
+                        // by ignoring input, this is in essence ignoring a
+                        // syntax error!
+                        return array_unique($expected);
+                    } elseif ($nextstate === self::YY_NO_ACTION) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // input accepted, but not shifted (I guess)
+                        return $expected;
+                    } else {
+                        $yyact = $nextstate;
+                    }
+                } while (true);
+            }
+            break;
+        } while (true);
+        $this->yyidx = $yyidx;
+        $this->yystack = $stack;
+        return array_unique($expected);
+    }
+
+    public function yy_is_expected_token($token)
+    {
+        static $res = array();
+        static $res2 = array();
+        if ($token === 0) {
+            return true; // 0 is not part of this
+        }
+        $state = $this->yystack[ $this->yyidx ]->stateno;
+        if (isset($res[ $state ][ $token ])) {
+            if ($res[ $state ][ $token ]) {
+                return true;
+            }
+        } else {
+            if ($res[ $state ][ $token ] = in_array($token, self::$yyExpectedTokens[ $state ], true)) {
+                return true;
+            }
+        }
+        $stack = $this->yystack;
+        $yyidx = $this->yyidx;
+        do {
+            $yyact = $this->yy_find_shift_action($token);
+            if ($yyact >= self::YYNSTATE && $yyact < self::YYNSTATE + self::YYNRULE) {
+                // reduce action
+                $done = 0;
+                do {
+                    if ($done++ === 100) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // too much recursion prevents proper detection
+                        // so give up
+                        return true;
+                    }
+                    $yyruleno = $yyact - self::YYNSTATE;
+                    $this->yyidx -= self::$yyRuleInfo[ $yyruleno ][ 1 ];
+                    $nextstate = $this->yy_find_reduce_action(
+                        $this->yystack[ $this->yyidx ]->stateno,
+                        self::$yyRuleInfo[ $yyruleno ][ 0 ]
+                    );
+                    if (isset($res2[ $nextstate ][ $token ])) {
+                        if ($res2[ $nextstate ][ $token ]) {
+                            $this->yyidx = $yyidx;
+                            $this->yystack = $stack;
+                            return true;
+                        }
+                    } else {
+                        if ($res2[ $nextstate ][ $token ] =
+                            (isset(self::$yyExpectedTokens[ $nextstate ]) &&
+                             in_array($token, self::$yyExpectedTokens[ $nextstate ], true))) {
+                            $this->yyidx = $yyidx;
+                            $this->yystack = $stack;
+                            return true;
+                        }
+                    }
+                    if ($nextstate < self::YYNSTATE) {
+                        // we need to shift a non-terminal
+                        $this->yyidx++;
+                        $x = new TPC_yyStackEntry;
+                        $x->stateno = $nextstate;
+                        $x->major = self::$yyRuleInfo[ $yyruleno ][ 0 ];
+                        $this->yystack[ $this->yyidx ] = $x;
+                        continue 2;
+                    } elseif ($nextstate === self::YYNSTATE + self::YYNRULE + 1) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        if (!$token) {
+                            // end of input: this is valid
+                            return true;
+                        }
+                        // the last token was just ignored, we can't accept
+                        // by ignoring input, this is in essence ignoring a
+                        // syntax error!
+                        return false;
+                    } elseif ($nextstate === self::YY_NO_ACTION) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // input accepted, but not shifted (I guess)
+                        return true;
+                    } else {
+                        $yyact = $nextstate;
+                    }
+                } while (true);
+            }
+            break;
+        } while (true);
+        $this->yyidx = $yyidx;
+        $this->yystack = $stack;
+        return true;
+    }
+
+    public function yy_find_shift_action($iLookAhead)
+    {
+        $stateno = $this->yystack[ $this->yyidx ]->stateno;
+        /* if ($this->yyidx < 0) return self::YY_NO_ACTION;  */
+        if (!isset(self::$yy_shift_ofst[ $stateno ])) {
+            // no shift actions
+            return self::$yy_default[ $stateno ];
+        }
+        $i = self::$yy_shift_ofst[ $stateno ];
+        if ($i === self::YY_SHIFT_USE_DFLT) {
+            return self::$yy_default[ $stateno ];
+        }
+        if ($iLookAhead === self::YYNOCODE) {
+            return self::YY_NO_ACTION;
+        }
+        $i += $iLookAhead;
+        if ($i < 0 || $i >= self::YY_SZ_ACTTAB ||
+            self::$yy_lookahead[ $i ] != $iLookAhead) {
+            if (count(self::$yyFallback) && $iLookAhead < count(self::$yyFallback)
+                && ($iFallback = self::$yyFallback[ $iLookAhead ]) != 0) {
+                if ($this->yyTraceFILE) {
+                    fwrite($this->yyTraceFILE, $this->yyTracePrompt . 'FALLBACK ' .
+                                               $this->yyTokenName[ $iLookAhead ] . ' => ' .
+                                               $this->yyTokenName[ $iFallback ] . "\n");
+                }
+                return $this->yy_find_shift_action($iFallback);
+            }
+            return self::$yy_default[ $stateno ];
+        } else {
+            return self::$yy_action[ $i ];
+        }
+    }
+
+    public function yy_find_reduce_action($stateno, $iLookAhead)
+    {
+        /* $stateno = $this->yystack[$this->yyidx]->stateno; */
+        if (!isset(self::$yy_reduce_ofst[ $stateno ])) {
+            return self::$yy_default[ $stateno ];
+        }
+        $i = self::$yy_reduce_ofst[ $stateno ];
+        if ($i === self::YY_REDUCE_USE_DFLT) {
+            return self::$yy_default[ $stateno ];
+        }
+        if ($iLookAhead === self::YYNOCODE) {
+            return self::YY_NO_ACTION;
+        }
+        $i += $iLookAhead;
+        if ($i < 0 || $i >= self::YY_SZ_ACTTAB ||
+            self::$yy_lookahead[ $i ] != $iLookAhead) {
+            return self::$yy_default[ $stateno ];
+        } else {
+            return self::$yy_action[ $i ];
+        }
+    }
+
+    public function yy_shift($yyNewState, $yyMajor, $yypMinor)
+    {
+        $this->yyidx++;
+        if ($this->yyidx >= self::YYSTACKDEPTH) {
+            $this->yyidx--;
+            if ($this->yyTraceFILE) {
+                fprintf($this->yyTraceFILE, "%sStack Overflow!\n", $this->yyTracePrompt);
+            }
+            while ($this->yyidx >= 0) {
+                $this->yy_pop_parser_stack();
+            }
+            // line 239 "../smarty/lexer/smarty_internal_configfileparser.y"
+            $this->internalError = true;
+            $this->compiler->trigger_config_file_error('Stack overflow in configfile parser');
+            return;
+        }
+        $yytos = new TPC_yyStackEntry;
+        $yytos->stateno = $yyNewState;
+        $yytos->major = $yyMajor;
+        $yytos->minor = $yypMinor;
+        $this->yystack[] = $yytos;
+        if ($this->yyTraceFILE && $this->yyidx > 0) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%sShift %d\n",
+                $this->yyTracePrompt,
+                $yyNewState
+            );
+            fprintf($this->yyTraceFILE, "%sStack:", $this->yyTracePrompt);
+            for ($i = 1; $i <= $this->yyidx; $i++) {
+                fprintf(
+                    $this->yyTraceFILE,
+                    " %s",
+                    $this->yyTokenName[ $this->yystack[ $i ]->major ]
+                );
+            }
+            fwrite($this->yyTraceFILE, "\n");
+        }
+    }
+
+    public function yy_r0()
+    {
+        $this->_retvalue = null;
+    }
+
+    public function yy_r1()
+    {
+        $this->add_global_vars($this->yystack[ $this->yyidx + 0 ]->minor);
+        $this->_retvalue = null;
+    }
+
+    public function yy_r4()
+    {
+        $this->add_section_vars($this->yystack[ $this->yyidx + -3 ]->minor, $this->yystack[ $this->yyidx + 0 ]->minor);
+        $this->_retvalue = null;
+    }
+
+    // line 245 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r5()
+    {
+        if ($this->configReadHidden) {
+            $this->add_section_vars(
+                $this->yystack[ $this->yyidx + -3 ]->minor,
+                $this->yystack[ $this->yyidx + 0 ]->minor
+            );
+        }
+        $this->_retvalue = null;
+    }
+
+    // line 250 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r6()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor;
+    }
+
+    // line 264 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r7()
+    {
+        $this->_retvalue =
+            array_merge($this->yystack[ $this->yyidx + -1 ]->minor, array($this->yystack[ $this->yyidx + 0 ]->minor));
+    }
+
+    // line 269 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r8()
+    {
+        $this->_retvalue = array();
+    }
+
+    // line 277 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r9()
+    {
+        $this->_retvalue =
+            array(
+                'key'   => $this->yystack[ $this->yyidx + -2 ]->minor,
+                'value' => $this->yystack[ $this->yyidx + 0 ]->minor
+            );
+    }
+
+    // line 281 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r10()
+    {
+        $this->_retvalue = (float)$this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 285 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r11()
+    {
+        $this->_retvalue = (int)$this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 291 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r12()
+    {
+        $this->_retvalue = $this->parse_bool($this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 296 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r13()
+    {
+        $this->_retvalue = self::parse_single_quoted_string($this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 300 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r14()
+    {
+        $this->_retvalue = self::parse_double_quoted_string($this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 304 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r15()
+    {
+        $this->_retvalue = self::parse_tripple_double_quoted_string($this->yystack[ $this->yyidx + -1 ]->minor);
+    }
+
+    // line 308 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r16()
+    {
+        $this->_retvalue = '';
+    }
+
+    // line 312 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_r17()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 316 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_reduce($yyruleno)
+    {
+        if ($this->yyTraceFILE && $yyruleno >= 0
+            && $yyruleno < count(self::$yyRuleName)) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%sReduce (%d) [%s].\n",
+                $this->yyTracePrompt,
+                $yyruleno,
+                self::$yyRuleName[ $yyruleno ]
+            );
+        }
+        $this->_retvalue = $yy_lefthand_side = null;
+        if (isset(self::$yyReduceMap[ $yyruleno ])) {
+            // call the action
+            $this->_retvalue = null;
+            $this->{'yy_r' . self::$yyReduceMap[ $yyruleno ]}();
+            $yy_lefthand_side = $this->_retvalue;
+        }
+        $yygoto = self::$yyRuleInfo[ $yyruleno ][ 0 ];
+        $yysize = self::$yyRuleInfo[ $yyruleno ][ 1 ];
+        $this->yyidx -= $yysize;
+        for ($i = $yysize; $i; $i--) {
+            // pop all of the right-hand side parameters
+            array_pop($this->yystack);
+        }
+        $yyact = $this->yy_find_reduce_action($this->yystack[ $this->yyidx ]->stateno, $yygoto);
+        if ($yyact < self::YYNSTATE) {
+            if (!$this->yyTraceFILE && $yysize) {
+                $this->yyidx++;
+                $x = new TPC_yyStackEntry;
+                $x->stateno = $yyact;
+                $x->major = $yygoto;
+                $x->minor = $yy_lefthand_side;
+                $this->yystack[ $this->yyidx ] = $x;
+            } else {
+                $this->yy_shift($yyact, $yygoto, $yy_lefthand_side);
+            }
+        } elseif ($yyact === self::YYNSTATE + self::YYNRULE + 1) {
+            $this->yy_accept();
+        }
+    }
+
+    // line 320 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_parse_failed()
+    {
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sFail!\n", $this->yyTracePrompt);
+        }
+        while ($this->yyidx >= 0) {
+            $this->yy_pop_parser_stack();
+        }
+    }
+
+    // line 324 "../smarty/lexer/smarty_internal_configfileparser.y"
+    public function yy_syntax_error($yymajor, $TOKEN)
+    {
+        // line 232 "../smarty/lexer/smarty_internal_configfileparser.y"
+        $this->internalError = true;
+        $this->yymajor = $yymajor;
+        $this->compiler->trigger_config_file_error();
+    }
+
+    public function yy_accept()
+    {
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sAccept!\n", $this->yyTracePrompt);
+        }
+        while ($this->yyidx >= 0) {
+            $this->yy_pop_parser_stack();
+        }
+        // line 225 "../smarty/lexer/smarty_internal_configfileparser.y"
+        $this->successful = !$this->internalError;
+        $this->internalError = false;
+        $this->retvalue = $this->_retvalue;
+    }
+
+    public function doParse($yymajor, $yytokenvalue)
+    {
+        $yyerrorhit = 0;   /* True if yymajor has invoked an error */
+        if ($this->yyidx === null || $this->yyidx < 0) {
+            $this->yyidx = 0;
+            $this->yyerrcnt = -1;
+            $x = new TPC_yyStackEntry;
+            $x->stateno = 0;
+            $x->major = 0;
+            $this->yystack = array();
+            $this->yystack[] = $x;
+        }
+        $yyendofinput = ($yymajor == 0);
+        if ($this->yyTraceFILE) {
+            fprintf(
+                $this->yyTraceFILE,
+                "%sInput %s\n",
+                $this->yyTracePrompt,
+                $this->yyTokenName[ $yymajor ]
+            );
+        }
+        do {
+            $yyact = $this->yy_find_shift_action($yymajor);
+            if ($yymajor < self::YYERRORSYMBOL &&
+                !$this->yy_is_expected_token($yymajor)) {
+                // force a syntax error
+                $yyact = self::YY_ERROR_ACTION;
+            }
+            if ($yyact < self::YYNSTATE) {
+                $this->yy_shift($yyact, $yymajor, $yytokenvalue);
+                $this->yyerrcnt--;
+                if ($yyendofinput && $this->yyidx >= 0) {
+                    $yymajor = 0;
+                } else {
+                    $yymajor = self::YYNOCODE;
+                }
+            } elseif ($yyact < self::YYNSTATE + self::YYNRULE) {
+                $this->yy_reduce($yyact - self::YYNSTATE);
+            } elseif ($yyact === self::YY_ERROR_ACTION) {
+                if ($this->yyTraceFILE) {
+                    fprintf(
+                        $this->yyTraceFILE,
+                        "%sSyntax Error!\n",
+                        $this->yyTracePrompt
+                    );
+                }
+                if (self::YYERRORSYMBOL) {
+                    if ($this->yyerrcnt < 0) {
+                        $this->yy_syntax_error($yymajor, $yytokenvalue);
+                    }
+                    $yymx = $this->yystack[ $this->yyidx ]->major;
+                    if ($yymx === self::YYERRORSYMBOL || $yyerrorhit) {
+                        if ($this->yyTraceFILE) {
+                            fprintf(
+                                $this->yyTraceFILE,
+                                "%sDiscard input token %s\n",
+                                $this->yyTracePrompt,
+                                $this->yyTokenName[ $yymajor ]
+                            );
+                        }
+                        $this->yy_destructor($yymajor, $yytokenvalue);
+                        $yymajor = self::YYNOCODE;
+                    } else {
+                        while ($this->yyidx >= 0 &&
+                               $yymx !== self::YYERRORSYMBOL &&
+                               ($yyact = $this->yy_find_shift_action(self::YYERRORSYMBOL)) >= self::YYNSTATE
+                        ) {
+                            $this->yy_pop_parser_stack();
+                        }
+                        if ($this->yyidx < 0 || $yymajor == 0) {
+                            $this->yy_destructor($yymajor, $yytokenvalue);
+                            $this->yy_parse_failed();
+                            $yymajor = self::YYNOCODE;
+                        } elseif ($yymx !== self::YYERRORSYMBOL) {
+                            $u2 = 0;
+                            $this->yy_shift($yyact, self::YYERRORSYMBOL, $u2);
+                        }
+                    }
+                    $this->yyerrcnt = 3;
+                    $yyerrorhit = 1;
+                } else {
+                    if ($this->yyerrcnt <= 0) {
+                        $this->yy_syntax_error($yymajor, $yytokenvalue);
+                    }
+                    $this->yyerrcnt = 3;
+                    $this->yy_destructor($yymajor, $yytokenvalue);
+                    if ($yyendofinput) {
+                        $this->yy_parse_failed();
+                    }
+                    $yymajor = self::YYNOCODE;
+                }
+            } else {
+                $this->yy_accept();
+                $yymajor = self::YYNOCODE;
+            }
+        } while ($yymajor !== self::YYNOCODE && $this->yyidx >= 0);
+    }
+
+    /**
+     * parse optional boolean keywords
+     *
+     * @param string $str
+     *
+     * @return bool
+     */
+    private function parse_bool($str)
+    {
+        $str = strtolower($str);
+        if (in_array($str, array('on', 'yes', 'true'))) {
+            $res = true;
+        } else {
+            $res = false;
+        }
+        return $res;
+    }
+
+    /**
+     * set a config variable in target array
+     *
+     * @param array $var
+     * @param array $target_array
+     */
+    private function set_var(array $var, array &$target_array)
+    {
+        $key = $var[ 'key' ];
+        $value = $var[ 'value' ];
+        if ($this->configOverwrite || !isset($target_array[ 'vars' ][ $key ])) {
+            $target_array[ 'vars' ][ $key ] = $value;
+        } else {
+            settype($target_array[ 'vars' ][ $key ], 'array');
+            $target_array[ 'vars' ][ $key ][] = $value;
+        }
+    }
+
+    /**
+     * add config variable to global vars
+     *
+     * @param array $vars
+     */
+    private function add_global_vars(array $vars)
+    {
+        if (!isset($this->compiler->config_data[ 'vars' ])) {
+            $this->compiler->config_data[ 'vars' ] = array();
+        }
+        foreach ($vars as $var) {
+            $this->set_var($var, $this->compiler->config_data);
+        }
+    }
+
+    /**
+     * add config variable to section
+     *
+     * @param string $section_name
+     * @param array  $vars
+     */
+    private function add_section_vars($section_name, array $vars)
+    {
+        if (!isset($this->compiler->config_data[ 'sections' ][ $section_name ][ 'vars' ])) {
+            $this->compiler->config_data[ 'sections' ][ $section_name ][ 'vars' ] = array();
+        }
+        foreach ($vars as $var) {
+            $this->set_var($var, $this->compiler->config_data[ 'sections' ][ $section_name ]);
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_data.php b/epgrec/Smarty/sysplugins/smarty_internal_data.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_data.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_data.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,292 @@
+<?php
+/**
+ * Smarty Internal Plugin Data
+ * This file contains the basic classes and methods for template and variable creation
+ *
+ * @package    Smarty
+ * @subpackage Template
+ * @author     Uwe Tews
+ */
+
+/**
+ * Base class with template and variable methods
+ *
+ * @package    Smarty
+ * @subpackage Template
+ *
+ * @property int    $scope
+ * @property Smarty $smarty
+ * The following methods will be dynamically loaded by the extension handler when they are called.
+ * They are located in a corresponding Smarty_Internal_Method_xxxx class
+ *
+ * @method mixed _getConfigVariable(string $varName, bool $errorEnable = true)
+ * @method mixed getConfigVariable(string $varName, bool $errorEnable = true)
+ * @method mixed getConfigVars(string $varName = null, bool $searchParents = true)
+ * @method mixed getGlobal(string $varName = null)
+ * @method mixed getStreamVariable(string $variable)
+ * @method Smarty_Internal_Data clearAssign(mixed $tpl_var)
+ * @method Smarty_Internal_Data clearAllAssign()
+ * @method Smarty_Internal_Data clearConfig(string $varName = null)
+ * @method Smarty_Internal_Data configLoad(string $config_file, mixed $sections = null, string $scope = 'local')
+ */
+abstract class Smarty_Internal_Data
+{
+    /**
+     * This object type (Smarty = 1, template = 2, data = 4)
+     *
+     * @var int
+     */
+    public $_objType = 4;
+
+    /**
+     * name of class used for templates
+     *
+     * @var string
+     */
+    public $template_class = 'Smarty_Internal_Template';
+
+    /**
+     * template variables
+     *
+     * @var Smarty_Variable[]
+     */
+    public $tpl_vars = array();
+
+    /**
+     * parent template (if any)
+     *
+     * @var Smarty|Smarty_Internal_Template|Smarty_Data
+     */
+    public $parent = null;
+
+    /**
+     * configuration settings
+     *
+     * @var string[]
+     */
+    public $config_vars = array();
+
+    /**
+     * extension handler
+     *
+     * @var Smarty_Internal_Extension_Handler
+     */
+    public $ext = null;
+
+    /**
+     * Smarty_Internal_Data constructor.
+     *
+     * Install extension handler
+     */
+    public function __construct()
+    {
+        $this->ext = new Smarty_Internal_Extension_Handler();
+        $this->ext->objType = $this->_objType;
+    }
+
+    /**
+     * assigns a Smarty variable
+     *
+     * @param array|string $tpl_var the template variable name(s)
+     * @param mixed        $value   the value to assign
+     * @param boolean      $nocache if true any output of this variable will be not cached
+     *
+     * @return Smarty_Internal_Data current Smarty_Internal_Data (or Smarty or Smarty_Internal_Template) instance for
+     *                              chaining
+     */
+    public function assign($tpl_var, $value = null, $nocache = false)
+    {
+        if (is_array($tpl_var)) {
+            foreach ($tpl_var as $_key => $_val) {
+                $this->assign($_key, $_val, $nocache);
+            }
+        } else {
+            if ($tpl_var !== '') {
+                if ($this->_objType === 2) {
+                    /**
+                     *
+                     *
+                     * @var Smarty_Internal_Template $this
+                     */
+                    $this->_assignInScope($tpl_var, $value, $nocache);
+                } else {
+                    $this->tpl_vars[ $tpl_var ] = new Smarty_Variable($value, $nocache);
+                }
+            }
+        }
+        return $this;
+    }
+
+    /**
+     * appends values to template variables
+     *
+     * @api  Smarty::append()
+     * @link http://www.smarty.net/docs/en/api.append.tpl
+     *
+     * @param array|string $tpl_var the template variable name(s)
+     * @param mixed        $value   the value to append
+     * @param bool         $merge   flag if array elements shall be merged
+     * @param bool         $nocache if true any output of this variable will
+     *                              be not cached
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function append($tpl_var, $value = null, $merge = false, $nocache = false)
+    {
+        return $this->ext->append->append($this, $tpl_var, $value, $merge, $nocache);
+    }
+
+    /**
+     * assigns a global Smarty variable
+     *
+     * @param string  $varName the global variable name
+     * @param mixed   $value   the value to assign
+     * @param boolean $nocache if true any output of this variable will be not cached
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function assignGlobal($varName, $value = null, $nocache = false)
+    {
+        return $this->ext->assignGlobal->assignGlobal($this, $varName, $value, $nocache);
+    }
+
+    /**
+     * appends values to template variables by reference
+     *
+     * @param string  $tpl_var the template variable name
+     * @param mixed   &$value  the referenced value to append
+     * @param boolean $merge   flag if array elements shall be merged
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function appendByRef($tpl_var, &$value, $merge = false)
+    {
+        return $this->ext->appendByRef->appendByRef($this, $tpl_var, $value, $merge);
+    }
+
+    /**
+     * assigns values to template variables by reference
+     *
+     * @param string  $tpl_var the template variable name
+     * @param         $value
+     * @param boolean $nocache if true any output of this variable will be not cached
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function assignByRef($tpl_var, &$value, $nocache = false)
+    {
+        return $this->ext->assignByRef->assignByRef($this, $tpl_var, $value, $nocache);
+    }
+
+    /**
+     * Returns a single or all template variables
+     *
+     * @api  Smarty::getTemplateVars()
+     * @link http://www.smarty.net/docs/en/api.get.template.vars.tpl
+     *
+     * @param string                                                  $varName       variable name or null
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $_ptr          optional pointer to data object
+     * @param bool                                                    $searchParents include parent templates?
+     *
+     * @return mixed variable value or or array of variables
+     */
+    public function getTemplateVars($varName = null, Smarty_Internal_Data $_ptr = null, $searchParents = true)
+    {
+        return $this->ext->getTemplateVars->getTemplateVars($this, $varName, $_ptr, $searchParents);
+    }
+
+    /**
+     * gets the object of a Smarty variable
+     *
+     * @param string               $variable      the name of the Smarty variable
+     * @param Smarty_Internal_Data $_ptr          optional pointer to data object
+     * @param boolean              $searchParents search also in parent data
+     * @param bool                 $error_enable
+     *
+     * @return     Smarty_Variable|Smarty_Undefined_Variable the object of the variable
+     * @deprecated since 3.1.28 please use Smarty_Internal_Data::getTemplateVars() instead.
+     */
+    public function getVariable(
+        $variable = null,
+        Smarty_Internal_Data $_ptr = null,
+        $searchParents = true,
+        $error_enable = true
+    ) {
+        return $this->ext->getTemplateVars->_getVariable($this, $variable, $_ptr, $searchParents, $error_enable);
+    }
+
+    /**
+     * Follow the parent chain an merge template and config variables
+     *
+     * @param \Smarty_Internal_Data|null $data
+     */
+    public function _mergeVars(Smarty_Internal_Data $data = null)
+    {
+        if (isset($data)) {
+            if (!empty($this->tpl_vars)) {
+                $data->tpl_vars = array_merge($this->tpl_vars, $data->tpl_vars);
+            }
+            if (!empty($this->config_vars)) {
+                $data->config_vars = array_merge($this->config_vars, $data->config_vars);
+            }
+        } else {
+            $data = $this;
+        }
+        if (isset($this->parent)) {
+            $this->parent->_mergeVars($data);
+        }
+    }
+
+    /**
+     * Return true if this instance is a Data obj
+     *
+     * @return bool
+     */
+    public function _isDataObj()
+    {
+        return $this->_objType === 4;
+    }
+
+    /**
+     * Return true if this instance is a template obj
+     *
+     * @return bool
+     */
+    public function _isTplObj()
+    {
+        return $this->_objType === 2;
+    }
+
+    /**
+     * Return true if this instance is a Smarty obj
+     *
+     * @return bool
+     */
+    public function _isSmartyObj()
+    {
+        return $this->_objType === 1;
+    }
+
+    /**
+     * Get Smarty object
+     *
+     * @return Smarty
+     */
+    public function _getSmartyObj()
+    {
+        return $this->smarty;
+    }
+
+    /**
+     * Handle unknown class methods
+     *
+     * @param string $name unknown method-name
+     * @param array  $args argument array
+     *
+     * @return mixed
+     */
+    public function __call($name, $args)
+    {
+        return $this->ext->_callExternalMethod($this, $name, $args);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_debug.php b/epgrec/Smarty/sysplugins/smarty_internal_debug.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_debug.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_debug.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,425 @@
+<?php
+/**
+ * Smarty Internal Plugin Debug
+ * Class to collect data for the Smarty Debugging Console
+ *
+ * @package    Smarty
+ * @subpackage Debug
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Debug Class
+ *
+ * @package    Smarty
+ * @subpackage Debug
+ */
+class Smarty_Internal_Debug extends Smarty_Internal_Data
+{
+    /**
+     * template data
+     *
+     * @var array
+     */
+    public $template_data = array();
+
+    /**
+     * List of uid's which shall be ignored
+     *
+     * @var array
+     */
+    public $ignore_uid = array();
+
+    /**
+     * Index of display() and fetch() calls
+     *
+     * @var int
+     */
+    public $index = 0;
+
+    /**
+     * Counter for window offset
+     *
+     * @var int
+     */
+    public $offset = 0;
+
+    /**
+     * Start logging template
+     *
+     * @param \Smarty_Internal_Template $template template
+     * @param null                      $mode     true: display   false: fetch  null: subtemplate
+     */
+    public function start_template(Smarty_Internal_Template $template, $mode = null)
+    {
+        if (isset($mode) && !$template->_isSubTpl()) {
+            $this->index++;
+            $this->offset++;
+            $this->template_data[ $this->index ] = null;
+        }
+        $key = $this->get_key($template);
+        $this->template_data[ $this->index ][ $key ][ 'start_template_time' ] = microtime(true);
+    }
+
+    /**
+     * End logging of cache time
+     *
+     * @param \Smarty_Internal_Template $template cached template
+     */
+    public function end_template(Smarty_Internal_Template $template)
+    {
+        $key = $this->get_key($template);
+        $this->template_data[ $this->index ][ $key ][ 'total_time' ] +=
+            microtime(true) - $this->template_data[ $this->index ][ $key ][ 'start_template_time' ];
+        //$this->template_data[$this->index][$key]['properties'] = $template->properties;
+    }
+
+    /**
+     * Start logging of compile time
+     *
+     * @param \Smarty_Internal_Template $template
+     */
+    public function start_compile(Smarty_Internal_Template $template)
+    {
+        static $_is_stringy = array('string' => true, 'eval' => true);
+        if (!empty($template->compiler->trace_uid)) {
+            $key = $template->compiler->trace_uid;
+            if (!isset($this->template_data[ $this->index ][ $key ])) {
+                if (isset($_is_stringy[ $template->source->type ])) {
+                    $this->template_data[ $this->index ][ $key ][ 'name' ] =
+                        '\'' . substr($template->source->name, 0, 25) . '...\'';
+                } else {
+                    $this->template_data[ $this->index ][ $key ][ 'name' ] = $template->source->filepath;
+                }
+                $this->template_data[ $this->index ][ $key ][ 'compile_time' ] = 0;
+                $this->template_data[ $this->index ][ $key ][ 'render_time' ] = 0;
+                $this->template_data[ $this->index ][ $key ][ 'cache_time' ] = 0;
+            }
+        } else {
+            if (isset($this->ignore_uid[ $template->source->uid ])) {
+                return;
+            }
+            $key = $this->get_key($template);
+        }
+        $this->template_data[ $this->index ][ $key ][ 'start_time' ] = microtime(true);
+    }
+
+    /**
+     * End logging of compile time
+     *
+     * @param \Smarty_Internal_Template $template
+     */
+    public function end_compile(Smarty_Internal_Template $template)
+    {
+        if (!empty($template->compiler->trace_uid)) {
+            $key = $template->compiler->trace_uid;
+        } else {
+            if (isset($this->ignore_uid[ $template->source->uid ])) {
+                return;
+            }
+            $key = $this->get_key($template);
+        }
+        $this->template_data[ $this->index ][ $key ][ 'compile_time' ] +=
+            microtime(true) - $this->template_data[ $this->index ][ $key ][ 'start_time' ];
+    }
+
+    /**
+     * Start logging of render time
+     *
+     * @param \Smarty_Internal_Template $template
+     */
+    public function start_render(Smarty_Internal_Template $template)
+    {
+        $key = $this->get_key($template);
+        $this->template_data[ $this->index ][ $key ][ 'start_time' ] = microtime(true);
+    }
+
+    /**
+     * End logging of compile time
+     *
+     * @param \Smarty_Internal_Template $template
+     */
+    public function end_render(Smarty_Internal_Template $template)
+    {
+        $key = $this->get_key($template);
+        $this->template_data[ $this->index ][ $key ][ 'render_time' ] +=
+            microtime(true) - $this->template_data[ $this->index ][ $key ][ 'start_time' ];
+    }
+
+    /**
+     * Start logging of cache time
+     *
+     * @param \Smarty_Internal_Template $template cached template
+     */
+    public function start_cache(Smarty_Internal_Template $template)
+    {
+        $key = $this->get_key($template);
+        $this->template_data[ $this->index ][ $key ][ 'start_time' ] = microtime(true);
+    }
+
+    /**
+     * End logging of cache time
+     *
+     * @param \Smarty_Internal_Template $template cached template
+     */
+    public function end_cache(Smarty_Internal_Template $template)
+    {
+        $key = $this->get_key($template);
+        $this->template_data[ $this->index ][ $key ][ 'cache_time' ] +=
+            microtime(true) - $this->template_data[ $this->index ][ $key ][ 'start_time' ];
+    }
+
+    /**
+     * Register template object
+     *
+     * @param \Smarty_Internal_Template $template cached template
+     */
+    public function register_template(Smarty_Internal_Template $template)
+    {
+    }
+
+    /**
+     * Register data object
+     *
+     * @param \Smarty_Data $data data object
+     */
+    public static function register_data(Smarty_Data $data)
+    {
+    }
+
+    /**
+     * Opens a window for the Smarty Debugging Console and display the data
+     *
+     * @param Smarty_Internal_Template|Smarty $obj object to debug
+     * @param bool                            $full
+     *
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function display_debug($obj, $full = false)
+    {
+        if (!$full) {
+            $this->offset++;
+            $savedIndex = $this->index;
+            $this->index = 9999;
+        }
+        $smarty = $obj->_getSmartyObj();
+        // create fresh instance of smarty for displaying the debug console
+        // to avoid problems if the application did overload the Smarty class
+        $debObj = new Smarty();
+        // copy the working dirs from application
+        $debObj->setCompileDir($smarty->getCompileDir());
+        // init properties by hand as user may have edited the original Smarty class
+        $debObj->setPluginsDir(is_dir(dirname(__FILE__) . '/../plugins') ? dirname(__FILE__) .
+                                                                           '/../plugins' : $smarty->getPluginsDir());
+        $debObj->force_compile = false;
+        $debObj->compile_check = Smarty::COMPILECHECK_ON;
+        $debObj->left_delimiter = '{';
+        $debObj->right_delimiter = '}';
+        $debObj->security_policy = null;
+        $debObj->debugging = false;
+        $debObj->debugging_ctrl = 'NONE';
+        $debObj->error_reporting = E_ALL & ~E_NOTICE;
+        $debObj->debug_tpl =
+            isset($smarty->debug_tpl) ? $smarty->debug_tpl : 'file:' . dirname(__FILE__) . '/../debug.tpl';
+        $debObj->registered_plugins = array();
+        $debObj->registered_resources = array();
+        $debObj->registered_filters = array();
+        $debObj->autoload_filters = array();
+        $debObj->default_modifiers = array();
+        $debObj->escape_html = true;
+        $debObj->caching = Smarty::CACHING_OFF;
+        $debObj->compile_id = null;
+        $debObj->cache_id = null;
+        // prepare information of assigned variables
+        $ptr = $this->get_debug_vars($obj);
+        $_assigned_vars = $ptr->tpl_vars;
+        ksort($_assigned_vars);
+        $_config_vars = $ptr->config_vars;
+        ksort($_config_vars);
+        $debugging = $smarty->debugging;
+        $_template = new Smarty_Internal_Template($debObj->debug_tpl, $debObj);
+        if ($obj->_isTplObj()) {
+            $_template->assign('template_name', $obj->source->type . ':' . $obj->source->name);
+        }
+        if ($obj->_objType === 1 || $full) {
+            $_template->assign('template_data', $this->template_data[ $this->index ]);
+        } else {
+            $_template->assign('template_data', null);
+        }
+        $_template->assign('assigned_vars', $_assigned_vars);
+        $_template->assign('config_vars', $_config_vars);
+        $_template->assign('execution_time', microtime(true) - $smarty->start_time);
+        $_template->assign('display_mode', $debugging === 2 || !$full);
+        $_template->assign('offset', $this->offset * 50);
+        echo $_template->fetch();
+        if (isset($full)) {
+            $this->index--;
+        }
+        if (!$full) {
+            $this->index = $savedIndex;
+        }
+    }
+
+    /**
+     * Recursively gets variables from all template/data scopes
+     *
+     * @param Smarty_Internal_Template|Smarty_Data $obj object to debug
+     *
+     * @return StdClass
+     */
+    public function get_debug_vars($obj)
+    {
+        $config_vars = array();
+        foreach ($obj->config_vars as $key => $var) {
+            $config_vars[ $key ][ 'value' ] = $var;
+            if ($obj->_isTplObj()) {
+                $config_vars[ $key ][ 'scope' ] = $obj->source->type . ':' . $obj->source->name;
+            } elseif ($obj->_isDataObj()) {
+                $tpl_vars[ $key ][ 'scope' ] = $obj->dataObjectName;
+            } else {
+                $config_vars[ $key ][ 'scope' ] = 'Smarty object';
+            }
+        }
+        $tpl_vars = array();
+        foreach ($obj->tpl_vars as $key => $var) {
+            foreach ($var as $varkey => $varvalue) {
+                if ($varkey === 'value') {
+                    $tpl_vars[ $key ][ $varkey ] = $varvalue;
+                } else {
+                    if ($varkey === 'nocache') {
+                        if ($varvalue === true) {
+                            $tpl_vars[ $key ][ $varkey ] = $varvalue;
+                        }
+                    } else {
+                        if ($varkey !== 'scope' || $varvalue !== 0) {
+                            $tpl_vars[ $key ][ 'attributes' ][ $varkey ] = $varvalue;
+                        }
+                    }
+                }
+            }
+            if ($obj->_isTplObj()) {
+                $tpl_vars[ $key ][ 'scope' ] = $obj->source->type . ':' . $obj->source->name;
+            } elseif ($obj->_isDataObj()) {
+                $tpl_vars[ $key ][ 'scope' ] = $obj->dataObjectName;
+            } else {
+                $tpl_vars[ $key ][ 'scope' ] = 'Smarty object';
+            }
+        }
+        if (isset($obj->parent)) {
+            $parent = $this->get_debug_vars($obj->parent);
+            foreach ($parent->tpl_vars as $name => $pvar) {
+                if (isset($tpl_vars[ $name ]) && $tpl_vars[ $name ][ 'value' ] === $pvar[ 'value' ]) {
+                    $tpl_vars[ $name ][ 'scope' ] = $pvar[ 'scope' ];
+                }
+            }
+            $tpl_vars = array_merge($parent->tpl_vars, $tpl_vars);
+            foreach ($parent->config_vars as $name => $pvar) {
+                if (isset($config_vars[ $name ]) && $config_vars[ $name ][ 'value' ] === $pvar[ 'value' ]) {
+                    $config_vars[ $name ][ 'scope' ] = $pvar[ 'scope' ];
+                }
+            }
+            $config_vars = array_merge($parent->config_vars, $config_vars);
+        } else {
+            foreach (Smarty::$global_tpl_vars as $key => $var) {
+                if (!array_key_exists($key, $tpl_vars)) {
+                    foreach ($var as $varkey => $varvalue) {
+                        if ($varkey === 'value') {
+                            $tpl_vars[ $key ][ $varkey ] = $varvalue;
+                        } else {
+                            if ($varkey === 'nocache') {
+                                if ($varvalue === true) {
+                                    $tpl_vars[ $key ][ $varkey ] = $varvalue;
+                                }
+                            } else {
+                                if ($varkey !== 'scope' || $varvalue !== 0) {
+                                    $tpl_vars[ $key ][ 'attributes' ][ $varkey ] = $varvalue;
+                                }
+                            }
+                        }
+                    }
+                    $tpl_vars[ $key ][ 'scope' ] = 'Global';
+                }
+            }
+        }
+        return (object)array('tpl_vars' => $tpl_vars, 'config_vars' => $config_vars);
+    }
+
+    /**
+     * Return key into $template_data for template
+     *
+     * @param \Smarty_Internal_Template $template template object
+     *
+     * @return string key into $template_data
+     */
+    private function get_key(Smarty_Internal_Template $template)
+    {
+        static $_is_stringy = array('string' => true, 'eval' => true);
+        // calculate Uid if not already done
+        if ($template->source->uid === '') {
+            $template->source->filepath;
+        }
+        $key = $template->source->uid;
+        if (isset($this->template_data[ $this->index ][ $key ])) {
+            return $key;
+        } else {
+            if (isset($_is_stringy[ $template->source->type ])) {
+                $this->template_data[ $this->index ][ $key ][ 'name' ] =
+                    '\'' . substr($template->source->name, 0, 25) . '...\'';
+            } else {
+                $this->template_data[ $this->index ][ $key ][ 'name' ] = $template->source->filepath;
+            }
+            $this->template_data[ $this->index ][ $key ][ 'compile_time' ] = 0;
+            $this->template_data[ $this->index ][ $key ][ 'render_time' ] = 0;
+            $this->template_data[ $this->index ][ $key ][ 'cache_time' ] = 0;
+            $this->template_data[ $this->index ][ $key ][ 'total_time' ] = 0;
+            return $key;
+        }
+    }
+
+    /**
+     * Ignore template
+     *
+     * @param \Smarty_Internal_Template $template
+     */
+    public function ignore(Smarty_Internal_Template $template)
+    {
+        // calculate Uid if not already done
+        if ($template->source->uid === '') {
+            $template->source->filepath;
+        }
+        $this->ignore_uid[ $template->source->uid ] = true;
+    }
+
+    /**
+     * handle 'URL' debugging mode
+     *
+     * @param Smarty $smarty
+     */
+    public function debugUrl(Smarty $smarty)
+    {
+        if (isset($_SERVER[ 'QUERY_STRING' ])) {
+            $_query_string = $_SERVER[ 'QUERY_STRING' ];
+        } else {
+            $_query_string = '';
+        }
+        if (false !== strpos($_query_string, $smarty->smarty_debug_id)) {
+            if (false !== strpos($_query_string, $smarty->smarty_debug_id . '=on')) {
+                // enable debugging for this browser session
+                setcookie('SMARTY_DEBUG', true);
+                $smarty->debugging = true;
+            } elseif (false !== strpos($_query_string, $smarty->smarty_debug_id . '=off')) {
+                // disable debugging for this browser session
+                setcookie('SMARTY_DEBUG', false);
+                $smarty->debugging = false;
+            } else {
+                // enable debugging for this page
+                $smarty->debugging = true;
+            }
+        } else {
+            if (isset($_COOKIE[ 'SMARTY_DEBUG' ])) {
+                $smarty->debugging = true;
+            }
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_errorhandler.php b/epgrec/Smarty/sysplugins/smarty_internal_errorhandler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_errorhandler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_errorhandler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,113 @@
+<?php
+
+/**
+ * Smarty error handler
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ *
+ * @deprecated
+Smarty does no longer use @filemtime()
+ */
+class Smarty_Internal_ErrorHandler
+{
+    /**
+     * contains directories outside of SMARTY_DIR that are to be muted by muteExpectedErrors()
+     */
+    public static $mutedDirectories = array();
+
+    /**
+     * error handler returned by set_error_handler() in self::muteExpectedErrors()
+     */
+    private static $previousErrorHandler = null;
+
+    /**
+     * Enable error handler to mute expected messages
+     *
+     */
+    public static function muteExpectedErrors()
+    {
+        /*
+            error muting is done because some people implemented custom error_handlers using
+            http://php.net/set_error_handler and for some reason did not understand the following paragraph:
+
+                It is important to remember that the standard PHP error handler is completely bypassed for the
+                error types specified by error_types unless the callback function returns FALSE.
+                error_reporting() settings will have no effect and your error handler will be called regardless -
+                however you are still able to read the current value of error_reporting and act appropriately.
+                Of particular note is that this value will be 0 if the statement that caused the error was
+                prepended by the @ error-control operator.
+
+            Smarty deliberately uses @filemtime() over file_exists() and filemtime() in some places. Reasons include
+                - @filemtime() is almost twice as fast as using an additional file_exists()
+                - between file_exists() and filemtime() a possible race condition is opened,
+                  which does not exist using the simple @filemtime() approach.
+        */
+        $error_handler = array('Smarty_Internal_ErrorHandler', 'mutingErrorHandler');
+        $previous = set_error_handler($error_handler);
+        // avoid dead loops
+        if ($previous !== $error_handler) {
+            self::$previousErrorHandler = $previous;
+        }
+    }
+
+    /**
+     * Error Handler to mute expected messages
+     *
+     * @link http://php.net/set_error_handler
+     *
+     * @param integer $errno Error level
+     * @param         $errstr
+     * @param         $errfile
+     * @param         $errline
+     * @param         $errcontext
+     *
+     * @return bool
+     */
+    public static function mutingErrorHandler($errno, $errstr, $errfile, $errline, $errcontext = array())
+    {
+        $_is_muted_directory = false;
+        // add the SMARTY_DIR to the list of muted directories
+        if (!isset(self::$mutedDirectories[ SMARTY_DIR ])) {
+            $smarty_dir = realpath(SMARTY_DIR);
+            if ($smarty_dir !== false) {
+                self::$mutedDirectories[ SMARTY_DIR ] =
+                    array('file' => $smarty_dir, 'length' => strlen($smarty_dir),);
+            }
+        }
+        // walk the muted directories and test against $errfile
+        foreach (self::$mutedDirectories as $key => &$dir) {
+            if (!$dir) {
+                // resolve directory and length for speedy comparisons
+                $file = realpath($key);
+                if ($file === false) {
+                    // this directory does not exist, remove and skip it
+                    unset(self::$mutedDirectories[ $key ]);
+                    continue;
+                }
+                $dir = array('file' => $file, 'length' => strlen($file),);
+            }
+            if (!strncmp($errfile, $dir[ 'file' ], $dir[ 'length' ])) {
+                $_is_muted_directory = true;
+                break;
+            }
+        }
+        // pass to next error handler if this error did not occur inside SMARTY_DIR
+        // or the error was within smarty but masked to be ignored
+        if (!$_is_muted_directory || ($errno && $errno & error_reporting())) {
+            if (self::$previousErrorHandler) {
+                return call_user_func(
+                    self::$previousErrorHandler,
+                    $errno,
+                    $errstr,
+                    $errfile,
+                    $errline,
+                    $errcontext
+                );
+            } else {
+                return false;
+            }
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_extension_handler.php b/epgrec/Smarty/sysplugins/smarty_internal_extension_handler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_extension_handler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_extension_handler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,197 @@
+<?php
+
+/**
+ * Smarty Extension handler
+ *
+ * Load extensions dynamically
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ *
+ * Runtime extensions
+ * @property   Smarty_Internal_Runtime_CacheModify       $_cacheModify
+ * @property   Smarty_Internal_Runtime_CacheResourceFile $_cacheResourceFile
+ * @property   Smarty_Internal_Runtime_Capture           $_capture
+ * @property   Smarty_Internal_Runtime_CodeFrame         $_codeFrame
+ * @property   Smarty_Internal_Runtime_FilterHandler     $_filterHandler
+ * @property   Smarty_Internal_Runtime_Foreach           $_foreach
+ * @property   Smarty_Internal_Runtime_GetIncludePath    $_getIncludePath
+ * @property   Smarty_Internal_Runtime_Make_Nocache      $_make_nocache
+ * @property   Smarty_Internal_Runtime_UpdateCache       $_updateCache
+ * @property   Smarty_Internal_Runtime_UpdateScope       $_updateScope
+ * @property   Smarty_Internal_Runtime_TplFunction       $_tplFunction
+ * @property   Smarty_Internal_Runtime_WriteFile         $_writeFile
+ *
+ * Method extensions
+ * @property   Smarty_Internal_Method_GetTemplateVars    $getTemplateVars
+ * @property   Smarty_Internal_Method_Append             $append
+ * @property   Smarty_Internal_Method_AppendByRef        $appendByRef
+ * @property   Smarty_Internal_Method_AssignGlobal       $assignGlobal
+ * @property   Smarty_Internal_Method_AssignByRef        $assignByRef
+ * @property   Smarty_Internal_Method_LoadFilter         $loadFilter
+ * @property   Smarty_Internal_Method_LoadPlugin         $loadPlugin
+ * @property   Smarty_Internal_Method_RegisterFilter     $registerFilter
+ * @property   Smarty_Internal_Method_RegisterObject     $registerObject
+ * @property   Smarty_Internal_Method_RegisterPlugin     $registerPlugin
+ * @property   mixed|\Smarty_Template_Cached             configLoad
+ */
+class Smarty_Internal_Extension_Handler
+{
+    public $objType = null;
+
+    /**
+     * Cache for property information from generic getter/setter
+     * Preloaded with names which should not use with generic getter/setter
+     *
+     * @var array
+     */
+    private $_property_info     = array(
+        'AutoloadFilters' => 0, 'DefaultModifiers' => 0, 'ConfigVars' => 0,
+        'DebugTemplate'   => 0, 'RegisteredObject' => 0, 'StreamVariable' => 0,
+        'TemplateVars'    => 0, 'Literals' => 'Literals',
+    );//
+
+    private $resolvedProperties = array();
+
+    /**
+     * Call external Method
+     *
+     * @param \Smarty_Internal_Data $data
+     * @param string                $name external method names
+     * @param array                 $args argument array
+     *
+     * @return mixed
+     */
+    public function _callExternalMethod(Smarty_Internal_Data $data, $name, $args)
+    {
+        /* @var Smarty $data ->smarty */
+        $smarty = isset($data->smarty) ? $data->smarty : $data;
+        if (!isset($smarty->ext->$name)) {
+            if (preg_match('/^((set|get)|(.*?))([A-Z].*)$/', $name, $match)) {
+                $basename = $this->upperCase($match[ 4 ]);
+                if (!isset($smarty->ext->$basename) && isset($this->_property_info[ $basename ])
+                    && is_string($this->_property_info[ $basename ])
+                ) {
+                    $class = 'Smarty_Internal_Method_' . $this->_property_info[ $basename ];
+                    if (class_exists($class)) {
+                        $classObj = new $class();
+                        $methodes = get_class_methods($classObj);
+                        foreach ($methodes as $method) {
+                            $smarty->ext->$method = $classObj;
+                        }
+                    }
+                }
+                if (!empty($match[ 2 ]) && !isset($smarty->ext->$name)) {
+                    $class = 'Smarty_Internal_Method_' . $this->upperCase($name);
+                    if (!class_exists($class)) {
+                        $objType = $data->_objType;
+                        $propertyType = false;
+                        if (!isset($this->resolvedProperties[ $match[ 0 ] ][ $objType ])) {
+                            $property = isset($this->resolvedProperties[ 'property' ][ $basename ]) ?
+                                $this->resolvedProperties[ 'property' ][ $basename ] :
+                                $property = $this->resolvedProperties[ 'property' ][ $basename ] = strtolower(
+                                    join(
+                                        '_',
+                                        preg_split(
+                                            '/([A-Z][^A-Z]*)/',
+                                            $basename,
+                                            -1,
+                                            PREG_SPLIT_NO_EMPTY |
+                                            PREG_SPLIT_DELIM_CAPTURE
+                                        )
+                                    )
+                                );
+                            if ($property !== false) {
+                                if (property_exists($data, $property)) {
+                                    $propertyType = $this->resolvedProperties[ $match[ 0 ] ][ $objType ] = 1;
+                                } elseif (property_exists($smarty, $property)) {
+                                    $propertyType = $this->resolvedProperties[ $match[ 0 ] ][ $objType ] = 2;
+                                } else {
+                                    $this->resolvedProperties[ 'property' ][ $basename ] = $property = false;
+                                }
+                            }
+                        } else {
+                            $propertyType = $this->resolvedProperties[ $match[ 0 ] ][ $objType ];
+                            $property = $this->resolvedProperties[ 'property' ][ $basename ];
+                        }
+                        if ($propertyType) {
+                            $obj = $propertyType === 1 ? $data : $smarty;
+                            if ($match[ 2 ] === 'get') {
+                                return $obj->$property;
+                            } elseif ($match[ 2 ] === 'set') {
+                                return $obj->$property = $args[ 0 ];
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        $callback = array($smarty->ext->$name, $name);
+        array_unshift($args, $data);
+        if (isset($callback) && $callback[ 0 ]->objMap | $data->_objType) {
+            return call_user_func_array($callback, $args);
+        }
+        return call_user_func_array(array(new Smarty_Internal_Undefined(), $name), $args);
+    }
+
+    /**
+     * Make first character of name parts upper case
+     *
+     * @param string $name
+     *
+     * @return string
+     */
+    public function upperCase($name)
+    {
+        $_name = explode('_', $name);
+        $_name = array_map('ucfirst', $_name);
+        return implode('_', $_name);
+    }
+
+    /**
+     * get extension object
+     *
+     * @param string $property_name property name
+     *
+     * @return mixed|Smarty_Template_Cached
+     */
+    public function __get($property_name)
+    {
+        // object properties of runtime template extensions will start with '_'
+        if ($property_name[ 0 ] === '_') {
+            $class = 'Smarty_Internal_Runtime' . $this->upperCase($property_name);
+        } else {
+            $class = 'Smarty_Internal_Method_' . $this->upperCase($property_name);
+        }
+        if (!class_exists($class)) {
+            return $this->$property_name = new Smarty_Internal_Undefined($class);
+        }
+        return $this->$property_name = new $class();
+    }
+
+    /**
+     * set extension property
+     *
+     * @param string $property_name property name
+     * @param mixed  $value         value
+     *
+     */
+    public function __set($property_name, $value)
+    {
+        $this->$property_name = $value;
+    }
+
+    /**
+     * Call error handler for undefined method
+     *
+     * @param string $name unknown method-name
+     * @param array  $args argument array
+     *
+     * @return mixed
+     */
+    public function __call($name, $args)
+    {
+        return call_user_func_array(array(new Smarty_Internal_Undefined(), $name), array($this));
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_addautoloadfilters.php b/epgrec/Smarty/sysplugins/smarty_internal_method_addautoloadfilters.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_addautoloadfilters.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_addautoloadfilters.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,53 @@
+<?php
+
+/**
+ * Smarty Method AddAutoloadFilters
+ *
+ * Smarty::addAutoloadFilters() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_AddAutoloadFilters extends Smarty_Internal_Method_SetAutoloadFilters
+{
+    /**
+     * Add autoload filters
+     *
+     * @api Smarty::setAutoloadFilters()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param array                                                           $filters filters to load automatically
+     * @param string                                                          $type    "pre", "output",  specify
+     *                                                                                 the filter type to set.
+     *                                                                                 Defaults to none treating
+     *                                                                                 $filters' keys as the
+     *                                                                                 appropriate types
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function addAutoloadFilters(Smarty_Internal_TemplateBase $obj, $filters, $type = null)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if ($type !== null) {
+            $this->_checkFilterType($type);
+            if (!empty($smarty->autoload_filters[ $type ])) {
+                $smarty->autoload_filters[ $type ] = array_merge($smarty->autoload_filters[ $type ], (array)$filters);
+            } else {
+                $smarty->autoload_filters[ $type ] = (array)$filters;
+            }
+        } else {
+            foreach ((array)$filters as $type => $value) {
+                $this->_checkFilterType($type);
+                if (!empty($smarty->autoload_filters[ $type ])) {
+                    $smarty->autoload_filters[ $type ] =
+                        array_merge($smarty->autoload_filters[ $type ], (array)$value);
+                } else {
+                    $smarty->autoload_filters[ $type ] = (array)$value;
+                }
+            }
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_adddefaultmodifiers.php b/epgrec/Smarty/sysplugins/smarty_internal_method_adddefaultmodifiers.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_adddefaultmodifiers.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_adddefaultmodifiers.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,42 @@
+<?php
+
+/**
+ * Smarty Method AddDefaultModifiers
+ *
+ * Smarty::addDefaultModifiers() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_AddDefaultModifiers
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Add default modifiers
+     *
+     * @api Smarty::addDefaultModifiers()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param array|string                                                    $modifiers modifier or list of modifiers
+     *                                                                                   to add
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function addDefaultModifiers(Smarty_Internal_TemplateBase $obj, $modifiers)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (is_array($modifiers)) {
+            $smarty->default_modifiers = array_merge($smarty->default_modifiers, $modifiers);
+        } else {
+            $smarty->default_modifiers[] = $modifiers;
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_append.php b/epgrec/Smarty/sysplugins/smarty_internal_method_append.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_append.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_append.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,74 @@
+<?php
+
+/**
+ * Smarty Method Append
+ *
+ * Smarty::append() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_Append
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * appends values to template variables
+     *
+     * @api  Smarty::append()
+     * @link http://www.smarty.net/docs/en/api.append.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param array|string                                            $tpl_var the template variable name(s)
+     * @param mixed                                                   $value   the value to append
+     * @param bool                                                    $merge   flag if array elements shall be merged
+     * @param bool                                                    $nocache if true any output of this variable will
+     *                                                                         be not cached
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function append(Smarty_Internal_Data $data, $tpl_var, $value = null, $merge = false, $nocache = false)
+    {
+        if (is_array($tpl_var)) {
+            // $tpl_var is an array, ignore $value
+            foreach ($tpl_var as $_key => $_val) {
+                if ($_key !== '') {
+                    $this->append($data, $_key, $_val, $merge, $nocache);
+                }
+            }
+        } else {
+            if ($tpl_var !== '' && isset($value)) {
+                if (!isset($data->tpl_vars[ $tpl_var ])) {
+                    $tpl_var_inst = $data->ext->getTemplateVars->_getVariable($data, $tpl_var, null, true, false);
+                    if ($tpl_var_inst instanceof Smarty_Undefined_Variable) {
+                        $data->tpl_vars[ $tpl_var ] = new Smarty_Variable(null, $nocache);
+                    } else {
+                        $data->tpl_vars[ $tpl_var ] = clone $tpl_var_inst;
+                    }
+                }
+                if (!(is_array($data->tpl_vars[ $tpl_var ]->value)
+                      || $data->tpl_vars[ $tpl_var ]->value instanceof ArrayAccess)
+                ) {
+                    settype($data->tpl_vars[ $tpl_var ]->value, 'array');
+                }
+                if ($merge && is_array($value)) {
+                    foreach ($value as $_mkey => $_mval) {
+                        $data->tpl_vars[ $tpl_var ]->value[ $_mkey ] = $_mval;
+                    }
+                } else {
+                    $data->tpl_vars[ $tpl_var ]->value[] = $value;
+                }
+            }
+            if ($data->_isTplObj() && $data->scope) {
+                $data->ext->_updateScope->_updateScope($data, $tpl_var);
+            }
+        }
+        return $data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_appendbyref.php b/epgrec/Smarty/sysplugins/smarty_internal_method_appendbyref.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_appendbyref.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_appendbyref.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,49 @@
+<?php
+
+/**
+ * Smarty Method AppendByRef
+ *
+ * Smarty::appendByRef() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_AppendByRef
+{
+    /**
+     * appends values to template variables by reference
+     *
+     * @api  Smarty::appendByRef()
+     * @link http://www.smarty.net/docs/en/api.append.by.ref.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $tpl_var the template variable name
+     * @param mixed                                                   &$value  the referenced value to append
+     * @param bool                                                    $merge   flag if array elements shall be merged
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public static function appendByRef(Smarty_Internal_Data $data, $tpl_var, &$value, $merge = false)
+    {
+        if ($tpl_var !== '' && isset($value)) {
+            if (!isset($data->tpl_vars[ $tpl_var ])) {
+                $data->tpl_vars[ $tpl_var ] = new Smarty_Variable();
+            }
+            if (!is_array($data->tpl_vars[ $tpl_var ]->value)) {
+                settype($data->tpl_vars[ $tpl_var ]->value, 'array');
+            }
+            if ($merge && is_array($value)) {
+                foreach ($value as $_key => $_val) {
+                    $data->tpl_vars[ $tpl_var ]->value[ $_key ] = &$value[ $_key ];
+                }
+            } else {
+                $data->tpl_vars[ $tpl_var ]->value[] = &$value;
+            }
+            if ($data->_isTplObj() && $data->scope) {
+                $data->ext->_updateScope->_updateScope($data, $tpl_var);
+            }
+        }
+        return $data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_assignbyref.php b/epgrec/Smarty/sysplugins/smarty_internal_method_assignbyref.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_assignbyref.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_assignbyref.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,36 @@
+<?php
+
+/**
+ * Smarty Method AssignByRef
+ *
+ * Smarty::assignByRef() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_AssignByRef
+{
+    /**
+     * assigns values to template variables by reference
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $tpl_var the template variable name
+     * @param                                                         $value
+     * @param boolean                                                 $nocache if true any output of this variable will
+     *                                                                         be not cached
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function assignByRef(Smarty_Internal_Data $data, $tpl_var, &$value, $nocache)
+    {
+        if ($tpl_var !== '') {
+            $data->tpl_vars[ $tpl_var ] = new Smarty_Variable(null, $nocache);
+            $data->tpl_vars[ $tpl_var ]->value = &$value;
+            if ($data->_isTplObj() && $data->scope) {
+                $data->ext->_updateScope->_updateScope($data, $tpl_var);
+            }
+        }
+        return $data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_assignglobal.php b/epgrec/Smarty/sysplugins/smarty_internal_method_assignglobal.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_assignglobal.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_assignglobal.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,44 @@
+<?php
+
+/**
+ * Smarty Method AssignGlobal
+ *
+ * Smarty::assignGlobal() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_AssignGlobal
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * assigns a global Smarty variable
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $varName the global variable name
+     * @param mixed                                                   $value   the value to assign
+     * @param boolean                                                 $nocache if true any output of this variable will
+     *                                                                         be not cached
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function assignGlobal(Smarty_Internal_Data $data, $varName, $value = null, $nocache = false)
+    {
+        if ($varName !== '') {
+            Smarty::$global_tpl_vars[ $varName ] = new Smarty_Variable($value, $nocache);
+            $ptr = $data;
+            while ($ptr->_isTplObj()) {
+                $ptr->tpl_vars[ $varName ] = clone Smarty::$global_tpl_vars[ $varName ];
+                $ptr = $ptr->parent;
+            }
+        }
+        return $data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_clearallassign.php b/epgrec/Smarty/sysplugins/smarty_internal_method_clearallassign.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_clearallassign.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_clearallassign.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,36 @@
+<?php
+
+/**
+ * Smarty Method ClearAllAssign
+ *
+ * Smarty::clearAllAssign() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_ClearAllAssign
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * clear all the assigned template variables.
+     *
+     * @api  Smarty::clearAllAssign()
+     * @link http://www.smarty.net/docs/en/api.clear.all.assign.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function clearAllAssign(Smarty_Internal_Data $data)
+    {
+        $data->tpl_vars = array();
+        return $data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_clearallcache.php b/epgrec/Smarty/sysplugins/smarty_internal_method_clearallcache.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_clearallcache.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_clearallcache.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,41 @@
+<?php
+
+/**
+ * Smarty Method ClearAllCache
+ *
+ * Smarty::clearAllCache() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_ClearAllCache
+{
+    /**
+     * Valid for Smarty object
+     *
+     * @var int
+     */
+    public $objMap = 1;
+
+    /**
+     * Empty cache folder
+     *
+     * @api  Smarty::clearAllCache()
+     * @link http://www.smarty.net/docs/en/api.clear.all.cache.tpl
+     *
+     * @param \Smarty $smarty
+     * @param integer $exp_time expiration time
+     * @param string  $type     resource type
+     *
+     * @return int number of cache files deleted
+     * @throws \SmartyException
+     */
+    public function clearAllCache(Smarty $smarty, $exp_time = null, $type = null)
+    {
+        $smarty->_clearTemplateCache();
+        // load cache resource and call clearAll
+        $_cache_resource = Smarty_CacheResource::load($smarty, $type);
+        return $_cache_resource->clearAll($smarty, $exp_time);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_clearassign.php b/epgrec/Smarty/sysplugins/smarty_internal_method_clearassign.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_clearassign.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_clearassign.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,43 @@
+<?php
+
+/**
+ * Smarty Method ClearAssign
+ *
+ * Smarty::clearAssign() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_ClearAssign
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * clear the given assigned template variable(s).
+     *
+     * @api  Smarty::clearAssign()
+     * @link http://www.smarty.net/docs/en/api.clear.assign.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string|array                                            $tpl_var the template variable(s) to clear
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function clearAssign(Smarty_Internal_Data $data, $tpl_var)
+    {
+        if (is_array($tpl_var)) {
+            foreach ($tpl_var as $curr_var) {
+                unset($data->tpl_vars[ $curr_var ]);
+            }
+        } else {
+            unset($data->tpl_vars[ $tpl_var ]);
+        }
+        return $data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_clearcache.php b/epgrec/Smarty/sysplugins/smarty_internal_method_clearcache.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_clearcache.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_clearcache.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,50 @@
+<?php
+
+/**
+ * Smarty Method ClearCache
+ *
+ * Smarty::clearCache() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_ClearCache
+{
+    /**
+     * Valid for Smarty object
+     *
+     * @var int
+     */
+    public $objMap = 1;
+
+    /**
+     * Empty cache for a specific template
+     *
+     * @api  Smarty::clearCache()
+     * @link http://www.smarty.net/docs/en/api.clear.cache.tpl
+     *
+     * @param \Smarty $smarty
+     * @param string  $template_name template name
+     * @param string  $cache_id      cache id
+     * @param string  $compile_id    compile id
+     * @param integer $exp_time      expiration time
+     * @param string  $type          resource type
+     *
+     * @return int number of cache files deleted
+     * @throws \SmartyException
+     */
+    public function clearCache(
+        Smarty $smarty,
+        $template_name,
+        $cache_id = null,
+        $compile_id = null,
+        $exp_time = null,
+        $type = null
+    ) {
+        $smarty->_clearTemplateCache();
+        // load cache resource and call clear
+        $_cache_resource = Smarty_CacheResource::load($smarty, $type);
+        return $_cache_resource->clear($smarty, $template_name, $cache_id, $compile_id, $exp_time);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_clearcompiledtemplate.php b/epgrec/Smarty/sysplugins/smarty_internal_method_clearcompiledtemplate.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_clearcompiledtemplate.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_clearcompiledtemplate.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,131 @@
+<?php
+
+/**
+ * Smarty Method ClearCompiledTemplate
+ *
+ * Smarty::clearCompiledTemplate() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_ClearCompiledTemplate
+{
+    /**
+     * Valid for Smarty object
+     *
+     * @var int
+     */
+    public $objMap = 1;
+
+    /**
+     * Delete compiled template file
+     *
+     * @api  Smarty::clearCompiledTemplate()
+     * @link http://www.smarty.net/docs/en/api.clear.compiled.template.tpl
+     *
+     * @param \Smarty $smarty
+     * @param string  $resource_name template name
+     * @param string  $compile_id    compile id
+     * @param integer $exp_time      expiration time
+     *
+     * @return int number of template files deleted
+     * @throws \SmartyException
+     */
+    public function clearCompiledTemplate(Smarty $smarty, $resource_name = null, $compile_id = null, $exp_time = null)
+    {
+        // clear template objects cache
+        $smarty->_clearTemplateCache();
+        $_compile_dir = $smarty->getCompileDir();
+        if ($_compile_dir === '/') { //We should never want to delete this!
+            return 0;
+        }
+        $_compile_id = isset($compile_id) ? preg_replace('![^\w]+!', '_', $compile_id) : null;
+        $_dir_sep = $smarty->use_sub_dirs ? DIRECTORY_SEPARATOR : '^';
+        if (isset($resource_name)) {
+            $_save_stat = $smarty->caching;
+            $smarty->caching = Smarty::CACHING_OFF;
+            /* @var Smarty_Internal_Template $tpl */
+            $tpl = $smarty->createTemplate($resource_name);
+            $smarty->caching = $_save_stat;
+            if (!$tpl->source->handler->uncompiled && !$tpl->source->handler->recompiled && $tpl->source->exists) {
+                $_resource_part_1 = basename(str_replace('^', DIRECTORY_SEPARATOR, $tpl->compiled->filepath));
+                $_resource_part_1_length = strlen($_resource_part_1);
+            } else {
+                return 0;
+            }
+            $_resource_part_2 = str_replace('.php', '.cache.php', $_resource_part_1);
+            $_resource_part_2_length = strlen($_resource_part_2);
+        }
+        $_dir = $_compile_dir;
+        if ($smarty->use_sub_dirs && isset($_compile_id)) {
+            $_dir .= $_compile_id . $_dir_sep;
+        }
+        if (isset($_compile_id)) {
+            $_compile_id_part = $_compile_dir . $_compile_id . $_dir_sep;
+            $_compile_id_part_length = strlen($_compile_id_part);
+        }
+        $_count = 0;
+        try {
+            $_compileDirs = new RecursiveDirectoryIterator($_dir);
+            // NOTE: UnexpectedValueException thrown for PHP >= 5.3
+        } catch (Exception $e) {
+            return 0;
+        }
+        $_compile = new RecursiveIteratorIterator($_compileDirs, RecursiveIteratorIterator::CHILD_FIRST);
+        foreach ($_compile as $_file) {
+            if (substr(basename($_file->getPathname()), 0, 1) === '.') {
+                continue;
+            }
+            $_filepath = (string)$_file;
+            if ($_file->isDir()) {
+                if (!$_compile->isDot()) {
+                    // delete folder if empty
+                    @rmdir($_file->getPathname());
+                }
+            } else {
+                // delete only php files
+                if (substr($_filepath, -4) !== '.php') {
+                    continue;
+                }
+                $unlink = false;
+                if ((!isset($_compile_id) ||
+                     (isset($_filepath[ $_compile_id_part_length ]) &&
+                      $a = !strncmp($_filepath, $_compile_id_part, $_compile_id_part_length)))
+                    && (!isset($resource_name) || (isset($_filepath[ $_resource_part_1_length ])
+                                                   && substr_compare(
+                                                          $_filepath,
+                                                          $_resource_part_1,
+                                                          -$_resource_part_1_length,
+                                                          $_resource_part_1_length
+                                                      ) === 0) || (isset($_filepath[ $_resource_part_2_length ])
+                                                                   && substr_compare(
+                                                                          $_filepath,
+                                                                          $_resource_part_2,
+                                                                          -$_resource_part_2_length,
+                                                                          $_resource_part_2_length
+                                                                      ) === 0))
+                ) {
+                    if (isset($exp_time)) {
+                        if (is_file($_filepath) && time() - filemtime($_filepath) >= $exp_time) {
+                            $unlink = true;
+                        }
+                    } else {
+                        $unlink = true;
+                    }
+                }
+                if ($unlink && is_file($_filepath) && @unlink($_filepath)) {
+                    $_count++;
+                    if (function_exists('opcache_invalidate')
+                        && (!function_exists('ini_get') || strlen(ini_get('opcache.restrict_api')) < 1)
+                    ) {
+                        opcache_invalidate($_filepath, true);
+                    } elseif (function_exists('apc_delete_file')) {
+                        apc_delete_file($_filepath);
+                    }
+                }
+            }
+        }
+        return $_count;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_clearconfig.php b/epgrec/Smarty/sysplugins/smarty_internal_method_clearconfig.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_clearconfig.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_clearconfig.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,41 @@
+<?php
+
+/**
+ * Smarty Method ClearConfig
+ *
+ * Smarty::clearConfig() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_ClearConfig
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * clear a single or all config variables
+     *
+     * @api  Smarty::clearConfig()
+     * @link http://www.smarty.net/docs/en/api.clear.config.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string|null                                             $name variable name or null
+     *
+     * @return \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty
+     */
+    public function clearConfig(Smarty_Internal_Data $data, $name = null)
+    {
+        if (isset($name)) {
+            unset($data->config_vars[ $name ]);
+        } else {
+            $data->config_vars = array();
+        }
+        return $data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_compileallconfig.php b/epgrec/Smarty/sysplugins/smarty_internal_method_compileallconfig.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_compileallconfig.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_compileallconfig.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,36 @@
+<?php
+
+/**
+ * Smarty Method CompileAllConfig
+ *
+ * Smarty::compileAllConfig() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_CompileAllConfig extends Smarty_Internal_Method_CompileAllTemplates
+{
+    /**
+     * Compile all config files
+     *
+     * @api Smarty::compileAllConfig()
+     *
+     * @param \Smarty $smarty        passed smarty object
+     * @param string  $extension     file extension
+     * @param bool    $force_compile force all to recompile
+     * @param int     $time_limit
+     * @param int     $max_errors
+     *
+     * @return int number of template files recompiled
+     */
+    public function compileAllConfig(
+        Smarty $smarty,
+        $extension = '.conf',
+        $force_compile = false,
+        $time_limit = 0,
+        $max_errors = null
+    ) {
+        return $this->compileAll($smarty, $extension, $force_compile, $time_limit, $max_errors, true);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_compilealltemplates.php b/epgrec/Smarty/sysplugins/smarty_internal_method_compilealltemplates.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_compilealltemplates.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_compilealltemplates.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,130 @@
+<?php
+
+/**
+ * Smarty Method CompileAllTemplates
+ *
+ * Smarty::compileAllTemplates() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_CompileAllTemplates
+{
+    /**
+     * Valid for Smarty object
+     *
+     * @var int
+     */
+    public $objMap = 1;
+
+    /**
+     * Compile all template files
+     *
+     * @api Smarty::compileAllTemplates()
+     *
+     * @param \Smarty $smarty        passed smarty object
+     * @param string  $extension     file extension
+     * @param bool    $force_compile force all to recompile
+     * @param int     $time_limit
+     * @param int     $max_errors
+     *
+     * @return integer number of template files recompiled
+     */
+    public function compileAllTemplates(
+        Smarty $smarty,
+        $extension = '.tpl',
+        $force_compile = false,
+        $time_limit = 0,
+        $max_errors = null
+    ) {
+        return $this->compileAll($smarty, $extension, $force_compile, $time_limit, $max_errors);
+    }
+
+    /**
+     * Compile all template or config files
+     *
+     * @param \Smarty $smarty
+     * @param string  $extension     template file name extension
+     * @param bool    $force_compile force all to recompile
+     * @param int     $time_limit    set maximum execution time
+     * @param int     $max_errors    set maximum allowed errors
+     * @param bool    $isConfig      flag true if called for config files
+     *
+     * @return int number of template files compiled
+     */
+    protected function compileAll(
+        Smarty $smarty,
+        $extension,
+        $force_compile,
+        $time_limit,
+        $max_errors,
+        $isConfig = false
+    ) {
+        // switch off time limit
+        if (function_exists('set_time_limit')) {
+            @set_time_limit($time_limit);
+        }
+        $_count = 0;
+        $_error_count = 0;
+        $sourceDir = $isConfig ? $smarty->getConfigDir() : $smarty->getTemplateDir();
+        // loop over array of source directories
+        foreach ($sourceDir as $_dir) {
+            $_dir_1 = new RecursiveDirectoryIterator(
+                $_dir,
+                defined('FilesystemIterator::FOLLOW_SYMLINKS') ?
+                    FilesystemIterator::FOLLOW_SYMLINKS : 0
+            );
+            $_dir_2 = new RecursiveIteratorIterator($_dir_1);
+            foreach ($_dir_2 as $_fileinfo) {
+                $_file = $_fileinfo->getFilename();
+                if (substr(basename($_fileinfo->getPathname()), 0, 1) === '.' || strpos($_file, '.svn') !== false) {
+                    continue;
+                }
+                if (substr_compare($_file, $extension, -strlen($extension)) !== 0) {
+                    continue;
+                }
+                if ($_fileinfo->getPath() !== substr($_dir, 0, -1)) {
+                    $_file = substr($_fileinfo->getPath(), strlen($_dir)) . DIRECTORY_SEPARATOR . $_file;
+                }
+                echo "\n<br>", $_dir, '---', $_file;
+                flush();
+                $_start_time = microtime(true);
+                $_smarty = clone $smarty;
+                //
+                $_smarty->_cache = array();
+                $_smarty->ext = new Smarty_Internal_Extension_Handler();
+                $_smarty->ext->objType = $_smarty->_objType;
+                $_smarty->force_compile = $force_compile;
+                try {
+                    /* @var Smarty_Internal_Template $_tpl */
+                    $_tpl = new $smarty->template_class($_file, $_smarty);
+                    $_tpl->caching = Smarty::CACHING_OFF;
+                    $_tpl->source =
+                        $isConfig ? Smarty_Template_Config::load($_tpl) : Smarty_Template_Source::load($_tpl);
+                    if ($_tpl->mustCompile()) {
+                        $_tpl->compileTemplateSource();
+                        $_count++;
+                        echo ' compiled in  ', microtime(true) - $_start_time, ' seconds';
+                        flush();
+                    } else {
+                        echo ' is up to date';
+                        flush();
+                    }
+                } catch (Exception $e) {
+                    echo "\n<br>        ------>Error: ", $e->getMessage(), "<br><br>\n";
+                    $_error_count++;
+                }
+                // free memory
+                unset($_tpl);
+                $_smarty->_clearTemplateCache();
+                if ($max_errors !== null && $_error_count === $max_errors) {
+                    echo "\n<br><br>too many errors\n";
+                    exit(1);
+                }
+            }
+        }
+        echo "\n<br>";
+        return $_count;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_configload.php b/epgrec/Smarty/sysplugins/smarty_internal_method_configload.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_configload.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_configload.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,182 @@
+<?php
+
+/**
+ * Smarty Method ConfigLoad
+ *
+ * Smarty::configLoad() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_ConfigLoad
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * load a config file, optionally load just selected sections
+     *
+     * @api  Smarty::configLoad()
+     * @link http://www.smarty.net/docs/en/api.config.load.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $config_file filename
+     * @param mixed                                                   $sections    array of section names, single
+     *                                                                             section or null
+     *
+     * @return \Smarty|\Smarty_Internal_Data|\Smarty_Internal_Template
+     * @throws \Exception
+     */
+    public function configLoad(Smarty_Internal_Data $data, $config_file, $sections = null)
+    {
+        $this->_loadConfigFile($data, $config_file, $sections, null);
+        return $data;
+    }
+
+    /**
+     * load a config file, optionally load just selected sections
+     *
+     * @api  Smarty::configLoad()
+     * @link http://www.smarty.net/docs/en/api.config.load.tpl
+     *
+     * @param \Smarty|\Smarty_Internal_Data|\Smarty_Internal_Template $data
+     * @param string                                                  $config_file filename
+     * @param mixed                                                   $sections    array of section names, single
+     *                                                                             section or null
+     * @param int                                                     $scope       scope into which config variables
+     *                                                                             shall be loaded
+     *
+     * @throws \Exception
+     */
+    public function _loadConfigFile(Smarty_Internal_Data $data, $config_file, $sections = null, $scope = 0)
+    {
+        /* @var \Smarty $smarty */
+        $smarty = $data->_getSmartyObj();
+        /* @var \Smarty_Internal_Template $confObj */
+        $confObj = new Smarty_Internal_Template($config_file, $smarty, $data, null, null, null, null, true);
+        $confObj->caching = Smarty::CACHING_OFF;
+        $confObj->source->config_sections = $sections;
+        $confObj->source->scope = $scope;
+        $confObj->compiled = Smarty_Template_Compiled::load($confObj);
+        $confObj->compiled->render($confObj);
+        if ($data->_isTplObj()) {
+            $data->compiled->file_dependency[ $confObj->source->uid ] =
+                array($confObj->source->filepath, $confObj->source->getTimeStamp(), $confObj->source->type);
+        }
+    }
+
+    /**
+     * load config variables into template object
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param array                     $new_config_vars
+     */
+    public function _loadConfigVars(Smarty_Internal_Template $tpl, $new_config_vars)
+    {
+        $this->_assignConfigVars($tpl->parent->config_vars, $tpl, $new_config_vars);
+        $tagScope = $tpl->source->scope;
+        if ($tagScope >= 0) {
+            if ($tagScope === Smarty::SCOPE_LOCAL) {
+                $this->_updateVarStack($tpl, $new_config_vars);
+                $tagScope = 0;
+                if (!$tpl->scope) {
+                    return;
+                }
+            }
+            if ($tpl->parent->_isTplObj() && ($tagScope || $tpl->parent->scope)) {
+                $mergedScope = $tagScope | $tpl->scope;
+                if ($mergedScope) {
+                    // update scopes
+                    /* @var \Smarty_Internal_Template|\Smarty|\Smarty_Internal_Data $ptr */
+                    foreach ($tpl->smarty->ext->_updateScope->_getAffectedScopes($tpl->parent, $mergedScope) as $ptr) {
+                        $this->_assignConfigVars($ptr->config_vars, $tpl, $new_config_vars);
+                        if ($tagScope && $ptr->_isTplObj() && isset($tpl->_cache[ 'varStack' ])) {
+                            $this->_updateVarStack($tpl, $new_config_vars);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Assign all config variables in given scope
+     *
+     * @param array                     $config_vars     config variables in scope
+     * @param \Smarty_Internal_Template $tpl
+     * @param array                     $new_config_vars loaded config variables
+     */
+    public function _assignConfigVars(&$config_vars, Smarty_Internal_Template $tpl, $new_config_vars)
+    {
+        // copy global config vars
+        foreach ($new_config_vars[ 'vars' ] as $variable => $value) {
+            if ($tpl->smarty->config_overwrite || !isset($config_vars[ $variable ])) {
+                $config_vars[ $variable ] = $value;
+            } else {
+                $config_vars[ $variable ] = array_merge((array)$config_vars[ $variable ], (array)$value);
+            }
+        }
+        // scan sections
+        $sections = $tpl->source->config_sections;
+        if (!empty($sections)) {
+            foreach ((array)$sections as $tpl_section) {
+                if (isset($new_config_vars[ 'sections' ][ $tpl_section ])) {
+                    foreach ($new_config_vars[ 'sections' ][ $tpl_section ][ 'vars' ] as $variable => $value) {
+                        if ($tpl->smarty->config_overwrite || !isset($config_vars[ $variable ])) {
+                            $config_vars[ $variable ] = $value;
+                        } else {
+                            $config_vars[ $variable ] = array_merge((array)$config_vars[ $variable ], (array)$value);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Update config variables in template local variable stack
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param array                     $config_vars
+     */
+    public function _updateVarStack(Smarty_Internal_Template $tpl, $config_vars)
+    {
+        $i = 0;
+        while (isset($tpl->_cache[ 'varStack' ][ $i ])) {
+            $this->_assignConfigVars($tpl->_cache[ 'varStack' ][ $i ][ 'config' ], $tpl, $config_vars);
+            $i++;
+        }
+    }
+
+    /**
+     * gets  a config variable value
+     *
+     * @param \Smarty|\Smarty_Internal_Data|\Smarty_Internal_Template $data
+     * @param string                                                  $varName the name of the config variable
+     * @param bool                                                    $errorEnable
+     *
+     * @return null|string  the value of the config variable
+     */
+    public function _getConfigVariable(Smarty_Internal_Data $data, $varName, $errorEnable = true)
+    {
+        $_ptr = $data;
+        while ($_ptr !== null) {
+            if (isset($_ptr->config_vars[ $varName ])) {
+                // found it, return it
+                return $_ptr->config_vars[ $varName ];
+            }
+            // not found, try at parent
+            $_ptr = $_ptr->parent;
+        }
+        if ($data->smarty->error_unassigned && $errorEnable) {
+            // force a notice
+            $x = $$varName;
+        }
+        return null;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_createdata.php b/epgrec/Smarty/sysplugins/smarty_internal_method_createdata.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_createdata.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_createdata.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,44 @@
+<?php
+
+/**
+ * Smarty Method CreateData
+ *
+ * Smarty::createData() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_CreateData
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * creates a data object
+     *
+     * @api  Smarty::createData()
+     * @link http://www.smarty.net/docs/en/api.create.data.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty      $obj
+     * @param \Smarty_Internal_Template|\Smarty_Internal_Data|\Smarty_Data|\Smarty $parent next higher level of Smarty
+     *                                                                                     variables
+     * @param string                                                               $name   optional data block name
+     *
+     * @return \Smarty_Data data object
+     */
+    public function createData(Smarty_Internal_TemplateBase $obj, Smarty_Internal_Data $parent = null, $name = null)
+    {
+        /* @var Smarty $smarty */
+        $smarty = $obj->_getSmartyObj();
+        $dataObj = new Smarty_Data($parent, $smarty, $name);
+        if ($smarty->debugging) {
+            Smarty_Internal_Debug::register_data($dataObj);
+        }
+        return $dataObj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getautoloadfilters.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getautoloadfilters.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getautoloadfilters.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getautoloadfilters.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,37 @@
+<?php
+
+/**
+ * Smarty Method GetAutoloadFilters
+ *
+ * Smarty::getAutoloadFilters() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetAutoloadFilters extends Smarty_Internal_Method_SetAutoloadFilters
+{
+    /**
+     * Get autoload filters
+     *
+     * @api Smarty::getAutoloadFilters()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type type of filter to get auto loads
+     *                                                                              for. Defaults to all autoload
+     *                                                                              filters
+     *
+     * @return array array( 'type1' => array( 'filter1', 'filter2',  ) ) or array( 'filter1', 'filter2', ) if $type
+     *                was specified
+     * @throws \SmartyException
+     */
+    public function getAutoloadFilters(Smarty_Internal_TemplateBase $obj, $type = null)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if ($type !== null) {
+            $this->_checkFilterType($type);
+            return isset($smarty->autoload_filters[ $type ]) ? $smarty->autoload_filters[ $type ] : array();
+        }
+        return $smarty->autoload_filters;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvariable.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvariable.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvariable.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvariable.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,34 @@
+<?php
+
+/**
+ * Smarty Method GetConfigVariable
+ *
+ * Smarty::getConfigVariable() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetConfigVariable
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * gets  a config variable value
+     *
+     * @param \Smarty|\Smarty_Internal_Data|\Smarty_Internal_Template $data
+     * @param string                                                  $varName the name of the config variable
+     * @param bool                                                    $errorEnable
+     *
+     * @return null|string  the value of the config variable
+     */
+    public function getConfigVariable(Smarty_Internal_Data $data, $varName = null, $errorEnable = true)
+    {
+        return $data->ext->configLoad->_getConfigVariable($data, $varName, $errorEnable);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvars.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvars.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvars.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getconfigvars.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,58 @@
+<?php
+
+/**
+ * Smarty Method GetConfigVars
+ *
+ * Smarty::getConfigVars() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetConfigVars
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * Returns a single or all config variables
+     *
+     * @api  Smarty::getConfigVars()
+     * @link http://www.smarty.net/docs/en/api.get.config.vars.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $varname        variable name or null
+     * @param bool                                                    $search_parents include parent templates?
+     *
+     * @return mixed variable value or or array of variables
+     */
+    public function getConfigVars(Smarty_Internal_Data $data, $varname = null, $search_parents = true)
+    {
+        $_ptr = $data;
+        $var_array = array();
+        while ($_ptr !== null) {
+            if (isset($varname)) {
+                if (isset($_ptr->config_vars[ $varname ])) {
+                    return $_ptr->config_vars[ $varname ];
+                }
+            } else {
+                $var_array = array_merge($_ptr->config_vars, $var_array);
+            }
+            // not found, try at parent
+            if ($search_parents) {
+                $_ptr = $_ptr->parent;
+            } else {
+                $_ptr = null;
+            }
+        }
+        if (isset($varname)) {
+            return '';
+        } else {
+            return $var_array;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getdebugtemplate.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getdebugtemplate.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getdebugtemplate.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getdebugtemplate.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,35 @@
+<?php
+
+/**
+ * Smarty Method GetDebugTemplate
+ *
+ * Smarty::getDebugTemplate() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetDebugTemplate
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * return name of debugging template
+     *
+     * @api Smarty::getDebugTemplate()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     *
+     * @return string
+     */
+    public function getDebugTemplate(Smarty_Internal_TemplateBase $obj)
+    {
+        $smarty = $obj->_getSmartyObj();
+        return $smarty->debug_tpl;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getdefaultmodifiers.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getdefaultmodifiers.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getdefaultmodifiers.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getdefaultmodifiers.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,35 @@
+<?php
+
+/**
+ * Smarty Method GetDefaultModifiers
+ *
+ * Smarty::getDefaultModifiers() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetDefaultModifiers
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Get default modifiers
+     *
+     * @api Smarty::getDefaultModifiers()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     *
+     * @return array list of default modifiers
+     */
+    public function getDefaultModifiers(Smarty_Internal_TemplateBase $obj)
+    {
+        $smarty = $obj->_getSmartyObj();
+        return $smarty->default_modifiers;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getglobal.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getglobal.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getglobal.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getglobal.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,47 @@
+<?php
+
+/**
+ * Smarty Method GetGlobal
+ *
+ * Smarty::getGlobal() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetGlobal
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * Returns a single or all global  variables
+     *
+     * @api Smarty::getGlobal()
+     *
+     * @param \Smarty_Internal_Data $data
+     * @param string                $varName variable name or null
+     *
+     * @return string|array variable value or or array of variables
+     */
+    public function getGlobal(Smarty_Internal_Data $data, $varName = null)
+    {
+        if (isset($varName)) {
+            if (isset(Smarty::$global_tpl_vars[ $varName ])) {
+                return Smarty::$global_tpl_vars[ $varName ]->value;
+            } else {
+                return '';
+            }
+        } else {
+            $_result = array();
+            foreach (Smarty::$global_tpl_vars as $key => $var) {
+                $_result[ $key ] = $var->value;
+            }
+            return $_result;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getregisteredobject.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getregisteredobject.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getregisteredobject.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getregisteredobject.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,44 @@
+<?php
+
+/**
+ * Smarty Method GetRegisteredObject
+ *
+ * Smarty::getRegisteredObject() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetRegisteredObject
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * return a reference to a registered object
+     *
+     * @api  Smarty::getRegisteredObject()
+     * @link http://www.smarty.net/docs/en/api.get.registered.object.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $object_name object name
+     *
+     * @return object
+     * @throws \SmartyException if no such object is found
+     */
+    public function getRegisteredObject(Smarty_Internal_TemplateBase $obj, $object_name)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (!isset($smarty->registered_objects[ $object_name ])) {
+            throw new SmartyException("'$object_name' is not a registered object");
+        }
+        if (!is_object($smarty->registered_objects[ $object_name ][ 0 ])) {
+            throw new SmartyException("registered '$object_name' is not an object");
+        }
+        return $smarty->registered_objects[ $object_name ][ 0 ];
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_getstreamvariable.php b/epgrec/Smarty/sysplugins/smarty_internal_method_getstreamvariable.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_getstreamvariable.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_getstreamvariable.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,50 @@
+<?php
+
+/**
+ * Smarty Method GetStreamVariable
+ *
+ * Smarty::getStreamVariable() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetStreamVariable
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * gets  a stream variable
+     *
+     * @api Smarty::getStreamVariable()
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $variable the stream of the variable
+     *
+     * @return mixed
+     * @throws \SmartyException
+     */
+    public function getStreamVariable(Smarty_Internal_Data $data, $variable)
+    {
+        $_result = '';
+        $fp = fopen($variable, 'r+');
+        if ($fp) {
+            while (!feof($fp) && ($current_line = fgets($fp)) !== false) {
+                $_result .= $current_line;
+            }
+            fclose($fp);
+            return $_result;
+        }
+        $smarty = isset($data->smarty) ? $data->smarty : $data;
+        if ($smarty->error_unassigned) {
+            throw new SmartyException('Undefined stream variable "' . $variable . '"');
+        } else {
+            return null;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_gettags.php b/epgrec/Smarty/sysplugins/smarty_internal_method_gettags.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_gettags.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_gettags.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,63 @@
+<?php
+
+/**
+ * Smarty Method GetTags
+ *
+ * Smarty::getTags() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetTags
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Return array of tag/attributes of all tags used by an template
+     *
+     * @api  Smarty::getTags()
+     * @link http://www.smarty.net/docs/en/api.get.tags.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param null|string|Smarty_Internal_Template                            $template
+     *
+     * @return array of tag/attributes
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function getTags(Smarty_Internal_TemplateBase $obj, $template = null)
+    {
+        /* @var Smarty $smarty */
+        $smarty = $obj->_getSmartyObj();
+        if ($obj->_isTplObj() && !isset($template)) {
+            $tpl = clone $obj;
+        } elseif (isset($template) && $template->_isTplObj()) {
+            $tpl = clone $template;
+        } elseif (isset($template) && is_string($template)) {
+            /* @var Smarty_Internal_Template $tpl */
+            $tpl = new $smarty->template_class($template, $smarty);
+            // checks if template exists
+            if (!$tpl->source->exists) {
+                throw new SmartyException("Unable to load template {$tpl->source->type} '{$tpl->source->name}'");
+            }
+        }
+        if (isset($tpl)) {
+            $tpl->smarty = clone $tpl->smarty;
+            $tpl->smarty->_cache[ 'get_used_tags' ] = true;
+            $tpl->_cache[ 'used_tags' ] = array();
+            $tpl->smarty->merge_compiled_includes = false;
+            $tpl->smarty->disableSecurity();
+            $tpl->caching = Smarty::CACHING_OFF;
+            $tpl->loadCompiler();
+            $tpl->compiler->compileTemplate($tpl);
+            return $tpl->_cache[ 'used_tags' ];
+        }
+        throw new SmartyException('Missing template specification');
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_gettemplatevars.php b/epgrec/Smarty/sysplugins/smarty_internal_method_gettemplatevars.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_gettemplatevars.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_gettemplatevars.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,119 @@
+<?php
+
+/**
+ * Smarty Method GetTemplateVars
+ *
+ * Smarty::getTemplateVars() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_GetTemplateVars
+{
+    /**
+     * Valid for all objects
+     *
+     * @var int
+     */
+    public $objMap = 7;
+
+    /**
+     * Returns a single or all template variables
+     *
+     * @api  Smarty::getTemplateVars()
+     * @link http://www.smarty.net/docs/en/api.get.template.vars.tpl
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $varName       variable name or null
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $_ptr          optional pointer to data object
+     * @param bool                                                    $searchParents include parent templates?
+     *
+     * @return mixed variable value or or array of variables
+     */
+    public function getTemplateVars(
+        Smarty_Internal_Data $data,
+        $varName = null,
+        Smarty_Internal_Data $_ptr = null,
+        $searchParents = true
+    ) {
+        if (isset($varName)) {
+            $_var = $this->_getVariable($data, $varName, $_ptr, $searchParents, false);
+            if (is_object($_var)) {
+                return $_var->value;
+            } else {
+                return null;
+            }
+        } else {
+            $_result = array();
+            if ($_ptr === null) {
+                $_ptr = $data;
+            }
+            while ($_ptr !== null) {
+                foreach ($_ptr->tpl_vars as $key => $var) {
+                    if (!array_key_exists($key, $_result)) {
+                        $_result[ $key ] = $var->value;
+                    }
+                }
+                // not found, try at parent
+                if ($searchParents && isset($_ptr->parent)) {
+                    $_ptr = $_ptr->parent;
+                } else {
+                    $_ptr = null;
+                }
+            }
+            if ($searchParents && isset(Smarty::$global_tpl_vars)) {
+                foreach (Smarty::$global_tpl_vars as $key => $var) {
+                    if (!array_key_exists($key, $_result)) {
+                        $_result[ $key ] = $var->value;
+                    }
+                }
+            }
+            return $_result;
+        }
+    }
+
+    /**
+     * gets the object of a Smarty variable
+     *
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $data
+     * @param string                                                  $varName       the name of the Smarty variable
+     * @param \Smarty_Internal_Data|\Smarty_Internal_Template|\Smarty $_ptr          optional pointer to data object
+     * @param bool                                                    $searchParents search also in parent data
+     * @param bool                                                    $errorEnable
+     *
+     * @return \Smarty_Variable
+     */
+    public function _getVariable(
+        Smarty_Internal_Data $data,
+        $varName,
+        Smarty_Internal_Data $_ptr = null,
+        $searchParents = true,
+        $errorEnable = true
+    ) {
+        if ($_ptr === null) {
+            $_ptr = $data;
+        }
+        while ($_ptr !== null) {
+            if (isset($_ptr->tpl_vars[ $varName ])) {
+                // found it, return it
+                return $_ptr->tpl_vars[ $varName ];
+            }
+            // not found, try at parent
+            if ($searchParents && isset($_ptr->parent)) {
+                $_ptr = $_ptr->parent;
+            } else {
+                $_ptr = null;
+            }
+        }
+        if (isset(Smarty::$global_tpl_vars[ $varName ])) {
+            // found it, return it
+            return Smarty::$global_tpl_vars[ $varName ];
+        }
+        if ($errorEnable && $data->_getSmartyObj()->error_unassigned) {
+            // force a notice
+            $x = $$varName;
+        }
+        return new Smarty_Undefined_Variable;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_literals.php b/epgrec/Smarty/sysplugins/smarty_internal_method_literals.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_literals.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_literals.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,100 @@
+<?php
+
+/**
+ * Smarty Method GetLiterals
+ *
+ * Smarty::getLiterals() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_Literals
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Get literals
+     *
+     * @api Smarty::getLiterals()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     *
+     * @return array list of literals
+     */
+    public function getLiterals(Smarty_Internal_TemplateBase $obj)
+    {
+        $smarty = $obj->_getSmartyObj();
+        return (array)$smarty->literals;
+    }
+
+    /**
+     * Add literals
+     *
+     * @api Smarty::addLiterals()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param array|string                                                    $literals literal or list of literals
+     *                                                                                  to addto add
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function addLiterals(Smarty_Internal_TemplateBase $obj, $literals = null)
+    {
+        if (isset($literals)) {
+            $this->set($obj->_getSmartyObj(), (array)$literals);
+        }
+        return $obj;
+    }
+
+    /**
+     * Set literals
+     *
+     * @api Smarty::setLiterals()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param array|string                                                    $literals literal or list of literals
+     *                                                                                  to setto set
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function setLiterals(Smarty_Internal_TemplateBase $obj, $literals = null)
+    {
+        $smarty = $obj->_getSmartyObj();
+        $smarty->literals = array();
+        if (!empty($literals)) {
+            $this->set($smarty, (array)$literals);
+        }
+        return $obj;
+    }
+
+    /**
+     * common setter for literals for easier handling of duplicates the
+     * Smarty::$literals array gets filled with identical key values
+     *
+     * @param \Smarty $smarty
+     * @param array   $literals
+     *
+     * @throws \SmartyException
+     */
+    private function set(Smarty $smarty, $literals)
+    {
+        $literals = array_combine($literals, $literals);
+        $error = isset($literals[ $smarty->left_delimiter ]) ? array($smarty->left_delimiter) : array();
+        $error = isset($literals[ $smarty->right_delimiter ]) ? $error[] = $smarty->right_delimiter : $error;
+        if (!empty($error)) {
+            throw new SmartyException(
+                'User defined literal(s) "' . $error .
+                '" may not be identical with left or right delimiter'
+            );
+        }
+        $smarty->literals = array_merge((array)$smarty->literals, (array)$literals);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_loadfilter.php b/epgrec/Smarty/sysplugins/smarty_internal_method_loadfilter.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_loadfilter.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_loadfilter.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,77 @@
+<?php
+
+/**
+ * Smarty Method LoadFilter
+ *
+ * Smarty::loadFilter() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_LoadFilter
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Valid filter types
+     *
+     * @var array
+     */
+    private $filterTypes = array('pre' => true, 'post' => true, 'output' => true, 'variable' => true);
+
+    /**
+     * load a filter of specified type and name
+     *
+     * @api  Smarty::loadFilter()
+     *
+     * @link http://www.smarty.net/docs/en/api.load.filter.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type filter type
+     * @param string                                                          $name filter name
+     *
+     * @return bool
+     * @throws SmartyException if filter could not be loaded
+     */
+    public function loadFilter(Smarty_Internal_TemplateBase $obj, $type, $name)
+    {
+        $smarty = $obj->_getSmartyObj();
+        $this->_checkFilterType($type);
+        $_plugin = "smarty_{$type}filter_{$name}";
+        $_filter_name = $_plugin;
+        if (is_callable($_plugin)) {
+            $smarty->registered_filters[ $type ][ $_filter_name ] = $_plugin;
+            return true;
+        }
+        if ($smarty->loadPlugin($_plugin)) {
+            if (class_exists($_plugin, false)) {
+                $_plugin = array($_plugin, 'execute');
+            }
+            if (is_callable($_plugin)) {
+                $smarty->registered_filters[ $type ][ $_filter_name ] = $_plugin;
+                return true;
+            }
+        }
+        throw new SmartyException("{$type}filter '{$name}' not found or callable");
+    }
+
+    /**
+     * Check if filter type is valid
+     *
+     * @param string $type
+     *
+     * @throws \SmartyException
+     */
+    public function _checkFilterType($type)
+    {
+        if (!isset($this->filterTypes[ $type ])) {
+            throw new SmartyException("Illegal filter type '{$type}'");
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_loadplugin.php b/epgrec/Smarty/sysplugins/smarty_internal_method_loadplugin.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_loadplugin.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_loadplugin.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,111 @@
+<?php
+
+/**
+ * Smarty Extension Loadplugin
+ *
+ * $smarty->loadPlugin() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_LoadPlugin
+{
+    /**
+     * Cache of searched plugin files
+     *
+     * @var array
+     */
+    public $plugin_files = array();
+
+    /**
+     * Takes unknown classes and loads plugin files for them
+     * class name format: Smarty_PluginType_PluginName
+     * plugin filename format: plugintype.pluginname.php
+     *
+     * @param \Smarty $smarty
+     * @param string  $plugin_name class plugin name to load
+     * @param bool    $check       check if already loaded
+     *
+     * @return bool|string
+     * @throws \SmartyException
+     */
+    public function loadPlugin(Smarty $smarty, $plugin_name, $check)
+    {
+        // if function or class exists, exit silently (already loaded)
+        if ($check && (is_callable($plugin_name) || class_exists($plugin_name, false))) {
+            return true;
+        }
+        if (!preg_match('#^smarty_((internal)|([^_]+))_(.+)$#i', $plugin_name, $match)) {
+            throw new SmartyException("plugin {$plugin_name} is not a valid name format");
+        }
+        if (!empty($match[ 2 ])) {
+            $file = SMARTY_SYSPLUGINS_DIR . strtolower($plugin_name) . '.php';
+            if (isset($this->plugin_files[ $file ])) {
+                if ($this->plugin_files[ $file ] !== false) {
+                    return $this->plugin_files[ $file ];
+                } else {
+                    return false;
+                }
+            } else {
+                if (is_file($file)) {
+                    $this->plugin_files[ $file ] = $file;
+                    include_once $file;
+                    return $file;
+                } else {
+                    $this->plugin_files[ $file ] = false;
+                    return false;
+                }
+            }
+        }
+        // plugin filename is expected to be: [type].[name].php
+        $_plugin_filename = "{$match[1]}.{$match[4]}.php";
+        $_lower_filename = strtolower($_plugin_filename);
+        if (isset($this->plugin_files)) {
+            if (isset($this->plugin_files[ 'plugins_dir' ][ $_lower_filename ])) {
+                if (!$smarty->use_include_path || $this->plugin_files[ 'plugins_dir' ][ $_lower_filename ] !== false) {
+                    return $this->plugin_files[ 'plugins_dir' ][ $_lower_filename ];
+                }
+            }
+            if (!$smarty->use_include_path || $smarty->ext->_getIncludePath->isNewIncludePath($smarty)) {
+                unset($this->plugin_files[ 'include_path' ]);
+            } else {
+                if (isset($this->plugin_files[ 'include_path' ][ $_lower_filename ])) {
+                    return $this->plugin_files[ 'include_path' ][ $_lower_filename ];
+                }
+            }
+        }
+        $_file_names = array($_plugin_filename);
+        if ($_lower_filename !== $_plugin_filename) {
+            $_file_names[] = $_lower_filename;
+        }
+        $_p_dirs = $smarty->getPluginsDir();
+        if (!isset($this->plugin_files[ 'plugins_dir' ][ $_lower_filename ])) {
+            // loop through plugin dirs and find the plugin
+            foreach ($_p_dirs as $_plugin_dir) {
+                foreach ($_file_names as $name) {
+                    $file = $_plugin_dir . $name;
+                    if (is_file($file)) {
+                        $this->plugin_files[ 'plugins_dir' ][ $_lower_filename ] = $file;
+                        include_once $file;
+                        return $file;
+                    }
+                    $this->plugin_files[ 'plugins_dir' ][ $_lower_filename ] = false;
+                }
+            }
+        }
+        if ($smarty->use_include_path) {
+            foreach ($_file_names as $_file_name) {
+                // try PHP include_path
+                $file = $smarty->ext->_getIncludePath->getIncludePath($_p_dirs, $_file_name, $smarty);
+                $this->plugin_files[ 'include_path' ][ $_lower_filename ] = $file;
+                if ($file !== false) {
+                    include_once $file;
+                    return $file;
+                }
+            }
+        }
+        // no plugin loaded
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_mustcompile.php b/epgrec/Smarty/sysplugins/smarty_internal_method_mustcompile.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_mustcompile.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_mustcompile.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,50 @@
+<?php
+
+/**
+ * Smarty Method MustCompile
+ *
+ * Smarty_Internal_Template::mustCompile() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_MustCompile
+{
+    /**
+     * Valid for template object
+     *
+     * @var int
+     */
+    public $objMap = 2;
+
+    /**
+     * Returns if the current template must be compiled by the Smarty compiler
+     * It does compare the timestamps of template source and the compiled templates and checks the force compile
+     * configuration
+     *
+     * @param \Smarty_Internal_Template $_template
+     *
+     * @return bool
+     * @throws \SmartyException
+     */
+    public function mustCompile(Smarty_Internal_Template $_template)
+    {
+        if (!$_template->source->exists) {
+            if ($_template->_isSubTpl()) {
+                $parent_resource = " in '$_template->parent->template_resource}'";
+            } else {
+                $parent_resource = '';
+            }
+            throw new SmartyException("Unable to load template {$_template->source->type} '{$_template->source->name}'{$parent_resource}");
+        }
+        if ($_template->mustCompile === null) {
+            $_template->mustCompile = (!$_template->source->handler->uncompiled &&
+                                       ($_template->smarty->force_compile || $_template->source->handler->recompiled ||
+                                        !$_template->compiled->exists || ($_template->compile_check &&
+                                                                          $_template->compiled->getTimeStamp() <
+                                                                          $_template->source->getTimeStamp())));
+        }
+        return $_template->mustCompile;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registercacheresource.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registercacheresource.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registercacheresource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registercacheresource.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,42 @@
+<?php
+
+/**
+ * Smarty Method RegisterCacheResource
+ *
+ * Smarty::registerCacheResource() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterCacheResource
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers a resource to fetch a template
+     *
+     * @api  Smarty::registerCacheResource()
+     * @link http://www.smarty.net/docs/en/api.register.cacheresource.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $name name of resource type
+     * @param \Smarty_CacheResource                                           $resource_handler
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function registerCacheResource(
+        Smarty_Internal_TemplateBase $obj,
+        $name,
+        Smarty_CacheResource $resource_handler
+    ) {
+        $smarty = $obj->_getSmartyObj();
+        $smarty->registered_cache_resources[ $name ] = $resource_handler;
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerclass.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerclass.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerclass.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerclass.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,46 @@
+<?php
+
+/**
+ * Smarty Method RegisterClass
+ *
+ * Smarty::registerClass() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterClass
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers static classes to be used in templates
+     *
+     * @api  Smarty::registerClass()
+     * @link http://www.smarty.net/docs/en/api.register.class.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $class_name
+     * @param string                                                          $class_impl the referenced PHP class to
+     *                                                                                    register
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function registerClass(Smarty_Internal_TemplateBase $obj, $class_name, $class_impl)
+    {
+        $smarty = $obj->_getSmartyObj();
+        // test if exists
+        if (!class_exists($class_impl)) {
+            throw new SmartyException("Undefined class '$class_impl' in register template class");
+        }
+        // register the class
+        $smarty->registered_classes[ $class_name ] = $class_impl;
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultconfighandler.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultconfighandler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultconfighandler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultconfighandler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,42 @@
+<?php
+
+/**
+ * Smarty Method RegisterDefaultConfigHandler
+ *
+ * Smarty::registerDefaultConfigHandler() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterDefaultConfigHandler
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Register config default handler
+     *
+     * @api Smarty::registerDefaultConfigHandler()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param callable                                                        $callback class/method name
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws SmartyException              if $callback is not callable
+     */
+    public function registerDefaultConfigHandler(Smarty_Internal_TemplateBase $obj, $callback)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (is_callable($callback)) {
+            $smarty->default_config_handler_func = $callback;
+        } else {
+            throw new SmartyException('Default config handler not callable');
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultpluginhandler.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultpluginhandler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultpluginhandler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaultpluginhandler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,43 @@
+<?php
+
+/**
+ * Smarty Method RegisterDefaultPluginHandler
+ *
+ * Smarty::registerDefaultPluginHandler() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterDefaultPluginHandler
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers a default plugin handler
+     *
+     * @api  Smarty::registerDefaultPluginHandler()
+     * @link http://www.smarty.net/docs/en/api.register.default.plugin.handler.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param callable                                                        $callback class/method name
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws SmartyException              if $callback is not callable
+     */
+    public function registerDefaultPluginHandler(Smarty_Internal_TemplateBase $obj, $callback)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (is_callable($callback)) {
+            $smarty->default_plugin_handler_func = $callback;
+        } else {
+            throw new SmartyException("Default plugin handler '$callback' not callable");
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaulttemplatehandler.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaulttemplatehandler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaulttemplatehandler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerdefaulttemplatehandler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,88 @@
+<?php
+
+/**
+ * Smarty Method RegisterDefaultTemplateHandler
+ *
+ * Smarty::registerDefaultTemplateHandler() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterDefaultTemplateHandler
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Register template default handler
+     *
+     * @api Smarty::registerDefaultTemplateHandler()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param callable                                                        $callback class/method name
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws SmartyException              if $callback is not callable
+     */
+    public function registerDefaultTemplateHandler(Smarty_Internal_TemplateBase $obj, $callback)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (is_callable($callback)) {
+            $smarty->default_template_handler_func = $callback;
+        } else {
+            throw new SmartyException('Default template handler not callable');
+        }
+        return $obj;
+    }
+
+    /**
+     * get default content from template or config resource handler
+     *
+     * @param Smarty_Template_Source $source
+     *
+     * @throws \SmartyException
+     */
+    public static function _getDefaultTemplate(Smarty_Template_Source $source)
+    {
+        if ($source->isConfig) {
+            $default_handler = $source->smarty->default_config_handler_func;
+        } else {
+            $default_handler = $source->smarty->default_template_handler_func;
+        }
+        $_content = $_timestamp = null;
+        $_return = call_user_func_array(
+            $default_handler,
+            array($source->type, $source->name, &$_content, &$_timestamp, $source->smarty)
+        );
+        if (is_string($_return)) {
+            $source->exists = is_file($_return);
+            if ($source->exists) {
+                $source->timestamp = filemtime($_return);
+            } else {
+                throw new SmartyException(
+                    'Default handler: Unable to load ' .
+                    ($source->isConfig ? 'config' : 'template') .
+                    " default file '{$_return}' for '{$source->type}:{$source->name}'"
+                );
+            }
+            $source->name = $source->filepath = $_return;
+            $source->uid = sha1($source->filepath);
+        } elseif ($_return === true) {
+            $source->content = $_content;
+            $source->exists = true;
+            $source->uid = $source->name = sha1($_content);
+            $source->handler = Smarty_Resource::load($source->smarty, 'eval');
+        } else {
+            $source->exists = false;
+            throw new SmartyException(
+                'Default handler: No ' . ($source->isConfig ? 'config' : 'template') .
+                " default content for '{$source->type}:{$source->name}'"
+            );
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerfilter.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerfilter.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerfilter.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerfilter.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,87 @@
+<?php
+
+/**
+ * Smarty Method RegisterFilter
+ *
+ * Smarty::registerFilter() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterFilter
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Valid filter types
+     *
+     * @var array
+     */
+    private $filterTypes = array('pre' => true, 'post' => true, 'output' => true, 'variable' => true);
+
+    /**
+     * Registers a filter function
+     *
+     * @api  Smarty::registerFilter()
+     *
+     * @link http://www.smarty.net/docs/en/api.register.filter.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type filter type
+     * @param callback                                                        $callback
+     * @param string|null                                                     $name optional filter name
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function registerFilter(Smarty_Internal_TemplateBase $obj, $type, $callback, $name = null)
+    {
+        $smarty = $obj->_getSmartyObj();
+        $this->_checkFilterType($type);
+        $name = isset($name) ? $name : $this->_getFilterName($callback);
+        if (!is_callable($callback)) {
+            throw new SmartyException("{$type}filter '{$name}' not callable");
+        }
+        $smarty->registered_filters[ $type ][ $name ] = $callback;
+        return $obj;
+    }
+
+    /**
+     * Return internal filter name
+     *
+     * @param callback $function_name
+     *
+     * @return string   internal filter name
+     */
+    public function _getFilterName($function_name)
+    {
+        if (is_array($function_name)) {
+            $_class_name = (is_object($function_name[ 0 ]) ? get_class($function_name[ 0 ]) : $function_name[ 0 ]);
+            return $_class_name . '_' . $function_name[ 1 ];
+        } elseif (is_string($function_name)) {
+            return $function_name;
+        } else {
+            return 'closure';
+        }
+    }
+
+    /**
+     * Check if filter type is valid
+     *
+     * @param string $type
+     *
+     * @throws \SmartyException
+     */
+    public function _checkFilterType($type)
+    {
+        if (!isset($this->filterTypes[ $type ])) {
+            throw new SmartyException("Illegal filter type '{$type}'");
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerobject.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerobject.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerobject.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerobject.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,84 @@
+<?php
+
+/**
+ * Smarty Method RegisterObject
+ *
+ * Smarty::registerObject() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterObject
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers object to be used in templates
+     *
+     * @api  Smarty::registerObject()
+     * @link http://www.smarty.net/docs/en/api.register.object.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $object_name
+     * @param object                                                          $object                     the
+     *                                                                                                    referenced
+     *                                                                                                    PHP
+     *                                                                                                    object
+     *                                                                                                    to
+     *                                                                                                    register
+     *
+     * @param array                                                           $allowed_methods_properties list of
+     *                                                                                                    allowed
+     *                                                                                                    methods
+     *                                                                                                    (empty
+     *                                                                                                    = all)
+     *
+     * @param bool                                                            $format                     smarty
+     *                                                                                                    argument
+     *                                                                                                    format,
+     *                                                                                                    else
+     *                                                                                                    traditional
+     *
+     * @param array                                                           $block_methods              list of
+     *                                                                                                    block-methods
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function registerObject(
+        Smarty_Internal_TemplateBase $obj,
+        $object_name,
+        $object,
+        $allowed_methods_properties = array(),
+        $format = true,
+        $block_methods = array()
+    ) {
+        $smarty = $obj->_getSmartyObj();
+        // test if allowed methods callable
+        if (!empty($allowed_methods_properties)) {
+            foreach ((array)$allowed_methods_properties as $method) {
+                if (!is_callable(array($object, $method)) && !property_exists($object, $method)) {
+                    throw new SmartyException("Undefined method or property '$method' in registered object");
+                }
+            }
+        }
+        // test if block methods callable
+        if (!empty($block_methods)) {
+            foreach ((array)$block_methods as $method) {
+                if (!is_callable(array($object, $method))) {
+                    throw new SmartyException("Undefined method '$method' in registered object");
+                }
+            }
+        }
+        // register the object
+        $smarty->registered_objects[ $object_name ] =
+            array($object, (array)$allowed_methods_properties, (boolean)$format, (array)$block_methods);
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerplugin.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerplugin.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerplugin.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerplugin.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,58 @@
+<?php
+
+/**
+ * Smarty Method RegisterPlugin
+ *
+ * Smarty::registerPlugin() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterPlugin
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers plugin to be used in templates
+     *
+     * @api  Smarty::registerPlugin()
+     * @link http://www.smarty.net/docs/en/api.register.plugin.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type       plugin type
+     * @param string                                                          $name       name of template tag
+     * @param callback                                                        $callback   PHP callback to register
+     * @param bool                                                            $cacheable  if true (default) this
+     *                                                                                    function is cache able
+     * @param mixed                                                           $cache_attr caching attributes if any
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws SmartyException              when the plugin tag is invalid
+     */
+    public function registerPlugin(
+        Smarty_Internal_TemplateBase $obj,
+        $type,
+        $name,
+        $callback,
+        $cacheable = true,
+        $cache_attr = null
+    ) {
+        $smarty = $obj->_getSmartyObj();
+        if (isset($smarty->registered_plugins[ $type ][ $name ])) {
+            throw new SmartyException("Plugin tag '{$name}' already registered");
+        } elseif (!is_callable($callback)) {
+            throw new SmartyException("Plugin '{$name}' not callable");
+        } elseif ($cacheable && $cache_attr) {
+            throw new SmartyException("Cannot set caching attributes for plugin '{$name}' when it is cacheable.");
+        } else {
+            $smarty->registered_plugins[ $type ][ $name ] = array($callback, (bool)$cacheable, (array)$cache_attr);
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_registerresource.php b/epgrec/Smarty/sysplugins/smarty_internal_method_registerresource.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_registerresource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_registerresource.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,46 @@
+<?php
+
+/**
+ * Smarty Method RegisterResource
+ *
+ * Smarty::registerResource() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_RegisterResource
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers a resource to fetch a template
+     *
+     * @api  Smarty::registerResource()
+     * @link http://www.smarty.net/docs/en/api.register.resource.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $name             name of resource type
+     * @param Smarty_Resource|array                                           $resource_handler or instance of
+     *                                                                                          Smarty_Resource,
+     *                                                                                          or array of
+     *                                                                                          callbacks to
+     *                                                                                          handle
+     *                                                                                          resource
+     *                                                                                          (deprecated)
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function registerResource(Smarty_Internal_TemplateBase $obj, $name, $resource_handler)
+    {
+        $smarty = $obj->_getSmartyObj();
+        $smarty->registered_resources[ $name ] =
+            $resource_handler instanceof Smarty_Resource ? $resource_handler : array($resource_handler, false);
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_setautoloadfilters.php b/epgrec/Smarty/sysplugins/smarty_internal_method_setautoloadfilters.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_setautoloadfilters.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_setautoloadfilters.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,72 @@
+<?php
+
+/**
+ * Smarty Method SetAutoloadFilters
+ *
+ * Smarty::setAutoloadFilters() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_SetAutoloadFilters
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Valid filter types
+     *
+     * @var array
+     */
+    private $filterTypes = array('pre' => true, 'post' => true, 'output' => true, 'variable' => true);
+
+    /**
+     * Set autoload filters
+     *
+     * @api Smarty::setAutoloadFilters()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param array                                                           $filters filters to load automatically
+     * @param string                                                          $type    "pre", "output",  specify
+     *                                                                                 the filter type to set.
+     *                                                                                 Defaults to none treating
+     *                                                                                 $filters' keys as the
+     *                                                                                 appropriate types
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function setAutoloadFilters(Smarty_Internal_TemplateBase $obj, $filters, $type = null)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if ($type !== null) {
+            $this->_checkFilterType($type);
+            $smarty->autoload_filters[ $type ] = (array)$filters;
+        } else {
+            foreach ((array)$filters as $type => $value) {
+                $this->_checkFilterType($type);
+            }
+            $smarty->autoload_filters = (array)$filters;
+        }
+        return $obj;
+    }
+
+    /**
+     * Check if filter type is valid
+     *
+     * @param string $type
+     *
+     * @throws \SmartyException
+     */
+    public function _checkFilterType($type)
+    {
+        if (!isset($this->filterTypes[ $type ])) {
+            throw new SmartyException("Illegal filter type '{$type}'");
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_setdebugtemplate.php b/epgrec/Smarty/sysplugins/smarty_internal_method_setdebugtemplate.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_setdebugtemplate.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_setdebugtemplate.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,41 @@
+<?php
+
+/**
+ * Smarty Method SetDebugTemplate
+ *
+ * Smarty::setDebugTemplate() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_SetDebugTemplate
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * set the debug template
+     *
+     * @api Smarty::setDebugTemplate()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $tpl_name
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws SmartyException if file is not readable
+     */
+    public function setDebugTemplate(Smarty_Internal_TemplateBase $obj, $tpl_name)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (!is_readable($tpl_name)) {
+            throw new SmartyException("Unknown file '{$tpl_name}'");
+        }
+        $smarty->debug_tpl = $tpl_name;
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_setdefaultmodifiers.php b/epgrec/Smarty/sysplugins/smarty_internal_method_setdefaultmodifiers.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_setdefaultmodifiers.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_setdefaultmodifiers.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,38 @@
+<?php
+
+/**
+ * Smarty Method SetDefaultModifiers
+ *
+ * Smarty::setDefaultModifiers() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_SetDefaultModifiers
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Set default modifiers
+     *
+     * @api Smarty::setDefaultModifiers()
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param array|string                                                    $modifiers modifier or list of modifiers
+     *                                                                                   to set
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function setDefaultModifiers(Smarty_Internal_TemplateBase $obj, $modifiers)
+    {
+        $smarty = $obj->_getSmartyObj();
+        $smarty->default_modifiers = (array)$modifiers;
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_unloadfilter.php b/epgrec/Smarty/sysplugins/smarty_internal_method_unloadfilter.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_unloadfilter.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_unloadfilter.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,43 @@
+<?php
+
+/**
+ * Smarty Method UnloadFilter
+ *
+ * Smarty::unloadFilter() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_UnloadFilter extends Smarty_Internal_Method_LoadFilter
+{
+    /**
+     * load a filter of specified type and name
+     *
+     * @api  Smarty::unloadFilter()
+     *
+     * @link http://www.smarty.net/docs/en/api.unload.filter.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type filter type
+     * @param string                                                          $name filter name
+     *
+     * @return Smarty_Internal_TemplateBase
+     * @throws \SmartyException
+     */
+    public function unloadFilter(Smarty_Internal_TemplateBase $obj, $type, $name)
+    {
+        $smarty = $obj->_getSmartyObj();
+        $this->_checkFilterType($type);
+        if (isset($smarty->registered_filters[ $type ])) {
+            $_filter_name = "smarty_{$type}filter_{$name}";
+            if (isset($smarty->registered_filters[ $type ][ $_filter_name ])) {
+                unset($smarty->registered_filters[ $type ][ $_filter_name ]);
+                if (empty($smarty->registered_filters[ $type ])) {
+                    unset($smarty->registered_filters[ $type ]);
+                }
+            }
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_unregistercacheresource.php b/epgrec/Smarty/sysplugins/smarty_internal_method_unregistercacheresource.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_unregistercacheresource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_unregistercacheresource.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,40 @@
+<?php
+
+/**
+ * Smarty Method UnregisterCacheResource
+ *
+ * Smarty::unregisterCacheResource() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_UnregisterCacheResource
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers a resource to fetch a template
+     *
+     * @api  Smarty::unregisterCacheResource()
+     * @link http://www.smarty.net/docs/en/api.unregister.cacheresource.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param                                                                 $name
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function unregisterCacheResource(Smarty_Internal_TemplateBase $obj, $name)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (isset($smarty->registered_cache_resources[ $name ])) {
+            unset($smarty->registered_cache_resources[ $name ]);
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterfilter.php b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterfilter.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterfilter.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterfilter.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,43 @@
+<?php
+
+/**
+ * Smarty Method UnregisterFilter
+ *
+ * Smarty::unregisterFilter() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_UnregisterFilter extends Smarty_Internal_Method_RegisterFilter
+{
+    /**
+     * Unregisters a filter function
+     *
+     * @api  Smarty::unregisterFilter()
+     *
+     * @link http://www.smarty.net/docs/en/api.unregister.filter.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type filter type
+     * @param callback|string                                                 $callback
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function unregisterFilter(Smarty_Internal_TemplateBase $obj, $type, $callback)
+    {
+        $smarty = $obj->_getSmartyObj();
+        $this->_checkFilterType($type);
+        if (isset($smarty->registered_filters[ $type ])) {
+            $name = is_string($callback) ? $callback : $this->_getFilterName($callback);
+            if (isset($smarty->registered_filters[ $type ][ $name ])) {
+                unset($smarty->registered_filters[ $type ][ $name ]);
+                if (empty($smarty->registered_filters[ $type ])) {
+                    unset($smarty->registered_filters[ $type ]);
+                }
+            }
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterobject.php b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterobject.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterobject.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterobject.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,40 @@
+<?php
+
+/**
+ * Smarty Method UnregisterObject
+ *
+ * Smarty::unregisterObject() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_UnregisterObject
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers plugin to be used in templates
+     *
+     * @api  Smarty::unregisterObject()
+     * @link http://www.smarty.net/docs/en/api.unregister.object.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $object_name name of object
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function unregisterObject(Smarty_Internal_TemplateBase $obj, $object_name)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (isset($smarty->registered_objects[ $object_name ])) {
+            unset($smarty->registered_objects[ $object_name ]);
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterplugin.php b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterplugin.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterplugin.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterplugin.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,41 @@
+<?php
+
+/**
+ * Smarty Method UnregisterPlugin
+ *
+ * Smarty::unregisterPlugin() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_UnregisterPlugin
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers plugin to be used in templates
+     *
+     * @api  Smarty::unregisterPlugin()
+     * @link http://www.smarty.net/docs/en/api.unregister.plugin.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type plugin type
+     * @param string                                                          $name name of template tag
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function unregisterPlugin(Smarty_Internal_TemplateBase $obj, $type, $name)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (isset($smarty->registered_plugins[ $type ][ $name ])) {
+            unset($smarty->registered_plugins[ $type ][ $name ]);
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterresource.php b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterresource.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterresource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_method_unregisterresource.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,40 @@
+<?php
+
+/**
+ * Smarty Method UnregisterResource
+ *
+ * Smarty::unregisterResource() method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Method_UnregisterResource
+{
+    /**
+     * Valid for Smarty and template object
+     *
+     * @var int
+     */
+    public $objMap = 3;
+
+    /**
+     * Registers a resource to fetch a template
+     *
+     * @api  Smarty::unregisterResource()
+     * @link http://www.smarty.net/docs/en/api.unregister.resource.tpl
+     *
+     * @param \Smarty_Internal_TemplateBase|\Smarty_Internal_Template|\Smarty $obj
+     * @param string                                                          $type name of resource type
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     */
+    public function unregisterResource(Smarty_Internal_TemplateBase $obj, $type)
+    {
+        $smarty = $obj->_getSmartyObj();
+        if (isset($smarty->registered_resources[ $type ])) {
+            unset($smarty->registered_resources[ $type ]);
+        }
+        return $obj;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_nocache_insert.php b/epgrec/Smarty/sysplugins/smarty_internal_nocache_insert.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_nocache_insert.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_nocache_insert.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,51 @@
+<?php
+/**
+ * Smarty Internal Plugin Nocache Insert
+ * Compiles the {insert} tag into the cache file
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Plugin Compile Insert Class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_Nocache_Insert
+{
+    /**
+     * Compiles code for the {insert} tag into cache file
+     *
+     * @param string                   $_function insert function name
+     * @param array                    $_attr     array with parameter
+     * @param Smarty_Internal_Template $_template template object
+     * @param string                   $_script   script name to load or 'null'
+     * @param string                   $_assign   optional variable name
+     *
+     * @return string                   compiled code
+     */
+    public static function compile($_function, $_attr, $_template, $_script, $_assign = null)
+    {
+        $_output = '<?php ';
+        if ($_script !== 'null') {
+            // script which must be included
+            // code for script file loading
+            $_output .= "require_once '{$_script}';";
+        }
+        // call insert
+        if (isset($_assign)) {
+            $_output .= "\$_smarty_tpl->assign('{$_assign}' , {$_function} (" . var_export($_attr, true) .
+                        ',\$_smarty_tpl), true);?>';
+        } else {
+            $_output .= "echo {$_function}(" . var_export($_attr, true) . ',$_smarty_tpl);?>';
+        }
+        $_tpl = $_template;
+        while ($_tpl->_isSubTpl()) {
+            $_tpl = $_tpl->parent;
+        }
+        return "/*%%SmartyNocache:{$_tpl->compiled->nocache_hash}%%*/{$_output}/*/%%SmartyNocache:{$_tpl->compiled->nocache_hash}%%*/";
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_parsetree.php b/epgrec/Smarty/sysplugins/smarty_internal_parsetree.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_parsetree.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_parsetree.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,50 @@
+<?php
+/**
+ * Smarty Internal Plugin Templateparser Parsetree
+ * These are classes to build parsetree in the template parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Thue Kristensen
+ * @author     Uwe Tews
+ */
+
+/**
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+abstract class Smarty_Internal_ParseTree
+{
+    /**
+     * Buffer content
+     *
+     * @var mixed
+     */
+    public $data;
+
+    /**
+     * Subtree array
+     *
+     * @var array
+     */
+    public $subtrees = array();
+
+    /**
+     * Return buffer
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string buffer content
+     */
+    abstract public function to_smarty_php(Smarty_Internal_Templateparser $parser);
+
+    /**
+     * Template data object destructor
+     */
+    public function __destruct()
+    {
+        $this->data = null;
+        $this->subtrees = null;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_code.php b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_code.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_code.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_code.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,42 @@
+<?php
+/**
+ * Smarty Internal Plugin Templateparser Parse Tree
+ * These are classes to build parse trees in the template parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Thue Kristensen
+ * @author     Uwe Tews
+ */
+
+/**
+ * Code fragment inside a tag .
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+class Smarty_Internal_ParseTree_Code extends Smarty_Internal_ParseTree
+{
+    /**
+     * Create parse tree buffer for code fragment
+     *
+     * @param string $data content
+     */
+    public function __construct($data)
+    {
+        $this->data = $data;
+    }
+
+    /**
+     * Return buffer content in parentheses
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string content
+     */
+    public function to_smarty_php(Smarty_Internal_Templateparser $parser)
+    {
+        return sprintf('(%s)', $this->data);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dq.php b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dq.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dq.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dq.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,95 @@
+<?php
+/**
+ * Double quoted string inside a tag.
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+
+/**
+ * Double quoted string inside a tag.
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+class Smarty_Internal_ParseTree_Dq extends Smarty_Internal_ParseTree
+{
+    /**
+     * Create parse tree buffer for double quoted string subtrees
+     *
+     * @param object                    $parser  parser object
+     * @param Smarty_Internal_ParseTree $subtree parse tree buffer
+     */
+    public function __construct($parser, Smarty_Internal_ParseTree $subtree)
+    {
+        $this->subtrees[] = $subtree;
+        if ($subtree instanceof Smarty_Internal_ParseTree_Tag) {
+            $parser->block_nesting_level = count($parser->compiler->_tag_stack);
+        }
+    }
+
+    /**
+     * Append buffer to subtree
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     * @param Smarty_Internal_ParseTree       $subtree parse tree buffer
+     */
+    public function append_subtree(Smarty_Internal_Templateparser $parser, Smarty_Internal_ParseTree $subtree)
+    {
+        $last_subtree = count($this->subtrees) - 1;
+        if ($last_subtree >= 0 && $this->subtrees[ $last_subtree ] instanceof Smarty_Internal_ParseTree_Tag
+            && $this->subtrees[ $last_subtree ]->saved_block_nesting < $parser->block_nesting_level
+        ) {
+            if ($subtree instanceof Smarty_Internal_ParseTree_Code) {
+                $this->subtrees[ $last_subtree ]->data =
+                    $parser->compiler->appendCode(
+                        $this->subtrees[ $last_subtree ]->data,
+                        '<?php echo ' . $subtree->data . ';?>'
+                    );
+            } elseif ($subtree instanceof Smarty_Internal_ParseTree_DqContent) {
+                $this->subtrees[ $last_subtree ]->data =
+                    $parser->compiler->appendCode(
+                        $this->subtrees[ $last_subtree ]->data,
+                        '<?php echo "' . $subtree->data . '";?>'
+                    );
+            } else {
+                $this->subtrees[ $last_subtree ]->data =
+                    $parser->compiler->appendCode($this->subtrees[ $last_subtree ]->data, $subtree->data);
+            }
+        } else {
+            $this->subtrees[] = $subtree;
+        }
+        if ($subtree instanceof Smarty_Internal_ParseTree_Tag) {
+            $parser->block_nesting_level = count($parser->compiler->_tag_stack);
+        }
+    }
+
+    /**
+     * Merge subtree buffer content together
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string compiled template code
+     */
+    public function to_smarty_php(Smarty_Internal_Templateparser $parser)
+    {
+        $code = '';
+        foreach ($this->subtrees as $subtree) {
+            if ($code !== '') {
+                $code .= '.';
+            }
+            if ($subtree instanceof Smarty_Internal_ParseTree_Tag) {
+                $more_php = $subtree->assign_to_var($parser);
+            } else {
+                $more_php = $subtree->to_smarty_php($parser);
+            }
+            $code .= $more_php;
+            if (!$subtree instanceof Smarty_Internal_ParseTree_DqContent) {
+                $parser->compiler->has_variable_string = true;
+            }
+        }
+        return $code;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dqcontent.php b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dqcontent.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dqcontent.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_dqcontent.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,42 @@
+<?php
+/**
+ * Smarty Internal Plugin Templateparser Parse Tree
+ * These are classes to build parse tree  in the template parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Thue Kristensen
+ * @author     Uwe Tews
+ */
+
+/**
+ * Raw chars as part of a double quoted string.
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+class Smarty_Internal_ParseTree_DqContent extends Smarty_Internal_ParseTree
+{
+    /**
+     * Create parse tree buffer with string content
+     *
+     * @param string $data string section
+     */
+    public function __construct($data)
+    {
+        $this->data = $data;
+    }
+
+    /**
+     * Return content as double quoted string
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string doubled quoted string
+     */
+    public function to_smarty_php(Smarty_Internal_Templateparser $parser)
+    {
+        return '"' . $this->data . '"';
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_tag.php b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_tag.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_tag.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_tag.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,67 @@
+<?php
+/**
+ * Smarty Internal Plugin Templateparser Parse Tree
+ * These are classes to build parse tree in the template parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Thue Kristensen
+ * @author     Uwe Tews
+ */
+
+/**
+ * A complete smarty tag.
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+class Smarty_Internal_ParseTree_Tag extends Smarty_Internal_ParseTree
+{
+    /**
+     * Saved block nesting level
+     *
+     * @var int
+     */
+    public $saved_block_nesting;
+
+    /**
+     * Create parse tree buffer for Smarty tag
+     *
+     * @param \Smarty_Internal_Templateparser $parser parser object
+     * @param string                          $data   content
+     */
+    public function __construct(Smarty_Internal_Templateparser $parser, $data)
+    {
+        $this->data = $data;
+        $this->saved_block_nesting = $parser->block_nesting_level;
+    }
+
+    /**
+     * Return buffer content
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string content
+     */
+    public function to_smarty_php(Smarty_Internal_Templateparser $parser)
+    {
+        return $this->data;
+    }
+
+    /**
+     * Return complied code that loads the evaluated output of buffer content into a temporary variable
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string template code
+     */
+    public function assign_to_var(Smarty_Internal_Templateparser $parser)
+    {
+        $var = $parser->compiler->getNewPrefixVariable();
+        $tmp = $parser->compiler->appendCode('<?php ob_start();?>', $this->data);
+        $tmp = $parser->compiler->appendCode($tmp, "<?php {$var}=ob_get_clean();?>");
+        $parser->compiler->prefix_code[] = sprintf('%s', $tmp);
+        return $var;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_template.php b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_template.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_template.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_template.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,169 @@
+<?php
+/**
+ * Smarty Internal Plugin Templateparser Parse Tree
+ * These are classes to build parse tree in the template parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Thue Kristensen
+ * @author     Uwe Tews
+ */
+
+/**
+ * Template element
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+class Smarty_Internal_ParseTree_Template extends Smarty_Internal_ParseTree
+{
+    /**
+     * Array of template elements
+     *
+     * @var array
+     */
+    public $subtrees = array();
+
+    /**
+     * Create root of parse tree for template elements
+     */
+    public function __construct()
+    {
+    }
+
+    /**
+     * Append buffer to subtree
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     * @param Smarty_Internal_ParseTree       $subtree
+     */
+    public function append_subtree(Smarty_Internal_Templateparser $parser, Smarty_Internal_ParseTree $subtree)
+    {
+        if (!empty($subtree->subtrees)) {
+            $this->subtrees = array_merge($this->subtrees, $subtree->subtrees);
+        } else {
+            if ($subtree->data !== '') {
+                $this->subtrees[] = $subtree;
+            }
+        }
+    }
+
+    /**
+     * Append array to subtree
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     * @param \Smarty_Internal_ParseTree[]    $array
+     */
+    public function append_array(Smarty_Internal_Templateparser $parser, $array = array())
+    {
+        if (!empty($array)) {
+            $this->subtrees = array_merge($this->subtrees, (array)$array);
+        }
+    }
+
+    /**
+     * Prepend array to subtree
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     * @param \Smarty_Internal_ParseTree[]    $array
+     */
+    public function prepend_array(Smarty_Internal_Templateparser $parser, $array = array())
+    {
+        if (!empty($array)) {
+            $this->subtrees = array_merge((array)$array, $this->subtrees);
+        }
+    }
+
+    /**
+     * Sanitize and merge subtree buffers together
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string template code content
+     */
+    public function to_smarty_php(Smarty_Internal_Templateparser $parser)
+    {
+        $code = '';
+
+        foreach ($this->getChunkedSubtrees() as $chunk) {
+	        $text = '';
+	        switch ($chunk['mode']) {
+		        case 'textstripped':
+			        foreach ($chunk['subtrees'] as $subtree) {
+				        $text .= $subtree->to_smarty_php($parser);
+			        }
+			        $code .= preg_replace(
+				        '/((<%)|(%>)|(<\?php)|(<\?)|(\?>)|(<\/?script))/',
+				        "<?php echo '\$1'; ?>\n",
+				        $parser->compiler->processText($text)
+			        );
+			        break;
+		        case 'text':
+			        foreach ($chunk['subtrees'] as $subtree) {
+				        $text .= $subtree->to_smarty_php($parser);
+			        }
+			        $code .= preg_replace(
+				        '/((<%)|(%>)|(<\?php)|(<\?)|(\?>)|(<\/?script))/',
+				        "<?php echo '\$1'; ?>\n",
+				        $text
+			        );
+			        break;
+		        case 'tag':
+			        foreach ($chunk['subtrees'] as $subtree) {
+				        $text = $parser->compiler->appendCode($text, $subtree->to_smarty_php($parser));
+			        }
+			        $code .= $text;
+			        break;
+		        default:
+			        foreach ($chunk['subtrees'] as $subtree) {
+				        $text = $subtree->to_smarty_php($parser);
+			        }
+			        $code .= $text;
+
+	        }
+        }
+        return $code;
+    }
+
+    private function getChunkedSubtrees() {
+    	$chunks = array();
+    	$currentMode = null;
+    	$currentChunk = array();
+	    for ($key = 0, $cnt = count($this->subtrees); $key < $cnt; $key++) {
+
+	    	if ($this->subtrees[ $key ]->data === '' && in_array($currentMode, array('textstripped', 'text', 'tag'))) {
+	    		continue;
+	    	}
+
+		    if ($this->subtrees[ $key ] instanceof Smarty_Internal_ParseTree_Text
+			    && $this->subtrees[ $key ]->isToBeStripped()) {
+		    	$newMode = 'textstripped';
+		    } elseif ($this->subtrees[ $key ] instanceof Smarty_Internal_ParseTree_Text) {
+			    $newMode = 'text';
+		    } elseif ($this->subtrees[ $key ] instanceof Smarty_Internal_ParseTree_Tag) {
+			    $newMode = 'tag';
+		    } else {
+			    $newMode = 'other';
+		    }
+
+		    if ($newMode == $currentMode) {
+			    $currentChunk[] = $this->subtrees[ $key ];
+		    } else {
+		    	$chunks[] = array(
+		    		'mode' => $currentMode,
+				    'subtrees' => $currentChunk
+			    );
+		    	$currentMode = $newMode;
+			    $currentChunk = array($this->subtrees[ $key ]);
+		    }
+	    }
+	    if ($currentMode && $currentChunk) {
+		    $chunks[] = array(
+			    'mode' => $currentMode,
+			    'subtrees' => $currentChunk
+		    );
+	    }
+		return $chunks;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_text.php b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_text.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_parsetree_text.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_parsetree_text.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,57 @@
+<?php
+
+/**
+ * Smarty Internal Plugin Templateparser Parse Tree
+ * These are classes to build parse tree in the template parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Thue Kristensen
+ * @author     Uwe Tews
+ *             *
+ *             template text
+ * @package    Smarty
+ * @subpackage Compiler
+ * @ignore
+ */
+class Smarty_Internal_ParseTree_Text extends Smarty_Internal_ParseTree
+{
+
+	/**
+	 * Wether this section should be stripped on output to smarty php
+	 * @var bool
+	 */
+	private $toBeStripped = false;
+
+	/**
+	 * Create template text buffer
+	 *
+	 * @param string $data text
+	 * @param bool $toBeStripped wether this section should be stripped on output to smarty php
+	 */
+    public function __construct($data, $toBeStripped = false)
+    {
+        $this->data = $data;
+        $this->toBeStripped = $toBeStripped;
+    }
+
+	/**
+	 * Wether this section should be stripped on output to smarty php
+	 * @return bool
+	 */
+	public function isToBeStripped() {
+    	return $this->toBeStripped;
+    }
+
+    /**
+     * Return buffer content
+     *
+     * @param \Smarty_Internal_Templateparser $parser
+     *
+     * @return string text
+     */
+    public function to_smarty_php(Smarty_Internal_Templateparser $parser)
+    {
+        return $this->data;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_resource_eval.php b/epgrec/Smarty/sysplugins/smarty_internal_resource_eval.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_resource_eval.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_resource_eval.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,94 @@
+<?php
+/**
+ * Smarty Internal Plugin Resource Eval
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Internal Plugin Resource Eval
+ * Implements the strings as resource for Smarty template
+ * {@internal unlike string-resources the compiled state of eval-resources is NOT saved for subsequent access}}
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+class Smarty_Internal_Resource_Eval extends Smarty_Resource_Recompiled
+{
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        $source->uid = $source->filepath = sha1($source->name);
+        $source->timestamp = $source->exists = true;
+    }
+
+    /**
+     * Load template's source from $resource_name into current template object
+     *
+     * @uses decode() to decode base64 and urlencoded template_resources
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 template source
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        return $this->decode($source->name);
+    }
+
+    /**
+     * decode base64 and urlencode
+     *
+     * @param string $string template_resource to decode
+     *
+     * @return string decoded template_resource
+     */
+    protected function decode($string)
+    {
+        // decode if specified
+        if (($pos = strpos($string, ':')) !== false) {
+            if (!strncmp($string, 'base64', 6)) {
+                return base64_decode(substr($string, 7));
+            } elseif (!strncmp($string, 'urlencode', 9)) {
+                return urldecode(substr($string, 10));
+            }
+        }
+        return $string;
+    }
+
+    /**
+     * modify resource_name according to resource handlers specifications
+     *
+     * @param Smarty  $smarty        Smarty instance
+     * @param string  $resource_name resource_name to make unique
+     * @param boolean $isConfig      flag for config resource
+     *
+     * @return string unique resource name
+     */
+    public function buildUniqueResourceName(Smarty $smarty, $resource_name, $isConfig = false)
+    {
+        return get_class($this) . '#' . $this->decode($resource_name);
+    }
+
+    /**
+     * Determine basename for compiled filename
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 resource's basename
+     */
+    public function getBasename(Smarty_Template_Source $source)
+    {
+        return '';
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_resource_extends.php b/epgrec/Smarty/sysplugins/smarty_internal_resource_extends.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_resource_extends.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_resource_extends.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,126 @@
+<?php
+/**
+ * Smarty Internal Plugin Resource Extends
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Internal Plugin Resource Extends
+ * Implements the file system as resource for Smarty which {extend}s a chain of template files templates
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+class Smarty_Internal_Resource_Extends extends Smarty_Resource
+{
+    /**
+     * mbstring.overload flag
+     *
+     * @var int
+     */
+    public $mbstring_overload = 0;
+
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @throws SmartyException
+     */
+    public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        $uid = '';
+        $sources = array();
+        $components = explode('|', $source->name);
+        $smarty = &$source->smarty;
+        $exists = true;
+        foreach ($components as $component) {
+            /* @var \Smarty_Template_Source $_s */
+            $_s = Smarty_Template_Source::load(null, $smarty, $component);
+            if ($_s->type === 'php') {
+                throw new SmartyException("Resource type {$_s->type} cannot be used with the extends resource type");
+            }
+            $sources[ $_s->uid ] = $_s;
+            $uid .= $_s->filepath;
+            if ($_template) {
+                $exists = $exists && $_s->exists;
+            }
+        }
+        $source->components = $sources;
+        $source->filepath = $_s->filepath;
+        $source->uid = sha1($uid . $source->smarty->_joined_template_dir);
+        $source->exists = $exists;
+        if ($_template) {
+            $source->timestamp = $_s->timestamp;
+        }
+    }
+
+    /**
+     * populate Source Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Source $source source object
+     */
+    public function populateTimestamp(Smarty_Template_Source $source)
+    {
+        $source->exists = true;
+        /* @var \Smarty_Template_Source $_s */
+        foreach ($source->components as $_s) {
+            $source->exists = $source->exists && $_s->exists;
+        }
+        $source->timestamp = $source->exists ? $_s->getTimeStamp() : false;
+    }
+
+    /**
+     * Load template's source from files into current template object
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string template source
+     * @throws SmartyException if source cannot be loaded
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        if (!$source->exists) {
+            throw new SmartyException("Unable to load template '{$source->type}:{$source->name}'");
+        }
+        $_components = array_reverse($source->components);
+        $_content = '';
+        /* @var \Smarty_Template_Source $_s */
+        foreach ($_components as $_s) {
+            // read content
+            $_content .= $_s->getContent();
+        }
+        return $_content;
+    }
+
+    /**
+     * Determine basename for compiled filename
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string resource's basename
+     */
+    public function getBasename(Smarty_Template_Source $source)
+    {
+        return str_replace(':', '.', basename($source->filepath));
+    }
+
+    /*
+      * Disable timestamp checks for extends resource.
+      * The individual source components will be checked.
+      *
+      * @return bool
+      */
+    /**
+     * @return bool
+     */
+    public function checkTimestamps()
+    {
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_resource_file.php b/epgrec/Smarty/sysplugins/smarty_internal_resource_file.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_resource_file.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_resource_file.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,180 @@
+<?php
+/**
+ * Smarty Internal Plugin Resource File
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Internal Plugin Resource File
+ * Implements the file system as resource for Smarty templates
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+class Smarty_Internal_Resource_File extends Smarty_Resource
+{
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @throws \SmartyException
+     */
+    public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        $source->filepath = $this->buildFilepath($source, $_template);
+        if ($source->filepath !== false) {
+            if (isset($source->smarty->security_policy) && is_object($source->smarty->security_policy)) {
+                $source->smarty->security_policy->isTrustedResourceDir($source->filepath, $source->isConfig);
+            }
+            $source->exists = true;
+            $source->uid = sha1(
+                $source->filepath . ($source->isConfig ? $source->smarty->_joined_config_dir :
+                    $source->smarty->_joined_template_dir)
+            );
+            $source->timestamp = filemtime($source->filepath);
+        } else {
+            $source->timestamp = $source->exists = false;
+        }
+    }
+
+    /**
+     * populate Source Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Source $source source object
+     */
+    public function populateTimestamp(Smarty_Template_Source $source)
+    {
+        if (!$source->exists) {
+            $source->timestamp = $source->exists = is_file($source->filepath);
+        }
+        if ($source->exists) {
+            $source->timestamp = filemtime($source->filepath);
+        }
+    }
+
+    /**
+     * Load template's source from file into current template object
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 template source
+     * @throws SmartyException        if source cannot be loaded
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        if ($source->exists) {
+            return file_get_contents($source->filepath);
+        }
+        throw new SmartyException(
+            'Unable to read ' . ($source->isConfig ? 'config' : 'template') .
+            " {$source->type} '{$source->name}'"
+        );
+    }
+
+    /**
+     * Determine basename for compiled filename
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 resource's basename
+     */
+    public function getBasename(Smarty_Template_Source $source)
+    {
+        return basename($source->filepath);
+    }
+
+    /**
+     * build template filepath by traversing the template_dir array
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return string fully qualified filepath
+     * @throws SmartyException
+     */
+    protected function buildFilepath(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        $file = $source->name;
+        // absolute file ?
+        if ($file[ 0 ] === '/' || $file[ 1 ] === ':') {
+            $file = $source->smarty->_realpath($file, true);
+            return is_file($file) ? $file : false;
+        }
+        // go relative to a given template?
+        if ($file[ 0 ] === '.' && $_template && $_template->_isSubTpl()
+            && preg_match('#^[.]{1,2}[\\\/]#', $file)
+        ) {
+            if ($_template->parent->source->type !== 'file' && $_template->parent->source->type !== 'extends'
+                && !isset($_template->parent->_cache[ 'allow_relative_path' ])
+            ) {
+                throw new SmartyException("Template '{$file}' cannot be relative to template of resource type '{$_template->parent->source->type}'");
+            }
+            // normalize path
+            $path =
+                $source->smarty->_realpath(dirname($_template->parent->source->filepath) . DIRECTORY_SEPARATOR . $file);
+            // files relative to a template only get one shot
+            return is_file($path) ? $path : false;
+        }
+        // normalize DIRECTORY_SEPARATOR
+        if (strpos($file, DIRECTORY_SEPARATOR === '/' ? '\\' : '/') !== false) {
+            $file = str_replace(DIRECTORY_SEPARATOR === '/' ? '\\' : '/', DIRECTORY_SEPARATOR, $file);
+        }
+        $_directories = $source->smarty->getTemplateDir(null, $source->isConfig);
+        // template_dir index?
+        if ($file[ 0 ] === '[' && preg_match('#^\[([^\]]+)\](.+)$#', $file, $fileMatch)) {
+            $file = $fileMatch[ 2 ];
+            $_indices = explode(',', $fileMatch[ 1 ]);
+            $_index_dirs = array();
+            foreach ($_indices as $index) {
+                $index = trim($index);
+                // try string indexes
+                if (isset($_directories[ $index ])) {
+                    $_index_dirs[] = $_directories[ $index ];
+                } elseif (is_numeric($index)) {
+                    // try numeric index
+                    $index = (int)$index;
+                    if (isset($_directories[ $index ])) {
+                        $_index_dirs[] = $_directories[ $index ];
+                    } else {
+                        // try at location index
+                        $keys = array_keys($_directories);
+                        if (isset($_directories[ $keys[ $index ] ])) {
+                            $_index_dirs[] = $_directories[ $keys[ $index ] ];
+                        }
+                    }
+                }
+            }
+            if (empty($_index_dirs)) {
+                // index not found
+                return false;
+            } else {
+                $_directories = $_index_dirs;
+            }
+        }
+        // relative file name?
+        foreach ($_directories as $_directory) {
+            $path = $_directory . $file;
+            if (is_file($path)) {
+                return (strpos($path, '.' . DIRECTORY_SEPARATOR) !== false) ? $source->smarty->_realpath($path) : $path;
+            }
+        }
+        if (!isset($_index_dirs)) {
+            // Could be relative to cwd
+            $path = $source->smarty->_realpath($file, true);
+            if (is_file($path)) {
+                return $path;
+            }
+        }
+        // Use include path ?
+        if ($source->smarty->use_include_path) {
+            return $source->smarty->ext->_getIncludePath->getIncludePath($_directories, $file, $source->smarty);
+        }
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_resource_php.php b/epgrec/Smarty/sysplugins/smarty_internal_resource_php.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_resource_php.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_resource_php.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,116 @@
+<?php
+
+/**
+ * Smarty Internal Plugin Resource PHP
+ * Implements the file system as resource for PHP templates
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+class Smarty_Internal_Resource_Php extends Smarty_Internal_Resource_File
+{
+    /**
+     * Flag that it's an uncompiled resource
+     *
+     * @var bool
+     */
+    public $uncompiled = true;
+
+    /**
+     * Resource does implement populateCompiledFilepath() method
+     *
+     * @var bool
+     */
+    public $hasCompiledHandler = true;
+
+    /**
+     * container for short_open_tag directive's value before executing PHP templates
+     *
+     * @var string
+     */
+    protected $short_open_tag;
+
+    /**
+     * Create a new PHP Resource
+     */
+    public function __construct()
+    {
+        $this->short_open_tag = function_exists('ini_get') ? ini_get('short_open_tag') : 1;
+    }
+
+    /**
+     * Load template's source from file into current template object
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 template source
+     * @throws SmartyException        if source cannot be loaded
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        if ($source->exists) {
+            return '';
+        }
+        throw new SmartyException("Unable to read template {$source->type} '{$source->name}'");
+    }
+
+    /**
+     * populate compiled object with compiled filepath
+     *
+     * @param Smarty_Template_Compiled $compiled  compiled object
+     * @param Smarty_Internal_Template $_template template object (is ignored)
+     */
+    public function populateCompiledFilepath(Smarty_Template_Compiled $compiled, Smarty_Internal_Template $_template)
+    {
+        $compiled->filepath = $_template->source->filepath;
+        $compiled->timestamp = $_template->source->timestamp;
+        $compiled->exists = $_template->source->exists;
+        $compiled->file_dependency[ $_template->source->uid ] =
+            array(
+                $compiled->filepath,
+                $compiled->timestamp,
+                $_template->source->type,
+            );
+    }
+
+    /**
+     * Render and output the template (without using the compiler)
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     * @throws SmartyException          if template cannot be loaded or allow_php_templates is disabled
+     */
+    public function renderUncompiled(Smarty_Template_Source $source, Smarty_Internal_Template $_template)
+    {
+        if (!$source->smarty->allow_php_templates) {
+            throw new SmartyException('PHP templates are disabled');
+        }
+        if (!$source->exists) {
+            throw new SmartyException(
+                "Unable to load template '{$source->type}:{$source->name}'" .
+                ($_template->_isSubTpl() ? " in '{$_template->parent->template_resource}'" : '')
+            );
+        }
+        // prepare variables
+        extract($_template->getTemplateVars());
+        // include PHP template with short open tags enabled
+        if (function_exists('ini_set')) {
+            ini_set('short_open_tag', '1');
+        }
+        /**
+         *
+         *
+         * @var Smarty_Internal_Template $_smarty_template
+         * used in included file
+         */
+        $_smarty_template = $_template;
+        include $source->filepath;
+        if (function_exists('ini_set')) {
+            ini_set('short_open_tag', $this->short_open_tag);
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_resource_registered.php b/epgrec/Smarty/sysplugins/smarty_internal_resource_registered.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_resource_registered.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_resource_registered.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,101 @@
+<?php
+/**
+ * Smarty Internal Plugin Resource Registered
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Internal Plugin Resource Registered
+ * Implements the registered resource for Smarty template
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @deprecated
+ */
+class Smarty_Internal_Resource_Registered extends Smarty_Resource
+{
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        $source->filepath = $source->type . ':' . $source->name;
+        $source->uid = sha1($source->filepath . $source->smarty->_joined_template_dir);
+        $source->timestamp = $this->getTemplateTimestamp($source);
+        $source->exists = !!$source->timestamp;
+    }
+
+    /**
+     * populate Source Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return void
+     */
+    public function populateTimestamp(Smarty_Template_Source $source)
+    {
+        $source->timestamp = $this->getTemplateTimestamp($source);
+        $source->exists = !!$source->timestamp;
+    }
+
+    /**
+     * Get timestamp (epoch) the template source was modified
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return integer|boolean        timestamp (epoch) the template was modified, false if resources has no timestamp
+     */
+    public function getTemplateTimestamp(Smarty_Template_Source $source)
+    {
+        // return timestamp
+        $time_stamp = false;
+        call_user_func_array(
+            $source->smarty->registered_resources[ $source->type ][ 0 ][ 1 ],
+            array($source->name, &$time_stamp, $source->smarty)
+        );
+        return is_numeric($time_stamp) ? (int)$time_stamp : $time_stamp;
+    }
+
+    /**
+     * Load template's source by invoking the registered callback into current template object
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 template source
+     * @throws SmartyException        if source cannot be loaded
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        // return template string
+        $content = null;
+        $t = call_user_func_array(
+            $source->smarty->registered_resources[ $source->type ][ 0 ][ 0 ],
+            array($source->name, &$content, $source->smarty)
+        );
+        if (is_bool($t) && !$t) {
+            throw new SmartyException("Unable to read template {$source->type} '{$source->name}'");
+        }
+        return $content;
+    }
+
+    /**
+     * Determine basename for compiled filename
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 resource's basename
+     */
+    public function getBasename(Smarty_Template_Source $source)
+    {
+        return basename($source->name);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_resource_stream.php b/epgrec/Smarty/sysplugins/smarty_internal_resource_stream.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_resource_stream.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_resource_stream.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,78 @@
+<?php
+/**
+ * Smarty Internal Plugin Resource Stream
+ * Implements the streams as resource for Smarty template
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Internal Plugin Resource Stream
+ * Implements the streams as resource for Smarty template
+ *
+ * @link       http://php.net/streams
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+class Smarty_Internal_Resource_Stream extends Smarty_Resource_Recompiled
+{
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        if (strpos($source->resource, '://') !== false) {
+            $source->filepath = $source->resource;
+        } else {
+            $source->filepath = str_replace(':', '://', $source->resource);
+        }
+        $source->uid = false;
+        $source->content = $this->getContent($source);
+        $source->timestamp = $source->exists = !!$source->content;
+    }
+
+    /**
+     * Load template's source from stream into current template object
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string template source
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        $t = '';
+        // the availability of the stream has already been checked in Smarty_Resource::fetch()
+        $fp = fopen($source->filepath, 'r+');
+        if ($fp) {
+            while (!feof($fp) && ($current_line = fgets($fp)) !== false) {
+                $t .= $current_line;
+            }
+            fclose($fp);
+            return $t;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * modify resource_name according to resource handlers specifications
+     *
+     * @param Smarty  $smarty        Smarty instance
+     * @param string  $resource_name resource_name to make unique
+     * @param boolean $isConfig      flag for config resource
+     *
+     * @return string unique resource name
+     */
+    public function buildUniqueResourceName(Smarty $smarty, $resource_name, $isConfig = false)
+    {
+        return get_class($this) . '#' . $resource_name;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_resource_string.php b/epgrec/Smarty/sysplugins/smarty_internal_resource_string.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_resource_string.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_resource_string.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,108 @@
+<?php
+/**
+ * Smarty Internal Plugin Resource String
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Internal Plugin Resource String
+ * Implements the strings as resource for Smarty template
+ * {@internal unlike eval-resources the compiled state of string-resources is saved for subsequent access}}
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+class Smarty_Internal_Resource_String extends Smarty_Resource
+{
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        $source->uid = $source->filepath = sha1($source->name . $source->smarty->_joined_template_dir);
+        $source->timestamp = $source->exists = true;
+    }
+
+    /**
+     * Load template's source from $resource_name into current template object
+     *
+     * @uses decode() to decode base64 and urlencoded template_resources
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 template source
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        return $this->decode($source->name);
+    }
+
+    /**
+     * decode base64 and urlencode
+     *
+     * @param string $string template_resource to decode
+     *
+     * @return string decoded template_resource
+     */
+    protected function decode($string)
+    {
+        // decode if specified
+        if (($pos = strpos($string, ':')) !== false) {
+            if (!strncmp($string, 'base64', 6)) {
+                return base64_decode(substr($string, 7));
+            } elseif (!strncmp($string, 'urlencode', 9)) {
+                return urldecode(substr($string, 10));
+            }
+        }
+        return $string;
+    }
+
+    /**
+     * modify resource_name according to resource handlers specifications
+     *
+     * @param Smarty  $smarty        Smarty instance
+     * @param string  $resource_name resource_name to make unique
+     * @param boolean $isConfig      flag for config resource
+     *
+     * @return string unique resource name
+     */
+    public function buildUniqueResourceName(Smarty $smarty, $resource_name, $isConfig = false)
+    {
+        return get_class($this) . '#' . $this->decode($resource_name);
+    }
+
+    /**
+     * Determine basename for compiled filename
+     * Always returns an empty string.
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 resource's basename
+     */
+    public function getBasename(Smarty_Template_Source $source)
+    {
+        return '';
+    }
+
+    /*
+        * Disable timestamp checks for string resource.
+        *
+        * @return bool
+        */
+    /**
+     * @return bool
+     */
+    public function checkTimestamps()
+    {
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_cachemodify.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_cachemodify.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_cachemodify.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_cachemodify.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,68 @@
+<?php
+
+/**
+ * Inline Runtime Methods render, setSourceByUid, setupSubTemplate
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ **/
+class Smarty_Internal_Runtime_CacheModify
+{
+    /**
+     * check client side cache
+     *
+     * @param \Smarty_Template_Cached   $cached
+     * @param \Smarty_Internal_Template $_template
+     * @param string                    $content
+     *
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function cacheModifiedCheck(Smarty_Template_Cached $cached, Smarty_Internal_Template $_template, $content)
+    {
+        $_isCached = $_template->isCached() && !$_template->compiled->has_nocache_code;
+        $_last_modified_date =
+            @substr($_SERVER[ 'HTTP_IF_MODIFIED_SINCE' ], 0, strpos($_SERVER[ 'HTTP_IF_MODIFIED_SINCE' ], 'GMT') + 3);
+        if ($_isCached && $cached->timestamp <= strtotime($_last_modified_date)) {
+            switch (PHP_SAPI) {
+                case 'cgi': // php-cgi < 5.3
+                case 'cgi-fcgi': // php-cgi >= 5.3
+                case 'fpm-fcgi': // php-fpm >= 5.3.3
+                    header('Status: 304 Not Modified');
+                    break;
+                case 'cli':
+                    if (/* ^phpunit */
+                    !empty($_SERVER[ 'SMARTY_PHPUNIT_DISABLE_HEADERS' ]) /* phpunit$ */
+                    ) {
+                        $_SERVER[ 'SMARTY_PHPUNIT_HEADERS' ][] = '304 Not Modified';
+                    }
+                    break;
+                default:
+                    if (/* ^phpunit */
+                    !empty($_SERVER[ 'SMARTY_PHPUNIT_DISABLE_HEADERS' ]) /* phpunit$ */
+                    ) {
+                        $_SERVER[ 'SMARTY_PHPUNIT_HEADERS' ][] = '304 Not Modified';
+                    } else {
+                        header($_SERVER[ 'SERVER_PROTOCOL' ] . ' 304 Not Modified');
+                    }
+                    break;
+            }
+        } else {
+            switch (PHP_SAPI) {
+                case 'cli':
+                    if (/* ^phpunit */
+                    !empty($_SERVER[ 'SMARTY_PHPUNIT_DISABLE_HEADERS' ]) /* phpunit$ */
+                    ) {
+                        $_SERVER[ 'SMARTY_PHPUNIT_HEADERS' ][] =
+                            'Last-Modified: ' . gmdate('D, d M Y H:i:s', $cached->timestamp) . ' GMT';
+                    }
+                    break;
+                default:
+                    header('Last-Modified: ' . gmdate('D, d M Y H:i:s', $cached->timestamp) . ' GMT');
+                    break;
+            }
+            echo $content;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_cacheresourcefile.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_cacheresourcefile.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_cacheresourcefile.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_cacheresourcefile.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,139 @@
+<?php
+/**
+ * Smarty cache resource file clear method
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Internal Runtime Cache Resource File Class
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ */
+class Smarty_Internal_Runtime_CacheResourceFile
+{
+    /**
+     * Empty cache for a specific template
+     *
+     * @param Smarty  $smarty
+     * @param string  $resource_name template name
+     * @param string  $cache_id      cache id
+     * @param string  $compile_id    compile id
+     * @param integer $exp_time      expiration time (number of seconds, not timestamp)
+     *
+     * @return integer number of cache files deleted
+     */
+    public function clear(Smarty $smarty, $resource_name, $cache_id, $compile_id, $exp_time)
+    {
+        $_cache_id = isset($cache_id) ? preg_replace('![^\w\|]+!', '_', $cache_id) : null;
+        $_compile_id = isset($compile_id) ? preg_replace('![^\w]+!', '_', $compile_id) : null;
+        $_dir_sep = $smarty->use_sub_dirs ? '/' : '^';
+        $_compile_id_offset = $smarty->use_sub_dirs ? 3 : 0;
+        $_dir = $smarty->getCacheDir();
+        if ($_dir === '/') { //We should never want to delete this!
+            return 0;
+        }
+        $_dir_length = strlen($_dir);
+        if (isset($_cache_id)) {
+            $_cache_id_parts = explode('|', $_cache_id);
+            $_cache_id_parts_count = count($_cache_id_parts);
+            if ($smarty->use_sub_dirs) {
+                foreach ($_cache_id_parts as $id_part) {
+                    $_dir .= $id_part . '/';
+                }
+            }
+        }
+        if (isset($resource_name)) {
+            $_save_stat = $smarty->caching;
+            $smarty->caching = Smarty::CACHING_LIFETIME_CURRENT;
+            $tpl = new $smarty->template_class($resource_name, $smarty);
+            $smarty->caching = $_save_stat;
+            // remove from template cache
+            $tpl->source; // have the template registered before unset()
+            if ($tpl->source->exists) {
+                $_resourcename_parts = basename(str_replace('^', '/', $tpl->cached->filepath));
+            } else {
+                return 0;
+            }
+        }
+        $_count = 0;
+        $_time = time();
+        if (file_exists($_dir)) {
+            $_cacheDirs = new RecursiveDirectoryIterator($_dir);
+            $_cache = new RecursiveIteratorIterator($_cacheDirs, RecursiveIteratorIterator::CHILD_FIRST);
+            foreach ($_cache as $_file) {
+                if (substr(basename($_file->getPathname()), 0, 1) === '.') {
+                    continue;
+                }
+                $_filepath = (string)$_file;
+                // directory ?
+                if ($_file->isDir()) {
+                    if (!$_cache->isDot()) {
+                        // delete folder if empty
+                        @rmdir($_file->getPathname());
+                    }
+                } else {
+                    // delete only php files
+                    if (substr($_filepath, -4) !== '.php') {
+                        continue;
+                    }
+                    $_parts = explode($_dir_sep, str_replace('\\', '/', substr($_filepath, $_dir_length)));
+                    $_parts_count = count($_parts);
+                    // check name
+                    if (isset($resource_name)) {
+                        if ($_parts[ $_parts_count - 1 ] !== $_resourcename_parts) {
+                            continue;
+                        }
+                    }
+                    // check compile id
+                    if (isset($_compile_id) && (!isset($_parts[ $_parts_count - 2 - $_compile_id_offset ])
+                                                || $_parts[ $_parts_count - 2 - $_compile_id_offset ] !== $_compile_id)
+                    ) {
+                        continue;
+                    }
+                    // check cache id
+                    if (isset($_cache_id)) {
+                        // count of cache id parts
+                        $_parts_count = (isset($_compile_id)) ? $_parts_count - 2 - $_compile_id_offset :
+                            $_parts_count - 1 - $_compile_id_offset;
+                        if ($_parts_count < $_cache_id_parts_count) {
+                            continue;
+                        }
+                        for ($i = 0; $i < $_cache_id_parts_count; $i++) {
+                            if ($_parts[ $i ] !== $_cache_id_parts[ $i ]) {
+                                continue 2;
+                            }
+                        }
+                    }
+                    if (is_file($_filepath)) {
+                        // expired ?
+                        if (isset($exp_time)) {
+                            if ($exp_time < 0) {
+                                preg_match('#\'cache_lifetime\' =>\s*(\d*)#', file_get_contents($_filepath), $match);
+                                if ($_time < (filemtime($_filepath) + $match[ 1 ])) {
+                                    continue;
+                                }
+                            } else {
+                                if ($_time - filemtime($_filepath) < $exp_time) {
+                                    continue;
+                                }
+                            }
+                        }
+                        $_count += @unlink($_filepath) ? 1 : 0;
+                        if (function_exists('opcache_invalidate')
+                            && (!function_exists('ini_get') || strlen(ini_get("opcache.restrict_api")) < 1)
+                        ) {
+                            opcache_invalidate($_filepath, true);
+                        } elseif (function_exists('apc_delete_file')) {
+                            apc_delete_file($_filepath);
+                        }
+                    }
+                }
+            }
+        }
+        return $_count;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_capture.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_capture.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_capture.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_capture.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,174 @@
+<?php
+
+/**
+ * Runtime Extension Capture
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Runtime_Capture
+{
+    /**
+     * Flag that this instance  will not be cached
+     *
+     * @var bool
+     */
+    public $isPrivateExtension = true;
+
+    /**
+     * Stack of capture parameter
+     *
+     * @var array
+     */
+    private $captureStack = array();
+
+    /**
+     * Current open capture sections
+     *
+     * @var int
+     */
+    private $captureCount = 0;
+
+    /**
+     * Count stack
+     *
+     * @var int[]
+     */
+    private $countStack = array();
+
+    /**
+     * Named buffer
+     *
+     * @var string[]
+     */
+    private $namedBuffer = array();
+
+    /**
+     * Flag if callbacks are registered
+     *
+     * @var bool
+     */
+    private $isRegistered = false;
+
+    /**
+     * Open capture section
+     *
+     * @param \Smarty_Internal_Template $_template
+     * @param string                    $buffer capture name
+     * @param string                    $assign variable name
+     * @param string                    $append variable name
+     */
+    public function open(Smarty_Internal_Template $_template, $buffer, $assign, $append)
+    {
+        if (!$this->isRegistered) {
+            $this->register($_template);
+        }
+        $this->captureStack[] = array(
+            $buffer,
+            $assign,
+            $append
+        );
+        $this->captureCount++;
+        ob_start();
+    }
+
+    /**
+     * Register callbacks in template class
+     *
+     * @param \Smarty_Internal_Template $_template
+     */
+    private function register(Smarty_Internal_Template $_template)
+    {
+        $_template->startRenderCallbacks[] = array(
+            $this,
+            'startRender'
+        );
+        $_template->endRenderCallbacks[] = array(
+            $this,
+            'endRender'
+        );
+        $this->startRender($_template);
+        $this->isRegistered = true;
+    }
+
+    /**
+     * Start render callback
+     *
+     * @param \Smarty_Internal_Template $_template
+     */
+    public function startRender(Smarty_Internal_Template $_template)
+    {
+        $this->countStack[] = $this->captureCount;
+        $this->captureCount = 0;
+    }
+
+    /**
+     * Close capture section
+     *
+     * @param \Smarty_Internal_Template $_template
+     *
+     * @throws \SmartyException
+     */
+    public function close(Smarty_Internal_Template $_template)
+    {
+        if ($this->captureCount) {
+            list($buffer, $assign, $append) = array_pop($this->captureStack);
+            $this->captureCount--;
+            if (isset($assign)) {
+                $_template->assign($assign, ob_get_contents());
+            }
+            if (isset($append)) {
+                $_template->append($append, ob_get_contents());
+            }
+            $this->namedBuffer[ $buffer ] = ob_get_clean();
+        } else {
+            $this->error($_template);
+        }
+    }
+
+    /**
+     * Error exception on not matching {capture}{/capture}
+     *
+     * @param \Smarty_Internal_Template $_template
+     *
+     * @throws \SmartyException
+     */
+    public function error(Smarty_Internal_Template $_template)
+    {
+        throw new SmartyException("Not matching {capture}{/capture} in '{$_template->template_resource}'");
+    }
+
+    /**
+     * Return content of named capture buffer by key or as array
+     *
+     * @param \Smarty_Internal_Template $_template
+     * @param string|null               $name
+     *
+     * @return string|string[]|null
+     */
+    public function getBuffer(Smarty_Internal_Template $_template, $name = null)
+    {
+        if (isset($name)) {
+            return isset($this->namedBuffer[ $name ]) ? $this->namedBuffer[ $name ] : null;
+        } else {
+            return $this->namedBuffer;
+        }
+    }
+
+    /**
+     * End render callback
+     *
+     * @param \Smarty_Internal_Template $_template
+     *
+     * @throws \SmartyException
+     */
+    public function endRender(Smarty_Internal_Template $_template)
+    {
+        if ($this->captureCount) {
+            $this->error($_template);
+        } else {
+            $this->captureCount = array_pop($this->countStack);
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_codeframe.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_codeframe.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_codeframe.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_codeframe.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,103 @@
+<?php
+/**
+ * Smarty Internal Extension
+ * This file contains the Smarty template extension to create a code frame
+ *
+ * @package    Smarty
+ * @subpackage Template
+ * @author     Uwe Tews
+ */
+
+/**
+ * Class Smarty_Internal_Extension_CodeFrame
+ * Create code frame for compiled and cached templates
+ */
+class Smarty_Internal_Runtime_CodeFrame
+{
+    /**
+     * Create code frame for compiled and cached templates
+     *
+     * @param Smarty_Internal_Template              $_template
+     * @param string                                $content   optional template content
+     * @param string                                $functions compiled template function and block code
+     * @param bool                                  $cache     flag for cache file
+     * @param \Smarty_Internal_TemplateCompilerBase $compiler
+     *
+     * @return string
+     */
+    public function create(
+        Smarty_Internal_Template $_template,
+        $content = '',
+        $functions = '',
+        $cache = false,
+        Smarty_Internal_TemplateCompilerBase $compiler = null
+    ) {
+        // build property code
+        $properties[ 'version' ] = Smarty::SMARTY_VERSION;
+        $properties[ 'unifunc' ] = 'content_' . str_replace(array('.', ','), '_', uniqid('', true));
+        if (!$cache) {
+            $properties[ 'has_nocache_code' ] = $_template->compiled->has_nocache_code;
+            $properties[ 'file_dependency' ] = $_template->compiled->file_dependency;
+            $properties[ 'includes' ] = $_template->compiled->includes;
+        } else {
+            $properties[ 'has_nocache_code' ] = $_template->cached->has_nocache_code;
+            $properties[ 'file_dependency' ] = $_template->cached->file_dependency;
+            $properties[ 'cache_lifetime' ] = $_template->cache_lifetime;
+        }
+        $output = sprintf(
+            "<?php\n/* Smarty version %s, created on %s\n  from '%s' */\n\n",
+            $properties[ 'version' ],
+            date("Y-m-d H:i:s"),
+            str_replace('*/', '* /', $_template->source->filepath)
+        );
+        $output .= "/* @var Smarty_Internal_Template \$_smarty_tpl */\n";
+        $dec = "\$_smarty_tpl->_decodeProperties(\$_smarty_tpl, " . var_export($properties, true) . ',' .
+               ($cache ? 'true' : 'false') . ')';
+        $output .= "if ({$dec}) {\n";
+        $output .= "function {$properties['unifunc']} (Smarty_Internal_Template \$_smarty_tpl) {\n";
+        if (!$cache && !empty($compiler->tpl_function)) {
+            $output .= '$_smarty_tpl->smarty->ext->_tplFunction->registerTplFunctions($_smarty_tpl, ';
+            $output .= var_export($compiler->tpl_function, true);
+            $output .= ");\n";
+        }
+        if ($cache && isset($_template->smarty->ext->_tplFunction)) {
+            $output .= "\$_smarty_tpl->smarty->ext->_tplFunction->registerTplFunctions(\$_smarty_tpl, " .
+                       var_export($_template->smarty->ext->_tplFunction->getTplFunction($_template), true) . ");\n";
+        }
+        $output .= "?>";
+        $output .= $content;
+        $output .= "<?php }\n?>";
+        $output .= $functions;
+        $output .= "<?php }\n";
+        // remove unneeded PHP tags
+        if (preg_match('/\s*\?>[\n]?<\?php\s*/', $output)) {
+            $curr_split = preg_split(
+                '/\s*\?>[\n]?<\?php\s*/',
+                $output
+            );
+            preg_match_all(
+                '/\s*\?>[\n]?<\?php\s*/',
+                $output,
+                $curr_parts
+            );
+            $output = '';
+            foreach ($curr_split as $idx => $curr_output) {
+                $output .= $curr_output;
+                if (isset($curr_parts[ 0 ][ $idx ])) {
+                    $output .= "\n";
+                }
+            }
+        }
+        if (preg_match('/\?>\s*$/', $output)) {
+            $curr_split = preg_split(
+                '/\?>\s*$/',
+                $output
+            );
+            $output = '';
+            foreach ($curr_split as $idx => $curr_output) {
+                $output .= $curr_output;
+            }
+        }
+        return $output;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_filterhandler.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_filterhandler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_filterhandler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_filterhandler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,69 @@
+<?php
+/**
+ * Smarty Internal Plugin Filter Handler
+ * Smarty filter handler class
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+
+/**
+ * Class for filter processing
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ */
+class Smarty_Internal_Runtime_FilterHandler
+{
+    /**
+     * Run filters over content
+     * The filters will be lazy loaded if required
+     * class name format: Smarty_FilterType_FilterName
+     * plugin filename format: filtertype.filtername.php
+     * Smarty2 filter plugins could be used
+     *
+     * @param string                   $type     the type of filter ('pre','post','output') which shall run
+     * @param string                   $content  the content which shall be processed by the filters
+     * @param Smarty_Internal_Template $template template object
+     *
+     * @throws SmartyException
+     * @return string                   the filtered content
+     */
+    public function runFilter($type, $content, Smarty_Internal_Template $template)
+    {
+        // loop over autoload filters of specified type
+        if (!empty($template->smarty->autoload_filters[ $type ])) {
+            foreach ((array)$template->smarty->autoload_filters[ $type ] as $name) {
+                $plugin_name = "Smarty_{$type}filter_{$name}";
+                if (function_exists($plugin_name)) {
+                    $callback = $plugin_name;
+                } elseif (class_exists($plugin_name, false) && is_callable(array($plugin_name, 'execute'))) {
+                    $callback = array($plugin_name, 'execute');
+                } elseif ($template->smarty->loadPlugin($plugin_name, false)) {
+                    if (function_exists($plugin_name)) {
+                        // use loaded Smarty2 style plugin
+                        $callback = $plugin_name;
+                    } elseif (class_exists($plugin_name, false) && is_callable(array($plugin_name, 'execute'))) {
+                        // loaded class of filter plugin
+                        $callback = array($plugin_name, 'execute');
+                    } else {
+                        throw new SmartyException("Auto load {$type}-filter plugin method '{$plugin_name}::execute' not callable");
+                    }
+                } else {
+                    // nothing found, throw exception
+                    throw new SmartyException("Unable to auto load {$type}-filter plugin '{$plugin_name}'");
+                }
+                $content = call_user_func($callback, $content, $template);
+            }
+        }
+        // loop over registered filters of specified type
+        if (!empty($template->smarty->registered_filters[ $type ])) {
+            foreach ($template->smarty->registered_filters[ $type ] as $key => $name) {
+                $content = call_user_func($template->smarty->registered_filters[ $type ][ $key ], $content, $template);
+            }
+        }
+        // return filtered output
+        return $content;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_foreach.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_foreach.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_foreach.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_foreach.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,162 @@
+<?php
+
+/**
+ * Foreach Runtime Methods count(), init(), restore()
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Runtime_Foreach
+{
+    /**
+     * Stack of saved variables
+     *
+     * @var array
+     */
+    private $stack = array();
+
+    /**
+     * Init foreach loop
+     *  - save item and key variables, named foreach property data if defined
+     *  - init item and key variables, named foreach property data if required
+     *  - count total if required
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param mixed                     $from       values to loop over
+     * @param string                    $item       variable name
+     * @param bool                      $needTotal  flag if we need to count values
+     * @param null|string               $key        variable name
+     * @param null|string               $name       of named foreach
+     * @param array                     $properties of named foreach
+     *
+     * @return mixed $from
+     */
+    public function init(
+        Smarty_Internal_Template $tpl,
+        $from,
+        $item,
+        $needTotal = false,
+        $key = null,
+        $name = null,
+        $properties = array()
+    ) {
+        $needTotal = $needTotal || isset($properties[ 'total' ]);
+        $saveVars = array();
+        $total = null;
+        if (!is_array($from)) {
+            if (is_object($from)) {
+                if ($needTotal) {
+                    $total = $this->count($from);
+                }
+            } else {
+                settype($from, 'array');
+            }
+        }
+        if (!isset($total)) {
+            $total = empty($from) ? 0 : ($needTotal ? count($from) : 1);
+        }
+        if (isset($tpl->tpl_vars[ $item ])) {
+            $saveVars[ 'item' ] = array(
+                $item,
+                $tpl->tpl_vars[ $item ]
+            );
+        }
+        $tpl->tpl_vars[ $item ] = new Smarty_Variable(null, $tpl->isRenderingCache);
+        if ($total === 0) {
+            $from = null;
+        } else {
+            if ($key) {
+                if (isset($tpl->tpl_vars[ $key ])) {
+                    $saveVars[ 'key' ] = array(
+                        $key,
+                        $tpl->tpl_vars[ $key ]
+                    );
+                }
+                $tpl->tpl_vars[ $key ] = new Smarty_Variable(null, $tpl->isRenderingCache);
+            }
+        }
+        if ($needTotal) {
+            $tpl->tpl_vars[ $item ]->total = $total;
+        }
+        if ($name) {
+            $namedVar = "__smarty_foreach_{$name}";
+            if (isset($tpl->tpl_vars[ $namedVar ])) {
+                $saveVars[ 'named' ] = array(
+                    $namedVar,
+                    $tpl->tpl_vars[ $namedVar ]
+                );
+            }
+            $namedProp = array();
+            if (isset($properties[ 'total' ])) {
+                $namedProp[ 'total' ] = $total;
+            }
+            if (isset($properties[ 'iteration' ])) {
+                $namedProp[ 'iteration' ] = 0;
+            }
+            if (isset($properties[ 'index' ])) {
+                $namedProp[ 'index' ] = -1;
+            }
+            if (isset($properties[ 'show' ])) {
+                $namedProp[ 'show' ] = ($total > 0);
+            }
+            $tpl->tpl_vars[ $namedVar ] = new Smarty_Variable($namedProp);
+        }
+        $this->stack[] = $saveVars;
+        return $from;
+    }
+
+    /**
+     * [util function] counts an array, arrayAccess/traversable or PDOStatement object
+     *
+     * @param mixed $value
+     *
+     * @return int   the count for arrays and objects that implement countable, 1 for other objects that don't, and 0
+     *               for empty elements
+     */
+    public function count($value)
+    {
+        if ($value instanceof IteratorAggregate) {
+            // Note: getIterator() returns a Traversable, not an Iterator
+            // thus rewind() and valid() methods may not be present
+            return iterator_count($value->getIterator());
+        } elseif ($value instanceof Iterator) {
+            return $value instanceof Generator ? 1 : iterator_count($value);
+        } elseif ($value instanceof Countable) {
+            return count($value);
+        } elseif ($value instanceof PDOStatement) {
+            return $value->rowCount();
+        } elseif ($value instanceof Traversable) {
+            return iterator_count($value);
+        }
+        return count((array)$value);
+    }
+
+    /**
+     * Restore saved variables
+     *
+     * will be called by {break n} or {continue n} for the required number of levels
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param int                       $levels number of levels
+     */
+    public function restore(Smarty_Internal_Template $tpl, $levels = 1)
+    {
+        while ($levels) {
+            $saveVars = array_pop($this->stack);
+            if (!empty($saveVars)) {
+                if (isset($saveVars[ 'item' ])) {
+                    $item = &$saveVars[ 'item' ];
+                    $tpl->tpl_vars[ $item[ 0 ] ]->value = $item[ 1 ]->value;
+                }
+                if (isset($saveVars[ 'key' ])) {
+                    $tpl->tpl_vars[ $saveVars[ 'key' ][ 0 ] ] = $saveVars[ 'key' ][ 1 ];
+                }
+                if (isset($saveVars[ 'named' ])) {
+                    $tpl->tpl_vars[ $saveVars[ 'named' ][ 0 ] ] = $saveVars[ 'named' ][ 1 ];
+                }
+            }
+            $levels--;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_getincludepath.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_getincludepath.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_getincludepath.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_getincludepath.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,181 @@
+<?php
+/**
+ * Smarty read include path plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Monte Ohrt
+ */
+
+/**
+ * Smarty Internal Read Include Path Class
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ */
+class Smarty_Internal_Runtime_GetIncludePath
+{
+    /**
+     * include path cache
+     *
+     * @var string
+     */
+    public $_include_path = '';
+
+    /**
+     * include path directory cache
+     *
+     * @var array
+     */
+    public $_include_dirs = array();
+
+    /**
+     * include path directory cache
+     *
+     * @var array
+     */
+    public $_user_dirs = array();
+
+    /**
+     * stream cache
+     *
+     * @var string[][]
+     */
+    public $isFile = array();
+
+    /**
+     * stream cache
+     *
+     * @var string[]
+     */
+    public $isPath = array();
+
+    /**
+     * stream cache
+     *
+     * @var int[]
+     */
+    public $number = array();
+
+    /**
+     * status cache
+     *
+     * @var bool
+     */
+    public $_has_stream_include = null;
+
+    /**
+     * Number for array index
+     *
+     * @var int
+     */
+    public $counter = 0;
+
+    /**
+     * Check if include path was updated
+     *
+     * @param \Smarty $smarty
+     *
+     * @return bool
+     */
+    public function isNewIncludePath(Smarty $smarty)
+    {
+        $_i_path = get_include_path();
+        if ($this->_include_path !== $_i_path) {
+            $this->_include_dirs = array();
+            $this->_include_path = $_i_path;
+            $_dirs = (array)explode(PATH_SEPARATOR, $_i_path);
+            foreach ($_dirs as $_path) {
+                if (is_dir($_path)) {
+                    $this->_include_dirs[] = $smarty->_realpath($_path . DIRECTORY_SEPARATOR, true);
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * return array with include path directories
+     *
+     * @param \Smarty $smarty
+     *
+     * @return array
+     */
+    public function getIncludePathDirs(Smarty $smarty)
+    {
+        $this->isNewIncludePath($smarty);
+        return $this->_include_dirs;
+    }
+
+    /**
+     * Return full file path from PHP include_path
+     *
+     * @param string[] $dirs
+     * @param string   $file
+     * @param \Smarty  $smarty
+     *
+     * @return bool|string full filepath or false
+     */
+    public function getIncludePath($dirs, $file, Smarty $smarty)
+    {
+        //if (!(isset($this->_has_stream_include) ? $this->_has_stream_include : $this->_has_stream_include = false)) {
+        if (!(isset($this->_has_stream_include) ? $this->_has_stream_include :
+            $this->_has_stream_include = function_exists('stream_resolve_include_path'))
+        ) {
+            $this->isNewIncludePath($smarty);
+        }
+        // try PHP include_path
+        foreach ($dirs as $dir) {
+            $dir_n = isset($this->number[ $dir ]) ? $this->number[ $dir ] : $this->number[ $dir ] = $this->counter++;
+            if (isset($this->isFile[ $dir_n ][ $file ])) {
+                if ($this->isFile[ $dir_n ][ $file ]) {
+                    return $this->isFile[ $dir_n ][ $file ];
+                } else {
+                    continue;
+                }
+            }
+            if (isset($this->_user_dirs[ $dir_n ])) {
+                if (false === $this->_user_dirs[ $dir_n ]) {
+                    continue;
+                } else {
+                    $dir = $this->_user_dirs[ $dir_n ];
+                }
+            } else {
+                if ($dir[ 0 ] === '/' || $dir[ 1 ] === ':') {
+                    $dir = str_ireplace(getcwd(), '.', $dir);
+                    if ($dir[ 0 ] === '/' || $dir[ 1 ] === ':') {
+                        $this->_user_dirs[ $dir_n ] = false;
+                        continue;
+                    }
+                }
+                $dir = substr($dir, 2);
+                $this->_user_dirs[ $dir_n ] = $dir;
+            }
+            if ($this->_has_stream_include) {
+                $path = stream_resolve_include_path($dir . (isset($file) ? $file : ''));
+                if ($path) {
+                    return $this->isFile[ $dir_n ][ $file ] = $path;
+                }
+            } else {
+                foreach ($this->_include_dirs as $key => $_i_path) {
+                    $path = isset($this->isPath[ $key ][ $dir_n ]) ? $this->isPath[ $key ][ $dir_n ] :
+                        $this->isPath[ $key ][ $dir_n ] = is_dir($_dir_path = $_i_path . $dir) ? $_dir_path : false;
+                    if ($path === false) {
+                        continue;
+                    }
+                    if (isset($file)) {
+                        $_file = $this->isFile[ $dir_n ][ $file ] = (is_file($path . $file)) ? $path . $file : false;
+                        if ($_file) {
+                            return $_file;
+                        }
+                    } else {
+                        // no file was given return directory path
+                        return $path;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_inheritance.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_inheritance.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_inheritance.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_inheritance.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,251 @@
+<?php
+
+/**
+ * Inheritance Runtime Methods processBlock, endChild, init
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ **/
+class Smarty_Internal_Runtime_Inheritance
+{
+    /**
+     * State machine
+     * - 0 idle next extends will create a new inheritance tree
+     * - 1 processing child template
+     * - 2 wait for next inheritance template
+     * - 3 assume parent template, if child will loaded goto state 1
+     *     a call to a sub template resets the state to 0
+     *
+     * @var int
+     */
+    public $state = 0;
+
+    /**
+     * Array of root child {block} objects
+     *
+     * @var Smarty_Internal_Block[]
+     */
+    public $childRoot = array();
+
+    /**
+     * inheritance template nesting level
+     *
+     * @var int
+     */
+    public $inheritanceLevel = 0;
+
+    /**
+     * inheritance template index
+     *
+     * @var int
+     */
+    public $tplIndex = -1;
+
+    /**
+     * Array of template source objects
+     *
+     * @var Smarty_Template_Source[]
+     */
+    public $sources = array();
+
+    /**
+     * Stack of source objects while executing block code
+     *
+     * @var Smarty_Template_Source[]
+     */
+    public $sourceStack = array();
+
+    /**
+     * Initialize inheritance
+     *
+     * @param \Smarty_Internal_Template $tpl        template object of caller
+     * @param bool                      $initChild  if true init for child template
+     * @param array                     $blockNames outer level block name
+     */
+    public function init(Smarty_Internal_Template $tpl, $initChild, $blockNames = array())
+    {
+        // if called while executing parent template it must be a sub-template with new inheritance root
+        if ($initChild && $this->state === 3 && (strpos($tpl->template_resource, 'extendsall') === false)) {
+            $tpl->inheritance = new Smarty_Internal_Runtime_Inheritance();
+            $tpl->inheritance->init($tpl, $initChild, $blockNames);
+            return;
+        }
+        ++$this->tplIndex;
+        $this->sources[ $this->tplIndex ] = $tpl->source;
+        // start of child sub template(s)
+        if ($initChild) {
+            $this->state = 1;
+            if (!$this->inheritanceLevel) {
+                //grab any output of child templates
+                ob_start();
+            }
+            ++$this->inheritanceLevel;
+            //           $tpl->startRenderCallbacks[ 'inheritance' ] = array($this, 'subTemplateStart');
+            //           $tpl->endRenderCallbacks[ 'inheritance' ] = array($this, 'subTemplateEnd');
+        }
+        // if state was waiting for parent change state to parent
+        if ($this->state === 2) {
+            $this->state = 3;
+        }
+    }
+
+    /**
+     * End of child template(s)
+     * - if outer level is reached flush output buffer and switch to wait for parent template state
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param null|string               $template optional name of inheritance parent template
+     * @param null|string               $uid      uid of inline template
+     * @param null|string               $func     function call name of inline template
+     *
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function endChild(Smarty_Internal_Template $tpl, $template = null, $uid = null, $func = null)
+    {
+        --$this->inheritanceLevel;
+        if (!$this->inheritanceLevel) {
+            ob_end_clean();
+            $this->state = 2;
+        }
+        if (isset($template) && (($tpl->parent->_isTplObj() && $tpl->parent->source->type !== 'extends')
+                                 || $tpl->smarty->extends_recursion)
+        ) {
+            $tpl->_subTemplateRender(
+                $template,
+                $tpl->cache_id,
+                $tpl->compile_id,
+                $tpl->caching ? 9999 : 0,
+                $tpl->cache_lifetime,
+                array(),
+                2,
+                false,
+                $uid,
+                $func
+            );
+        }
+    }
+
+    /**
+     * Smarty_Internal_Block constructor.
+     * - if outer level {block} of child template ($state === 1) save it as child root block
+     * - otherwise process inheritance and render
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param                           $className
+     * @param string                    $name
+     * @param int|null                  $tplIndex index of outer level {block} if nested
+     *
+     * @throws \SmartyException
+     */
+    public function instanceBlock(Smarty_Internal_Template $tpl, $className, $name, $tplIndex = null)
+    {
+        $block = new $className($name, isset($tplIndex) ? $tplIndex : $this->tplIndex);
+        if (isset($this->childRoot[ $name ])) {
+            $block->child = $this->childRoot[ $name ];
+        }
+        if ($this->state === 1) {
+            $this->childRoot[ $name ] = $block;
+            return;
+        }
+        // make sure we got child block of child template of current block
+        while ($block->child && $block->child->child && $block->tplIndex <= $block->child->tplIndex) {
+            $block->child = $block->child->child;
+        }
+        $this->process($tpl, $block);
+    }
+
+    /**
+     * Goto child block or render this
+     *
+     * @param \Smarty_Internal_Template   $tpl
+     * @param \Smarty_Internal_Block      $block
+     * @param \Smarty_Internal_Block|null $parent
+     *
+     * @throws \SmartyException
+     */
+    public function process(
+        Smarty_Internal_Template $tpl,
+        Smarty_Internal_Block $block,
+        Smarty_Internal_Block $parent = null
+    ) {
+        if ($block->hide && !isset($block->child)) {
+            return;
+        }
+        if (isset($block->child) && $block->child->hide && !isset($block->child->child)) {
+            $block->child = null;
+        }
+        $block->parent = $parent;
+        if ($block->append && !$block->prepend && isset($parent)) {
+            $this->callParent($tpl, $block, '\'{block append}\'');
+        }
+        if ($block->callsChild || !isset($block->child) || ($block->child->hide && !isset($block->child->child))) {
+            $this->callBlock($block, $tpl);
+        } else {
+            $this->process($tpl, $block->child, $block);
+        }
+        if ($block->prepend && isset($parent)) {
+            $this->callParent($tpl, $block, '{block prepend}');
+            if ($block->append) {
+                if ($block->callsChild || !isset($block->child)
+                    || ($block->child->hide && !isset($block->child->child))
+                ) {
+                    $this->callBlock($block, $tpl);
+                } else {
+                    $this->process($tpl, $block->child, $block);
+                }
+            }
+        }
+        $block->parent = null;
+    }
+
+    /**
+     * Render child on \$smarty.block.child
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param \Smarty_Internal_Block    $block
+     *
+     * @return null|string block content
+     * @throws \SmartyException
+     */
+    public function callChild(Smarty_Internal_Template $tpl, Smarty_Internal_Block $block)
+    {
+        if (isset($block->child)) {
+            $this->process($tpl, $block->child, $block);
+        }
+    }
+
+    /**
+     * Render parent block on \$smarty.block.parent or {block append/prepend}
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param \Smarty_Internal_Block    $block
+     * @param string                    $tag
+     *
+     * @return null|string  block content
+     * @throws \SmartyException
+     */
+    public function callParent(Smarty_Internal_Template $tpl, Smarty_Internal_Block $block, $tag)
+    {
+        if (isset($block->parent)) {
+            $this->callBlock($block->parent, $tpl);
+        } else {
+            throw new SmartyException("inheritance: illegal '{$tag}' used in child template '{$tpl->inheritance->sources[$block->tplIndex]->filepath}' block '{$block->name}'");
+        }
+    }
+
+    /**
+     * render block
+     *
+     * @param \Smarty_Internal_Block    $block
+     * @param \Smarty_Internal_Template $tpl
+     */
+    public function callBlock(Smarty_Internal_Block $block, Smarty_Internal_Template $tpl)
+    {
+        $this->sourceStack[] = $tpl->source;
+        $tpl->source = $this->sources[ $block->tplIndex ];
+        $block->callBlock($tpl);
+        $tpl->source = array_pop($this->sourceStack);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_make_nocache.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_make_nocache.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_make_nocache.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_make_nocache.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,54 @@
+<?php
+
+/**
+ * {make_nocache} Runtime Methods save(), store()
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Runtime_Make_Nocache
+{
+    /**
+     * Save current variable value while rendering compiled template and inject nocache code to
+     * assign variable value in cahed template
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param string                    $var variable name
+     *
+     * @throws \SmartyException
+     */
+    public function save(Smarty_Internal_Template $tpl, $var)
+    {
+        if (isset($tpl->tpl_vars[ $var ])) {
+            $export =
+                preg_replace('/^Smarty_Variable::__set_state[(]|[)]$/', '', var_export($tpl->tpl_vars[ $var ], true));
+            if (preg_match('/(\w+)::__set_state/', $export, $match)) {
+                throw new SmartyException("{make_nocache \${$var}} in template '{$tpl->source->name}': variable does contain object '{$match[1]}' not implementing method '__set_state'");
+            }
+            echo "/*%%SmartyNocache:{$tpl->compiled->nocache_hash}%%*/<?php " .
+                 addcslashes("\$_smarty_tpl->smarty->ext->_make_nocache->store(\$_smarty_tpl, '{$var}', ", '\\') .
+                 $export . ");?>\n/*/%%SmartyNocache:{$tpl->compiled->nocache_hash}%%*/";
+        }
+    }
+
+    /**
+     * Store variable value saved while rendering compiled template in cached template context
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param string                    $var variable name
+     * @param array                     $properties
+     */
+    public function store(Smarty_Internal_Template $tpl, $var, $properties)
+    {
+        // do not overwrite existing nocache variables
+        if (!isset($tpl->tpl_vars[ $var ]) || !$tpl->tpl_vars[ $var ]->nocache) {
+            $newVar = new Smarty_Variable();
+            unset($properties[ 'nocache' ]);
+            foreach ($properties as $k => $v) {
+                $newVar->$k = $v;
+            }
+            $tpl->tpl_vars[ $var ] = $newVar;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_tplfunction.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_tplfunction.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_tplfunction.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_tplfunction.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,177 @@
+<?php
+
+/**
+ * TplFunction Runtime Methods callTemplateFunction
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ **/
+class Smarty_Internal_Runtime_TplFunction
+{
+    /**
+     * Call template function
+     *
+     * @param \Smarty_Internal_Template $tpl     template object
+     * @param string                    $name    template function name
+     * @param array                     $params  parameter array
+     * @param bool                      $nocache true if called nocache
+     *
+     * @throws \SmartyException
+     */
+    public function callTemplateFunction(Smarty_Internal_Template $tpl, $name, $params, $nocache)
+    {
+        $funcParam = isset($tpl->tplFunctions[ $name ]) ? $tpl->tplFunctions[ $name ] :
+            (isset($tpl->smarty->tplFunctions[ $name ]) ? $tpl->smarty->tplFunctions[ $name ] : null);
+        if (isset($funcParam)) {
+            if (!$tpl->caching || ($tpl->caching && $nocache)) {
+                $function = $funcParam[ 'call_name' ];
+            } else {
+                if (isset($funcParam[ 'call_name_caching' ])) {
+                    $function = $funcParam[ 'call_name_caching' ];
+                } else {
+                    $function = $funcParam[ 'call_name' ];
+                }
+            }
+            if (function_exists($function)) {
+                $this->saveTemplateVariables($tpl, $name);
+                $function($tpl, $params);
+                $this->restoreTemplateVariables($tpl, $name);
+                return;
+            }
+            // try to load template function dynamically
+            if ($this->addTplFuncToCache($tpl, $name, $function)) {
+                $this->saveTemplateVariables($tpl, $name);
+                $function($tpl, $params);
+                $this->restoreTemplateVariables($tpl, $name);
+                return;
+            }
+        }
+        throw new SmartyException("Unable to find template function '{$name}'");
+    }
+
+    /**
+     * Register template functions defined by template
+     *
+     * @param \Smarty|\Smarty_Internal_Template|\Smarty_Internal_TemplateBase $obj
+     * @param array                                                           $tplFunctions source information array of
+     *                                                                                      template functions defined
+     *                                                                                      in template
+     * @param bool                                                            $override     if true replace existing
+     *                                                                                      functions with same name
+     */
+    public function registerTplFunctions(Smarty_Internal_TemplateBase $obj, $tplFunctions, $override = true)
+    {
+        $obj->tplFunctions =
+            $override ? array_merge($obj->tplFunctions, $tplFunctions) : array_merge($tplFunctions, $obj->tplFunctions);
+        // make sure that the template functions are known in parent templates
+        if ($obj->_isSubTpl()) {
+            $obj->smarty->ext->_tplFunction->registerTplFunctions($obj->parent, $tplFunctions, false);
+        } else {
+            $obj->smarty->tplFunctions = $override ? array_merge($obj->smarty->tplFunctions, $tplFunctions) :
+                array_merge($tplFunctions, $obj->smarty->tplFunctions);
+        }
+    }
+
+    /**
+     * Return source parameter array for single or all template functions
+     *
+     * @param \Smarty_Internal_Template $tpl  template object
+     * @param null|string               $name template function name
+     *
+     * @return array|bool|mixed
+     */
+    public function getTplFunction(Smarty_Internal_Template $tpl, $name = null)
+    {
+        if (isset($name)) {
+            return isset($tpl->tplFunctions[ $name ]) ? $tpl->tplFunctions[ $name ] :
+                (isset($tpl->smarty->tplFunctions[ $name ]) ? $tpl->smarty->tplFunctions[ $name ] : false);
+        } else {
+            return empty($tpl->tplFunctions) ? $tpl->smarty->tplFunctions : $tpl->tplFunctions;
+        }
+    }
+
+    /**
+     * Add template function to cache file for nocache calls
+     *
+     * @param Smarty_Internal_Template $tpl
+     * @param string                   $_name     template function name
+     * @param string                   $_function PHP function name
+     *
+     * @return bool
+     */
+    public function addTplFuncToCache(Smarty_Internal_Template $tpl, $_name, $_function)
+    {
+        $funcParam = $tpl->tplFunctions[ $_name ];
+        if (is_file($funcParam[ 'compiled_filepath' ])) {
+            // read compiled file
+            $code = file_get_contents($funcParam[ 'compiled_filepath' ]);
+            // grab template function
+            if (preg_match("/\/\* {$_function} \*\/([\S\s]*?)\/\*\/ {$_function} \*\//", $code, $match)) {
+                // grab source info from file dependency
+                preg_match("/\s*'{$funcParam['uid']}'([\S\s]*?)\),/", $code, $match1);
+                unset($code);
+                // make PHP function known
+                eval($match[ 0 ]);
+                if (function_exists($_function)) {
+                    // search cache file template
+                    $tplPtr = $tpl;
+                    while (!isset($tplPtr->cached) && isset($tplPtr->parent)) {
+                        $tplPtr = $tplPtr->parent;
+                    }
+                    // add template function code to cache file
+                    if (isset($tplPtr->cached)) {
+                        $content = $tplPtr->cached->read($tplPtr);
+                        if ($content) {
+                            // check if we must update file dependency
+                            if (!preg_match("/'{$funcParam['uid']}'(.*?)'nocache_hash'/", $content, $match2)) {
+                                $content = preg_replace("/('file_dependency'(.*?)\()/", "\\1{$match1[0]}", $content);
+                            }
+                            $tplPtr->smarty->ext->_updateCache->write(
+                                $tplPtr,
+                                preg_replace('/\s*\?>\s*$/', "\n", $content) .
+                                "\n" . preg_replace(
+                                    array(
+                                        '/^\s*<\?php\s+/',
+                                        '/\s*\?>\s*$/',
+                                    ),
+                                    "\n",
+                                    $match[ 0 ]
+                                )
+                            );
+                        }
+                    }
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Save current template variables on stack
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param string                    $name stack name
+     */
+    public function saveTemplateVariables(Smarty_Internal_Template $tpl, $name)
+    {
+        $tpl->_cache[ 'varStack' ][] =
+            array('tpl' => $tpl->tpl_vars, 'config' => $tpl->config_vars, 'name' => "_tplFunction_{$name}");
+    }
+
+    /**
+     * Restore saved variables into template objects
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param string                    $name stack name
+     */
+    public function restoreTemplateVariables(Smarty_Internal_Template $tpl, $name)
+    {
+        if (isset($tpl->_cache[ 'varStack' ])) {
+            $vars = array_pop($tpl->_cache[ 'varStack' ]);
+            $tpl->tpl_vars = $vars[ 'tpl' ];
+            $tpl->config_vars = $vars[ 'config' ];
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatecache.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatecache.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatecache.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatecache.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,183 @@
+<?php
+
+/**
+ * Inline Runtime Methods render, setSourceByUid, setupSubTemplate
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ **/
+class Smarty_Internal_Runtime_UpdateCache
+{
+    /**
+     * check client side cache
+     *
+     * @param \Smarty_Template_Cached  $cached
+     * @param Smarty_Internal_Template $_template
+     * @param string                   $content
+     */
+    public function cacheModifiedCheck(Smarty_Template_Cached $cached, Smarty_Internal_Template $_template, $content)
+    {
+    }
+
+    /**
+     * Cache was invalid , so render from compiled and write to cache
+     *
+     * @param \Smarty_Template_Cached   $cached
+     * @param \Smarty_Internal_Template $_template
+     * @param                           $no_output_filter
+     *
+     * @throws \Exception
+     */
+    public function updateCache(Smarty_Template_Cached $cached, Smarty_Internal_Template $_template, $no_output_filter)
+    {
+        ob_start();
+        if (!isset($_template->compiled)) {
+            $_template->loadCompiled();
+        }
+        $_template->compiled->render($_template);
+        if ($_template->smarty->debugging) {
+            $_template->smarty->_debug->start_cache($_template);
+        }
+        $this->removeNoCacheHash($cached, $_template, $no_output_filter);
+        $compile_check = (int)$_template->compile_check;
+        $_template->compile_check = Smarty::COMPILECHECK_OFF;
+        if ($_template->_isSubTpl()) {
+            $_template->compiled->unifunc = $_template->parent->compiled->unifunc;
+        }
+        if (!$_template->cached->processed) {
+            $_template->cached->process($_template, true);
+        }
+        $_template->compile_check = $compile_check;
+        $cached->getRenderedTemplateCode($_template);
+        if ($_template->smarty->debugging) {
+            $_template->smarty->_debug->end_cache($_template);
+        }
+    }
+
+    /**
+     * Sanitize content and write it to cache resource
+     *
+     * @param \Smarty_Template_Cached  $cached
+     * @param Smarty_Internal_Template $_template
+     * @param bool                     $no_output_filter
+     *
+     * @throws \SmartyException
+     */
+    public function removeNoCacheHash(
+        Smarty_Template_Cached $cached,
+        Smarty_Internal_Template $_template,
+        $no_output_filter
+    ) {
+        $php_pattern = '/(<%|%>|<\?php|<\?|\?>|<script\s+language\s*=\s*[\"\']?\s*php\s*[\"\']?\s*>)/';
+        $content = ob_get_clean();
+        $hash_array = $cached->hashes;
+        $hash_array[ $_template->compiled->nocache_hash ] = true;
+        $hash_array = array_keys($hash_array);
+        $nocache_hash = '(' . implode('|', $hash_array) . ')';
+        $_template->cached->has_nocache_code = false;
+        // get text between non-cached items
+        $cache_split =
+            preg_split(
+                "!/\*%%SmartyNocache:{$nocache_hash}%%\*\/(.+?)/\*/%%SmartyNocache:{$nocache_hash}%%\*/!s",
+                $content
+            );
+        // get non-cached items
+        preg_match_all(
+            "!/\*%%SmartyNocache:{$nocache_hash}%%\*\/(.+?)/\*/%%SmartyNocache:{$nocache_hash}%%\*/!s",
+            $content,
+            $cache_parts
+        );
+        $content = '';
+        // loop over items, stitch back together
+        foreach ($cache_split as $curr_idx => $curr_split) {
+            if (preg_match($php_pattern, $curr_split)) {
+                // escape PHP tags in template content
+                $php_split = preg_split(
+                    $php_pattern,
+                    $curr_split
+                );
+                preg_match_all(
+                    $php_pattern,
+                    $curr_split,
+                    $php_parts
+                );
+                foreach ($php_split as $idx_php => $curr_php) {
+                    $content .= $curr_php;
+                    if (isset($php_parts[ 0 ][ $idx_php ])) {
+                        $content .= "<?php echo '{$php_parts[ 1 ][ $idx_php ]}'; ?>\n";
+                    }
+                }
+            } else {
+                $content .= $curr_split;
+            }
+            if (isset($cache_parts[ 0 ][ $curr_idx ])) {
+                $_template->cached->has_nocache_code = true;
+                $content .= $cache_parts[ 2 ][ $curr_idx ];
+            }
+        }
+        if (!$no_output_filter && !$_template->cached->has_nocache_code
+            && (isset($_template->smarty->autoload_filters[ 'output' ])
+                || isset($_template->smarty->registered_filters[ 'output' ]))
+        ) {
+            $content = $_template->smarty->ext->_filterHandler->runFilter('output', $content, $_template);
+        }
+        // write cache file content
+        $this->writeCachedContent($_template, $content);
+    }
+
+    /**
+     * Writes the content to cache resource
+     *
+     * @param Smarty_Internal_Template $_template
+     * @param string                   $content
+     *
+     * @return bool
+     */
+    public function writeCachedContent(Smarty_Internal_Template $_template, $content)
+    {
+        if ($_template->source->handler->recompiled || !$_template->caching
+        ) {
+            // don't write cache file
+            return false;
+        }
+        if (!isset($_template->cached)) {
+            $_template->loadCached();
+        }
+        $content = $_template->smarty->ext->_codeFrame->create($_template, $content, '', true);
+        return $this->write($_template, $content);
+    }
+
+    /**
+     * Write this cache object to handler
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param string                   $content   content to cache
+     *
+     * @return bool success
+     */
+    public function write(Smarty_Internal_Template $_template, $content)
+    {
+        if (!$_template->source->handler->recompiled) {
+            $cached = $_template->cached;
+            if ($cached->handler->writeCachedContent($_template, $content)) {
+                $cached->content = null;
+                $cached->timestamp = time();
+                $cached->exists = true;
+                $cached->valid = true;
+                $cached->cache_lifetime = $_template->cache_lifetime;
+                $cached->processed = false;
+                if ($_template->smarty->cache_locking) {
+                    $cached->handler->releaseLock($_template->smarty, $cached);
+                }
+                return true;
+            }
+            $cached->content = null;
+            $cached->timestamp = false;
+            $cached->exists = false;
+            $cached->valid = false;
+            $cached->processed = false;
+        }
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatescope.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatescope.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatescope.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_updatescope.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,115 @@
+<?php
+
+/**
+ * Runtime Extension updateScope
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ **/
+class Smarty_Internal_Runtime_UpdateScope
+{
+    /**
+     * Update new assigned template or config variable in other effected scopes
+     *
+     * @param Smarty_Internal_Template $tpl      data object
+     * @param string|null              $varName  variable name
+     * @param int                      $tagScope tag scope to which bubble up variable value
+     */
+    public function _updateScope(Smarty_Internal_Template $tpl, $varName, $tagScope = 0)
+    {
+        if ($tagScope) {
+            $this->_updateVarStack($tpl, $varName);
+            $tagScope = $tagScope & ~Smarty::SCOPE_LOCAL;
+            if (!$tpl->scope && !$tagScope) {
+                return;
+            }
+        }
+        $mergedScope = $tagScope | $tpl->scope;
+        if ($mergedScope) {
+            if ($mergedScope & Smarty::SCOPE_GLOBAL && $varName) {
+                Smarty::$global_tpl_vars[ $varName ] = $tpl->tpl_vars[ $varName ];
+            }
+            // update scopes
+            foreach ($this->_getAffectedScopes($tpl, $mergedScope) as $ptr) {
+                $this->_updateVariableInOtherScope($ptr->tpl_vars, $tpl, $varName);
+                if ($tagScope && $ptr->_isTplObj() && isset($tpl->_cache[ 'varStack' ])) {
+                    $this->_updateVarStack($ptr, $varName);
+                }
+            }
+        }
+    }
+
+    /**
+     * Get array of objects which needs to be updated  by given scope value
+     *
+     * @param Smarty_Internal_Template $tpl
+     * @param int                      $mergedScope merged tag and template scope to which bubble up variable value
+     *
+     * @return array
+     */
+    public function _getAffectedScopes(Smarty_Internal_Template $tpl, $mergedScope)
+    {
+        $_stack = array();
+        $ptr = $tpl->parent;
+        if ($mergedScope && isset($ptr) && $ptr->_isTplObj()) {
+            $_stack[] = $ptr;
+            $mergedScope = $mergedScope & ~Smarty::SCOPE_PARENT;
+            if (!$mergedScope) {
+                // only parent was set, we are done
+                return $_stack;
+            }
+            $ptr = $ptr->parent;
+        }
+        while (isset($ptr) && $ptr->_isTplObj()) {
+            $_stack[] = $ptr;
+            $ptr = $ptr->parent;
+        }
+        if ($mergedScope & Smarty::SCOPE_SMARTY) {
+            if (isset($tpl->smarty)) {
+                $_stack[] = $tpl->smarty;
+            }
+        } elseif ($mergedScope & Smarty::SCOPE_ROOT) {
+            while (isset($ptr)) {
+                if (!$ptr->_isTplObj()) {
+                    $_stack[] = $ptr;
+                    break;
+                }
+                $ptr = $ptr->parent;
+            }
+        }
+        return $_stack;
+    }
+
+    /**
+     * Update variable in other scope
+     *
+     * @param array                     $tpl_vars template variable array
+     * @param \Smarty_Internal_Template $from
+     * @param string                    $varName  variable name
+     */
+    public function _updateVariableInOtherScope(&$tpl_vars, Smarty_Internal_Template $from, $varName)
+    {
+        if (!isset($tpl_vars[ $varName ])) {
+            $tpl_vars[ $varName ] = clone $from->tpl_vars[ $varName ];
+        } else {
+            $tpl_vars[ $varName ] = clone $tpl_vars[ $varName ];
+            $tpl_vars[ $varName ]->value = $from->tpl_vars[ $varName ]->value;
+        }
+    }
+
+    /**
+     * Update variable in template local variable stack
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param string|null               $varName variable name or null for config variables
+     */
+    public function _updateVarStack(Smarty_Internal_Template $tpl, $varName)
+    {
+        $i = 0;
+        while (isset($tpl->_cache[ 'varStack' ][ $i ])) {
+            $this->_updateVariableInOtherScope($tpl->_cache[ 'varStack' ][ $i ][ 'tpl' ], $tpl, $varName);
+            $i++;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_runtime_writefile.php b/epgrec/Smarty/sysplugins/smarty_internal_runtime_writefile.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_runtime_writefile.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_runtime_writefile.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,100 @@
+<?php
+/**
+ * Smarty write file plugin
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Monte Ohrt
+ */
+
+/**
+ * Smarty Internal Write File Class
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ */
+class Smarty_Internal_Runtime_WriteFile
+{
+    /**
+     * Writes file in a safe way to disk
+     *
+     * @param string $_filepath complete filepath
+     * @param string $_contents file content
+     * @param Smarty $smarty    smarty instance
+     *
+     * @throws SmartyException
+     * @return boolean true
+     */
+    public function writeFile($_filepath, $_contents, Smarty $smarty)
+    {
+        $_error_reporting = error_reporting();
+        error_reporting($_error_reporting & ~E_NOTICE & ~E_WARNING);
+        $_file_perms = property_exists($smarty, '_file_perms') ? $smarty->_file_perms : 0644;
+        $_dir_perms =
+            property_exists($smarty, '_dir_perms') ? (isset($smarty->_dir_perms) ? $smarty->_dir_perms : 0777) : 0771;
+        if ($_file_perms !== null) {
+            $old_umask = umask(0);
+        }
+        $_dirpath = dirname($_filepath);
+        // if subdirs, create dir structure
+        if ($_dirpath !== '.') {
+            $i = 0;
+            // loop if concurrency problem occurs
+            // see https://bugs.php.net/bug.php?id=35326
+            while (!is_dir($_dirpath)) {
+                if (@mkdir($_dirpath, $_dir_perms, true)) {
+                    break;
+                }
+                clearstatcache();
+                if (++$i === 3) {
+                    error_reporting($_error_reporting);
+                    throw new SmartyException("unable to create directory {$_dirpath}");
+                }
+                sleep(1);
+            }
+        }
+        // write to tmp file, then move to overt file lock race condition
+        $_tmp_file = $_dirpath . DIRECTORY_SEPARATOR . str_replace(array('.', ','), '_', uniqid('wrt', true));
+        if (!file_put_contents($_tmp_file, $_contents)) {
+            error_reporting($_error_reporting);
+            throw new SmartyException("unable to write file {$_tmp_file}");
+        }
+        /*
+         * Windows' rename() fails if the destination exists,
+         * Linux' rename() properly handles the overwrite.
+         * Simply unlink()ing a file might cause other processes
+         * currently reading that file to fail, but linux' rename()
+         * seems to be smart enough to handle that for us.
+         */
+        if (Smarty::$_IS_WINDOWS) {
+            // remove original file
+            if (is_file($_filepath)) {
+                @unlink($_filepath);
+            }
+            // rename tmp file
+            $success = @rename($_tmp_file, $_filepath);
+        } else {
+            // rename tmp file
+            $success = @rename($_tmp_file, $_filepath);
+            if (!$success) {
+                // remove original file
+                if (is_file($_filepath)) {
+                    @unlink($_filepath);
+                }
+                // rename tmp file
+                $success = @rename($_tmp_file, $_filepath);
+            }
+        }
+        if (!$success) {
+            error_reporting($_error_reporting);
+            throw new SmartyException("unable to write file {$_filepath}");
+        }
+        if ($_file_perms !== null) {
+            // set file permissions
+            chmod($_filepath, $_file_perms);
+            umask($old_umask);
+        }
+        error_reporting($_error_reporting);
+        return true;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_smartytemplatecompiler.php b/epgrec/Smarty/sysplugins/smarty_internal_smartytemplatecompiler.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_smartytemplatecompiler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_smartytemplatecompiler.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,184 @@
+<?php
+/**
+ * Smarty Internal Plugin Smarty Template Compiler Base
+ * This file contains the basic classes and methods for compiling Smarty templates with lexer/parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Class SmartyTemplateCompiler
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ */
+class Smarty_Internal_SmartyTemplateCompiler extends Smarty_Internal_TemplateCompilerBase
+{
+    /**
+     * Lexer class name
+     *
+     * @var string
+     */
+    public $lexer_class;
+
+    /**
+     * Parser class name
+     *
+     * @var string
+     */
+    public $parser_class;
+
+    /**
+     * array of vars which can be compiled in local scope
+     *
+     * @var array
+     */
+    public $local_var = array();
+
+    /**
+     * array of callbacks called when the normal compile process of template is finished
+     *
+     * @var array
+     */
+    public $postCompileCallbacks = array();
+
+    /**
+     * prefix code
+     *
+     * @var string
+     */
+    public $prefixCompiledCode = '';
+
+    /**
+     * postfix code
+     *
+     * @var string
+     */
+    public $postfixCompiledCode = '';
+
+    /**
+     * Initialize compiler
+     *
+     * @param string $lexer_class  class name
+     * @param string $parser_class class name
+     * @param Smarty $smarty       global instance
+     */
+    public function __construct($lexer_class, $parser_class, Smarty $smarty)
+    {
+        parent::__construct($smarty);
+        // get required plugins
+        $this->lexer_class = $lexer_class;
+        $this->parser_class = $parser_class;
+    }
+
+    /**
+     * method to compile a Smarty template
+     *
+     * @param mixed $_content template source
+     * @param bool  $isTemplateSource
+     *
+     * @return bool true if compiling succeeded, false if it failed
+     * @throws \SmartyCompilerException
+     */
+    protected function doCompile($_content, $isTemplateSource = false)
+    {
+        /* here is where the compiling takes place. Smarty
+          tags in the templates are replaces with PHP code,
+          then written to compiled files. */
+        // init the lexer/parser to compile the template
+        $this->parser =
+            new $this->parser_class(
+                new $this->lexer_class(
+                    str_replace(
+                        array(
+                            "\r\n",
+                            "\r"
+                        ),
+                        "\n",
+                        $_content
+                    ),
+                    $this
+                ),
+                $this
+            );
+        if ($isTemplateSource && $this->template->caching) {
+            $this->parser->insertPhpCode("<?php\n\$_smarty_tpl->compiled->nocache_hash = '{$this->nocache_hash}';\n?>\n");
+        }
+        if (function_exists('mb_internal_encoding')
+            && function_exists('ini_get')
+            && ((int)ini_get('mbstring.func_overload')) & 2
+        ) {
+            $mbEncoding = mb_internal_encoding();
+            mb_internal_encoding('ASCII');
+        } else {
+            $mbEncoding = null;
+        }
+        if ($this->smarty->_parserdebug) {
+            $this->parser->PrintTrace();
+            $this->parser->lex->PrintTrace();
+        }
+        // get tokens from lexer and parse them
+        while ($this->parser->lex->yylex()) {
+            if ($this->smarty->_parserdebug) {
+                echo "<pre>Line {$this->parser->lex->line} Parsing  {$this->parser->yyTokenName[$this->parser->lex->token]} Token " .
+                     htmlentities($this->parser->lex->value) . "</pre>";
+            }
+            $this->parser->doParse($this->parser->lex->token, $this->parser->lex->value);
+        }
+        // finish parsing process
+        $this->parser->doParse(0, 0);
+        if ($mbEncoding) {
+            mb_internal_encoding($mbEncoding);
+        }
+        // check for unclosed tags
+        if (count($this->_tag_stack) > 0) {
+            // get stacked info
+            list($openTag, $_data) = array_pop($this->_tag_stack);
+            $this->trigger_template_error(
+                "unclosed {$this->smarty->left_delimiter}" . $openTag .
+                "{$this->smarty->right_delimiter} tag"
+            );
+        }
+        // call post compile callbacks
+        foreach ($this->postCompileCallbacks as $cb) {
+            $parameter = $cb;
+            $parameter[ 0 ] = $this;
+            call_user_func_array($cb[ 0 ], $parameter);
+        }
+        // return compiled code
+        return $this->prefixCompiledCode . $this->parser->retvalue . $this->postfixCompiledCode;
+    }
+
+    /**
+     * Register a post compile callback
+     * - when the callback is called after template compiling the compiler object will be inserted as first parameter
+     *
+     * @param callback $callback
+     * @param array    $parameter optional parameter array
+     * @param string   $key       optional key for callback
+     * @param bool     $replace   if true replace existing keyed callback
+     */
+    public function registerPostCompileCallback($callback, $parameter = array(), $key = null, $replace = false)
+    {
+        array_unshift($parameter, $callback);
+        if (isset($key)) {
+            if ($replace || !isset($this->postCompileCallbacks[ $key ])) {
+                $this->postCompileCallbacks[ $key ] = $parameter;
+            }
+        } else {
+            $this->postCompileCallbacks[] = $parameter;
+        }
+    }
+
+    /**
+     * Remove a post compile callback
+     *
+     * @param string $key callback key
+     */
+    public function unregisterPostCompileCallback($key)
+    {
+        unset($this->postCompileCallbacks[ $key ]);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_template.php b/epgrec/Smarty/sysplugins/smarty_internal_template.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_template.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_template.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,740 @@
+<?php
+/**
+ * Smarty Internal Plugin Template
+ * This file contains the Smarty template engine
+ *
+ * @package    Smarty
+ * @subpackage Template
+ * @author     Uwe Tews
+ */
+
+/**
+ * Main class with template data structures and methods
+ *
+ * @package    Smarty
+ * @subpackage Template
+ *
+ * @property Smarty_Template_Compiled             $compiled
+ * @property Smarty_Template_Cached               $cached
+ * @property Smarty_Internal_TemplateCompilerBase $compiler
+ * @property mixed|\Smarty_Template_Cached        registered_plugins
+ *
+ * The following methods will be dynamically loaded by the extension handler when they are called.
+ * They are located in a corresponding Smarty_Internal_Method_xxxx class
+ *
+ * @method bool mustCompile()
+ */
+class Smarty_Internal_Template extends Smarty_Internal_TemplateBase
+{
+    /**
+     * Template object cache
+     *
+     * @var Smarty_Internal_Template[]
+     */
+    public static $tplObjCache = array();
+
+    /**
+     * Template object cache for Smarty::isCached() === true
+     *
+     * @var Smarty_Internal_Template[]
+     */
+    public static $isCacheTplObj = array();
+
+    /**
+     * Sub template Info Cache
+     * - index name
+     * - value use count
+     *
+     * @var int[]
+     */
+    public static $subTplInfo = array();
+
+    /**
+     * This object type (Smarty = 1, template = 2, data = 4)
+     *
+     * @var int
+     */
+    public $_objType = 2;
+
+    /**
+     * Global smarty instance
+     *
+     * @var Smarty
+     */
+    public $smarty = null;
+
+    /**
+     * Source instance
+     *
+     * @var Smarty_Template_Source|Smarty_Template_Config
+     */
+    public $source = null;
+
+    /**
+     * Inheritance runtime extension
+     *
+     * @var Smarty_Internal_Runtime_Inheritance
+     */
+    public $inheritance = null;
+
+    /**
+     * Template resource
+     *
+     * @var string
+     */
+    public $template_resource = null;
+
+    /**
+     * flag if compiled template is invalid and must be (re)compiled
+     *
+     * @var bool
+     */
+    public $mustCompile = null;
+
+    /**
+     * Template Id
+     *
+     * @var null|string
+     */
+    public $templateId = null;
+
+    /**
+     * Scope in which variables shall be assigned
+     *
+     * @var int
+     */
+    public $scope = 0;
+
+    /**
+     * Flag which is set while rending a cache file
+     *
+     * @var bool
+     */
+    public $isRenderingCache = false;
+
+    /**
+     * Callbacks called before rendering template
+     *
+     * @var callback[]
+     */
+    public $startRenderCallbacks = array();
+
+    /**
+     * Callbacks called after rendering template
+     *
+     * @var callback[]
+     */
+    public $endRenderCallbacks = array();
+
+    /**
+     * Create template data object
+     * Some of the global Smarty settings copied to template scope
+     * It load the required template resources and caching plugins
+     *
+     * @param string                                                       $template_resource template resource string
+     * @param Smarty                                                       $smarty            Smarty instance
+     * @param null|\Smarty_Internal_Template|\Smarty|\Smarty_Internal_Data $_parent           back pointer to parent
+     *                                                                                        object with variables or
+     *                                                                                        null
+     * @param mixed                                                        $_cache_id         cache   id or null
+     * @param mixed                                                        $_compile_id       compile id or null
+     * @param bool|int|null                                                $_caching          use caching?
+     * @param int|null                                                     $_cache_lifetime   cache life-time in
+     *                                                                                        seconds
+     * @param bool                                                         $_isConfig
+     *
+     * @throws \SmartyException
+     */
+    public function __construct(
+        $template_resource,
+        Smarty $smarty,
+        Smarty_Internal_Data $_parent = null,
+        $_cache_id = null,
+        $_compile_id = null,
+        $_caching = null,
+        $_cache_lifetime = null,
+        $_isConfig = false
+    ) {
+        $this->smarty = $smarty;
+        // Smarty parameter
+        $this->cache_id = $_cache_id === null ? $this->smarty->cache_id : $_cache_id;
+        $this->compile_id = $_compile_id === null ? $this->smarty->compile_id : $_compile_id;
+        $this->caching = (int)($_caching === null ? $this->smarty->caching : $_caching);
+        $this->cache_lifetime = $_cache_lifetime === null ? $this->smarty->cache_lifetime : $_cache_lifetime;
+        $this->compile_check = (int)$smarty->compile_check;
+        $this->parent = $_parent;
+        // Template resource
+        $this->template_resource = $template_resource;
+        $this->source = $_isConfig ? Smarty_Template_Config::load($this) : Smarty_Template_Source::load($this);
+        parent::__construct();
+        if ($smarty->security_policy && method_exists($smarty->security_policy, 'registerCallBacks')) {
+            $smarty->security_policy->registerCallBacks($this);
+        }
+    }
+
+    /**
+     * render template
+     *
+     * @param bool      $no_output_filter if true do not run output filter
+     * @param null|bool $display          true: display, false: fetch null: sub-template
+     *
+     * @return string
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function render($no_output_filter = true, $display = null)
+    {
+        if ($this->smarty->debugging) {
+            if (!isset($this->smarty->_debug)) {
+                $this->smarty->_debug = new Smarty_Internal_Debug();
+            }
+            $this->smarty->_debug->start_template($this, $display);
+        }
+        // checks if template exists
+        if (!$this->source->exists) {
+            throw new SmartyException(
+                "Unable to load template '{$this->source->type}:{$this->source->name}'" .
+                ($this->_isSubTpl() ? " in '{$this->parent->template_resource}'" : '')
+            );
+        }
+        // disable caching for evaluated code
+        if ($this->source->handler->recompiled) {
+            $this->caching = Smarty::CACHING_OFF;
+        }
+        // read from cache or render
+        if ($this->caching === Smarty::CACHING_LIFETIME_CURRENT || $this->caching === Smarty::CACHING_LIFETIME_SAVED) {
+            if (!isset($this->cached) || $this->cached->cache_id !== $this->cache_id
+                || $this->cached->compile_id !== $this->compile_id
+            ) {
+                $this->loadCached(true);
+            }
+            $this->cached->render($this, $no_output_filter);
+        } else {
+            if (!isset($this->compiled) || $this->compiled->compile_id !== $this->compile_id) {
+                $this->loadCompiled(true);
+            }
+            $this->compiled->render($this);
+        }
+        // display or fetch
+        if ($display) {
+            if ($this->caching && $this->smarty->cache_modified_check) {
+                $this->smarty->ext->_cacheModify->cacheModifiedCheck(
+                    $this->cached,
+                    $this,
+                    isset($content) ? $content : ob_get_clean()
+                );
+            } else {
+                if ((!$this->caching || $this->cached->has_nocache_code || $this->source->handler->recompiled)
+                    && !$no_output_filter && (isset($this->smarty->autoload_filters[ 'output' ])
+                                              || isset($this->smarty->registered_filters[ 'output' ]))
+                ) {
+                    echo $this->smarty->ext->_filterHandler->runFilter('output', ob_get_clean(), $this);
+                } else {
+                    echo ob_get_clean();
+                }
+            }
+            if ($this->smarty->debugging) {
+                $this->smarty->_debug->end_template($this);
+                // debug output
+                $this->smarty->_debug->display_debug($this, true);
+            }
+            return '';
+        } else {
+            if ($this->smarty->debugging) {
+                $this->smarty->_debug->end_template($this);
+                if ($this->smarty->debugging === 2 && $display === false) {
+                    $this->smarty->_debug->display_debug($this, true);
+                }
+            }
+            if (!$no_output_filter
+                && (!$this->caching || $this->cached->has_nocache_code || $this->source->handler->recompiled)
+                && (isset($this->smarty->autoload_filters[ 'output' ])
+                    || isset($this->smarty->registered_filters[ 'output' ]))
+            ) {
+                return $this->smarty->ext->_filterHandler->runFilter('output', ob_get_clean(), $this);
+            }
+            // return cache content
+            return null;
+        }
+    }
+
+    /**
+     * Runtime function to render sub-template
+     *
+     * @param string  $template       template name
+     * @param mixed   $cache_id       cache id
+     * @param mixed   $compile_id     compile id
+     * @param integer $caching        cache mode
+     * @param integer $cache_lifetime life time of cache data
+     * @param array   $data           passed parameter template variables
+     * @param int     $scope          scope in which {include} should execute
+     * @param bool    $forceTplCache  cache template object
+     * @param string  $uid            file dependency uid
+     * @param string  $content_func   function name
+     *
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function _subTemplateRender(
+        $template,
+        $cache_id,
+        $compile_id,
+        $caching,
+        $cache_lifetime,
+        $data,
+        $scope,
+        $forceTplCache,
+        $uid = null,
+        $content_func = null
+    ) {
+        $tpl = clone $this;
+        $tpl->parent = $this;
+        $smarty = &$this->smarty;
+        $_templateId = $smarty->_getTemplateId($template, $cache_id, $compile_id, $caching, $tpl);
+        // recursive call ?
+        if (isset($tpl->templateId) ? $tpl->templateId : $tpl->_getTemplateId() !== $_templateId) {
+            // already in template cache?
+            if (isset(self::$tplObjCache[ $_templateId ])) {
+                // copy data from cached object
+                $cachedTpl = &self::$tplObjCache[ $_templateId ];
+                $tpl->templateId = $cachedTpl->templateId;
+                $tpl->template_resource = $cachedTpl->template_resource;
+                $tpl->cache_id = $cachedTpl->cache_id;
+                $tpl->compile_id = $cachedTpl->compile_id;
+                $tpl->source = $cachedTpl->source;
+                if (isset($cachedTpl->compiled)) {
+                    $tpl->compiled = $cachedTpl->compiled;
+                } else {
+                    unset($tpl->compiled);
+                }
+                if ($caching !== 9999 && isset($cachedTpl->cached)) {
+                    $tpl->cached = $cachedTpl->cached;
+                } else {
+                    unset($tpl->cached);
+                }
+            } else {
+                $tpl->templateId = $_templateId;
+                $tpl->template_resource = $template;
+                $tpl->cache_id = $cache_id;
+                $tpl->compile_id = $compile_id;
+                if (isset($uid)) {
+                    // for inline templates we can get all resource information from file dependency
+                    list($filepath, $timestamp, $type) = $tpl->compiled->file_dependency[ $uid ];
+                    $tpl->source = new Smarty_Template_Source($smarty, $filepath, $type, $filepath);
+                    $tpl->source->filepath = $filepath;
+                    $tpl->source->timestamp = $timestamp;
+                    $tpl->source->exists = true;
+                    $tpl->source->uid = $uid;
+                } else {
+                    $tpl->source = Smarty_Template_Source::load($tpl);
+                    unset($tpl->compiled);
+                }
+                if ($caching !== 9999) {
+                    unset($tpl->cached);
+                }
+            }
+        } else {
+            // on recursive calls force caching
+            $forceTplCache = true;
+        }
+        $tpl->caching = $caching;
+        $tpl->cache_lifetime = $cache_lifetime;
+        // set template scope
+        $tpl->scope = $scope;
+        if (!isset(self::$tplObjCache[ $tpl->templateId ]) && !$tpl->source->handler->recompiled) {
+            // check if template object should be cached
+            if ($forceTplCache || (isset(self::$subTplInfo[ $tpl->template_resource ])
+                                   && self::$subTplInfo[ $tpl->template_resource ] > 1)
+                || ($tpl->_isSubTpl() && isset(self::$tplObjCache[ $tpl->parent->templateId ]))
+            ) {
+                self::$tplObjCache[ $tpl->templateId ] = $tpl;
+            }
+        }
+        if (!empty($data)) {
+            // set up variable values
+            foreach ($data as $_key => $_val) {
+                $tpl->tpl_vars[ $_key ] = new Smarty_Variable($_val, $this->isRenderingCache);
+            }
+        }
+        if ($tpl->caching === 9999) {
+            if (!isset($tpl->compiled)) {
+                $this->loadCompiled(true);
+            }
+            if ($tpl->compiled->has_nocache_code) {
+                $this->cached->hashes[ $tpl->compiled->nocache_hash ] = true;
+            }
+        }
+        $tpl->_cache = array();
+        if (isset($uid)) {
+            if ($smarty->debugging) {
+                if (!isset($smarty->_debug)) {
+                    $smarty->_debug = new Smarty_Internal_Debug();
+                }
+                $smarty->_debug->start_template($tpl);
+                $smarty->_debug->start_render($tpl);
+            }
+            $tpl->compiled->getRenderedTemplateCode($tpl, $content_func);
+            if ($smarty->debugging) {
+                $smarty->_debug->end_template($tpl);
+                $smarty->_debug->end_render($tpl);
+            }
+        } else {
+            if (isset($tpl->compiled)) {
+                $tpl->compiled->render($tpl);
+            } else {
+                $tpl->render();
+            }
+        }
+    }
+
+    /**
+     * Get called sub-templates and save call count
+     */
+    public function _subTemplateRegister()
+    {
+        foreach ($this->compiled->includes as $name => $count) {
+            if (isset(self::$subTplInfo[ $name ])) {
+                self::$subTplInfo[ $name ] += $count;
+            } else {
+                self::$subTplInfo[ $name ] = $count;
+            }
+        }
+    }
+
+    /**
+     * Check if this is a sub template
+     *
+     * @return bool true is sub template
+     */
+    public function _isSubTpl()
+    {
+        return isset($this->parent) && $this->parent->_isTplObj();
+    }
+
+    /**
+     * Assign variable in scope
+     *
+     * @param string $varName variable name
+     * @param mixed  $value   value
+     * @param bool   $nocache nocache flag
+     * @param int    $scope   scope into which variable shall be assigned
+     */
+    public function _assignInScope($varName, $value, $nocache = false, $scope = 0)
+    {
+        if (isset($this->tpl_vars[ $varName ])) {
+            $this->tpl_vars[ $varName ] = clone $this->tpl_vars[ $varName ];
+            $this->tpl_vars[ $varName ]->value = $value;
+            if ($nocache || $this->isRenderingCache) {
+                $this->tpl_vars[ $varName ]->nocache = true;
+            }
+        } else {
+            $this->tpl_vars[ $varName ] = new Smarty_Variable($value, $nocache || $this->isRenderingCache);
+        }
+        if ($scope >= 0) {
+            if ($scope > 0 || $this->scope > 0) {
+                $this->smarty->ext->_updateScope->_updateScope($this, $varName, $scope);
+            }
+        }
+    }
+
+    /**
+     * Check if plugins are callable require file otherwise
+     *
+     * @param array $plugins required plugins
+     *
+     * @throws \SmartyException
+     */
+    public function _checkPlugins($plugins)
+    {
+        static $checked = array();
+        foreach ($plugins as $plugin) {
+            $name = join('::', (array)$plugin[ 'function' ]);
+            if (!isset($checked[ $name ])) {
+                if (!is_callable($plugin[ 'function' ])) {
+                    if (is_file($plugin[ 'file' ])) {
+                        include_once $plugin[ 'file' ];
+                        if (is_callable($plugin[ 'function' ])) {
+                            $checked[ $name ] = true;
+                        }
+                    }
+                } else {
+                    $checked[ $name ] = true;
+                }
+            }
+            if (!isset($checked[ $name ])) {
+                if (false !== $this->smarty->loadPlugin($name)) {
+                    $checked[ $name ] = true;
+                } else {
+                    throw new SmartyException("Plugin '{$name}' not callable");
+                }
+            }
+        }
+    }
+
+    /**
+     * This function is executed automatically when a compiled or cached template file is included
+     * - Decode saved properties from compiled template and cache files
+     * - Check if compiled or cache file is valid
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param array                     $properties special template properties
+     * @param bool                      $cache      flag if called from cache file
+     *
+     * @return bool flag if compiled or cache file is valid
+     * @throws \SmartyException
+     */
+    public function _decodeProperties(Smarty_Internal_Template $tpl, $properties, $cache = false)
+    {
+        // on cache resources other than file check version stored in cache code
+        if (!isset($properties[ 'version' ]) || Smarty::SMARTY_VERSION !== $properties[ 'version' ]) {
+            if ($cache) {
+                $tpl->smarty->clearAllCache();
+            } else {
+                $tpl->smarty->clearCompiledTemplate();
+            }
+            return false;
+        }
+        $is_valid = true;
+        if (!empty($properties[ 'file_dependency' ])
+            && ((!$cache && $tpl->compile_check) || $tpl->compile_check === Smarty::COMPILECHECK_ON)
+        ) {
+            // check file dependencies at compiled code
+            foreach ($properties[ 'file_dependency' ] as $_file_to_check) {
+                if ($_file_to_check[ 2 ] === 'file' || $_file_to_check[ 2 ] === 'php') {
+                    if ($tpl->source->filepath === $_file_to_check[ 0 ]) {
+                        // do not recheck current template
+                        continue;
+                        //$mtime = $tpl->source->getTimeStamp();
+                    } else {
+                        // file and php types can be checked without loading the respective resource handlers
+                        $mtime = is_file($_file_to_check[ 0 ]) ? filemtime($_file_to_check[ 0 ]) : false;
+                    }
+                } else {
+                    $handler = Smarty_Resource::load($tpl->smarty, $_file_to_check[ 2 ]);
+                    if ($handler->checkTimestamps()) {
+                        $source = Smarty_Template_Source::load($tpl, $tpl->smarty, $_file_to_check[ 0 ]);
+                        $mtime = $source->getTimeStamp();
+                    } else {
+                        continue;
+                    }
+                }
+                if ($mtime === false || $mtime > $_file_to_check[ 1 ]) {
+                    $is_valid = false;
+                    break;
+                }
+            }
+        }
+        if ($cache) {
+            // CACHING_LIFETIME_SAVED cache expiry has to be validated here since otherwise we'd define the unifunc
+            if ($tpl->caching === Smarty::CACHING_LIFETIME_SAVED && $properties[ 'cache_lifetime' ] >= 0
+                && (time() > ($tpl->cached->timestamp + $properties[ 'cache_lifetime' ]))
+            ) {
+                $is_valid = false;
+            }
+            $tpl->cached->cache_lifetime = $properties[ 'cache_lifetime' ];
+            $tpl->cached->valid = $is_valid;
+            $resource = $tpl->cached;
+        } else {
+            $tpl->mustCompile = !$is_valid;
+            $resource = $tpl->compiled;
+            $resource->includes = isset($properties[ 'includes' ]) ? $properties[ 'includes' ] : array();
+        }
+        if ($is_valid) {
+            $resource->unifunc = $properties[ 'unifunc' ];
+            $resource->has_nocache_code = $properties[ 'has_nocache_code' ];
+            //            $tpl->compiled->nocache_hash = $properties['nocache_hash'];
+            $resource->file_dependency = $properties[ 'file_dependency' ];
+        }
+        return $is_valid && !function_exists($properties[ 'unifunc' ]);
+    }
+
+    /**
+     * Compiles the template
+     * If the template is not evaluated the compiled template is saved on disk
+     *
+     * @throws \Exception
+     */
+    public function compileTemplateSource()
+    {
+        return $this->compiled->compileTemplateSource($this);
+    }
+
+    /**
+     * Writes the content to cache resource
+     *
+     * @param string $content
+     *
+     * @return bool
+     */
+    public function writeCachedContent($content)
+    {
+        return $this->smarty->ext->_updateCache->writeCachedContent($this, $content);
+    }
+
+    /**
+     * Get unique template id
+     *
+     * @return string
+     * @throws \SmartyException
+     */
+    public function _getTemplateId()
+    {
+        return isset($this->templateId) ? $this->templateId : $this->templateId =
+            $this->smarty->_getTemplateId($this->template_resource, $this->cache_id, $this->compile_id);
+    }
+
+    /**
+     * runtime error not matching capture tags
+     *
+     * @throws \SmartyException
+     */
+    public function capture_error()
+    {
+        throw new SmartyException("Not matching {capture} open/close in '{$this->template_resource}'");
+    }
+
+    /**
+     * Load compiled object
+     *
+     * @param bool $force force new compiled object
+     */
+    public function loadCompiled($force = false)
+    {
+        if ($force || !isset($this->compiled)) {
+            $this->compiled = Smarty_Template_Compiled::load($this);
+        }
+    }
+
+    /**
+     * Load cached object
+     *
+     * @param bool $force force new cached object
+     */
+    public function loadCached($force = false)
+    {
+        if ($force || !isset($this->cached)) {
+            $this->cached = Smarty_Template_Cached::load($this);
+        }
+    }
+
+    /**
+     * Load inheritance object
+     */
+    public function _loadInheritance()
+    {
+        if (!isset($this->inheritance)) {
+            $this->inheritance = new Smarty_Internal_Runtime_Inheritance();
+        }
+    }
+
+    /**
+     * Unload inheritance object
+     */
+    public function _cleanUp()
+    {
+        $this->startRenderCallbacks = array();
+        $this->endRenderCallbacks = array();
+        $this->inheritance = null;
+    }
+
+    /**
+     * Load compiler object
+     *
+     * @throws \SmartyException
+     */
+    public function loadCompiler()
+    {
+        if (!class_exists($this->source->compiler_class)) {
+            $this->smarty->loadPlugin($this->source->compiler_class);
+        }
+        $this->compiler =
+            new $this->source->compiler_class(
+                $this->source->template_lexer_class,
+                $this->source->template_parser_class,
+                $this->smarty
+            );
+    }
+
+    /**
+     * Handle unknown class methods
+     *
+     * @param string $name unknown method-name
+     * @param array  $args argument array
+     *
+     * @return mixed
+     */
+    public function __call($name, $args)
+    {
+        // method of Smarty object?
+        if (method_exists($this->smarty, $name)) {
+            return call_user_func_array(array($this->smarty, $name), $args);
+        }
+        // parent
+        return parent::__call($name, $args);
+    }
+
+    /**
+     * get Smarty property in template context
+     *
+     * @param string $property_name property name
+     *
+     * @return mixed|Smarty_Template_Cached
+     * @throws SmartyException
+     */
+    public function __get($property_name)
+    {
+        switch ($property_name) {
+            case 'compiled':
+                $this->loadCompiled();
+                return $this->compiled;
+            case 'cached':
+                $this->loadCached();
+                return $this->cached;
+            case 'compiler':
+                $this->loadCompiler();
+                return $this->compiler;
+            default:
+                // Smarty property ?
+                if (property_exists($this->smarty, $property_name)) {
+                    return $this->smarty->$property_name;
+                }
+        }
+        throw new SmartyException("template property '$property_name' does not exist.");
+    }
+
+    /**
+     * set Smarty property in template context
+     *
+     * @param string $property_name property name
+     * @param mixed  $value         value
+     *
+     * @throws SmartyException
+     */
+    public function __set($property_name, $value)
+    {
+        switch ($property_name) {
+            case 'compiled':
+            case 'cached':
+            case 'compiler':
+                $this->$property_name = $value;
+                return;
+            default:
+                // Smarty property ?
+                if (property_exists($this->smarty, $property_name)) {
+                    $this->smarty->$property_name = $value;
+                    return;
+                }
+        }
+        throw new SmartyException("invalid template property '$property_name'.");
+    }
+
+    /**
+     * Template data object destructor
+     */
+    public function __destruct()
+    {
+        if ($this->smarty->cache_locking && isset($this->cached) && $this->cached->is_locked) {
+            $this->cached->handler->releaseLock($this->smarty, $this->cached);
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_templatebase.php b/epgrec/Smarty/sysplugins/smarty_internal_templatebase.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_templatebase.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_templatebase.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,386 @@
+<?php
+/**
+ * Smarty Internal Plugin Smarty Template  Base
+ * This file contains the basic shared methods for template handling
+ *
+ * @package    Smarty
+ * @subpackage Template
+ * @author     Uwe Tews
+ */
+
+/**
+ * Class with shared smarty/template methods
+ *
+ * @package    Smarty
+ * @subpackage Template
+ *
+ * @property int $_objType
+ *
+ * The following methods will be dynamically loaded by the extension handler when they are called.
+ * They are located in a corresponding Smarty_Internal_Method_xxxx class
+ *
+ * @method Smarty_Internal_TemplateBase addAutoloadFilters(mixed $filters, string $type = null)
+ * @method Smarty_Internal_TemplateBase addDefaultModifiers(mixed $modifiers)
+ * @method Smarty_Internal_TemplateBase addLiterals(mixed $literals)
+ * @method Smarty_Internal_TemplateBase createData(Smarty_Internal_Data $parent = null, string $name = null)
+ * @method array getAutoloadFilters(string $type = null)
+ * @method string getDebugTemplate()
+ * @method array getDefaultModifier()
+ * @method array getLiterals()
+ * @method array getTags(mixed $template = null)
+ * @method object getRegisteredObject(string $object_name)
+ * @method Smarty_Internal_TemplateBase registerCacheResource(string $name, Smarty_CacheResource $resource_handler)
+ * @method Smarty_Internal_TemplateBase registerClass(string $class_name, string $class_impl)
+ * @method Smarty_Internal_TemplateBase registerDefaultConfigHandler(callback $callback)
+ * @method Smarty_Internal_TemplateBase registerDefaultPluginHandler(callback $callback)
+ * @method Smarty_Internal_TemplateBase registerDefaultTemplateHandler(callback $callback)
+ * @method Smarty_Internal_TemplateBase registerResource(string $name, mixed $resource_handler)
+ * @method Smarty_Internal_TemplateBase setAutoloadFilters(mixed $filters, string $type = null)
+ * @method Smarty_Internal_TemplateBase setDebugTemplate(string $tpl_name)
+ * @method Smarty_Internal_TemplateBase setDefaultModifiers(mixed $modifiers)
+ * @method Smarty_Internal_TemplateBase setLiterals(mixed $literals)
+ * @method Smarty_Internal_TemplateBase unloadFilter(string $type, string $name)
+ * @method Smarty_Internal_TemplateBase unregisterCacheResource(string $name)
+ * @method Smarty_Internal_TemplateBase unregisterObject(string $object_name)
+ * @method Smarty_Internal_TemplateBase unregisterPlugin(string $type, string $name)
+ * @method Smarty_Internal_TemplateBase unregisterFilter(string $type, mixed $callback)
+ * @method Smarty_Internal_TemplateBase unregisterResource(string $name)
+ */
+abstract class Smarty_Internal_TemplateBase extends Smarty_Internal_Data
+{
+    /**
+     * Set this if you want different sets of cache files for the same
+     * templates.
+     *
+     * @var string
+     */
+    public $cache_id = null;
+
+    /**
+     * Set this if you want different sets of compiled files for the same
+     * templates.
+     *
+     * @var string
+     */
+    public $compile_id = null;
+
+    /**
+     * caching enabled
+     *
+     * @var int
+     */
+    public $caching = Smarty::CACHING_OFF;
+
+    /**
+     * check template for modifications?
+     *
+     * @var int
+     */
+    public $compile_check = Smarty::COMPILECHECK_ON;
+
+    /**
+     * cache lifetime in seconds
+     *
+     * @var integer
+     */
+    public $cache_lifetime = 3600;
+
+    /**
+     * Array of source information for known template functions
+     *
+     * @var array
+     */
+    public $tplFunctions = array();
+
+    /**
+     * universal cache
+     *
+     * @var array()
+     */
+    public $_cache = array();
+
+    /**
+     * fetches a rendered Smarty template
+     *
+     * @param string $template   the resource handle of the template file or template object
+     * @param mixed  $cache_id   cache id to be used with this template
+     * @param mixed  $compile_id compile id to be used with this template
+     * @param object $parent     next higher level of Smarty variables
+     *
+     * @throws Exception
+     * @throws SmartyException
+     * @return string rendered template output
+     */
+    public function fetch($template = null, $cache_id = null, $compile_id = null, $parent = null)
+    {
+        $result = $this->_execute($template, $cache_id, $compile_id, $parent, 0);
+        return $result === null ? ob_get_clean() : $result;
+    }
+
+    /**
+     * displays a Smarty template
+     *
+     * @param string $template   the resource handle of the template file or template object
+     * @param mixed  $cache_id   cache id to be used with this template
+     * @param mixed  $compile_id compile id to be used with this template
+     * @param object $parent     next higher level of Smarty variables
+     *
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function display($template = null, $cache_id = null, $compile_id = null, $parent = null)
+    {
+        // display template
+        $this->_execute($template, $cache_id, $compile_id, $parent, 1);
+    }
+
+    /**
+     * test if cache is valid
+     *
+     * @api  Smarty::isCached()
+     * @link http://www.smarty.net/docs/en/api.is.cached.tpl
+     *
+     * @param null|string|\Smarty_Internal_Template $template   the resource handle of the template file or template
+     *                                                          object
+     * @param mixed                                 $cache_id   cache id to be used with this template
+     * @param mixed                                 $compile_id compile id to be used with this template
+     * @param object                                $parent     next higher level of Smarty variables
+     *
+     * @return bool cache status
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    public function isCached($template = null, $cache_id = null, $compile_id = null, $parent = null)
+    {
+        return $this->_execute($template, $cache_id, $compile_id, $parent, 2);
+    }
+
+    /**
+     * fetches a rendered Smarty template
+     *
+     * @param string $template   the resource handle of the template file or template object
+     * @param mixed  $cache_id   cache id to be used with this template
+     * @param mixed  $compile_id compile id to be used with this template
+     * @param object $parent     next higher level of Smarty variables
+     * @param string $function   function type 0 = fetch,  1 = display, 2 = isCache
+     *
+     * @return mixed
+     * @throws \Exception
+     * @throws \SmartyException
+     */
+    private function _execute($template, $cache_id, $compile_id, $parent, $function)
+    {
+        $smarty = $this->_getSmartyObj();
+        $saveVars = true;
+        if ($template === null) {
+            if (!$this->_isTplObj()) {
+                throw new SmartyException($function . '():Missing \'$template\' parameter');
+            } else {
+                $template = $this;
+            }
+        } elseif (is_object($template)) {
+            /* @var Smarty_Internal_Template $template */
+            if (!isset($template->_objType) || !$template->_isTplObj()) {
+                throw new SmartyException($function . '():Template object expected');
+            }
+        } else {
+            // get template object
+            $saveVars = false;
+            $template = $smarty->createTemplate($template, $cache_id, $compile_id, $parent ? $parent : $this, false);
+            if ($this->_objType === 1) {
+                // set caching in template object
+                $template->caching = $this->caching;
+            }
+        }
+        // make sure we have integer values
+        $template->caching = (int)$template->caching;
+        // fetch template content
+        $level = ob_get_level();
+        try {
+            $_smarty_old_error_level =
+                isset($smarty->error_reporting) ? error_reporting($smarty->error_reporting) : null;
+            if ($this->_objType === 2) {
+                /* @var Smarty_Internal_Template $this */
+                $template->tplFunctions = $this->tplFunctions;
+                $template->inheritance = $this->inheritance;
+            }
+            /* @var Smarty_Internal_Template $parent */
+            if (isset($parent->_objType) && ($parent->_objType === 2) && !empty($parent->tplFunctions)) {
+                $template->tplFunctions = array_merge($parent->tplFunctions, $template->tplFunctions);
+            }
+            if ($function === 2) {
+                if ($template->caching) {
+                    // return cache status of template
+                    if (!isset($template->cached)) {
+                        $template->loadCached();
+                    }
+                    $result = $template->cached->isCached($template);
+                    Smarty_Internal_Template::$isCacheTplObj[ $template->_getTemplateId() ] = $template;
+                } else {
+                    return false;
+                }
+            } else {
+                if ($saveVars) {
+                    $savedTplVars = $template->tpl_vars;
+                    $savedConfigVars = $template->config_vars;
+                }
+                ob_start();
+                $template->_mergeVars();
+                if (!empty(Smarty::$global_tpl_vars)) {
+                    $template->tpl_vars = array_merge(Smarty::$global_tpl_vars, $template->tpl_vars);
+                }
+                $result = $template->render(false, $function);
+                $template->_cleanUp();
+                if ($saveVars) {
+                    $template->tpl_vars = $savedTplVars;
+                    $template->config_vars = $savedConfigVars;
+                } else {
+                    if (!$function && !isset(Smarty_Internal_Template::$tplObjCache[ $template->templateId ])) {
+                        $template->parent = null;
+                        $template->tpl_vars = $template->config_vars = array();
+                        Smarty_Internal_Template::$tplObjCache[ $template->templateId ] = $template;
+                    }
+                }
+            }
+            if (isset($_smarty_old_error_level)) {
+                error_reporting($_smarty_old_error_level);
+            }
+            return $result;
+        } catch (Exception $e) {
+            while (ob_get_level() > $level) {
+                ob_end_clean();
+            }
+            if (isset($_smarty_old_error_level)) {
+                error_reporting($_smarty_old_error_level);
+            }
+            throw $e;
+        }
+    }
+
+    /**
+     * Registers plugin to be used in templates
+     *
+     * @api  Smarty::registerPlugin()
+     * @link http://www.smarty.net/docs/en/api.register.plugin.tpl
+     *
+     * @param string   $type       plugin type
+     * @param string   $name       name of template tag
+     * @param callable $callback   PHP callback to register
+     * @param bool     $cacheable  if true (default) this function is cache able
+     * @param mixed    $cache_attr caching attributes if any
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function registerPlugin($type, $name, $callback, $cacheable = true, $cache_attr = null)
+    {
+        return $this->ext->registerPlugin->registerPlugin($this, $type, $name, $callback, $cacheable, $cache_attr);
+    }
+
+    /**
+     * load a filter of specified type and name
+     *
+     * @api  Smarty::loadFilter()
+     * @link http://www.smarty.net/docs/en/api.load.filter.tpl
+     *
+     * @param string $type filter type
+     * @param string $name filter name
+     *
+     * @return bool
+     * @throws \SmartyException
+     */
+    public function loadFilter($type, $name)
+    {
+        return $this->ext->loadFilter->loadFilter($this, $type, $name);
+    }
+
+    /**
+     * Registers a filter function
+     *
+     * @api  Smarty::registerFilter()
+     * @link http://www.smarty.net/docs/en/api.register.filter.tpl
+     *
+     * @param string      $type filter type
+     * @param callable    $callback
+     * @param string|null $name optional filter name
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function registerFilter($type, $callback, $name = null)
+    {
+        return $this->ext->registerFilter->registerFilter($this, $type, $callback, $name);
+    }
+
+    /**
+     * Registers object to be used in templates
+     *
+     * @api  Smarty::registerObject()
+     * @link http://www.smarty.net/docs/en/api.register.object.tpl
+     *
+     * @param string $object_name
+     * @param object $object                     the referenced PHP object to register
+     * @param array  $allowed_methods_properties list of allowed methods (empty = all)
+     * @param bool   $format                     smarty argument format, else traditional
+     * @param array  $block_methods              list of block-methods
+     *
+     * @return \Smarty|\Smarty_Internal_Template
+     * @throws \SmartyException
+     */
+    public function registerObject(
+        $object_name,
+        $object,
+        $allowed_methods_properties = array(),
+        $format = true,
+        $block_methods = array()
+    ) {
+        return $this->ext->registerObject->registerObject(
+            $this,
+            $object_name,
+            $object,
+            $allowed_methods_properties,
+            $format,
+            $block_methods
+        );
+    }
+
+    /**
+     * @param int $compile_check
+     */
+    public function setCompileCheck($compile_check)
+    {
+        $this->compile_check = (int)$compile_check;
+    }
+
+    /**
+     * @param int $caching
+     */
+    public function setCaching($caching)
+    {
+        $this->caching = (int)$caching;
+    }
+
+    /**
+     * @param int $cache_lifetime
+     */
+    public function setCacheLifetime($cache_lifetime)
+    {
+        $this->cache_lifetime = $cache_lifetime;
+    }
+
+    /**
+     * @param string $compile_id
+     */
+    public function setCompileId($compile_id)
+    {
+        $this->compile_id = $compile_id;
+    }
+
+    /**
+     * @param string $cache_id
+     */
+    public function setCacheId($cache_id)
+    {
+        $this->cache_id = $cache_id;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_templatecompilerbase.php b/epgrec/Smarty/sysplugins/smarty_internal_templatecompilerbase.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_templatecompilerbase.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_templatecompilerbase.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,1764 @@
+<?php
+/**
+ * Smarty Internal Plugin Smarty Template Compiler Base
+ * This file contains the basic classes and methods for compiling Smarty templates with lexer/parser
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ * @author     Uwe Tews
+ */
+
+/**
+ * Main abstract compiler class
+ *
+ * @package    Smarty
+ * @subpackage Compiler
+ *
+ * @property Smarty_Internal_SmartyTemplateCompiler $prefixCompiledCode  = ''
+ * @property Smarty_Internal_SmartyTemplateCompiler $postfixCompiledCode = ''
+ * @method   registerPostCompileCallback($callback, $parameter = array(), $key = null, $replace = false)
+ * @method   unregisterPostCompileCallback($key)
+ */
+abstract class Smarty_Internal_TemplateCompilerBase
+{
+    /**
+     * compile tag objects cache
+     *
+     * @var array
+     */
+    public static $_tag_objects = array();
+
+    /**
+     * counter for prefix variable number
+     *
+     * @var int
+     */
+    public static $prefixVariableNumber = 0;
+
+    /**
+     * Smarty object
+     *
+     * @var Smarty
+     */
+    public $smarty = null;
+
+    /**
+     * Parser object
+     *
+     * @var Smarty_Internal_Templateparser
+     */
+    public $parser = null;
+
+    /**
+     * hash for nocache sections
+     *
+     * @var mixed
+     */
+    public $nocache_hash = null;
+
+    /**
+     * suppress generation of nocache code
+     *
+     * @var bool
+     */
+    public $suppressNocacheProcessing = false;
+
+    /**
+     * caching enabled (copied from template object)
+     *
+     * @var int
+     */
+    public $caching = 0;
+
+    /**
+     * tag stack
+     *
+     * @var array
+     */
+    public $_tag_stack = array();
+
+    /**
+     * tag stack count
+     *
+     * @var array
+     */
+    public $_tag_stack_count = array();
+
+    /**
+     * Plugins used by template
+     *
+     * @var array
+     */
+    public $required_plugins = array('compiled' => array(), 'nocache' => array());
+
+    /**
+     * Required plugins stack
+     *
+     * @var array
+     */
+    public $required_plugins_stack = array();
+
+    /**
+     * current template
+     *
+     * @var Smarty_Internal_Template
+     */
+    public $template = null;
+
+    /**
+     * merged included sub template data
+     *
+     * @var array
+     */
+    public $mergedSubTemplatesData = array();
+
+    /**
+     * merged sub template code
+     *
+     * @var array
+     */
+    public $mergedSubTemplatesCode = array();
+
+    /**
+     * collected template properties during compilation
+     *
+     * @var array
+     */
+    public $templateProperties = array();
+
+    /**
+     * source line offset for error messages
+     *
+     * @var int
+     */
+    public $trace_line_offset = 0;
+
+    /**
+     * trace uid
+     *
+     * @var string
+     */
+    public $trace_uid = '';
+
+    /**
+     * trace file path
+     *
+     * @var string
+     */
+    public $trace_filepath = '';
+
+    /**
+     * stack for tracing file and line of nested {block} tags
+     *
+     * @var array
+     */
+    public $trace_stack = array();
+
+    /**
+     * plugins loaded by default plugin handler
+     *
+     * @var array
+     */
+    public $default_handler_plugins = array();
+
+    /**
+     * saved preprocessed modifier list
+     *
+     * @var mixed
+     */
+    public $default_modifier_list = null;
+
+    /**
+     * force compilation of complete template as nocache
+     *
+     * @var boolean
+     */
+    public $forceNocache = false;
+
+    /**
+     * flag if compiled template file shall we written
+     *
+     * @var bool
+     */
+    public $write_compiled_code = true;
+
+    /**
+     * Template functions
+     *
+     * @var array
+     */
+    public $tpl_function = array();
+
+    /**
+     * called sub functions from template function
+     *
+     * @var array
+     */
+    public $called_functions = array();
+
+    /**
+     * compiled template or block function code
+     *
+     * @var string
+     */
+    public $blockOrFunctionCode = '';
+
+    /**
+     * php_handling setting either from Smarty or security
+     *
+     * @var int
+     */
+    public $php_handling = 0;
+
+    /**
+     * flags for used modifier plugins
+     *
+     * @var array
+     */
+    public $modifier_plugins = array();
+
+    /**
+     * type of already compiled modifier
+     *
+     * @var array
+     */
+    public $known_modifier_type = array();
+
+    /**
+     * parent compiler object for merged subtemplates and template functions
+     *
+     * @var Smarty_Internal_TemplateCompilerBase
+     */
+    public $parent_compiler = null;
+
+    /**
+     * Flag true when compiling nocache section
+     *
+     * @var bool
+     */
+    public $nocache = false;
+
+    /**
+     * Flag true when tag is compiled as nocache
+     *
+     * @var bool
+     */
+    public $tag_nocache = false;
+
+    /**
+     * Compiled tag prefix code
+     *
+     * @var array
+     */
+    public $prefix_code = array();
+
+    /**
+     * used prefix variables by current compiled tag
+     *
+     * @var array
+     */
+    public $usedPrefixVariables = array();
+
+    /**
+     * Prefix code  stack
+     *
+     * @var array
+     */
+    public $prefixCodeStack = array();
+
+    /**
+     * Tag has compiled code
+     *
+     * @var bool
+     */
+    public $has_code = false;
+
+    /**
+     * A variable string was compiled
+     *
+     * @var bool
+     */
+    public $has_variable_string = false;
+
+    /**
+     * Stack for {setfilter} {/setfilter}
+     *
+     * @var array
+     */
+    public $variable_filter_stack = array();
+
+    /**
+     * variable filters for {setfilter} {/setfilter}
+     *
+     * @var array
+     */
+    public $variable_filters = array();
+
+    /**
+     * Nesting count of looping tags like {foreach}, {for}, {section}, {while}
+     *
+     * @var int
+     */
+    public $loopNesting = 0;
+
+    /**
+     * Strip preg pattern
+     *
+     * @var string
+     */
+    public $stripRegEx = '![\t ]*[\r\n]+[\t ]*!';
+
+    /**
+     * plugin search order
+     *
+     * @var array
+     */
+    public $plugin_search_order = array(
+        'function',
+        'block',
+        'compiler',
+        'class'
+    );
+
+    /**
+     * General storage area for tag compiler plugins
+     *
+     * @var array
+     */
+    public $_cache = array();
+
+    /**
+     * Lexer preg pattern for left delimiter
+     *
+     * @var string
+     */
+    private $ldelPreg = '[{]';
+
+    /**
+     * Lexer preg pattern for right delimiter
+     *
+     * @var string
+     */
+    private $rdelPreg = '[}]';
+
+    /**
+     * Length of right delimiter
+     *
+     * @var int
+     */
+    private $rdelLength = 0;
+
+    /**
+     * Length of left delimiter
+     *
+     * @var int
+     */
+    private $ldelLength = 0;
+
+    /**
+     * Lexer preg pattern for user literals
+     *
+     * @var string
+     */
+    private $literalPreg = '';
+
+    /**
+     * Initialize compiler
+     *
+     * @param Smarty $smarty global instance
+     */
+    public function __construct(Smarty $smarty)
+    {
+        $this->smarty = $smarty;
+        $this->nocache_hash = str_replace(
+            array(
+                '.',
+                ','
+            ),
+            '_',
+            uniqid(mt_rand(), true)
+        );
+    }
+
+    /**
+     * Method to compile a Smarty template
+     *
+     * @param Smarty_Internal_Template                  $template template object to compile
+     * @param bool                                      $nocache  true is shall be compiled in nocache mode
+     * @param null|Smarty_Internal_TemplateCompilerBase $parent_compiler
+     *
+     * @return bool true if compiling succeeded, false if it failed
+     * @throws \Exception
+     */
+    public function compileTemplate(
+        Smarty_Internal_Template $template,
+        $nocache = null,
+        Smarty_Internal_TemplateCompilerBase $parent_compiler = null
+    ) {
+        // get code frame of compiled template
+        $_compiled_code = $template->smarty->ext->_codeFrame->create(
+            $template,
+            $this->compileTemplateSource(
+                $template,
+                $nocache,
+                $parent_compiler
+            ),
+            $this->postFilter($this->blockOrFunctionCode) .
+            join('', $this->mergedSubTemplatesCode),
+            false,
+            $this
+        );
+        return $_compiled_code;
+    }
+
+    /**
+     * Compile template source and run optional post filter
+     *
+     * @param \Smarty_Internal_Template             $template
+     * @param null|bool                             $nocache flag if template must be compiled in nocache mode
+     * @param \Smarty_Internal_TemplateCompilerBase $parent_compiler
+     *
+     * @return string
+     * @throws \Exception
+     */
+    public function compileTemplateSource(
+        Smarty_Internal_Template $template,
+        $nocache = null,
+        Smarty_Internal_TemplateCompilerBase $parent_compiler = null
+    ) {
+        try {
+            // save template object in compiler class
+            $this->template = $template;
+            if (property_exists($this->template->smarty, 'plugin_search_order')) {
+                $this->plugin_search_order = $this->template->smarty->plugin_search_order;
+            }
+            if ($this->smarty->debugging) {
+                if (!isset($this->smarty->_debug)) {
+                    $this->smarty->_debug = new Smarty_Internal_Debug();
+                }
+                $this->smarty->_debug->start_compile($this->template);
+            }
+            if (isset($this->template->smarty->security_policy)) {
+                $this->php_handling = $this->template->smarty->security_policy->php_handling;
+            } else {
+                $this->php_handling = $this->template->smarty->php_handling;
+            }
+            $this->parent_compiler = $parent_compiler ? $parent_compiler : $this;
+            $nocache = isset($nocache) ? $nocache : false;
+            if (empty($template->compiled->nocache_hash)) {
+                $template->compiled->nocache_hash = $this->nocache_hash;
+            } else {
+                $this->nocache_hash = $template->compiled->nocache_hash;
+            }
+            $this->caching = $template->caching;
+            // flag for nocache sections
+            $this->nocache = $nocache;
+            $this->tag_nocache = false;
+            // reset has nocache code flag
+            $this->template->compiled->has_nocache_code = false;
+            $this->has_variable_string = false;
+            $this->prefix_code = array();
+            // add file dependency
+            if ($this->smarty->merge_compiled_includes || $this->template->source->handler->checkTimestamps()) {
+                $this->parent_compiler->template->compiled->file_dependency[ $this->template->source->uid ] =
+                    array(
+                        $this->template->source->filepath,
+                        $this->template->source->getTimeStamp(),
+                        $this->template->source->type,
+                    );
+            }
+            $this->smarty->_current_file = $this->template->source->filepath;
+            // get template source
+            if (!empty($this->template->source->components)) {
+                // we have array of inheritance templates by extends: resource
+                // generate corresponding source code sequence
+                $_content =
+                    Smarty_Internal_Compile_Extends::extendsSourceArrayCode($this->template);
+            } else {
+                // get template source
+                $_content = $this->template->source->getContent();
+            }
+            $_compiled_code = $this->postFilter($this->doCompile($this->preFilter($_content), true));
+            if (!empty($this->required_plugins[ 'compiled' ]) || !empty($this->required_plugins[ 'nocache' ])) {
+                $_compiled_code = '<?php ' . $this->compileRequiredPlugins() . "?>\n" . $_compiled_code;
+            }
+        } catch (Exception $e) {
+            if ($this->smarty->debugging) {
+                $this->smarty->_debug->end_compile($this->template);
+            }
+            $this->_tag_stack = array();
+            // free memory
+            $this->parent_compiler = null;
+            $this->template = null;
+            $this->parser = null;
+            throw $e;
+        }
+        if ($this->smarty->debugging) {
+            $this->smarty->_debug->end_compile($this->template);
+        }
+        $this->parent_compiler = null;
+        $this->parser = null;
+        return $_compiled_code;
+    }
+
+    /**
+     * Optionally process compiled code by post filter
+     *
+     * @param string $code compiled code
+     *
+     * @return string
+     * @throws \SmartyException
+     */
+    public function postFilter($code)
+    {
+        // run post filter if on code
+        if (!empty($code)
+            && (isset($this->smarty->autoload_filters[ 'post' ]) || isset($this->smarty->registered_filters[ 'post' ]))
+        ) {
+            return $this->smarty->ext->_filterHandler->runFilter('post', $code, $this->template);
+        } else {
+            return $code;
+        }
+    }
+
+    /**
+     * Run optional prefilter
+     *
+     * @param string $_content template source
+     *
+     * @return string
+     * @throws \SmartyException
+     */
+    public function preFilter($_content)
+    {
+        // run pre filter if required
+        if ($_content !== ''
+            && ((isset($this->smarty->autoload_filters[ 'pre' ]) || isset($this->smarty->registered_filters[ 'pre' ])))
+        ) {
+            return $this->smarty->ext->_filterHandler->runFilter('pre', $_content, $this->template);
+        } else {
+            return $_content;
+        }
+    }
+
+    /**
+     * Compile Tag
+     * This is a call back from the lexer/parser
+     *
+     * Save current prefix code
+     * Compile tag
+     * Merge tag prefix code with saved one
+     * (required nested tags in attributes)
+     *
+     * @param string $tag       tag name
+     * @param array  $args      array with tag attributes
+     * @param array  $parameter array with compilation parameter
+     *
+     * @throws SmartyCompilerException
+     * @throws SmartyException
+     * @return string compiled code
+     */
+    public function compileTag($tag, $args, $parameter = array())
+    {
+        $this->prefixCodeStack[] = $this->prefix_code;
+        $this->prefix_code = array();
+        $result = $this->compileTag2($tag, $args, $parameter);
+        $this->prefix_code = array_merge($this->prefix_code, array_pop($this->prefixCodeStack));
+        return $result;
+    }
+
+    /**
+     * compile variable
+     *
+     * @param string $variable
+     *
+     * @return string
+     */
+    public function compileVariable($variable)
+    {
+        if (!strpos($variable, '(')) {
+            // not a variable variable
+            $var = trim($variable, '\'');
+            $this->tag_nocache = $this->tag_nocache |
+                                 $this->template->ext->getTemplateVars->_getVariable(
+                                     $this->template,
+                                     $var,
+                                     null,
+                                     true,
+                                     false
+                                 )->nocache;
+            // todo $this->template->compiled->properties['variables'][$var] = $this->tag_nocache | $this->nocache;
+        }
+        return '$_smarty_tpl->tpl_vars[' . $variable . ']->value';
+    }
+
+    /**
+     * compile config variable
+     *
+     * @param string $variable
+     *
+     * @return string
+     */
+    public function compileConfigVariable($variable)
+    {
+        // return '$_smarty_tpl->config_vars[' . $variable . ']';
+        return '$_smarty_tpl->smarty->ext->configLoad->_getConfigVariable($_smarty_tpl, ' . $variable . ')';
+    }
+
+    /**
+     * compile PHP function call
+     *
+     * @param string $name
+     * @param array  $parameter
+     *
+     * @return string
+     * @throws \SmartyCompilerException
+     */
+    public function compilePHPFunctionCall($name, $parameter)
+    {
+        if (!$this->smarty->security_policy || $this->smarty->security_policy->isTrustedPhpFunction($name, $this)) {
+            if (strcasecmp($name, 'isset') === 0 || strcasecmp($name, 'empty') === 0
+                || strcasecmp($name, 'array') === 0 || is_callable($name)
+            ) {
+                $func_name = strtolower($name);
+
+                if ($func_name === 'isset') {
+                    if (count($parameter) === 0) {
+                        $this->trigger_template_error('Illegal number of parameter in "isset()"');
+                    }
+
+	                $pa = array();
+	                foreach ($parameter as $p) {
+		                $pa[] = $this->syntaxMatchesVariable($p) ? 'isset(' . $p . ')' : '(' . $p . ' !== null )';
+	                }
+	                return '(' . implode(' && ', $pa) . ')';
+
+                } elseif (in_array(
+                    $func_name,
+                    array(
+                        'empty',
+                        'reset',
+                        'current',
+                        'end',
+                        'prev',
+                        'next'
+                    )
+                )
+                ) {
+                    if (count($parameter) !== 1) {
+                        $this->trigger_template_error("Illegal number of parameter in '{$func_name()}'");
+                    }
+                    if ($func_name === 'empty') {
+                        if (!$this->syntaxMatchesVariable($parameter[0]) && version_compare(PHP_VERSION, '5.5.0', '<')) {
+                            return '(' . $parameter[ 0 ] . ' === false )';
+                        } else {
+                            return $func_name . '(' .
+                                   str_replace("')->value", "',null,true,false)->value", $parameter[ 0 ]) . ')';
+                        }
+                    } else {
+                        return $func_name . '(' . $parameter[ 0 ] . ')';
+                    }
+                } else {
+                    return $name . '(' . implode(',', $parameter) . ')';
+                }
+            } else {
+                $this->trigger_template_error("unknown function '{$name}'");
+            }
+        }
+    }
+
+	/**
+	 * Determines whether the passed string represents a valid (PHP) variable.
+	 * This is important, because `isset()` only works on variables and `empty()` can only be passed
+	 * a variable prior to php5.5
+	 * @param $string
+	 * @return bool
+	 */
+	private function syntaxMatchesVariable($string) {
+    	static $regex_pattern = '/^\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*((->)[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*|\[.*]*\])*$/';
+    	return 1 === preg_match($regex_pattern, trim($string));
+    }
+
+    /**
+     * This method is called from parser to process a text content section if strip is enabled
+     * - remove text from inheritance child templates as they may generate output
+     *
+     * @param string $text
+     *
+     * @return string
+     */
+    public function processText($text)
+    {
+
+        if (strpos($text, '<') === false) {
+        	return preg_replace($this->stripRegEx, '', $text);
+        }
+
+	    $store = array();
+	    $_store = 0;
+
+        // capture html elements not to be messed with
+        $_offset = 0;
+        if (preg_match_all(
+            '#(<script[^>]*>.*?</script[^>]*>)|(<textarea[^>]*>.*?</textarea[^>]*>)|(<pre[^>]*>.*?</pre[^>]*>)#is',
+            $text,
+            $matches,
+            PREG_OFFSET_CAPTURE | PREG_SET_ORDER
+        )
+        ) {
+            foreach ($matches as $match) {
+                $store[] = $match[ 0 ][ 0 ];
+                $_length = strlen($match[ 0 ][ 0 ]);
+                $replace = '@!@SMARTY:' . $_store . ':SMARTY@!@';
+                $text = substr_replace($text, $replace, $match[ 0 ][ 1 ] - $_offset, $_length);
+                $_offset += $_length - strlen($replace);
+                $_store++;
+            }
+        }
+        $expressions = array(// replace multiple spaces between tags by a single space
+                             '#(:SMARTY@!@|>)[\040\011]+(?=@!@SMARTY:|<)#s'                            => '\1 \2',
+                             // remove newline between tags
+                             '#(:SMARTY@!@|>)[\040\011]*[\n]\s*(?=@!@SMARTY:|<)#s'                     => '\1\2',
+                             // remove multiple spaces between attributes (but not in attribute values!)
+                             '#(([a-z0-9]\s*=\s*("[^"]*?")|(\'[^\']*?\'))|<[a-z0-9_]+)\s+([a-z/>])#is' => '\1 \5',
+                             '#>[\040\011]+$#Ss'                                                       => '> ',
+                             '#>[\040\011]*[\n]\s*$#Ss'                                                => '>',
+                             $this->stripRegEx                                                         => '',
+        );
+        $text = preg_replace(array_keys($expressions), array_values($expressions), $text);
+        $_offset = 0;
+        if (preg_match_all(
+            '#@!@SMARTY:([0-9]+):SMARTY@!@#is',
+            $text,
+            $matches,
+            PREG_OFFSET_CAPTURE | PREG_SET_ORDER
+        )
+        ) {
+            foreach ($matches as $match) {
+                $_length = strlen($match[ 0 ][ 0 ]);
+                $replace = $store[ $match[ 1 ][ 0 ] ];
+                $text = substr_replace($text, $replace, $match[ 0 ][ 1 ] + $_offset, $_length);
+                $_offset += strlen($replace) - $_length;
+                $_store++;
+            }
+        }
+        return $text;
+    }
+
+    /**
+     * lazy loads internal compile plugin for tag and calls the compile method
+     * compile objects cached for reuse.
+     * class name format:  Smarty_Internal_Compile_TagName
+     * plugin filename format: Smarty_Internal_TagName.php
+     *
+     * @param string $tag    tag name
+     * @param array  $args   list of tag attributes
+     * @param mixed  $param1 optional parameter
+     * @param mixed  $param2 optional parameter
+     * @param mixed  $param3 optional parameter
+     *
+     * @return bool|string compiled code or false
+     * @throws \SmartyCompilerException
+     */
+    public function callTagCompiler($tag, $args, $param1 = null, $param2 = null, $param3 = null)
+    {
+        /* @var Smarty_Internal_CompileBase $tagCompiler */
+        $tagCompiler = $this->getTagCompiler($tag);
+        // compile this tag
+        return $tagCompiler === false ? false : $tagCompiler->compile($args, $this, $param1, $param2, $param3);
+    }
+
+    /**
+     * lazy loads internal compile plugin for tag compile objects cached for reuse.
+     *
+     * class name format:  Smarty_Internal_Compile_TagName
+     * plugin filename format: Smarty_Internal_TagName.php
+     *
+     * @param string $tag tag name
+     *
+     * @return bool|\Smarty_Internal_CompileBase tag compiler object or false if not found
+     */
+    public function getTagCompiler($tag)
+    {
+        // re-use object if already exists
+        if (!isset(self::$_tag_objects[ $tag ])) {
+            // lazy load internal compiler plugin
+            $_tag = explode('_', $tag);
+            $_tag = array_map('ucfirst', $_tag);
+            $class_name = 'Smarty_Internal_Compile_' . implode('_', $_tag);
+            if (class_exists($class_name)
+                && (!isset($this->smarty->security_policy) || $this->smarty->security_policy->isTrustedTag($tag, $this))
+            ) {
+                self::$_tag_objects[ $tag ] = new $class_name;
+            } else {
+                self::$_tag_objects[ $tag ] = false;
+            }
+        }
+        return self::$_tag_objects[ $tag ];
+    }
+
+    /**
+     * Check for plugins and return function name
+     *
+     * @param        $plugin_name
+     * @param string $plugin_type type of plugin
+     *
+     * @return string call name of function
+     * @throws \SmartyException
+     */
+    public function getPlugin($plugin_name, $plugin_type)
+    {
+        $function = null;
+        if ($this->caching && ($this->nocache || $this->tag_nocache)) {
+            if (isset($this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ])) {
+                $function =
+                    $this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ][ 'function' ];
+            } elseif (isset($this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ])) {
+                $this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ] =
+                    $this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ];
+                $function =
+                    $this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ][ 'function' ];
+            }
+        } else {
+            if (isset($this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ])) {
+                $function =
+                    $this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ][ 'function' ];
+            } elseif (isset($this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ])) {
+                $this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ] =
+                    $this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ];
+                $function =
+                    $this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ][ 'function' ];
+            }
+        }
+        if (isset($function)) {
+            if ($plugin_type === 'modifier') {
+                $this->modifier_plugins[ $plugin_name ] = true;
+            }
+            return $function;
+        }
+        // loop through plugin dirs and find the plugin
+        $function = 'smarty_' . $plugin_type . '_' . $plugin_name;
+        $file = $this->smarty->loadPlugin($function, false);
+        if (is_string($file)) {
+            if ($this->caching && ($this->nocache || $this->tag_nocache)) {
+                $this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ][ 'file' ] =
+                    $file;
+                $this->required_plugins[ 'nocache' ][ $plugin_name ][ $plugin_type ][ 'function' ] =
+                    $function;
+            } else {
+                $this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ][ 'file' ] =
+                    $file;
+                $this->required_plugins[ 'compiled' ][ $plugin_name ][ $plugin_type ][ 'function' ] =
+                    $function;
+            }
+            if ($plugin_type === 'modifier') {
+                $this->modifier_plugins[ $plugin_name ] = true;
+            }
+            return $function;
+        }
+        if (is_callable($function)) {
+            // plugin function is defined in the script
+            return $function;
+        }
+        return false;
+    }
+
+    /**
+     * Check for plugins by default plugin handler
+     *
+     * @param string $tag         name of tag
+     * @param string $plugin_type type of plugin
+     *
+     * @return bool true if found
+     * @throws \SmartyCompilerException
+     */
+    public function getPluginFromDefaultHandler($tag, $plugin_type)
+    {
+        $callback = null;
+        $script = null;
+        $cacheable = true;
+        $result = call_user_func_array(
+            $this->smarty->default_plugin_handler_func,
+            array(
+                $tag,
+                $plugin_type,
+                $this->template,
+                &$callback,
+                &$script,
+                &$cacheable,
+            )
+        );
+        if ($result) {
+            $this->tag_nocache = $this->tag_nocache || !$cacheable;
+            if ($script !== null) {
+                if (is_file($script)) {
+                    if ($this->caching && ($this->nocache || $this->tag_nocache)) {
+                        $this->required_plugins[ 'nocache' ][ $tag ][ $plugin_type ][ 'file' ] =
+                            $script;
+                        $this->required_plugins[ 'nocache' ][ $tag ][ $plugin_type ][ 'function' ] =
+                            $callback;
+                    } else {
+                        $this->required_plugins[ 'compiled' ][ $tag ][ $plugin_type ][ 'file' ] =
+                            $script;
+                        $this->required_plugins[ 'compiled' ][ $tag ][ $plugin_type ][ 'function' ] =
+                            $callback;
+                    }
+                    include_once $script;
+                } else {
+                    $this->trigger_template_error("Default plugin handler: Returned script file '{$script}' for '{$tag}' not found");
+                }
+            }
+            if (is_callable($callback)) {
+                $this->default_handler_plugins[ $plugin_type ][ $tag ] = array(
+                    $callback,
+                    true,
+                    array()
+                );
+                return true;
+            } else {
+                $this->trigger_template_error("Default plugin handler: Returned callback for '{$tag}' not callable");
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Append code segments and remove unneeded ?> <?php transitions
+     *
+     * @param string $left
+     * @param string $right
+     *
+     * @return string
+     */
+    public function appendCode($left, $right)
+    {
+        if (preg_match('/\s*\?>\s?$/D', $left) && preg_match('/^<\?php\s+/', $right)) {
+            $left = preg_replace('/\s*\?>\s?$/D', "\n", $left);
+            $left .= preg_replace('/^<\?php\s+/', '', $right);
+        } else {
+            $left .= $right;
+        }
+        return $left;
+    }
+
+    /**
+     * Inject inline code for nocache template sections
+     * This method gets the content of each template element from the parser.
+     * If the content is compiled code and it should be not cached the code is injected
+     * into the rendered output.
+     *
+     * @param string  $content content of template element
+     * @param boolean $is_code true if content is compiled code
+     *
+     * @return string  content
+     */
+    public function processNocacheCode($content, $is_code)
+    {
+        // If the template is not evaluated and we have a nocache section and or a nocache tag
+        if ($is_code && !empty($content)) {
+            // generate replacement code
+            if ((!($this->template->source->handler->recompiled) || $this->forceNocache) && $this->caching
+                && !$this->suppressNocacheProcessing && ($this->nocache || $this->tag_nocache)
+            ) {
+                $this->template->compiled->has_nocache_code = true;
+                $_output = addcslashes($content, '\'\\');
+                $_output = str_replace('^#^', '\'', $_output);
+                $_output =
+                    "<?php echo '/*%%SmartyNocache:{$this->nocache_hash}%%*/{$_output}/*/%%SmartyNocache:{$this->nocache_hash}%%*/';?>\n";
+                // make sure we include modifier plugins for nocache code
+                foreach ($this->modifier_plugins as $plugin_name => $dummy) {
+                    if (isset($this->required_plugins[ 'compiled' ][ $plugin_name ][ 'modifier' ])) {
+                        $this->required_plugins[ 'nocache' ][ $plugin_name ][ 'modifier' ] =
+                            $this->required_plugins[ 'compiled' ][ $plugin_name ][ 'modifier' ];
+                    }
+                }
+            } else {
+                $_output = $content;
+            }
+        } else {
+            $_output = $content;
+        }
+        $this->modifier_plugins = array();
+        $this->suppressNocacheProcessing = false;
+        $this->tag_nocache = false;
+        return $_output;
+    }
+
+    /**
+     * Get Id
+     *
+     * @param string $input
+     *
+     * @return bool|string
+     */
+    public function getId($input)
+    {
+        if (preg_match('~^([\'"]*)([0-9]*[a-zA-Z_]\w*)\1$~', $input, $match)) {
+            return $match[ 2 ];
+        }
+        return false;
+    }
+
+    /**
+     * Get variable name from string
+     *
+     * @param string $input
+     *
+     * @return bool|string
+     */
+    public function getVariableName($input)
+    {
+        if (preg_match('~^[$]_smarty_tpl->tpl_vars\[[\'"]*([0-9]*[a-zA-Z_]\w*)[\'"]*\]->value$~', $input, $match)) {
+            return $match[ 1 ];
+        }
+        return false;
+    }
+
+    /**
+     * Set nocache flag in variable or create new variable
+     *
+     * @param string $varName
+     */
+    public function setNocacheInVariable($varName)
+    {
+        // create nocache var to make it know for further compiling
+        if ($_var = $this->getId($varName)) {
+            if (isset($this->template->tpl_vars[ $_var ])) {
+                $this->template->tpl_vars[ $_var ] = clone $this->template->tpl_vars[ $_var ];
+                $this->template->tpl_vars[ $_var ]->nocache = true;
+            } else {
+                $this->template->tpl_vars[ $_var ] = new Smarty_Variable(null, true);
+            }
+        }
+    }
+
+    /**
+     * @param array $_attr tag attributes
+     * @param array $validScopes
+     *
+     * @return int|string
+     * @throws \SmartyCompilerException
+     */
+    public function convertScope($_attr, $validScopes)
+    {
+        $_scope = 0;
+        if (isset($_attr[ 'scope' ])) {
+            $_scopeName = trim($_attr[ 'scope' ], '\'"');
+            if (is_numeric($_scopeName) && in_array($_scopeName, $validScopes)) {
+                $_scope = $_scopeName;
+            } elseif (is_string($_scopeName)) {
+                $_scopeName = trim($_scopeName, '\'"');
+                $_scope = isset($validScopes[ $_scopeName ]) ? $validScopes[ $_scopeName ] : false;
+            } else {
+                $_scope = false;
+            }
+            if ($_scope === false) {
+                $err = var_export($_scopeName, true);
+                $this->trigger_template_error("illegal value '{$err}' for \"scope\" attribute", null, true);
+            }
+        }
+        return $_scope;
+    }
+
+    /**
+     * Generate nocache code string
+     *
+     * @param string $code PHP code
+     *
+     * @return string
+     */
+    public function makeNocacheCode($code)
+    {
+        return "echo '/*%%SmartyNocache:{$this->nocache_hash}%%*/<?php " .
+               str_replace('^#^', '\'', addcslashes($code, '\'\\')) .
+               "?>/*/%%SmartyNocache:{$this->nocache_hash}%%*/';\n";
+    }
+
+    /**
+     * display compiler error messages without dying
+     * If parameter $args is empty it is a parser detected syntax error.
+     * In this case the parser is called to obtain information about expected tokens.
+     * If parameter $args contains a string this is used as error message
+     *
+     * @param string    $args    individual error message or null
+     * @param string    $line    line-number
+     * @param null|bool $tagline if true the line number of last tag
+     *
+     * @throws \SmartyCompilerException when an unexpected token is found
+     */
+    public function trigger_template_error($args = null, $line = null, $tagline = null)
+    {
+        $lex = $this->parser->lex;
+        if ($tagline === true) {
+            // get line number of Tag
+            $line = $lex->taglineno;
+        } elseif (!isset($line)) {
+            // get template source line which has error
+            $line = $lex->line;
+        } else {
+            $line = (int)$line;
+        }
+        if (in_array(
+            $this->template->source->type,
+            array(
+                'eval',
+                'string'
+            )
+        )
+        ) {
+            $templateName = $this->template->source->type . ':' . trim(
+                    preg_replace(
+                        '![\t\r\n]+!',
+                        ' ',
+                        strlen($lex->data) > 40 ?
+                            substr($lex->data, 0, 40) .
+                            '...' : $lex->data
+                    )
+                );
+        } else {
+            $templateName = $this->template->source->type . ':' . $this->template->source->filepath;
+        }
+        //        $line += $this->trace_line_offset;
+        $match = preg_split("/\n/", $lex->data);
+        $error_text =
+            'Syntax error in template "' . (empty($this->trace_filepath) ? $templateName : $this->trace_filepath) .
+            '"  on line ' . ($line + $this->trace_line_offset) . ' "' .
+            trim(preg_replace('![\t\r\n]+!', ' ', $match[ $line - 1 ])) . '" ';
+        if (isset($args)) {
+            // individual error message
+            $error_text .= $args;
+        } else {
+            $expect = array();
+            // expected token from parser
+            $error_text .= ' - Unexpected "' . $lex->value . '"';
+            if (count($this->parser->yy_get_expected_tokens($this->parser->yymajor)) <= 4) {
+                foreach ($this->parser->yy_get_expected_tokens($this->parser->yymajor) as $token) {
+                    $exp_token = $this->parser->yyTokenName[ $token ];
+                    if (isset($lex->smarty_token_names[ $exp_token ])) {
+                        // token type from lexer
+                        $expect[] = '"' . $lex->smarty_token_names[ $exp_token ] . '"';
+                    } else {
+                        // otherwise internal token name
+                        $expect[] = $this->parser->yyTokenName[ $token ];
+                    }
+                }
+                $error_text .= ', expected one of: ' . implode(' , ', $expect);
+            }
+        }
+        if ($this->smarty->_parserdebug) {
+            $this->parser->errorRunDown();
+            echo ob_get_clean();
+            flush();
+        }
+        $e = new SmartyCompilerException($error_text);
+        $e->line = $line;
+        $e->source = trim(preg_replace('![\t\r\n]+!', ' ', $match[ $line - 1 ]));
+        $e->desc = $args;
+        $e->template = $this->template->source->filepath;
+        throw $e;
+    }
+
+    /**
+     * Return var_export() value with all white spaces removed
+     *
+     * @param mixed $value
+     *
+     * @return string
+     */
+    public function getVarExport($value)
+    {
+        return preg_replace('/\s/', '', var_export($value, true));
+    }
+
+    /**
+     *  enter double quoted string
+     *  - save tag stack count
+     */
+    public function enterDoubleQuote()
+    {
+        array_push($this->_tag_stack_count, $this->getTagStackCount());
+    }
+
+    /**
+     * Return tag stack count
+     *
+     * @return int
+     */
+    public function getTagStackCount()
+    {
+        return count($this->_tag_stack);
+    }
+
+    /**
+     * @param $lexerPreg
+     *
+     * @return mixed
+     */
+    public function replaceDelimiter($lexerPreg)
+    {
+        return str_replace(
+            array('SMARTYldel', 'SMARTYliteral', 'SMARTYrdel', 'SMARTYautoliteral', 'SMARTYal'),
+            array(
+                $this->ldelPreg, $this->literalPreg, $this->rdelPreg,
+                $this->smarty->getAutoLiteral() ? '{1,}' : '{9}',
+                $this->smarty->getAutoLiteral() ? '' : '\\s*'
+            ),
+            $lexerPreg
+        );
+    }
+
+    /**
+     * Build lexer regular expressions for left and right delimiter and user defined literals
+     */
+    public function initDelimiterPreg()
+    {
+        $ldel = $this->smarty->getLeftDelimiter();
+        $this->ldelLength = strlen($ldel);
+        $this->ldelPreg = '';
+        foreach (str_split($ldel, 1) as $chr) {
+            $this->ldelPreg .= '[' . preg_quote($chr,'/') . ']';
+        }
+        $rdel = $this->smarty->getRightDelimiter();
+        $this->rdelLength = strlen($rdel);
+        $this->rdelPreg = '';
+        foreach (str_split($rdel, 1) as $chr) {
+            $this->rdelPreg .= '[' . preg_quote($chr,'/') . ']';
+        }
+        $literals = $this->smarty->getLiterals();
+        if (!empty($literals)) {
+            foreach ($literals as $key => $literal) {
+                $literalPreg = '';
+                foreach (str_split($literal, 1) as $chr) {
+                    $literalPreg .= '[' . preg_quote($chr,'/') . ']';
+                }
+                $literals[ $key ] = $literalPreg;
+            }
+            $this->literalPreg = '|' . implode('|', $literals);
+        } else {
+            $this->literalPreg = '';
+        }
+    }
+
+    /**
+     *  leave double quoted string
+     *  - throw exception if block in string was not closed
+     *
+     * @throws \SmartyCompilerException
+     */
+    public function leaveDoubleQuote()
+    {
+        if (array_pop($this->_tag_stack_count) !== $this->getTagStackCount()) {
+            $tag = $this->getOpenBlockTag();
+            $this->trigger_template_error(
+                "unclosed '{{$tag}}' in doubled quoted string",
+                null,
+                true
+            );
+        }
+    }
+
+    /**
+     * Get left delimiter preg
+     *
+     * @return string
+     */
+    public function getLdelPreg()
+    {
+        return $this->ldelPreg;
+    }
+
+    /**
+     * Get right delimiter preg
+     *
+     * @return string
+     */
+    public function getRdelPreg()
+    {
+        return $this->rdelPreg;
+    }
+
+    /**
+     * Get length of left delimiter
+     *
+     * @return int
+     */
+    public function getLdelLength()
+    {
+        return $this->ldelLength;
+    }
+
+    /**
+     * Get length of right delimiter
+     *
+     * @return int
+     */
+    public function getRdelLength()
+    {
+        return $this->rdelLength;
+    }
+
+    /**
+     * Get name of current open block tag
+     *
+     * @return string|boolean
+     */
+    public function getOpenBlockTag()
+    {
+        $tagCount = $this->getTagStackCount();
+        if ($tagCount) {
+            return $this->_tag_stack[ $tagCount - 1 ][ 0 ];
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Check if $value contains variable elements
+     *
+     * @param mixed $value
+     *
+     * @return bool|int
+     */
+    public function isVariable($value)
+    {
+        if (is_string($value)) {
+            return preg_match('/[$(]/', $value);
+        }
+        if (is_bool($value) || is_numeric($value)) {
+            return false;
+        }
+        if (is_array($value)) {
+            foreach ($value as $k => $v) {
+                if ($this->isVariable($k) || $this->isVariable($v)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        return false;
+    }
+
+    /**
+     * Get new prefix variable name
+     *
+     * @return string
+     */
+    public function getNewPrefixVariable()
+    {
+        ++self::$prefixVariableNumber;
+        return $this->getPrefixVariable();
+    }
+
+    /**
+     * Get current prefix variable name
+     *
+     * @return string
+     */
+    public function getPrefixVariable()
+    {
+        return '$_prefixVariable' . self::$prefixVariableNumber;
+    }
+
+    /**
+     * append  code to prefix buffer
+     *
+     * @param string $code
+     */
+    public function appendPrefixCode($code)
+    {
+        $this->prefix_code[] = $code;
+    }
+
+    /**
+     * get prefix code string
+     *
+     * @return string
+     */
+    public function getPrefixCode()
+    {
+        $code = '';
+        $prefixArray = array_merge($this->prefix_code, array_pop($this->prefixCodeStack));
+        $this->prefixCodeStack[] = array();
+        foreach ($prefixArray as $c) {
+            $code = $this->appendCode($code, $c);
+        }
+        $this->prefix_code = array();
+        return $code;
+    }
+
+    /**
+     * Save current required plugins
+     *
+     * @param bool $init if true init required plugins
+     */
+    public function saveRequiredPlugins($init = false)
+    {
+        $this->required_plugins_stack[] = $this->required_plugins;
+        if ($init) {
+            $this->required_plugins = array('compiled' => array(), 'nocache' => array());
+        }
+    }
+
+    /**
+     * Restore required plugins
+     */
+    public function restoreRequiredPlugins()
+    {
+        $this->required_plugins = array_pop($this->required_plugins_stack);
+    }
+
+    /**
+     * Compile code to call Smarty_Internal_Template::_checkPlugins()
+     * for required plugins
+     *
+     * @return string
+     */
+    public function compileRequiredPlugins()
+    {
+        $code = $this->compileCheckPlugins($this->required_plugins[ 'compiled' ]);
+        if ($this->caching && !empty($this->required_plugins[ 'nocache' ])) {
+            $code .= $this->makeNocacheCode($this->compileCheckPlugins($this->required_plugins[ 'nocache' ]));
+        }
+        return $code;
+    }
+
+    /**
+     * Compile code to call Smarty_Internal_Template::_checkPlugins
+     *   - checks if plugin is callable require otherwise
+     *
+     * @param $requiredPlugins
+     *
+     * @return string
+     */
+    public function compileCheckPlugins($requiredPlugins)
+    {
+        if (!empty($requiredPlugins)) {
+            $plugins = array();
+            foreach ($requiredPlugins as $plugin) {
+                foreach ($plugin as $data) {
+                    $plugins[] = $data;
+                }
+            }
+            return '$_smarty_tpl->_checkPlugins(' . $this->getVarExport($plugins) . ');' . "\n";
+        } else {
+            return '';
+        }
+    }
+
+    /**
+     * method to compile a Smarty template
+     *
+     * @param mixed $_content template source
+     * @param bool  $isTemplateSource
+     *
+     * @return bool true if compiling succeeded, false if it failed
+     */
+    abstract protected function doCompile($_content, $isTemplateSource = false);
+
+    public function cStyleComment($string) {
+        return '/*' . str_replace('*/', '* /' , $string) . '*/';
+    }
+
+    /**
+     * Compile Tag
+     *
+     * @param string $tag       tag name
+     * @param array  $args      array with tag attributes
+     * @param array  $parameter array with compilation parameter
+     *
+     * @throws SmartyCompilerException
+     * @throws SmartyException
+     * @return string compiled code
+     */
+    private function compileTag2($tag, $args, $parameter)
+    {
+        $plugin_type = '';
+        // $args contains the attributes parsed and compiled by the lexer/parser
+        // assume that tag does compile into code, but creates no HTML output
+        $this->has_code = true;
+        // log tag/attributes
+        if (isset($this->smarty->_cache[ 'get_used_tags' ])) {
+            $this->template->_cache[ 'used_tags' ][] = array(
+                $tag,
+                $args
+            );
+        }
+        // check nocache option flag
+        foreach ($args as $arg) {
+            if (!is_array($arg)) {
+                if ($arg === "'nocache'" || $arg === 'nocache') {
+                    $this->tag_nocache = true;
+                }
+            } else {
+                foreach ($arg as $k => $v) {
+                    if (($k === "'nocache'" || $k === 'nocache') && (trim($v, "'\" ") === 'true')) {
+                        $this->tag_nocache = true;
+                    }
+                }
+            }
+        }
+        // compile the smarty tag (required compile classes to compile the tag are auto loaded)
+        if (($_output = $this->callTagCompiler($tag, $args, $parameter)) === false) {
+            if (isset($this->parent_compiler->tpl_function[ $tag ])
+                || (isset($this->template->smarty->ext->_tplFunction)
+                    && $this->template->smarty->ext->_tplFunction->getTplFunction($this->template, $tag) !== false)
+            ) {
+                // template defined by {template} tag
+                $args[ '_attr' ][ 'name' ] = "'{$tag}'";
+                $_output = $this->callTagCompiler('call', $args, $parameter);
+            }
+        }
+        if ($_output !== false) {
+            if ($_output !== true) {
+                // did we get compiled code
+                if ($this->has_code) {
+                    // return compiled code
+                    return $_output;
+                }
+            }
+            // tag did not produce compiled code
+            return null;
+        } else {
+            // map_named attributes
+            if (isset($args[ '_attr' ])) {
+                foreach ($args[ '_attr' ] as $key => $attribute) {
+                    if (is_array($attribute)) {
+                        $args = array_merge($args, $attribute);
+                    }
+                }
+            }
+            // not an internal compiler tag
+            if (strlen($tag) < 6 || substr($tag, -5) !== 'close') {
+                // check if tag is a registered object
+                if (isset($this->smarty->registered_objects[ $tag ]) && isset($parameter[ 'object_method' ])) {
+                    $method = $parameter[ 'object_method' ];
+                    if (!in_array($method, $this->smarty->registered_objects[ $tag ][ 3 ])
+                        && (empty($this->smarty->registered_objects[ $tag ][ 1 ])
+                            || in_array($method, $this->smarty->registered_objects[ $tag ][ 1 ]))
+                    ) {
+                        return $this->callTagCompiler('private_object_function', $args, $parameter, $tag, $method);
+                    } elseif (in_array($method, $this->smarty->registered_objects[ $tag ][ 3 ])) {
+                        return $this->callTagCompiler(
+                            'private_object_block_function',
+                            $args,
+                            $parameter,
+                            $tag,
+                            $method
+                        );
+                    } else {
+                        // throw exception
+                        $this->trigger_template_error(
+                            'not allowed method "' . $method . '" in registered object "' .
+                            $tag . '"',
+                            null,
+                            true
+                        );
+                    }
+                }
+                // check if tag is registered
+                foreach (array(
+                    Smarty::PLUGIN_COMPILER,
+                    Smarty::PLUGIN_FUNCTION,
+                    Smarty::PLUGIN_BLOCK,
+                ) as $plugin_type) {
+                    if (isset($this->smarty->registered_plugins[ $plugin_type ][ $tag ])) {
+                        // if compiler function plugin call it now
+                        if ($plugin_type === Smarty::PLUGIN_COMPILER) {
+                            $new_args = array();
+                            foreach ($args as $key => $mixed) {
+                                if (is_array($mixed)) {
+                                    $new_args = array_merge($new_args, $mixed);
+                                } else {
+                                    $new_args[ $key ] = $mixed;
+                                }
+                            }
+                            if (!$this->smarty->registered_plugins[ $plugin_type ][ $tag ][ 1 ]) {
+                                $this->tag_nocache = true;
+                            }
+                            return call_user_func_array(
+                                $this->smarty->registered_plugins[ $plugin_type ][ $tag ][ 0 ],
+                                array(
+                                    $new_args,
+                                    $this
+                                )
+                            );
+                        }
+                        // compile registered function or block function
+                        if ($plugin_type === Smarty::PLUGIN_FUNCTION || $plugin_type === Smarty::PLUGIN_BLOCK) {
+                            return $this->callTagCompiler(
+                                'private_registered_' . $plugin_type,
+                                $args,
+                                $parameter,
+                                $tag
+                            );
+                        }
+                    }
+                }
+                // check plugins from plugins folder
+                foreach ($this->plugin_search_order as $plugin_type) {
+                    if ($plugin_type === Smarty::PLUGIN_COMPILER
+                        && $this->smarty->loadPlugin('smarty_compiler_' . $tag)
+                        && (!isset($this->smarty->security_policy)
+                            || $this->smarty->security_policy->isTrustedTag($tag, $this))
+                    ) {
+                        $plugin = 'smarty_compiler_' . $tag;
+                        if (is_callable($plugin)) {
+                            // convert arguments format for old compiler plugins
+                            $new_args = array();
+                            foreach ($args as $key => $mixed) {
+                                if (is_array($mixed)) {
+                                    $new_args = array_merge($new_args, $mixed);
+                                } else {
+                                    $new_args[ $key ] = $mixed;
+                                }
+                            }
+                            return $plugin($new_args, $this->smarty);
+                        }
+                        if (class_exists($plugin, false)) {
+                            $plugin_object = new $plugin;
+                            if (method_exists($plugin_object, 'compile')) {
+                                return $plugin_object->compile($args, $this);
+                            }
+                        }
+                        throw new SmartyException("Plugin '{$tag}' not callable");
+                    } else {
+                        if ($function = $this->getPlugin($tag, $plugin_type)) {
+                            if (!isset($this->smarty->security_policy)
+                                || $this->smarty->security_policy->isTrustedTag($tag, $this)
+                            ) {
+                                return $this->callTagCompiler(
+                                    'private_' . $plugin_type . '_plugin',
+                                    $args,
+                                    $parameter,
+                                    $tag,
+                                    $function
+                                );
+                            }
+                        }
+                    }
+                }
+                if (is_callable($this->smarty->default_plugin_handler_func)) {
+                    $found = false;
+                    // look for already resolved tags
+                    foreach ($this->plugin_search_order as $plugin_type) {
+                        if (isset($this->default_handler_plugins[ $plugin_type ][ $tag ])) {
+                            $found = true;
+                            break;
+                        }
+                    }
+                    if (!$found) {
+                        // call default handler
+                        foreach ($this->plugin_search_order as $plugin_type) {
+                            if ($this->getPluginFromDefaultHandler($tag, $plugin_type)) {
+                                $found = true;
+                                break;
+                            }
+                        }
+                    }
+                    if ($found) {
+                        // if compiler function plugin call it now
+                        if ($plugin_type === Smarty::PLUGIN_COMPILER) {
+                            $new_args = array();
+                            foreach ($args as $key => $mixed) {
+                                if (is_array($mixed)) {
+                                    $new_args = array_merge($new_args, $mixed);
+                                } else {
+                                    $new_args[ $key ] = $mixed;
+                                }
+                            }
+                            return call_user_func_array(
+                                $this->default_handler_plugins[ $plugin_type ][ $tag ][ 0 ],
+                                array(
+                                    $new_args,
+                                    $this
+                                )
+                            );
+                        } else {
+                            return $this->callTagCompiler(
+                                'private_registered_' . $plugin_type,
+                                $args,
+                                $parameter,
+                                $tag
+                            );
+                        }
+                    }
+                }
+            } else {
+                // compile closing tag of block function
+                $base_tag = substr($tag, 0, -5);
+                // check if closing tag is a registered object
+                if (isset($this->smarty->registered_objects[ $base_tag ]) && isset($parameter[ 'object_method' ])) {
+                    $method = $parameter[ 'object_method' ];
+                    if (in_array($method, $this->smarty->registered_objects[ $base_tag ][ 3 ])) {
+                        return $this->callTagCompiler(
+                            'private_object_block_function',
+                            $args,
+                            $parameter,
+                            $tag,
+                            $method
+                        );
+                    } else {
+                        // throw exception
+                        $this->trigger_template_error(
+                            'not allowed closing tag method "' . $method .
+                            '" in registered object "' . $base_tag . '"',
+                            null,
+                            true
+                        );
+                    }
+                }
+                // registered block tag ?
+                if (isset($this->smarty->registered_plugins[ Smarty::PLUGIN_BLOCK ][ $base_tag ])
+                    || isset($this->default_handler_plugins[ Smarty::PLUGIN_BLOCK ][ $base_tag ])
+                ) {
+                    return $this->callTagCompiler('private_registered_block', $args, $parameter, $tag);
+                }
+                // registered function tag ?
+                if (isset($this->smarty->registered_plugins[ Smarty::PLUGIN_FUNCTION ][ $tag ])) {
+                    return $this->callTagCompiler('private_registered_function', $args, $parameter, $tag);
+                }
+                // block plugin?
+                if ($function = $this->getPlugin($base_tag, Smarty::PLUGIN_BLOCK)) {
+                    return $this->callTagCompiler('private_block_plugin', $args, $parameter, $tag, $function);
+                }
+                // function plugin?
+                if ($function = $this->getPlugin($tag, Smarty::PLUGIN_FUNCTION)) {
+                    if (!isset($this->smarty->security_policy)
+                        || $this->smarty->security_policy->isTrustedTag($tag, $this)
+                    ) {
+                        return $this->callTagCompiler('private_function_plugin', $args, $parameter, $tag, $function);
+                    }
+                }
+                // registered compiler plugin ?
+                if (isset($this->smarty->registered_plugins[ Smarty::PLUGIN_COMPILER ][ $tag ])) {
+                    // if compiler function plugin call it now
+                    $args = array();
+                    if (!$this->smarty->registered_plugins[ Smarty::PLUGIN_COMPILER ][ $tag ][ 1 ]) {
+                        $this->tag_nocache = true;
+                    }
+                    return call_user_func_array(
+                        $this->smarty->registered_plugins[ Smarty::PLUGIN_COMPILER ][ $tag ][ 0 ],
+                        array(
+                            $args,
+                            $this
+                        )
+                    );
+                }
+                if ($this->smarty->loadPlugin('smarty_compiler_' . $tag)) {
+                    $plugin = 'smarty_compiler_' . $tag;
+                    if (is_callable($plugin)) {
+                        return $plugin($args, $this->smarty);
+                    }
+                    if (class_exists($plugin, false)) {
+                        $plugin_object = new $plugin;
+                        if (method_exists($plugin_object, 'compile')) {
+                            return $plugin_object->compile($args, $this);
+                        }
+                    }
+                    throw new SmartyException("Plugin '{$tag}' not callable");
+                }
+            }
+            $this->trigger_template_error("unknown tag '{$tag}'", null, true);
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_templatelexer.php b/epgrec/Smarty/sysplugins/smarty_internal_templatelexer.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_templatelexer.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_templatelexer.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,1095 @@
+<?php
+/*
+ * This file is part of Smarty.
+ *
+ * (c) 2015 Uwe Tews
+ *
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * Smarty_Internal_Templatelexer
+ * This is the template file lexer.
+ * It is generated from the smarty_internal_templatelexer.plex file
+ *
+ *
+ * @author Uwe Tews <uwe.tews@googlemail.com>
+ */
+class Smarty_Internal_Templatelexer
+{
+    const TEXT               = 1;
+    const TAG                = 2;
+    const TAGBODY            = 3;
+    const LITERAL            = 4;
+    const DOUBLEQUOTEDSTRING = 5;
+
+    /**
+     * Source
+     *
+     * @var string
+     */
+    public $data;
+
+    /**
+     * Source length
+     *
+     * @var int
+     */
+    public $dataLength = null;
+
+    /**
+     * byte counter
+     *
+     * @var int
+     */
+    public $counter;
+
+    /**
+     * token number
+     *
+     * @var int
+     */
+    public $token;
+
+    /**
+     * token value
+     *
+     * @var string
+     */
+    public $value;
+
+    /**
+     * current line
+     *
+     * @var int
+     */
+    public $line;
+
+    /**
+     * tag start line
+     *
+     * @var
+     */
+    public $taglineno;
+
+    /**
+     * php code type
+     *
+     * @var string
+     */
+    public $phpType = '';
+
+    /**
+     * state number
+     *
+     * @var int
+     */
+    public $state = 1;
+
+    /**
+     * Smarty object
+     *
+     * @var Smarty
+     */
+    public $smarty = null;
+
+    /**
+     * compiler object
+     *
+     * @var Smarty_Internal_TemplateCompilerBase
+     */
+    public $compiler = null;
+
+    /**
+     * trace file
+     *
+     * @var resource
+     */
+    public $yyTraceFILE;
+
+    /**
+     * trace prompt
+     *
+     * @var string
+     */
+    public $yyTracePrompt;
+
+    /**
+     * XML flag true while processing xml
+     *
+     * @var bool
+     */
+    public $is_xml = false;
+
+    /**
+     * state names
+     *
+     * @var array
+     */
+    public $state_name = array(1 => 'TEXT', 2 => 'TAG', 3 => 'TAGBODY', 4 => 'LITERAL', 5 => 'DOUBLEQUOTEDSTRING',);
+
+    /**
+     * token names
+     *
+     * @var array
+     */
+    public $smarty_token_names = array(        // Text for parser error messages
+                                               'NOT'         => '(!,not)',
+                                               'OPENP'       => '(',
+                                               'CLOSEP'      => ')',
+                                               'OPENB'       => '[',
+                                               'CLOSEB'      => ']',
+                                               'PTR'         => '->',
+                                               'APTR'        => '=>',
+                                               'EQUAL'       => '=',
+                                               'NUMBER'      => 'number',
+                                               'UNIMATH'     => '+" , "-',
+                                               'MATH'        => '*" , "/" , "%',
+                                               'INCDEC'      => '++" , "--',
+                                               'SPACE'       => ' ',
+                                               'DOLLAR'      => '$',
+                                               'SEMICOLON'   => ';',
+                                               'COLON'       => ':',
+                                               'DOUBLECOLON' => '::',
+                                               'AT'          => '@',
+                                               'HATCH'       => '#',
+                                               'QUOTE'       => '"',
+                                               'BACKTICK'    => '`',
+                                               'VERT'        => '"|" modifier',
+                                               'DOT'         => '.',
+                                               'COMMA'       => '","',
+                                               'QMARK'       => '"?"',
+                                               'ID'          => 'id, name',
+                                               'TEXT'        => 'text',
+                                               'LDELSLASH'   => '{/..} closing tag',
+                                               'LDEL'        => '{...} Smarty tag',
+                                               'COMMENT'     => 'comment',
+                                               'AS'          => 'as',
+                                               'TO'          => 'to',
+                                               'PHP'         => '"<?php", "<%", "{php}" tag',
+                                               'LOGOP'       => '"<", "==" ... logical operator',
+                                               'TLOGOP'      => '"lt", "eq" ... logical operator; "is div by" ... if condition',
+                                               'SCOND'       => '"is even" ... if condition',
+    );
+
+    /**
+     * literal tag nesting level
+     *
+     * @var int
+     */
+    private $literal_cnt = 0;
+
+    /**
+     * preg token pattern for state TEXT
+     *
+     * @var string
+     */
+    private $yy_global_pattern1 = null;
+
+    /**
+     * preg token pattern for state TAG
+     *
+     * @var string
+     */
+    private $yy_global_pattern2 = null;
+
+    /**
+     * preg token pattern for state TAGBODY
+     *
+     * @var string
+     */
+    private $yy_global_pattern3 = null;
+
+    /**
+     * preg token pattern for state LITERAL
+     *
+     * @var string
+     */
+    private $yy_global_pattern4 = null;
+
+    /**
+     * preg token pattern for state DOUBLEQUOTEDSTRING
+     *
+     * @var null
+     */
+    private $yy_global_pattern5 = null;
+
+    /**
+     * preg token pattern for text
+     *
+     * @var null
+     */
+    private $yy_global_text = null;
+
+    /**
+     * preg token pattern for literal
+     *
+     * @var null
+     */
+    private $yy_global_literal = null;
+
+    private $_yy_state         = 1;
+
+    private $_yy_stack         = array();
+
+    /**
+     * constructor
+     *
+     * @param   string                             $source template source
+     * @param Smarty_Internal_TemplateCompilerBase $compiler
+     */
+    public function __construct($source, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $this->data = $source;
+        $this->dataLength = strlen($this->data);
+        $this->counter = 0;
+        if (preg_match('/^\xEF\xBB\xBF/i', $this->data, $match)) {
+            $this->counter += strlen($match[ 0 ]);
+        }
+        $this->line = 1;
+        $this->smarty = $compiler->template->smarty;
+        $this->compiler = $compiler;
+        $this->compiler->initDelimiterPreg();
+        $this->smarty_token_names[ 'LDEL' ] = $this->smarty->getLeftDelimiter();
+        $this->smarty_token_names[ 'RDEL' ] = $this->smarty->getRightDelimiter();
+    }
+
+    /**
+     * open lexer/parser trace file
+     *
+     */
+    public function PrintTrace()
+    {
+        $this->yyTraceFILE = fopen('php://output', 'w');
+        $this->yyTracePrompt = '<br>';
+    }
+
+    /**
+     * replace placeholders with runtime preg  code
+     *
+     * @param string $preg
+     *
+     * @return string
+     */
+    public function replace($preg)
+    {
+        return $this->compiler->replaceDelimiter($preg);
+    }
+
+    /**
+     * check if current value is an autoliteral left delimiter
+     *
+     * @return bool
+     */
+    public function isAutoLiteral()
+    {
+        return $this->smarty->getAutoLiteral() && isset($this->value[ $this->compiler->getLdelLength() ]) ?
+            strpos(" \n\t\r", $this->value[ $this->compiler->getLdelLength() ]) !== false : false;
+    } // end function
+
+    public function yylex()
+    {
+        return $this->{'yylex' . $this->_yy_state}();
+    }
+
+    public function yypushstate($state)
+    {
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sState push %s\n", $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state);
+        }
+        array_push($this->_yy_stack, $this->_yy_state);
+        $this->_yy_state = $state;
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%snew State %s\n", $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state);
+        }
+    }
+
+    public function yypopstate()
+    {
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sState pop %s\n", $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state);
+        }
+        $this->_yy_state = array_pop($this->_yy_stack);
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%snew State %s\n", $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state);
+        }
+    }
+
+    public function yybegin($state)
+    {
+        $this->_yy_state = $state;
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sState set %s\n", $this->yyTracePrompt,
+                isset($this->state_name[ $this->_yy_state ]) ? $this->state_name[ $this->_yy_state ] : $this->_yy_state);
+        }
+    }
+
+    public function yylex1()
+    {
+        if (!isset($this->yy_global_pattern1)) {
+            $this->yy_global_pattern1 =
+                $this->replace("/\G([{][}])|\G((SMARTYldel)SMARTYal[*])|\G((SMARTYldel)SMARTYalphp([ ].*?)?SMARTYrdel|(SMARTYldel)SMARTYal[\/]phpSMARTYrdel)|\G((SMARTYldel)SMARTYautoliteral\\s+SMARTYliteral)|\G((SMARTYldel)SMARTYalliteral\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[\/]literal\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal)|\G([<][?]((php\\s+|=)|\\s+)|[<][%]|[<][?]xml\\s+|[<]script\\s+language\\s*=\\s*[\"']?\\s*php\\s*[\"']?\\s*[>]|[?][>]|[%][>])|\G([\S\s])/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern1, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr($this->data,
+                            $this->counter, 5) . '... state TEXT');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r1_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line ' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r1_1()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yy_r1_2()
+    {
+        $to = $this->dataLength;
+        preg_match("/[*]{$this->compiler->getRdelPreg()}[\n]?/", $this->data, $match, PREG_OFFSET_CAPTURE,
+            $this->counter);
+        if (isset($match[ 0 ][ 1 ])) {
+            $to = $match[ 0 ][ 1 ] + strlen($match[ 0 ][ 0 ]);
+        } else {
+            $this->compiler->trigger_template_error("missing or misspelled comment closing tag '{$this->smarty->getRightDelimiter()}'");
+        }
+        $this->value = substr($this->data, $this->counter, $to - $this->counter);
+        return false;
+    }
+
+    public function yy_r1_4()
+    {
+        $this->compiler->getTagCompiler('private_php')->parsePhp($this);
+    }
+
+    public function yy_r1_8()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yy_r1_10()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LITERALSTART;
+        $this->yypushstate(self::LITERAL);
+    }
+
+    public function yy_r1_12()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LITERALEND;
+        $this->yypushstate(self::LITERAL);
+    } // end function
+
+    public function yy_r1_14()
+    {
+        $this->yypushstate(self::TAG);
+        return true;
+    }
+
+    public function yy_r1_16()
+    {
+        $this->compiler->getTagCompiler('private_php')->parsePhp($this);
+    }
+
+    public function yy_r1_19()
+    {
+        if (!isset($this->yy_global_text)) {
+            $this->yy_global_text =
+                $this->replace('/(SMARTYldel)SMARTYal|[<][?]((php\s+|=)|\s+)|[<][%]|[<][?]xml\s+|[<]script\s+language\s*=\s*["\']?\s*php\s*["\']?\s*[>]|[?][>]|[%][>]SMARTYliteral/isS');
+        }
+        $to = $this->dataLength;
+        preg_match($this->yy_global_text, $this->data, $match, PREG_OFFSET_CAPTURE, $this->counter);
+        if (isset($match[ 0 ][ 1 ])) {
+            $to = $match[ 0 ][ 1 ];
+        }
+        $this->value = substr($this->data, $this->counter, $to - $this->counter);
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yylex2()
+    {
+        if (!isset($this->yy_global_pattern2)) {
+            $this->yy_global_pattern2 =
+                $this->replace("/\G((SMARTYldel)SMARTYal(if|elseif|else if|while)\\s+)|\G((SMARTYldel)SMARTYalfor\\s+)|\G((SMARTYldel)SMARTYalforeach(?![^\s]))|\G((SMARTYldel)SMARTYalsetfilter\\s+)|\G((SMARTYldel)SMARTYalmake_nocache\\s+)|\G((SMARTYldel)SMARTYal[0-9]*[a-zA-Z_]\\w*(\\s+nocache)?\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[$]smarty\\.block\\.(child|parent)\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[\/][0-9]*[a-zA-Z_]\\w*\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[$][0-9]*[a-zA-Z_]\\w*(\\s+nocache)?\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[\/])|\G((SMARTYldel)SMARTYal)/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern2, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr($this->data,
+                            $this->counter, 5) . '... state TAG');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r2_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line ' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r2_1()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDELIF;
+        $this->yybegin(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_4()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDELFOR;
+        $this->yybegin(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_6()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDELFOREACH;
+        $this->yybegin(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_8()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDELSETFILTER;
+        $this->yybegin(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_10()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDELMAKENOCACHE;
+        $this->yybegin(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_12()
+    {
+        $this->yypopstate();
+        $this->token = Smarty_Internal_Templateparser::TP_SIMPLETAG;
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_15()
+    {
+        $this->yypopstate();
+        $this->token = Smarty_Internal_Templateparser::TP_SMARTYBLOCKCHILDPARENT;
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_18()
+    {
+        $this->yypopstate();
+        $this->token = Smarty_Internal_Templateparser::TP_CLOSETAG;
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_20()
+    {
+        if ($this->_yy_stack[ count($this->_yy_stack) - 1 ] === self::TEXT) {
+            $this->yypopstate();
+            $this->token = Smarty_Internal_Templateparser::TP_SIMPELOUTPUT;
+            $this->taglineno = $this->line;
+        } else {
+            $this->value = $this->smarty->getLeftDelimiter();
+            $this->token = Smarty_Internal_Templateparser::TP_LDEL;
+            $this->yybegin(self::TAGBODY);
+            $this->taglineno = $this->line;
+        }
+    } // end function
+
+    public function yy_r2_23()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDELSLASH;
+        $this->yybegin(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r2_25()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDEL;
+        $this->yybegin(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yylex3()
+    {
+        if (!isset($this->yy_global_pattern3)) {
+            $this->yy_global_pattern3 =
+                $this->replace("/\G(\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal)|\G([\"])|\G('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|\G([$][0-9]*[a-zA-Z_]\\w*)|\G([$])|\G(\\s+is\\s+in\\s+)|\G(\\s+as\\s+)|\G(\\s+to\\s+)|\G(\\s+step\\s+)|\G(\\s+instanceof\\s+)|\G(\\s*([!=][=]{1,2}|[<][=>]?|[>][=]?|[&|]{2})\\s*)|\G(\\s+(eq|ne|neq|gt|ge|gte|lt|le|lte|mod|and|or|xor)\\s+)|\G(\\s+is\\s+(not\\s+)?(odd|even|div)\\s+by\\s+)|\G(\\s+is\\s+(not\\s+)?(odd|even))|\G([!]\\s*|not\\s+)|\G([(](int(eger)?|bool(ean)?|float|double|real|string|binary|array|object)[)]\\s*)|\G(\\s*[(]\\s*)|\G(\\s*[)])|\G(\\[\\s*)|\G(\\s*\\])|\G(\\s*[-][>]\\s*)|\G(\\s*[=][>]\\s*)|\G(\\s*[=]\\s*)|\G(([+]|[-]){2})|\G(\\s*([+]|[-])\\s*)|\G(\\s*([*]{1,2}|[%\/^&]|[<>]{2})\\s*)|\G([@])|\G(array\\s*[(]\\s*)|\G([#])|\G(\\s+[0-9]*[a-zA-Z_][a-zA-Z0-9_\-:]*\\s*[=]\\s*)|\G(([0-9]*[a-zA-Z_]\\w*)?(\\\\[0-9]*[a-zA-Z_]\\w*)+)|\G([0-9]*[a-zA-Z_]\\w*)|\G(\\d+)|\G([`])|\G([|][@]?)|\G([.])|\G(\\s*[,]\\s*)|\G(\\s*[;]\\s*)|\G([:]{2})|\G(\\s*[:]\\s*)|\G(\\s*[?]\\s*)|\G(0[xX][0-9a-fA-F]+)|\G(\\s+)|\G([\S\s])/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern3, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr($this->data,
+                            $this->counter, 5) . '... state TAGBODY');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r3_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line ' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r3_1()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_RDEL;
+        $this->yypopstate();
+    }
+
+    public function yy_r3_2()
+    {
+        $this->yypushstate(self::TAG);
+        return true;
+    }
+
+    public function yy_r3_4()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_QUOTE;
+        $this->yypushstate(self::DOUBLEQUOTEDSTRING);
+        $this->compiler->enterDoubleQuote();
+    }
+
+    public function yy_r3_5()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_SINGLEQUOTESTRING;
+    }
+
+    public function yy_r3_6()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_DOLLARID;
+    }
+
+    public function yy_r3_7()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_DOLLAR;
+    }
+
+    public function yy_r3_8()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_ISIN;
+    }
+
+    public function yy_r3_9()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_AS;
+    }
+
+    public function yy_r3_10()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TO;
+    }
+
+    public function yy_r3_11()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_STEP;
+    }
+
+    public function yy_r3_12()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_INSTANCEOF;
+    }
+
+    public function yy_r3_13()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LOGOP;
+    }
+
+    public function yy_r3_15()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_SLOGOP;
+    }
+
+    public function yy_r3_17()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TLOGOP;
+    }
+
+    public function yy_r3_20()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_SINGLECOND;
+    }
+
+    public function yy_r3_23()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_NOT;
+    }
+
+    public function yy_r3_24()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TYPECAST;
+    }
+
+    public function yy_r3_28()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_OPENP;
+    }
+
+    public function yy_r3_29()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_CLOSEP;
+    }
+
+    public function yy_r3_30()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_OPENB;
+    }
+
+    public function yy_r3_31()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_CLOSEB;
+    }
+
+    public function yy_r3_32()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_PTR;
+    }
+
+    public function yy_r3_33()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_APTR;
+    }
+
+    public function yy_r3_34()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_EQUAL;
+    }
+
+    public function yy_r3_35()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_INCDEC;
+    }
+
+    public function yy_r3_37()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_UNIMATH;
+    }
+
+    public function yy_r3_39()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_MATH;
+    }
+
+    public function yy_r3_41()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_AT;
+    }
+
+    public function yy_r3_42()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_ARRAYOPEN;
+    }
+
+    public function yy_r3_43()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_HATCH;
+    }
+
+    public function yy_r3_44()
+    {
+        // resolve conflicts with shorttag and right_delimiter starting with '='
+        if (substr($this->data, $this->counter + strlen($this->value) - 1, $this->compiler->getRdelLength()) ===
+            $this->smarty->getRightDelimiter()) {
+            preg_match('/\s+/', $this->value, $match);
+            $this->value = $match[ 0 ];
+            $this->token = Smarty_Internal_Templateparser::TP_SPACE;
+        } else {
+            $this->token = Smarty_Internal_Templateparser::TP_ATTR;
+        }
+    }
+
+    public function yy_r3_45()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_NAMESPACE;
+    }
+
+    public function yy_r3_48()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_ID;
+    }
+
+    public function yy_r3_49()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_INTEGER;
+    }
+
+    public function yy_r3_50()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_BACKTICK;
+        $this->yypopstate();
+    }
+
+    public function yy_r3_51()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_VERT;
+    }
+
+    public function yy_r3_52()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_DOT;
+    }
+
+    public function yy_r3_53()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_COMMA;
+    }
+
+    public function yy_r3_54()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_SEMICOLON;
+    }
+
+    public function yy_r3_55()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_DOUBLECOLON;
+    }
+
+    public function yy_r3_56()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_COLON;
+    }
+
+    public function yy_r3_57()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_QMARK;
+    }
+
+    public function yy_r3_58()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_HEX;
+    }
+
+    public function yy_r3_59()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_SPACE;
+    } // end function
+
+    public function yy_r3_60()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yylex4()
+    {
+        if (!isset($this->yy_global_pattern4)) {
+            $this->yy_global_pattern4 =
+                $this->replace("/\G((SMARTYldel)SMARTYalliteral\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[\/]literal\\s*SMARTYrdel)|\G([\S\s])/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern4, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr($this->data,
+                            $this->counter, 5) . '... state LITERAL');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r4_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line ' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r4_1()
+    {
+        $this->literal_cnt++;
+        $this->token = Smarty_Internal_Templateparser::TP_LITERAL;
+    }
+
+    public function yy_r4_3()
+    {
+        if ($this->literal_cnt) {
+            $this->literal_cnt--;
+            $this->token = Smarty_Internal_Templateparser::TP_LITERAL;
+        } else {
+            $this->token = Smarty_Internal_Templateparser::TP_LITERALEND;
+            $this->yypopstate();
+        }
+    }
+
+    public function yy_r4_5()
+    {
+        if (!isset($this->yy_global_literal)) {
+            $this->yy_global_literal = $this->replace('/(SMARTYldel)SMARTYal[\/]?literalSMARTYrdel/isS');
+        }
+        $to = $this->dataLength;
+        preg_match($this->yy_global_literal, $this->data, $match, PREG_OFFSET_CAPTURE, $this->counter);
+        if (isset($match[ 0 ][ 1 ])) {
+            $to = $match[ 0 ][ 1 ];
+        } else {
+            $this->compiler->trigger_template_error("missing or misspelled literal closing tag");
+        }
+        $this->value = substr($this->data, $this->counter, $to - $this->counter);
+        $this->token = Smarty_Internal_Templateparser::TP_LITERAL;
+    } // end function
+
+    public function yylex5()
+    {
+        if (!isset($this->yy_global_pattern5)) {
+            $this->yy_global_pattern5 =
+                $this->replace("/\G((SMARTYldel)SMARTYautoliteral\\s+SMARTYliteral)|\G((SMARTYldel)SMARTYalliteral\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[\/]literal\\s*SMARTYrdel)|\G((SMARTYldel)SMARTYal[\/])|\G((SMARTYldel)SMARTYal[0-9]*[a-zA-Z_]\\w*)|\G((SMARTYldel)SMARTYal)|\G([\"])|\G([`][$])|\G([$][0-9]*[a-zA-Z_]\\w*)|\G([$])|\G(([^\"\\\\]*?)((?:\\\\.[^\"\\\\]*?)*?)(?=((SMARTYldel)SMARTYal|\\$|`\\$|\"SMARTYliteral)))|\G([\S\s])/isS");
+        }
+        if (!isset($this->dataLength)) {
+            $this->dataLength = strlen($this->data);
+        }
+        if ($this->counter >= $this->dataLength) {
+            return false; // end of input
+        }
+        do {
+            if (preg_match($this->yy_global_pattern5, $this->data, $yymatches, 0, $this->counter)) {
+                if (!isset($yymatches[ 0 ][ 1 ])) {
+                    $yymatches = preg_grep("/(.|\s)+/", $yymatches);
+                } else {
+                    $yymatches = array_filter($yymatches);
+                }
+                if (empty($yymatches)) {
+                    throw new Exception('Error: lexing failed because a rule matched' .
+                                        ' an empty string.  Input "' . substr($this->data,
+                            $this->counter, 5) . '... state DOUBLEQUOTEDSTRING');
+                }
+                next($yymatches); // skip global match
+                $this->token = key($yymatches); // token number
+                $this->value = current($yymatches); // token value
+                $r = $this->{'yy_r5_' . $this->token}();
+                if ($r === null) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    // accept this token
+                    return true;
+                } elseif ($r === true) {
+                    // we have changed state
+                    // process this token in the new state
+                    return $this->yylex();
+                } elseif ($r === false) {
+                    $this->counter += strlen($this->value);
+                    $this->line += substr_count($this->value, "\n");
+                    if ($this->counter >= $this->dataLength) {
+                        return false; // end of input
+                    }
+                    // skip this token
+                    continue;
+                }
+            } else {
+                throw new Exception('Unexpected input at line ' . $this->line .
+                                    ': ' . $this->data[ $this->counter ]);
+            }
+            break;
+        } while (true);
+    }
+
+    public function yy_r5_1()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yy_r5_3()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yy_r5_5()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yy_r5_7()
+    {
+        $this->yypushstate(self::TAG);
+        return true;
+    }
+
+    public function yy_r5_9()
+    {
+        $this->yypushstate(self::TAG);
+        return true;
+    }
+
+    public function yy_r5_11()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_LDEL;
+        $this->taglineno = $this->line;
+        $this->yypushstate(self::TAGBODY);
+    }
+
+    public function yy_r5_13()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_QUOTE;
+        $this->yypopstate();
+    }
+
+    public function yy_r5_14()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_BACKTICK;
+        $this->value = substr($this->value, 0, -1);
+        $this->yypushstate(self::TAGBODY);
+        $this->taglineno = $this->line;
+    }
+
+    public function yy_r5_15()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_DOLLARID;
+    }
+
+    public function yy_r5_16()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yy_r5_17()
+    {
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+
+    public function yy_r5_22()
+    {
+        $to = $this->dataLength;
+        $this->value = substr($this->data, $this->counter, $to - $this->counter);
+        $this->token = Smarty_Internal_Templateparser::TP_TEXT;
+    }
+}
+
+     
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_templateparser.php b/epgrec/Smarty/sysplugins/smarty_internal_templateparser.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_templateparser.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_templateparser.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,3627 @@
+<?php
+
+class TP_yyStackEntry
+{
+    public $stateno;       /* The state-number */
+    public $major;         /* The major token value.  This is the code
+                     ** number for the token at this stack level */
+    public $minor; /* The user-supplied minor token value.  This
+                     ** is the value of the token  */
+}
+
+// line 11 "../smarty/lexer/smarty_internal_templateparser.y"
+
+/**
+ * Smarty Template Parser Class
+ *
+ * This is the template parser.
+ * It is generated from the smarty_internal_templateparser.y file
+ *
+ * @author Uwe Tews <uwe.tews@googlemail.com>
+ */
+class Smarty_Internal_Templateparser
+{
+    // line 23 "../smarty/lexer/smarty_internal_templateparser.y"
+    const ERR1                      = 'Security error: Call to private object member not allowed';
+    const ERR2                      = 'Security error: Call to dynamic object member not allowed';
+    const ERR3                      = 'PHP in template not allowed. Use SmartyBC to enable it';
+    const TP_VERT                   = 1;
+    const TP_COLON                  = 2;
+    const TP_PHP                    = 3;
+    const TP_TEXT                   = 4;
+    const TP_STRIPON                = 5;
+    const TP_STRIPOFF               = 6;
+    const TP_LITERALSTART           = 7;
+    const TP_LITERALEND             = 8;
+    const TP_LITERAL                = 9;
+    const TP_SIMPELOUTPUT           = 10;
+    const TP_SIMPLETAG              = 11;
+    const TP_SMARTYBLOCKCHILDPARENT = 12;
+    const TP_LDEL                   = 13;
+    const TP_RDEL                   = 14;
+    const TP_DOLLARID               = 15;
+    const TP_EQUAL                  = 16;
+    const TP_ID                     = 17;
+    const TP_PTR                    = 18;
+    const TP_LDELMAKENOCACHE        = 19;
+    const TP_LDELIF                 = 20;
+    const TP_LDELFOR                = 21;
+    const TP_SEMICOLON              = 22;
+    const TP_INCDEC                 = 23;
+    const TP_TO                     = 24;
+    const TP_STEP                   = 25;
+    const TP_LDELFOREACH            = 26;
+    const TP_SPACE                  = 27;
+    const TP_AS                     = 28;
+    const TP_APTR                   = 29;
+    const TP_LDELSETFILTER          = 30;
+    const TP_CLOSETAG               = 31;
+    const TP_LDELSLASH              = 32;
+    const TP_ATTR                   = 33;
+    const TP_INTEGER                = 34;
+    const TP_COMMA                  = 35;
+    const TP_OPENP                  = 36;
+    const TP_CLOSEP                 = 37;
+    const TP_MATH                   = 38;
+    const TP_UNIMATH                = 39;
+    const TP_ISIN                   = 40;
+    const TP_QMARK                  = 41;
+    const TP_NOT                    = 42;
+    const TP_TYPECAST               = 43;
+    const TP_HEX                    = 44;
+    const TP_DOT                    = 45;
+    const TP_INSTANCEOF             = 46;
+    const TP_SINGLEQUOTESTRING      = 47;
+    const TP_DOUBLECOLON            = 48;
+    const TP_NAMESPACE              = 49;
+    const TP_AT                     = 50;
+    const TP_HATCH                  = 51;
+    const TP_OPENB                  = 52;
+    const TP_CLOSEB                 = 53;
+    const TP_DOLLAR                 = 54;
+    const TP_LOGOP                  = 55;
+    const TP_SLOGOP                 = 56;
+    const TP_TLOGOP                 = 57;
+    const TP_SINGLECOND             = 58;
+    const TP_ARRAYOPEN              = 59;
+    const TP_QUOTE                  = 60;
+    const TP_BACKTICK               = 61;
+    const YY_NO_ACTION              = 516;
+    const YY_ACCEPT_ACTION          = 515;
+    const YY_ERROR_ACTION           = 514;
+    const YY_SZ_ACTTAB              = 2071;
+    const YY_SHIFT_USE_DFLT         = -31;
+    const YY_SHIFT_MAX              = 230;
+    const YY_REDUCE_USE_DFLT        = -91;
+    const YY_REDUCE_MAX             = 178;
+    const YYNOCODE                  = 110;
+    const YYSTACKDEPTH              = 500;
+    const YYNSTATE                  = 327;
+    const YYNRULE                   = 187;
+    const YYERRORSYMBOL             = 62;
+    const YYERRSYMDT                = 'yy0';
+    const YYFALLBACK                = 0;
+
+    public static $yy_action        = array(
+        251, 234, 237, 1, 144, 127, 428, 184, 199, 212,
+        10, 54, 19, 175, 282, 215, 109, 389, 428, 428,
+        224, 321, 223, 303, 203, 389, 13, 389, 281, 43,
+        389, 428, 41, 40, 266, 225, 389, 213, 389, 194,
+        389, 52, 4, 308, 301, 383, 34, 209, 222, 3,
+        50, 153, 251, 234, 237, 1, 199, 131, 383, 198,
+        305, 212, 10, 54, 383, 16, 199, 428, 109, 385,
+        132, 18, 224, 321, 223, 222, 221, 12, 32, 428,
+        116, 43, 385, 262, 41, 40, 266, 225, 385, 233,
+        95, 194, 16, 52, 4, 131, 301, 252, 18, 265,
+        164, 3, 50, 324, 251, 234, 237, 1, 23, 130,
+        229, 198, 150, 212, 10, 54, 326, 11, 170, 284,
+        109, 42, 22, 239, 224, 321, 223, 193, 221, 261,
+        13, 52, 157, 43, 301, 286, 41, 40, 266, 225,
+        205, 233, 5, 194, 96, 52, 4, 263, 301, 301,
+        99, 349, 96, 3, 50, 199, 251, 234, 237, 1,
+        238, 130, 241, 181, 349, 212, 10, 54, 382, 240,
+        349, 36, 109, 185, 104, 256, 224, 321, 223, 132,
+        191, 382, 13, 49, 91, 43, 12, 382, 41, 40,
+        266, 225, 257, 233, 152, 194, 457, 52, 4, 457,
+        301, 301, 228, 457, 282, 3, 50, 285, 251, 234,
+        237, 1, 301, 131, 441, 198, 238, 212, 10, 54,
+        349, 441, 325, 175, 109, 30, 349, 273, 224, 321,
+        223, 20, 221, 295, 32, 211, 457, 39, 166, 49,
+        41, 40, 266, 225, 87, 233, 205, 194, 279, 52,
+        4, 24, 301, 204, 200, 280, 99, 3, 50, 199,
+        251, 234, 237, 1, 31, 130, 96, 198, 205, 212,
+        10, 54, 350, 55, 293, 207, 109, 283, 99, 96,
+        224, 321, 223, 199, 180, 350, 13, 134, 230, 43,
+        222, 350, 41, 40, 266, 225, 104, 233, 316, 194,
+        279, 52, 4, 24, 301, 165, 284, 280, 85, 3,
+        50, 25, 251, 234, 237, 1, 131, 129, 210, 198,
+        14, 212, 10, 54, 269, 270, 301, 116, 109, 295,
+        216, 211, 224, 321, 223, 171, 221, 95, 13, 28,
+        219, 43, 323, 9, 41, 40, 266, 225, 151, 233,
+        324, 194, 52, 52, 4, 301, 301, 30, 282, 302,
+        178, 3, 50, 7, 251, 234, 237, 1, 136, 130,
+        304, 179, 238, 212, 10, 54, 279, 175, 282, 24,
+        109, 238, 429, 280, 224, 321, 223, 177, 221, 270,
+        13, 255, 281, 43, 429, 49, 41, 40, 266, 225,
+        275, 233, 318, 194, 49, 52, 4, 276, 301, 163,
+        26, 199, 8, 3, 50, 119, 251, 234, 237, 1,
+        11, 93, 291, 51, 107, 212, 10, 54, 226, 428,
+        206, 201, 109, 148, 178, 322, 224, 321, 223, 441,
+        221, 428, 13, 282, 9, 43, 441, 115, 41, 40,
+        266, 225, 167, 233, 227, 194, 457, 52, 4, 457,
+        301, 96, 158, 457, 101, 3, 50, 271, 251, 234,
+        237, 1, 282, 130, 235, 186, 135, 212, 10, 54,
+        199, 37, 119, 315, 109, 165, 284, 176, 224, 321,
+        223, 104, 221, 149, 13, 281, 146, 43, 281, 300,
+        41, 40, 266, 225, 30, 233, 289, 194, 21, 52,
+        4, 272, 301, 211, 18, 301, 161, 3, 50, 110,
+        251, 234, 237, 1, 137, 128, 282, 198, 268, 212,
+        10, 54, 222, 169, 515, 92, 109, 172, 284, 31,
+        224, 321, 223, 29, 221, 238, 6, 260, 53, 43,
+        232, 139, 41, 40, 266, 225, 154, 233, 178, 194,
+        168, 52, 4, 214, 301, 145, 99, 33, 49, 3,
+        50, 245, 208, 211, 320, 282, 90, 111, 311, 183,
+        98, 70, 309, 297, 236, 178, 95, 319, 142, 258,
+        247, 267, 249, 264, 250, 195, 231, 199, 246, 324,
+        317, 253, 254, 259, 126, 137, 133, 251, 234, 237,
+        1, 326, 290, 105, 143, 156, 212, 10, 54, 88,
+        84, 83, 484, 109, 322, 282, 37, 224, 321, 223,
+        245, 208, 211, 320, 281, 90, 111, 298, 182, 98,
+        56, 245, 298, 211, 178, 95, 103, 147, 258, 197,
+        102, 75, 141, 250, 195, 231, 95, 246, 324, 258,
+        279, 242, 89, 24, 250, 195, 231, 280, 246, 324,
+        298, 298, 298, 298, 298, 298, 298, 16, 298, 192,
+        277, 298, 298, 18, 294, 44, 45, 38, 298, 298,
+        251, 234, 237, 2, 298, 296, 298, 298, 298, 212,
+        10, 54, 310, 312, 313, 314, 109, 162, 298, 298,
+        224, 321, 223, 298, 298, 298, 294, 282, 298, 42,
+        22, 239, 251, 234, 237, 2, 298, 296, 298, 298,
+        298, 212, 10, 54, 298, 159, 298, 298, 109, 298,
+        298, 17, 224, 321, 223, 282, 298, 42, 22, 239,
+        298, 298, 245, 298, 211, 278, 298, 103, 111, 298,
+        183, 98, 70, 298, 298, 298, 298, 95, 298, 298,
+        258, 298, 292, 17, 298, 250, 195, 231, 279, 246,
+        324, 24, 298, 395, 245, 280, 211, 298, 298, 103,
+        298, 298, 197, 102, 75, 16, 298, 140, 298, 95,
+        298, 18, 258, 298, 298, 298, 298, 250, 195, 231,
+        298, 246, 324, 298, 298, 298, 298, 428, 298, 395,
+        395, 395, 202, 277, 298, 245, 298, 211, 298, 428,
+        103, 298, 298, 197, 120, 69, 395, 395, 395, 395,
+        95, 298, 298, 258, 298, 298, 298, 160, 250, 195,
+        231, 86, 246, 324, 245, 16, 211, 282, 298, 103,
+        196, 18, 197, 120, 69, 298, 44, 45, 38, 95,
+        298, 298, 258, 298, 298, 298, 178, 250, 195, 231,
+        298, 246, 324, 310, 312, 313, 314, 298, 298, 190,
+        245, 298, 211, 298, 298, 103, 298, 298, 197, 102,
+        75, 298, 298, 298, 298, 95, 298, 298, 258, 298,
+        298, 298, 298, 250, 195, 231, 298, 246, 324, 298,
+        298, 298, 245, 298, 211, 298, 199, 100, 298, 288,
+        197, 120, 47, 298, 106, 298, 298, 95, 298, 353,
+        258, 155, 298, 218, 298, 250, 195, 231, 298, 246,
+        324, 282, 16, 42, 22, 239, 298, 245, 18, 211,
+        298, 428, 103, 298, 298, 197, 120, 69, 298, 298,
+        298, 298, 95, 428, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 100, 189, 298, 197, 120, 59, 245, 207, 211,
+        298, 95, 103, 298, 258, 197, 120, 81, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 120, 80, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 120, 67, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 120, 57, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 120, 58, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 120, 82, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 97, 76, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 120, 71, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 187, 120, 61, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 120, 63, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 94, 79, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 120, 59, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 120, 77, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 188, 108, 64, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 120, 65, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 97, 66, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 120, 68, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 120, 62, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 120, 60, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 120, 74, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 120, 72, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 120, 48, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 120, 46, 298, 298,
+        298, 298, 95, 298, 298, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 120, 78, 245, 298, 211,
+        298, 95, 103, 298, 258, 197, 120, 73, 298, 250,
+        195, 231, 95, 246, 324, 258, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 125, 298, 298, 298,
+        298, 298, 95, 298, 298, 298, 298, 298, 298, 244,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 114, 298, 245, 298, 211,
+        298, 95, 103, 298, 298, 197, 122, 298, 243, 250,
+        195, 231, 95, 246, 324, 298, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 117, 298, 298, 298,
+        298, 298, 95, 298, 298, 298, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 121, 298, 245, 298, 211,
+        298, 95, 103, 298, 298, 197, 124, 298, 298, 250,
+        195, 231, 95, 246, 324, 298, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 298, 245, 298, 211,
+        298, 298, 103, 298, 298, 197, 118, 298, 298, 298,
+        298, 298, 95, 298, 298, 298, 298, 298, 298, 298,
+        250, 195, 231, 298, 246, 324, 245, 298, 211, 298,
+        298, 103, 298, 298, 197, 123, 298, 245, 298, 211,
+        298, 95, 103, 298, 298, 197, 113, 298, 298, 250,
+        195, 231, 95, 246, 324, 298, 298, 298, 298, 298,
+        250, 195, 231, 220, 246, 324, 298, 27, 298, 16,
+        298, 457, 298, 298, 457, 18, 298, 26, 457, 441,
+        44, 45, 38, 217, 44, 45, 38, 298, 298, 298,
+        298, 298, 298, 298, 298, 298, 298, 310, 312, 313,
+        314, 310, 312, 313, 314, 298, 441, 298, 298, 441,
+        298, 457, 220, 441, 457, 298, 298, 457, 298, 298,
+        457, 457, 441, 457, 298, 298, 220, 457, 441, 298,
+        298, 298, 298, 298, 457, 298, 298, 457, 298, 298,
+        5, 457, 441, 298, 298, 298, 298, 298, 298, 441,
+        298, 298, 441, 298, 457, 441, 441, 298, 441, 298,
+        457, 298, 441, 306, 298, 298, 298, 298, 298, 441,
+        298, 298, 441, 298, 457, 220, 441, 298, 298, 298,
+        298, 298, 298, 457, 298, 298, 457, 298, 298, 15,
+        457, 441, 35, 274, 44, 45, 38, 457, 298, 298,
+        457, 298, 298, 298, 457, 441, 298, 298, 298, 298,
+        298, 310, 312, 313, 314, 298, 298, 298, 441, 298,
+        298, 441, 298, 457, 298, 441, 287, 298, 44, 45,
+        38, 298, 441, 298, 298, 441, 298, 457, 298, 441,
+        248, 298, 298, 298, 298, 310, 312, 313, 314, 298,
+        44, 45, 38, 298, 298, 112, 298, 44, 45, 38,
+        298, 173, 298, 298, 44, 45, 38, 310, 312, 313,
+        314, 44, 45, 38, 310, 312, 313, 314, 298, 298,
+        299, 310, 312, 313, 314, 44, 45, 38, 310, 312,
+        313, 314, 174, 298, 298, 298, 138, 298, 298, 298,
+        298, 298, 310, 312, 313, 314, 44, 45, 38, 298,
+        298, 298, 44, 45, 38, 298, 44, 45, 38, 298,
+        44, 45, 38, 310, 312, 313, 314, 307, 298, 310,
+        312, 313, 314, 310, 312, 313, 314, 310, 312, 313,
+        314,
+    );
+
+    public static $yy_lookahead     = array(
+        10, 11, 12, 13, 74, 15, 36, 17, 1, 19,
+        20, 21, 29, 103, 84, 45, 26, 14, 48, 36,
+        30, 31, 32, 53, 34, 22, 36, 24, 98, 39,
+        27, 48, 42, 43, 44, 45, 33, 47, 35, 49,
+        37, 51, 52, 53, 54, 14, 16, 16, 45, 59,
+        60, 96, 10, 11, 12, 13, 1, 15, 27, 17,
+        53, 19, 20, 21, 33, 27, 1, 36, 26, 14,
+        45, 33, 30, 31, 32, 45, 34, 52, 36, 48,
+        72, 39, 27, 75, 42, 43, 44, 45, 33, 47,
+        82, 49, 27, 51, 52, 15, 54, 17, 33, 91,
+        83, 59, 60, 95, 10, 11, 12, 13, 13, 15,
+        15, 17, 17, 19, 20, 21, 97, 35, 99, 100,
+        26, 86, 87, 88, 30, 31, 32, 66, 34, 49,
+        36, 51, 96, 39, 54, 53, 42, 43, 44, 45,
+        72, 47, 16, 49, 18, 51, 52, 79, 54, 54,
+        82, 14, 18, 59, 60, 1, 10, 11, 12, 13,
+        23, 15, 15, 17, 27, 19, 20, 21, 14, 17,
+        33, 13, 26, 15, 48, 17, 30, 31, 32, 45,
+        34, 27, 36, 46, 83, 39, 52, 33, 42, 43,
+        44, 45, 34, 47, 74, 49, 10, 51, 52, 13,
+        54, 54, 50, 17, 84, 59, 60, 14, 10, 11,
+        12, 13, 54, 15, 45, 17, 23, 19, 20, 21,
+        27, 52, 100, 103, 26, 35, 33, 37, 30, 31,
+        32, 22, 34, 67, 36, 69, 50, 39, 83, 46,
+        42, 43, 44, 45, 35, 47, 72, 49, 10, 51,
+        52, 13, 54, 79, 80, 17, 82, 59, 60, 1,
+        10, 11, 12, 13, 16, 15, 18, 17, 72, 19,
+        20, 21, 14, 107, 108, 79, 26, 71, 82, 18,
+        30, 31, 32, 1, 34, 27, 36, 15, 50, 39,
+        45, 33, 42, 43, 44, 45, 48, 47, 53, 49,
+        10, 51, 52, 13, 54, 99, 100, 17, 36, 59,
+        60, 29, 10, 11, 12, 13, 15, 15, 17, 17,
+        13, 19, 20, 21, 8, 9, 54, 72, 26, 67,
+        75, 69, 30, 31, 32, 78, 34, 82, 36, 24,
+        50, 39, 17, 36, 42, 43, 44, 45, 74, 47,
+        95, 49, 51, 51, 52, 54, 54, 35, 84, 37,
+        103, 59, 60, 36, 10, 11, 12, 13, 74, 15,
+        108, 17, 23, 19, 20, 21, 10, 103, 84, 13,
+        26, 23, 36, 17, 30, 31, 32, 7, 34, 9,
+        36, 17, 98, 39, 48, 46, 42, 43, 44, 45,
+        17, 47, 53, 49, 46, 51, 52, 93, 54, 78,
+        16, 1, 36, 59, 60, 101, 10, 11, 12, 13,
+        35, 15, 37, 17, 48, 19, 20, 21, 18, 36,
+        65, 66, 26, 74, 103, 104, 30, 31, 32, 45,
+        34, 48, 36, 84, 36, 39, 52, 17, 42, 43,
+        44, 45, 15, 47, 17, 49, 10, 51, 52, 13,
+        54, 18, 74, 17, 82, 59, 60, 34, 10, 11,
+        12, 13, 84, 15, 93, 17, 15, 19, 20, 21,
+        1, 2, 101, 101, 26, 99, 100, 17, 30, 31,
+        32, 48, 34, 96, 36, 98, 96, 39, 98, 71,
+        42, 43, 44, 45, 35, 47, 37, 49, 27, 51,
+        52, 67, 54, 69, 33, 54, 74, 59, 60, 17,
+        10, 11, 12, 13, 96, 15, 84, 17, 34, 19,
+        20, 21, 45, 78, 63, 64, 26, 99, 100, 16,
+        30, 31, 32, 16, 34, 23, 36, 17, 17, 39,
+        23, 51, 42, 43, 44, 45, 72, 47, 103, 49,
+        78, 51, 52, 17, 54, 74, 82, 41, 46, 59,
+        60, 67, 68, 69, 70, 84, 72, 73, 53, 75,
+        76, 77, 53, 61, 15, 103, 82, 14, 51, 85,
+        14, 37, 17, 8, 90, 91, 92, 1, 94, 95,
+        3, 4, 5, 6, 7, 96, 82, 10, 11, 12,
+        13, 97, 84, 81, 96, 74, 19, 20, 21, 78,
+        82, 82, 1, 26, 104, 84, 2, 30, 31, 32,
+        67, 68, 69, 70, 98, 72, 73, 109, 75, 76,
+        77, 67, 109, 69, 103, 82, 72, 96, 85, 75,
+        76, 77, 96, 90, 91, 92, 82, 94, 95, 85,
+        10, 14, 96, 13, 90, 91, 92, 17, 94, 95,
+        109, 109, 109, 109, 109, 109, 109, 27, 109, 105,
+        106, 109, 109, 33, 4, 38, 39, 40, 109, 109,
+        10, 11, 12, 13, 109, 15, 109, 109, 109, 19,
+        20, 21, 55, 56, 57, 58, 26, 74, 109, 109,
+        30, 31, 32, 109, 109, 109, 4, 84, 109, 86,
+        87, 88, 10, 11, 12, 13, 109, 15, 109, 109,
+        109, 19, 20, 21, 109, 74, 109, 109, 26, 109,
+        60, 61, 30, 31, 32, 84, 109, 86, 87, 88,
+        109, 109, 67, 109, 69, 70, 109, 72, 73, 109,
+        75, 76, 77, 109, 109, 109, 109, 82, 109, 109,
+        85, 109, 60, 61, 109, 90, 91, 92, 10, 94,
+        95, 13, 109, 2, 67, 17, 69, 109, 109, 72,
+        109, 109, 75, 76, 77, 27, 109, 29, 109, 82,
+        109, 33, 85, 109, 109, 109, 109, 90, 91, 92,
+        109, 94, 95, 109, 109, 109, 109, 36, 109, 38,
+        39, 40, 105, 106, 109, 67, 109, 69, 109, 48,
+        72, 109, 109, 75, 76, 77, 55, 56, 57, 58,
+        82, 109, 109, 85, 109, 109, 109, 74, 90, 91,
+        92, 78, 94, 95, 67, 27, 69, 84, 109, 72,
+        102, 33, 75, 76, 77, 109, 38, 39, 40, 82,
+        109, 109, 85, 109, 109, 109, 103, 90, 91, 92,
+        109, 94, 95, 55, 56, 57, 58, 109, 109, 102,
+        67, 109, 69, 109, 109, 72, 109, 109, 75, 76,
+        77, 109, 109, 109, 109, 82, 109, 109, 85, 109,
+        109, 109, 109, 90, 91, 92, 109, 94, 95, 109,
+        109, 109, 67, 109, 69, 109, 1, 72, 109, 106,
+        75, 76, 77, 109, 79, 109, 109, 82, 109, 14,
+        85, 74, 109, 18, 109, 90, 91, 92, 109, 94,
+        95, 84, 27, 86, 87, 88, 109, 67, 33, 69,
+        109, 36, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 48, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 102, 109, 75, 76, 77, 67, 79, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 77, 109, 109,
+        109, 109, 82, 109, 109, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 77, 67, 109, 69,
+        109, 82, 72, 109, 85, 75, 76, 77, 109, 90,
+        91, 92, 82, 94, 95, 85, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 109, 109, 109,
+        109, 109, 82, 109, 109, 109, 109, 109, 109, 89,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 109, 67, 109, 69,
+        109, 82, 72, 109, 109, 75, 76, 109, 89, 90,
+        91, 92, 82, 94, 95, 109, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 109, 109, 109,
+        109, 109, 82, 109, 109, 109, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 109, 67, 109, 69,
+        109, 82, 72, 109, 109, 75, 76, 109, 109, 90,
+        91, 92, 82, 94, 95, 109, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 109, 67, 109, 69,
+        109, 109, 72, 109, 109, 75, 76, 109, 109, 109,
+        109, 109, 82, 109, 109, 109, 109, 109, 109, 109,
+        90, 91, 92, 109, 94, 95, 67, 109, 69, 109,
+        109, 72, 109, 109, 75, 76, 109, 67, 109, 69,
+        109, 82, 72, 109, 109, 75, 76, 109, 109, 90,
+        91, 92, 82, 94, 95, 109, 109, 109, 109, 109,
+        90, 91, 92, 2, 94, 95, 109, 25, 109, 27,
+        109, 10, 109, 109, 13, 33, 109, 16, 17, 18,
+        38, 39, 40, 37, 38, 39, 40, 109, 109, 109,
+        109, 109, 109, 109, 109, 109, 109, 55, 56, 57,
+        58, 55, 56, 57, 58, 109, 45, 109, 109, 48,
+        109, 50, 2, 52, 10, 109, 109, 13, 109, 109,
+        10, 17, 18, 13, 109, 109, 2, 17, 18, 109,
+        109, 109, 109, 109, 10, 109, 109, 13, 109, 109,
+        16, 17, 18, 109, 109, 109, 109, 109, 109, 45,
+        109, 109, 48, 109, 50, 45, 52, 109, 48, 109,
+        50, 109, 52, 53, 109, 109, 109, 109, 109, 45,
+        109, 109, 48, 109, 50, 2, 52, 109, 109, 109,
+        109, 109, 109, 10, 109, 109, 13, 109, 109, 2,
+        17, 18, 2, 37, 38, 39, 40, 10, 109, 109,
+        13, 109, 109, 109, 17, 18, 109, 109, 109, 109,
+        109, 55, 56, 57, 58, 109, 109, 109, 45, 109,
+        109, 48, 109, 50, 109, 52, 14, 109, 38, 39,
+        40, 109, 45, 109, 109, 48, 109, 50, 109, 52,
+        14, 109, 109, 109, 109, 55, 56, 57, 58, 109,
+        38, 39, 40, 109, 109, 22, 109, 38, 39, 40,
+        109, 14, 109, 109, 38, 39, 40, 55, 56, 57,
+        58, 38, 39, 40, 55, 56, 57, 58, 109, 109,
+        61, 55, 56, 57, 58, 38, 39, 40, 55, 56,
+        57, 58, 14, 109, 109, 109, 28, 109, 109, 109,
+        109, 109, 55, 56, 57, 58, 38, 39, 40, 109,
+        109, 109, 38, 39, 40, 109, 38, 39, 40, 109,
+        38, 39, 40, 55, 56, 57, 58, 53, 109, 55,
+        56, 57, 58, 55, 56, 57, 58, 55, 56, 57,
+        58,
+    );
+
+    public static $yy_shift_ofst    = array(
+        -31, 406, 406, 458, 458, 94, 510, 94, 94, 94,
+        510, 458, -10, 94, 94, 354, 146, 94, 94, 94,
+        94, 146, 94, 94, 94, 94, 250, 94, 94, 94,
+        94, 94, 94, 302, 94, 94, 94, 198, 42, 42,
+        42, 42, 42, 42, 42, 42, 1772, 828, 828, 80,
+        712, 925, 301, 65, 272, 680, 1942, 1920, 1886, 1776,
+        647, 1949, 1977, 2008, 2004, 1963, 1998, 1956, 2012, 2012,
+        2012, 2012, 2012, 2012, 2012, 2012, 2012, 2012, 2012, 2012,
+        2012, 2012, 2012, 768, 650, 272, 65, 272, 65, 134,
+        126, 479, 597, 1854, 154, 290, 95, 55, 258, 366,
+        248, 366, 282, 443, 437, 38, 38, 437, 7, 481,
+        410, 38, 461, 621, 596, 596, 261, 596, 596, 261,
+        596, 596, 596, 596, 596, -31, -31, 1840, 1791, 1917,
+        1903, 1834, 158, 238, 394, 446, 38, 25, 147, 169,
+        147, 25, 169, 25, 38, 38, 25, 25, 38, 25,
+        307, 38, 38, 25, 527, 38, 38, 25, 38, 38,
+        38, 38, 38, 596, 624, 261, 624, 327, 596, 596,
+        261, 596, 261, -31, -31, -31, -31, -31, -31, 781,
+        3, 31, 193, 137, -30, 186, -17, 522, 349, 469,
+        322, 30, 82, 316, 346, 376, 190, 358, 393, 152,
+        209, 380, 385, 245, 315, 523, 585, 554, 576, 575,
+        537, 573, 569, 529, 525, 546, 500, 526, 531, 325,
+        530, 487, 494, 502, 470, 433, 430, 408, 383, 327,
+        374,
+    );
+
+    public static $yy_reduce_ofst   = array(
+        471, 504, 563, 717, 574, 685, 919, 890, 787, 758,
+        855, 823, 1240, 1199, 1140, 1100, 1070, 1129, 1170, 1210,
+        1269, 1280, 1310, 1339, 1350, 1380, 1409, 1420, 1450, 1479,
+        1490, 1059, 1030, 1000, 930, 960, 989, 1520, 1549, 1700,
+        1619, 1689, 1660, 1630, 1590, 1560, 633, 661, 867, 8,
+        166, 773, 255, 541, 174, 262, 35, 35, 35, 35,
+        35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
+        35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
+        35, 35, 35, 294, -70, 196, 120, 68, 274, 19,
+        206, 331, 444, 428, 257, 400, 382, 257, 257, 400,
+        386, 397, 257, 386, 381, 388, 359, 314, 257, 442,
+        482, 491, 484, 257, 257, 455, 386, 257, 257, 438,
+        257, 257, 257, 257, 257, 257, 365, 509, 509, 509,
+        509, 509, 524, 536, 509, 509, 528, 514, 539, 551,
+        538, 514, 556, 514, 528, 528, 514, 514, 528, 514,
+        518, 528, 528, 514, 532, 528, 528, 514, 528, 528,
+        528, 528, 528, -90, 520, 122, 520, 566, -90, -90,
+        122, -90, 122, -45, 36, 155, 101, 61, 17,
+    );
+
+    public static $yyExpectedTokens = array(
+        array(),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 53, 54, 59,
+            60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(
+            10, 11, 12, 13, 15, 17, 19, 20, 21, 26, 30, 31, 32, 34, 36, 39, 42, 43, 44, 45, 47, 49, 51, 52, 54, 59, 60,
+        ),
+        array(25, 27, 33, 38, 39, 40, 55, 56, 57, 58,),
+        array(27, 33, 38, 39, 40, 55, 56, 57, 58,),
+        array(27, 33, 38, 39, 40, 55, 56, 57, 58,),
+        array(15, 17, 49, 51, 54,),
+        array(4, 10, 11, 12, 13, 15, 19, 20, 21, 26, 30, 31, 32, 60, 61,),
+        array(1, 14, 18, 27, 33, 36, 48,),
+        array(15, 17, 51, 54,),
+        array(1, 27, 33,),
+        array(15, 36, 54,),
+        array(4, 10, 11, 12, 13, 15, 19, 20, 21, 26, 30, 31, 32, 60, 61,),
+        array(14, 38, 39, 40, 55, 56, 57, 58,),
+        array(2, 38, 39, 40, 55, 56, 57, 58,),
+        array(37, 38, 39, 40, 55, 56, 57, 58,),
+        array(37, 38, 39, 40, 55, 56, 57, 58,),
+        array(14, 38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58, 61,),
+        array(14, 38, 39, 40, 55, 56, 57, 58,),
+        array(14, 38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 53, 55, 56, 57, 58,),
+        array(22, 38, 39, 40, 55, 56, 57, 58,),
+        array(28, 38, 39, 40, 55, 56, 57, 58,),
+        array(14, 38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(38, 39, 40, 55, 56, 57, 58,),
+        array(10, 13, 17, 27, 29, 33,),
+        array(10, 13, 17, 27, 33,),
+        array(15, 36, 54,),
+        array(1, 27, 33,),
+        array(15, 36, 54,),
+        array(1, 27, 33,),
+        array(18, 45, 52,),
+        array(16, 18, 48,),
+        array(1, 2,),
+        array(3, 4, 5, 6, 7, 10, 11, 12, 13, 19, 20, 21, 26, 30, 31, 32,),
+        array(2, 10, 13, 16, 17, 18, 45, 48, 50, 52,),
+        array(1, 14, 27, 33,),
+        array(10, 13, 17, 50,),
+        array(13, 15, 17, 54,),
+        array(1, 14, 27, 33,),
+        array(1, 14, 27, 33,),
+        array(10, 13, 17,),
+        array(16, 18, 48,),
+        array(10, 13, 17,),
+        array(1, 29,),
+        array(18, 48,),
+        array(15, 17,),
+        array(27, 33,),
+        array(27, 33,),
+        array(15, 17,),
+        array(1, 53,),
+        array(27, 33,),
+        array(1, 18,),
+        array(27, 33,),
+        array(15, 54,),
+        array(1,),
+        array(1,),
+        array(1,),
+        array(18,),
+        array(1,),
+        array(1,),
+        array(18,),
+        array(1,),
+        array(1,),
+        array(1,),
+        array(1,),
+        array(1,),
+        array(),
+        array(),
+        array(2, 10, 13, 17, 18, 45, 48, 50, 52, 53,),
+        array(2, 10, 13, 16, 17, 18, 45, 48, 50, 52,),
+        array(2, 10, 13, 17, 18, 45, 48, 50, 52,),
+        array(2, 10, 13, 17, 18, 45, 48, 50, 52,),
+        array(10, 13, 17, 18, 45, 48, 50, 52,),
+        array(13, 15, 17, 34, 54,),
+        array(10, 13, 17, 50,),
+        array(16, 45, 52,),
+        array(10, 13, 17,),
+        array(27, 33,),
+        array(45, 52,),
+        array(15, 54,),
+        array(45, 52,),
+        array(15, 54,),
+        array(45, 52,),
+        array(45, 52,),
+        array(45, 52,),
+        array(27, 33,),
+        array(27, 33,),
+        array(45, 52,),
+        array(45, 52,),
+        array(27, 33,),
+        array(45, 52,),
+        array(13, 36,),
+        array(27, 33,),
+        array(27, 33,),
+        array(45, 52,),
+        array(16, 23,),
+        array(27, 33,),
+        array(27, 33,),
+        array(45, 52,),
+        array(27, 33,),
+        array(27, 33,),
+        array(27, 33,),
+        array(27, 33,),
+        array(27, 33,),
+        array(1,),
+        array(2,),
+        array(18,),
+        array(2,),
+        array(36,),
+        array(1,),
+        array(1,),
+        array(18,),
+        array(1,),
+        array(18,),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(2, 36, 38, 39, 40, 48, 55, 56, 57, 58,),
+        array(14, 22, 24, 27, 33, 35, 37, 45,),
+        array(14, 16, 27, 33, 36, 48,),
+        array(14, 23, 27, 33, 46,),
+        array(14, 23, 27, 33, 46,),
+        array(36, 45, 48, 53,),
+        array(10, 13, 17, 50,),
+        array(29, 36, 48,),
+        array(23, 46, 61,),
+        array(23, 46, 53,),
+        array(35, 37,),
+        array(35, 37,),
+        array(16, 45,),
+        array(35, 53,),
+        array(8, 9,),
+        array(36, 48,),
+        array(36, 48,),
+        array(35, 37,),
+        array(23, 46,),
+        array(36, 48,),
+        array(17, 50,),
+        array(22, 35,),
+        array(7, 9,),
+        array(35, 37,),
+        array(45, 53,),
+        array(24,),
+        array(16,),
+        array(8,),
+        array(37,),
+        array(14,),
+        array(17,),
+        array(51,),
+        array(14,),
+        array(15,),
+        array(53,),
+        array(53,),
+        array(17,),
+        array(51,),
+        array(41,),
+        array(17,),
+        array(17,),
+        array(17,),
+        array(45,),
+        array(34,),
+        array(17,),
+        array(17,),
+        array(34,),
+        array(17,),
+        array(36,),
+        array(17,),
+        array(36,),
+        array(17,),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+        array(),
+    );
+
+    public static $yy_default       = array(
+        338, 514, 514, 499, 499, 514, 514, 476, 476, 476,
+        514, 514, 514, 514, 514, 514, 514, 514, 514, 514,
+        514, 514, 514, 514, 514, 514, 514, 514, 514, 514,
+        514, 514, 514, 514, 514, 514, 514, 514, 514, 514,
+        514, 514, 514, 514, 514, 514, 379, 358, 379, 514,
+        514, 415, 514, 379, 514, 514, 351, 514, 514, 514,
+        514, 514, 514, 514, 514, 514, 384, 514, 399, 475,
+        351, 403, 390, 474, 500, 502, 384, 501, 363, 381,
+        404, 386, 391, 379, 379, 514, 379, 514, 379, 489,
+        431, 370, 327, 430, 393, 441, 514, 393, 393, 441,
+        431, 441, 393, 431, 514, 379, 360, 514, 393, 379,
+        373, 379, 514, 406, 402, 375, 431, 396, 398, 486,
+        393, 408, 397, 407, 406, 483, 336, 430, 430, 430,
+        430, 430, 514, 443, 457, 441, 367, 438, 514, 436,
+        514, 435, 434, 466, 368, 348, 439, 437, 361, 467,
+        441, 356, 354, 468, 514, 366, 355, 469, 362, 359,
+        352, 369, 365, 371, 478, 463, 477, 441, 374, 376,
+        490, 424, 487, 441, 441, 482, 482, 336, 482, 415,
+        411, 415, 405, 405, 415, 442, 415, 405, 405, 514,
+        514, 411, 514, 514, 425, 514, 514, 405, 415, 514,
+        514, 334, 514, 411, 387, 514, 514, 514, 514, 514,
+        514, 514, 514, 420, 514, 514, 514, 417, 514, 514,
+        514, 411, 413, 514, 514, 514, 514, 488, 514, 457,
+        514, 421, 364, 420, 340, 422, 357, 341, 409, 400,
+        480, 457, 462, 401, 485, 423, 426, 342, 447, 380,
+        416, 339, 428, 329, 330, 444, 445, 446, 394, 331,
+        395, 429, 419, 388, 332, 418, 410, 392, 412, 333,
+        335, 414, 337, 472, 417, 479, 427, 497, 347, 461,
+        460, 459, 378, 346, 464, 510, 495, 511, 498, 473,
+        377, 496, 503, 506, 513, 512, 509, 507, 504, 508,
+        345, 458, 471, 448, 505, 454, 452, 455, 456, 450,
+        491, 449, 492, 493, 494, 470, 451, 328, 453, 343,
+        344, 372, 481, 432, 433, 465, 440,
+    );
+
+    public static $yyFallback       = array();
+
+    public static $yyRuleName       = array(
+        'start ::= template',
+        'template ::= template PHP',
+        'template ::= template TEXT',
+        'template ::= template STRIPON',
+        'template ::= template STRIPOFF',
+        'template ::= template LITERALSTART literal_e2 LITERALEND',
+        'literal_e2 ::= literal_e1 LITERALSTART literal_e1 LITERALEND',
+        'literal_e2 ::= literal_e1',
+        'literal_e1 ::= literal_e1 LITERAL',
+        'literal_e1 ::=',
+        'template ::= template smartytag',
+        'template ::=',
+        'smartytag ::= SIMPELOUTPUT',
+        'smartytag ::= SIMPLETAG',
+        'smartytag ::= SMARTYBLOCKCHILDPARENT',
+        'smartytag ::= LDEL tagbody RDEL',
+        'smartytag ::= tag RDEL',
+        'tagbody ::= outattr',
+        'tagbody ::= DOLLARID eqoutattr',
+        'tagbody ::= varindexed eqoutattr',
+        'eqoutattr ::= EQUAL outattr',
+        'outattr ::= output attributes',
+        'output ::= variable',
+        'output ::= value',
+        'output ::= expr',
+        'tag ::= LDEL ID attributes',
+        'tag ::= LDEL ID',
+        'tag ::= LDEL ID modifierlist attributes',
+        'tag ::= LDEL ID PTR ID attributes',
+        'tag ::= LDEL ID PTR ID modifierlist attributes',
+        'tag ::= LDELMAKENOCACHE DOLLARID',
+        'tag ::= LDELIF expr',
+        'tag ::= LDELIF expr attributes',
+        'tag ::= LDELIF statement',
+        'tag ::= LDELIF statement attributes',
+        'tag ::= LDELFOR statements SEMICOLON expr SEMICOLON varindexed foraction attributes',
+        'foraction ::= EQUAL expr',
+        'foraction ::= INCDEC',
+        'tag ::= LDELFOR statement TO expr attributes',
+        'tag ::= LDELFOR statement TO expr STEP expr attributes',
+        'tag ::= LDELFOREACH SPACE expr AS varvar attributes',
+        'tag ::= LDELFOREACH SPACE expr AS varvar APTR varvar attributes',
+        'tag ::= LDELFOREACH attributes',
+        'tag ::= LDELSETFILTER ID modparameters',
+        'tag ::= LDELSETFILTER ID modparameters modifierlist',
+        'smartytag ::= CLOSETAG',
+        'tag ::= LDELSLASH ID',
+        'tag ::= LDELSLASH ID modifierlist',
+        'tag ::= LDELSLASH ID PTR ID',
+        'tag ::= LDELSLASH ID PTR ID modifierlist',
+        'attributes ::= attributes attribute',
+        'attributes ::= attribute',
+        'attributes ::=',
+        'attribute ::= SPACE ID EQUAL ID',
+        'attribute ::= ATTR expr',
+        'attribute ::= ATTR value',
+        'attribute ::= SPACE ID',
+        'attribute ::= SPACE expr',
+        'attribute ::= SPACE value',
+        'attribute ::= SPACE INTEGER EQUAL expr',
+        'statements ::= statement',
+        'statements ::= statements COMMA statement',
+        'statement ::= DOLLARID EQUAL INTEGER',
+        'statement ::= DOLLARID EQUAL expr',
+        'statement ::= varindexed EQUAL expr',
+        'statement ::= OPENP statement CLOSEP',
+        'expr ::= value',
+        'expr ::= ternary',
+        'expr ::= DOLLARID COLON ID',
+        'expr ::= expr MATH value',
+        'expr ::= expr UNIMATH value',
+        'expr ::= expr tlop value',
+        'expr ::= expr lop expr',
+        'expr ::= expr scond',
+        'expr ::= expr ISIN array',
+        'expr ::= expr ISIN value',
+        'ternary ::= OPENP expr CLOSEP QMARK DOLLARID COLON expr',
+        'ternary ::= OPENP expr CLOSEP QMARK expr COLON expr',
+        'value ::= variable',
+        'value ::= UNIMATH value',
+        'value ::= NOT value',
+        'value ::= TYPECAST value',
+        'value ::= variable INCDEC',
+        'value ::= HEX',
+        'value ::= INTEGER',
+        'value ::= INTEGER DOT INTEGER',
+        'value ::= INTEGER DOT',
+        'value ::= DOT INTEGER',
+        'value ::= ID',
+        'value ::= function',
+        'value ::= OPENP expr CLOSEP',
+        'value ::= variable INSTANCEOF ns1',
+        'value ::= variable INSTANCEOF variable',
+        'value ::= SINGLEQUOTESTRING',
+        'value ::= doublequoted_with_quotes',
+        'value ::= varindexed DOUBLECOLON static_class_access',
+        'value ::= smartytag',
+        'value ::= value modifierlist',
+        'value ::= NAMESPACE',
+        'value ::= arraydef',
+        'value ::= ns1 DOUBLECOLON static_class_access',
+        'ns1 ::= ID',
+        'ns1 ::= NAMESPACE',
+        'variable ::= DOLLARID',
+        'variable ::= varindexed',
+        'variable ::= varvar AT ID',
+        'variable ::= object',
+        'variable ::= HATCH ID HATCH',
+        'variable ::= HATCH ID HATCH arrayindex',
+        'variable ::= HATCH variable HATCH',
+        'variable ::= HATCH variable HATCH arrayindex',
+        'varindexed ::= DOLLARID arrayindex',
+        'varindexed ::= varvar arrayindex',
+        'arrayindex ::= arrayindex indexdef',
+        'arrayindex ::=',
+        'indexdef ::= DOT DOLLARID',
+        'indexdef ::= DOT varvar',
+        'indexdef ::= DOT varvar AT ID',
+        'indexdef ::= DOT ID',
+        'indexdef ::= DOT INTEGER',
+        'indexdef ::= DOT LDEL expr RDEL',
+        'indexdef ::= OPENB ID CLOSEB',
+        'indexdef ::= OPENB ID DOT ID CLOSEB',
+        'indexdef ::= OPENB SINGLEQUOTESTRING CLOSEB',
+        'indexdef ::= OPENB INTEGER CLOSEB',
+        'indexdef ::= OPENB DOLLARID CLOSEB',
+        'indexdef ::= OPENB variable CLOSEB',
+        'indexdef ::= OPENB value CLOSEB',
+        'indexdef ::= OPENB expr CLOSEB',
+        'indexdef ::= OPENB CLOSEB',
+        'varvar ::= DOLLARID',
+        'varvar ::= DOLLAR',
+        'varvar ::= varvar varvarele',
+        'varvarele ::= ID',
+        'varvarele ::= SIMPELOUTPUT',
+        'varvarele ::= LDEL expr RDEL',
+        'object ::= varindexed objectchain',
+        'objectchain ::= objectelement',
+        'objectchain ::= objectchain objectelement',
+        'objectelement ::= PTR ID arrayindex',
+        'objectelement ::= PTR varvar arrayindex',
+        'objectelement ::= PTR LDEL expr RDEL arrayindex',
+        'objectelement ::= PTR ID LDEL expr RDEL arrayindex',
+        'objectelement ::= PTR method',
+        'function ::= ns1 OPENP params CLOSEP',
+        'method ::= ID OPENP params CLOSEP',
+        'method ::= DOLLARID OPENP params CLOSEP',
+        'params ::= params COMMA expr',
+        'params ::= expr',
+        'params ::=',
+        'modifierlist ::= modifierlist modifier modparameters',
+        'modifierlist ::= modifier modparameters',
+        'modifier ::= VERT AT ID',
+        'modifier ::= VERT ID',
+        'modparameters ::= modparameters modparameter',
+        'modparameters ::=',
+        'modparameter ::= COLON value',
+        'modparameter ::= COLON UNIMATH value',
+        'modparameter ::= COLON array',
+        'static_class_access ::= method',
+        'static_class_access ::= method objectchain',
+        'static_class_access ::= ID',
+        'static_class_access ::= DOLLARID arrayindex',
+        'static_class_access ::= DOLLARID arrayindex objectchain',
+        'lop ::= LOGOP',
+        'lop ::= SLOGOP',
+        'tlop ::= TLOGOP',
+        'scond ::= SINGLECOND',
+        'arraydef ::= OPENB arrayelements CLOSEB',
+        'arraydef ::= ARRAYOPEN arrayelements CLOSEP',
+        'arrayelements ::= arrayelement',
+        'arrayelements ::= arrayelements COMMA arrayelement',
+        'arrayelements ::=',
+        'arrayelement ::= value APTR expr',
+        'arrayelement ::= ID APTR expr',
+        'arrayelement ::= expr',
+        'doublequoted_with_quotes ::= QUOTE QUOTE',
+        'doublequoted_with_quotes ::= QUOTE doublequoted QUOTE',
+        'doublequoted ::= doublequoted doublequotedcontent',
+        'doublequoted ::= doublequotedcontent',
+        'doublequotedcontent ::= BACKTICK variable BACKTICK',
+        'doublequotedcontent ::= BACKTICK expr BACKTICK',
+        'doublequotedcontent ::= DOLLARID',
+        'doublequotedcontent ::= LDEL variable RDEL',
+        'doublequotedcontent ::= LDEL expr RDEL',
+        'doublequotedcontent ::= smartytag',
+        'doublequotedcontent ::= TEXT',
+    );
+
+    public static $yyRuleInfo       = array(
+        array(0 => 63, 1 => 1),
+        array(0 => 64, 1 => 2),
+        array(0 => 64, 1 => 2),
+        array(0 => 64, 1 => 2),
+        array(0 => 64, 1 => 2),
+        array(0 => 64, 1 => 4),
+        array(0 => 65, 1 => 4),
+        array(0 => 65, 1 => 1),
+        array(0 => 66, 1 => 2),
+        array(0 => 66, 1 => 0),
+        array(0 => 64, 1 => 2),
+        array(0 => 64, 1 => 0),
+        array(0 => 67, 1 => 1),
+        array(0 => 67, 1 => 1),
+        array(0 => 67, 1 => 1),
+        array(0 => 67, 1 => 3),
+        array(0 => 67, 1 => 2),
+        array(0 => 68, 1 => 1),
+        array(0 => 68, 1 => 2),
+        array(0 => 68, 1 => 2),
+        array(0 => 71, 1 => 2),
+        array(0 => 70, 1 => 2),
+        array(0 => 73, 1 => 1),
+        array(0 => 73, 1 => 1),
+        array(0 => 73, 1 => 1),
+        array(0 => 69, 1 => 3),
+        array(0 => 69, 1 => 2),
+        array(0 => 69, 1 => 4),
+        array(0 => 69, 1 => 5),
+        array(0 => 69, 1 => 6),
+        array(0 => 69, 1 => 2),
+        array(0 => 69, 1 => 2),
+        array(0 => 69, 1 => 3),
+        array(0 => 69, 1 => 2),
+        array(0 => 69, 1 => 3),
+        array(0 => 69, 1 => 8),
+        array(0 => 81, 1 => 2),
+        array(0 => 81, 1 => 1),
+        array(0 => 69, 1 => 5),
+        array(0 => 69, 1 => 7),
+        array(0 => 69, 1 => 6),
+        array(0 => 69, 1 => 8),
+        array(0 => 69, 1 => 2),
+        array(0 => 69, 1 => 3),
+        array(0 => 69, 1 => 4),
+        array(0 => 67, 1 => 1),
+        array(0 => 69, 1 => 2),
+        array(0 => 69, 1 => 3),
+        array(0 => 69, 1 => 4),
+        array(0 => 69, 1 => 5),
+        array(0 => 74, 1 => 2),
+        array(0 => 74, 1 => 1),
+        array(0 => 74, 1 => 0),
+        array(0 => 84, 1 => 4),
+        array(0 => 84, 1 => 2),
+        array(0 => 84, 1 => 2),
+        array(0 => 84, 1 => 2),
+        array(0 => 84, 1 => 2),
+        array(0 => 84, 1 => 2),
+        array(0 => 84, 1 => 4),
+        array(0 => 80, 1 => 1),
+        array(0 => 80, 1 => 3),
+        array(0 => 79, 1 => 3),
+        array(0 => 79, 1 => 3),
+        array(0 => 79, 1 => 3),
+        array(0 => 79, 1 => 3),
+        array(0 => 77, 1 => 1),
+        array(0 => 77, 1 => 1),
+        array(0 => 77, 1 => 3),
+        array(0 => 77, 1 => 3),
+        array(0 => 77, 1 => 3),
+        array(0 => 77, 1 => 3),
+        array(0 => 77, 1 => 3),
+        array(0 => 77, 1 => 2),
+        array(0 => 77, 1 => 3),
+        array(0 => 77, 1 => 3),
+        array(0 => 85, 1 => 7),
+        array(0 => 85, 1 => 7),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 2),
+        array(0 => 76, 1 => 2),
+        array(0 => 76, 1 => 2),
+        array(0 => 76, 1 => 2),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 3),
+        array(0 => 76, 1 => 2),
+        array(0 => 76, 1 => 2),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 3),
+        array(0 => 76, 1 => 3),
+        array(0 => 76, 1 => 3),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 3),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 2),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 1),
+        array(0 => 76, 1 => 3),
+        array(0 => 91, 1 => 1),
+        array(0 => 91, 1 => 1),
+        array(0 => 75, 1 => 1),
+        array(0 => 75, 1 => 1),
+        array(0 => 75, 1 => 3),
+        array(0 => 75, 1 => 1),
+        array(0 => 75, 1 => 3),
+        array(0 => 75, 1 => 4),
+        array(0 => 75, 1 => 3),
+        array(0 => 75, 1 => 4),
+        array(0 => 72, 1 => 2),
+        array(0 => 72, 1 => 2),
+        array(0 => 96, 1 => 2),
+        array(0 => 96, 1 => 0),
+        array(0 => 97, 1 => 2),
+        array(0 => 97, 1 => 2),
+        array(0 => 97, 1 => 4),
+        array(0 => 97, 1 => 2),
+        array(0 => 97, 1 => 2),
+        array(0 => 97, 1 => 4),
+        array(0 => 97, 1 => 3),
+        array(0 => 97, 1 => 5),
+        array(0 => 97, 1 => 3),
+        array(0 => 97, 1 => 3),
+        array(0 => 97, 1 => 3),
+        array(0 => 97, 1 => 3),
+        array(0 => 97, 1 => 3),
+        array(0 => 97, 1 => 3),
+        array(0 => 97, 1 => 2),
+        array(0 => 82, 1 => 1),
+        array(0 => 82, 1 => 1),
+        array(0 => 82, 1 => 2),
+        array(0 => 98, 1 => 1),
+        array(0 => 98, 1 => 1),
+        array(0 => 98, 1 => 3),
+        array(0 => 95, 1 => 2),
+        array(0 => 99, 1 => 1),
+        array(0 => 99, 1 => 2),
+        array(0 => 100, 1 => 3),
+        array(0 => 100, 1 => 3),
+        array(0 => 100, 1 => 5),
+        array(0 => 100, 1 => 6),
+        array(0 => 100, 1 => 2),
+        array(0 => 90, 1 => 4),
+        array(0 => 101, 1 => 4),
+        array(0 => 101, 1 => 4),
+        array(0 => 102, 1 => 3),
+        array(0 => 102, 1 => 1),
+        array(0 => 102, 1 => 0),
+        array(0 => 78, 1 => 3),
+        array(0 => 78, 1 => 2),
+        array(0 => 103, 1 => 3),
+        array(0 => 103, 1 => 2),
+        array(0 => 83, 1 => 2),
+        array(0 => 83, 1 => 0),
+        array(0 => 104, 1 => 2),
+        array(0 => 104, 1 => 3),
+        array(0 => 104, 1 => 2),
+        array(0 => 93, 1 => 1),
+        array(0 => 93, 1 => 2),
+        array(0 => 93, 1 => 1),
+        array(0 => 93, 1 => 2),
+        array(0 => 93, 1 => 3),
+        array(0 => 87, 1 => 1),
+        array(0 => 87, 1 => 1),
+        array(0 => 86, 1 => 1),
+        array(0 => 88, 1 => 1),
+        array(0 => 94, 1 => 3),
+        array(0 => 94, 1 => 3),
+        array(0 => 105, 1 => 1),
+        array(0 => 105, 1 => 3),
+        array(0 => 105, 1 => 0),
+        array(0 => 106, 1 => 3),
+        array(0 => 106, 1 => 3),
+        array(0 => 106, 1 => 1),
+        array(0 => 92, 1 => 2),
+        array(0 => 92, 1 => 3),
+        array(0 => 107, 1 => 2),
+        array(0 => 107, 1 => 1),
+        array(0 => 108, 1 => 3),
+        array(0 => 108, 1 => 3),
+        array(0 => 108, 1 => 1),
+        array(0 => 108, 1 => 3),
+        array(0 => 108, 1 => 3),
+        array(0 => 108, 1 => 1),
+        array(0 => 108, 1 => 1),
+    );
+
+    public static $yyReduceMap      = array(
+        0   => 0,
+        1   => 1,
+        2   => 2,
+        3   => 3,
+        4   => 4,
+        5   => 5,
+        6   => 6,
+        7   => 7,
+        22  => 7,
+        23  => 7,
+        24  => 7,
+        37  => 7,
+        57  => 7,
+        58  => 7,
+        66  => 7,
+        67  => 7,
+        78  => 7,
+        83  => 7,
+        84  => 7,
+        89  => 7,
+        93  => 7,
+        94  => 7,
+        98  => 7,
+        99  => 7,
+        101 => 7,
+        106 => 7,
+        170 => 7,
+        175 => 7,
+        8   => 8,
+        9   => 9,
+        10  => 10,
+        12  => 12,
+        13  => 13,
+        14  => 14,
+        15  => 15,
+        16  => 16,
+        17  => 17,
+        18  => 18,
+        19  => 19,
+        20  => 20,
+        21  => 21,
+        25  => 25,
+        26  => 26,
+        27  => 27,
+        28  => 28,
+        29  => 29,
+        30  => 30,
+        31  => 31,
+        32  => 32,
+        34  => 32,
+        33  => 33,
+        35  => 35,
+        36  => 36,
+        38  => 38,
+        39  => 39,
+        40  => 40,
+        41  => 41,
+        42  => 42,
+        43  => 43,
+        44  => 44,
+        45  => 45,
+        46  => 46,
+        47  => 47,
+        48  => 48,
+        49  => 49,
+        50  => 50,
+        51  => 51,
+        60  => 51,
+        148 => 51,
+        152 => 51,
+        156 => 51,
+        158 => 51,
+        52  => 52,
+        149 => 52,
+        155 => 52,
+        53  => 53,
+        54  => 54,
+        55  => 54,
+        56  => 56,
+        133 => 56,
+        59  => 59,
+        61  => 61,
+        62  => 62,
+        63  => 62,
+        64  => 64,
+        65  => 65,
+        68  => 68,
+        69  => 69,
+        70  => 69,
+        71  => 71,
+        72  => 72,
+        73  => 73,
+        74  => 74,
+        75  => 75,
+        76  => 76,
+        77  => 77,
+        79  => 79,
+        81  => 79,
+        82  => 79,
+        113 => 79,
+        80  => 80,
+        85  => 85,
+        86  => 86,
+        87  => 87,
+        88  => 88,
+        90  => 90,
+        91  => 91,
+        92  => 91,
+        95  => 95,
+        96  => 96,
+        97  => 97,
+        100 => 100,
+        102 => 102,
+        103 => 103,
+        104 => 104,
+        105 => 105,
+        107 => 107,
+        108 => 108,
+        109 => 109,
+        110 => 110,
+        111 => 111,
+        112 => 112,
+        114 => 114,
+        172 => 114,
+        115 => 115,
+        116 => 116,
+        117 => 117,
+        118 => 118,
+        119 => 119,
+        120 => 120,
+        128 => 120,
+        121 => 121,
+        122 => 122,
+        123 => 123,
+        124 => 123,
+        126 => 123,
+        127 => 123,
+        125 => 125,
+        129 => 129,
+        130 => 130,
+        131 => 131,
+        176 => 131,
+        132 => 132,
+        134 => 134,
+        135 => 135,
+        136 => 136,
+        137 => 137,
+        138 => 138,
+        139 => 139,
+        140 => 140,
+        141 => 141,
+        142 => 142,
+        143 => 143,
+        144 => 144,
+        145 => 145,
+        146 => 146,
+        147 => 147,
+        150 => 150,
+        151 => 151,
+        153 => 153,
+        154 => 154,
+        157 => 157,
+        159 => 159,
+        160 => 160,
+        161 => 161,
+        162 => 162,
+        163 => 163,
+        164 => 164,
+        165 => 165,
+        166 => 166,
+        167 => 167,
+        168 => 168,
+        169 => 168,
+        171 => 171,
+        173 => 173,
+        174 => 174,
+        177 => 177,
+        178 => 178,
+        179 => 179,
+        180 => 180,
+        183 => 180,
+        181 => 181,
+        184 => 181,
+        182 => 182,
+        185 => 185,
+        186 => 186,
+    );
+
+    /**
+     * result status
+     *
+     * @var bool
+     */
+    public $successful = true;
+
+    /**
+     * return value
+     *
+     * @var mixed
+     */
+    public $retvalue = 0;
+
+    /**
+     * @var
+     */
+    public $yymajor;
+
+    /**
+     * last index of array variable
+     *
+     * @var mixed
+     */
+    public $last_index;
+
+    /**
+     * last variable name
+     *
+     * @var string
+     */
+    public $last_variable;
+
+    /**
+     * root parse tree buffer
+     *
+     * @var Smarty_Internal_ParseTree_Template
+     */
+    public $root_buffer;
+
+    /**
+     * current parse tree object
+     *
+     * @var Smarty_Internal_ParseTree
+     */
+    public $current_buffer;
+
+    /**
+     * lexer object
+     *
+     * @var Smarty_Internal_Templatelexer
+     */
+    public $lex;
+
+    /**
+     * {strip} status
+     *
+     * @var bool
+     */
+    public $strip = false;
+
+    /**
+     * compiler object
+     *
+     * @var Smarty_Internal_TemplateCompilerBase
+     */
+    public $compiler = null;
+
+    /**
+     * smarty object
+     *
+     * @var Smarty
+     */
+    public $smarty = null;
+
+    /**
+     * template object
+     *
+     * @var Smarty_Internal_Template
+     */
+    public $template = null;
+
+    /**
+     * block nesting level
+     *
+     * @var int
+     */
+    public $block_nesting_level = 0;
+
+    /**
+     * security object
+     *
+     * @var Smarty_Security
+     */
+    public $security = null;
+
+    /**
+     * template prefix array
+     *
+     * @var \Smarty_Internal_ParseTree[]
+     */
+    public $template_prefix = array();
+
+    /**
+     * template prefix array
+     *
+     * @var \Smarty_Internal_ParseTree[]
+     */
+    public $template_postfix = array();
+
+    public $yyTraceFILE;
+
+    public $yyTracePrompt;
+
+    public $yyidx;
+
+    public $yyerrcnt;
+
+    public $yystack          = array();
+
+    public $yyTokenName      = array(
+        '$', 'VERT', 'COLON', 'PHP',
+        'TEXT', 'STRIPON', 'STRIPOFF', 'LITERALSTART',
+        'LITERALEND', 'LITERAL', 'SIMPELOUTPUT', 'SIMPLETAG',
+        'SMARTYBLOCKCHILDPARENT', 'LDEL', 'RDEL', 'DOLLARID',
+        'EQUAL', 'ID', 'PTR', 'LDELMAKENOCACHE',
+        'LDELIF', 'LDELFOR', 'SEMICOLON', 'INCDEC',
+        'TO', 'STEP', 'LDELFOREACH', 'SPACE',
+        'AS', 'APTR', 'LDELSETFILTER', 'CLOSETAG',
+        'LDELSLASH', 'ATTR', 'INTEGER', 'COMMA',
+        'OPENP', 'CLOSEP', 'MATH', 'UNIMATH',
+        'ISIN', 'QMARK', 'NOT', 'TYPECAST',
+        'HEX', 'DOT', 'INSTANCEOF', 'SINGLEQUOTESTRING',
+        'DOUBLECOLON', 'NAMESPACE', 'AT', 'HATCH',
+        'OPENB', 'CLOSEB', 'DOLLAR', 'LOGOP',
+        'SLOGOP', 'TLOGOP', 'SINGLECOND', 'ARRAYOPEN',
+        'QUOTE', 'BACKTICK', 'error', 'start',
+        'template', 'literal_e2', 'literal_e1', 'smartytag',
+        'tagbody', 'tag', 'outattr', 'eqoutattr',
+        'varindexed', 'output', 'attributes', 'variable',
+        'value', 'expr', 'modifierlist', 'statement',
+        'statements', 'foraction', 'varvar', 'modparameters',
+        'attribute', 'ternary', 'tlop', 'lop',
+        'scond', 'array', 'function', 'ns1',
+        'doublequoted_with_quotes', 'static_class_access', 'arraydef', 'object',
+        'arrayindex', 'indexdef', 'varvarele', 'objectchain',
+        'objectelement', 'method', 'params', 'modifier',
+        'modparameter', 'arrayelements', 'arrayelement', 'doublequoted',
+        'doublequotedcontent',
+    );
+
+    /**
+     * internal error flag
+     *
+     * @var bool
+     */
+    private $internalError = false;                    /* Index of top element in stack */
+    private $_retvalue;                 /* Shifts left before out of the error */
+    /**
+     * constructor
+     *
+     * @param Smarty_Internal_Templatelexer        $lex
+     * @param Smarty_Internal_TemplateCompilerBase $compiler
+     */
+    public function __construct(Smarty_Internal_Templatelexer $lex, Smarty_Internal_TemplateCompilerBase $compiler)
+    {
+        $this->lex = $lex;
+        $this->compiler = $compiler;
+        $this->template = $this->compiler->template;
+        $this->smarty = $this->template->smarty;
+        $this->security = isset($this->smarty->security_policy) ? $this->smarty->security_policy : false;
+        $this->current_buffer = $this->root_buffer = new Smarty_Internal_ParseTree_Template();
+    }  /* The parser's stack */
+    public static function yy_destructor($yymajor, $yypminor)
+    {
+        switch ($yymajor) {
+            default:
+                break;   /* If no destructor action specified: do nothing */
+        }
+    }
+
+    /**
+     * insert PHP code in current buffer
+     *
+     * @param string $code
+     */
+    public function insertPhpCode($code)
+    {
+        $this->current_buffer->append_subtree($this, new Smarty_Internal_ParseTree_Tag($this, $code));
+    }
+
+    /**
+     * error rundown
+     *
+     */
+    public function errorRunDown()
+    {
+        while ($this->yystack !== array()) {
+            $this->yy_pop_parser_stack();
+        }
+        if (is_resource($this->yyTraceFILE)) {
+            fclose($this->yyTraceFILE);
+        }
+    }
+
+    /**
+     *  merge PHP code with prefix code and return parse tree tag object
+     *
+     * @param string $code
+     *
+     * @return Smarty_Internal_ParseTree_Tag
+     */
+    public function mergePrefixCode($code)
+    {
+        $tmp = '';
+        foreach ($this->compiler->prefix_code as $preCode) {
+            $tmp .= $preCode;
+        }
+        $this->compiler->prefix_code = array();
+        $tmp .= $code;
+        return new Smarty_Internal_ParseTree_Tag($this, $this->compiler->processNocacheCode($tmp, true));
+    }
+
+    public function Trace($TraceFILE, $zTracePrompt)
+    {
+        if (!$TraceFILE) {
+            $zTracePrompt = 0;
+        } elseif (!$zTracePrompt) {
+            $TraceFILE = 0;
+        }
+        $this->yyTraceFILE = $TraceFILE;
+        $this->yyTracePrompt = $zTracePrompt;
+    }
+
+    public function PrintTrace()
+    {
+        $this->yyTraceFILE = fopen('php://output', 'w');
+        $this->yyTracePrompt = '<br>';
+    }
+
+    public function tokenName($tokenType)
+    {
+        if ($tokenType === 0) {
+            return 'End of Input';
+        }
+        if ($tokenType > 0 && $tokenType < count($this->yyTokenName)) {
+            return $this->yyTokenName[ $tokenType ];
+        } else {
+            return 'Unknown';
+        }
+    }
+
+    public function yy_pop_parser_stack()
+    {
+        if (empty($this->yystack)) {
+            return;
+        }
+        $yytos = array_pop($this->yystack);
+        if ($this->yyTraceFILE && $this->yyidx >= 0) {
+            fwrite($this->yyTraceFILE,
+                $this->yyTracePrompt . 'Popping ' . $this->yyTokenName[ $yytos->major ] .
+                "\n");
+        }
+        $yymajor = $yytos->major;
+        self::yy_destructor($yymajor, $yytos->minor);
+        $this->yyidx--;
+        return $yymajor;
+    }
+
+    public function __destruct()
+    {
+        while ($this->yystack !== array()) {
+            $this->yy_pop_parser_stack();
+        }
+        if (is_resource($this->yyTraceFILE)) {
+            fclose($this->yyTraceFILE);
+        }
+    }
+
+    public function yy_get_expected_tokens($token)
+    {
+        static $res3 = array();
+        static $res4 = array();
+        $state = $this->yystack[ $this->yyidx ]->stateno;
+        $expected = self::$yyExpectedTokens[ $state ];
+        if (isset($res3[ $state ][ $token ])) {
+            if ($res3[ $state ][ $token ]) {
+                return $expected;
+            }
+        } else {
+            if ($res3[ $state ][ $token ] = in_array($token, self::$yyExpectedTokens[ $state ], true)) {
+                return $expected;
+            }
+        }
+        $stack = $this->yystack;
+        $yyidx = $this->yyidx;
+        do {
+            $yyact = $this->yy_find_shift_action($token);
+            if ($yyact >= self::YYNSTATE && $yyact < self::YYNSTATE + self::YYNRULE) {
+                // reduce action
+                $done = 0;
+                do {
+                    if ($done++ === 100) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // too much recursion prevents proper detection
+                        // so give up
+                        return array_unique($expected);
+                    }
+                    $yyruleno = $yyact - self::YYNSTATE;
+                    $this->yyidx -= self::$yyRuleInfo[ $yyruleno ][ 1 ];
+                    $nextstate = $this->yy_find_reduce_action(
+                        $this->yystack[ $this->yyidx ]->stateno,
+                        self::$yyRuleInfo[ $yyruleno ][ 0 ]);
+                    if (isset(self::$yyExpectedTokens[ $nextstate ])) {
+                        $expected = array_merge($expected, self::$yyExpectedTokens[ $nextstate ]);
+                        if (isset($res4[ $nextstate ][ $token ])) {
+                            if ($res4[ $nextstate ][ $token ]) {
+                                $this->yyidx = $yyidx;
+                                $this->yystack = $stack;
+                                return array_unique($expected);
+                            }
+                        } else {
+                            if ($res4[ $nextstate ][ $token ] =
+                                in_array($token, self::$yyExpectedTokens[ $nextstate ], true)) {
+                                $this->yyidx = $yyidx;
+                                $this->yystack = $stack;
+                                return array_unique($expected);
+                            }
+                        }
+                    }
+                    if ($nextstate < self::YYNSTATE) {
+                        // we need to shift a non-terminal
+                        $this->yyidx++;
+                        $x = new TP_yyStackEntry;
+                        $x->stateno = $nextstate;
+                        $x->major = self::$yyRuleInfo[ $yyruleno ][ 0 ];
+                        $this->yystack[ $this->yyidx ] = $x;
+                        continue 2;
+                    } elseif ($nextstate === self::YYNSTATE + self::YYNRULE + 1) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // the last token was just ignored, we can't accept
+                        // by ignoring input, this is in essence ignoring a
+                        // syntax error!
+                        return array_unique($expected);
+                    } elseif ($nextstate === self::YY_NO_ACTION) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // input accepted, but not shifted (I guess)
+                        return $expected;
+                    } else {
+                        $yyact = $nextstate;
+                    }
+                } while (true);
+            }
+            break;
+        } while (true);
+        $this->yyidx = $yyidx;
+        $this->yystack = $stack;
+        return array_unique($expected);
+    }
+
+    public function yy_is_expected_token($token)
+    {
+        static $res = array();
+        static $res2 = array();
+        if ($token === 0) {
+            return true; // 0 is not part of this
+        }
+        $state = $this->yystack[ $this->yyidx ]->stateno;
+        if (isset($res[ $state ][ $token ])) {
+            if ($res[ $state ][ $token ]) {
+                return true;
+            }
+        } else {
+            if ($res[ $state ][ $token ] = in_array($token, self::$yyExpectedTokens[ $state ], true)) {
+                return true;
+            }
+        }
+        $stack = $this->yystack;
+        $yyidx = $this->yyidx;
+        do {
+            $yyact = $this->yy_find_shift_action($token);
+            if ($yyact >= self::YYNSTATE && $yyact < self::YYNSTATE + self::YYNRULE) {
+                // reduce action
+                $done = 0;
+                do {
+                    if ($done++ === 100) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // too much recursion prevents proper detection
+                        // so give up
+                        return true;
+                    }
+                    $yyruleno = $yyact - self::YYNSTATE;
+                    $this->yyidx -= self::$yyRuleInfo[ $yyruleno ][ 1 ];
+                    $nextstate = $this->yy_find_reduce_action(
+                        $this->yystack[ $this->yyidx ]->stateno,
+                        self::$yyRuleInfo[ $yyruleno ][ 0 ]);
+                    if (isset($res2[ $nextstate ][ $token ])) {
+                        if ($res2[ $nextstate ][ $token ]) {
+                            $this->yyidx = $yyidx;
+                            $this->yystack = $stack;
+                            return true;
+                        }
+                    } else {
+                        if ($res2[ $nextstate ][ $token ] =
+                            (isset(self::$yyExpectedTokens[ $nextstate ]) &&
+                             in_array($token, self::$yyExpectedTokens[ $nextstate ], true))) {
+                            $this->yyidx = $yyidx;
+                            $this->yystack = $stack;
+                            return true;
+                        }
+                    }
+                    if ($nextstate < self::YYNSTATE) {
+                        // we need to shift a non-terminal
+                        $this->yyidx++;
+                        $x = new TP_yyStackEntry;
+                        $x->stateno = $nextstate;
+                        $x->major = self::$yyRuleInfo[ $yyruleno ][ 0 ];
+                        $this->yystack[ $this->yyidx ] = $x;
+                        continue 2;
+                    } elseif ($nextstate === self::YYNSTATE + self::YYNRULE + 1) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        if (!$token) {
+                            // end of input: this is valid
+                            return true;
+                        }
+                        // the last token was just ignored, we can't accept
+                        // by ignoring input, this is in essence ignoring a
+                        // syntax error!
+                        return false;
+                    } elseif ($nextstate === self::YY_NO_ACTION) {
+                        $this->yyidx = $yyidx;
+                        $this->yystack = $stack;
+                        // input accepted, but not shifted (I guess)
+                        return true;
+                    } else {
+                        $yyact = $nextstate;
+                    }
+                } while (true);
+            }
+            break;
+        } while (true);
+        $this->yyidx = $yyidx;
+        $this->yystack = $stack;
+        return true;
+    }
+
+    public function yy_find_shift_action($iLookAhead)
+    {
+        $stateno = $this->yystack[ $this->yyidx ]->stateno;
+        /* if ($this->yyidx < 0) return self::YY_NO_ACTION;  */
+        if (!isset(self::$yy_shift_ofst[ $stateno ])) {
+            // no shift actions
+            return self::$yy_default[ $stateno ];
+        }
+        $i = self::$yy_shift_ofst[ $stateno ];
+        if ($i === self::YY_SHIFT_USE_DFLT) {
+            return self::$yy_default[ $stateno ];
+        }
+        if ($iLookAhead === self::YYNOCODE) {
+            return self::YY_NO_ACTION;
+        }
+        $i += $iLookAhead;
+        if ($i < 0 || $i >= self::YY_SZ_ACTTAB ||
+            self::$yy_lookahead[ $i ] != $iLookAhead) {
+            if (count(self::$yyFallback) && $iLookAhead < count(self::$yyFallback)
+                && ($iFallback = self::$yyFallback[ $iLookAhead ]) != 0) {
+                if ($this->yyTraceFILE) {
+                    fwrite($this->yyTraceFILE, $this->yyTracePrompt . 'FALLBACK ' .
+                                               $this->yyTokenName[ $iLookAhead ] . ' => ' .
+                                               $this->yyTokenName[ $iFallback ] . "\n");
+                }
+                return $this->yy_find_shift_action($iFallback);
+            }
+            return self::$yy_default[ $stateno ];
+        } else {
+            return self::$yy_action[ $i ];
+        }
+    }
+
+    public function yy_find_reduce_action($stateno, $iLookAhead)
+    {
+        /* $stateno = $this->yystack[$this->yyidx]->stateno; */
+        if (!isset(self::$yy_reduce_ofst[ $stateno ])) {
+            return self::$yy_default[ $stateno ];
+        }
+        $i = self::$yy_reduce_ofst[ $stateno ];
+        if ($i === self::YY_REDUCE_USE_DFLT) {
+            return self::$yy_default[ $stateno ];
+        }
+        if ($iLookAhead === self::YYNOCODE) {
+            return self::YY_NO_ACTION;
+        }
+        $i += $iLookAhead;
+        if ($i < 0 || $i >= self::YY_SZ_ACTTAB ||
+            self::$yy_lookahead[ $i ] != $iLookAhead) {
+            return self::$yy_default[ $stateno ];
+        } else {
+            return self::$yy_action[ $i ];
+        }
+    }
+
+    // line 234 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_shift($yyNewState, $yyMajor, $yypMinor)
+    {
+        $this->yyidx++;
+        if ($this->yyidx >= self::YYSTACKDEPTH) {
+            $this->yyidx--;
+            if ($this->yyTraceFILE) {
+                fprintf($this->yyTraceFILE, "%sStack Overflow!\n", $this->yyTracePrompt);
+            }
+            while ($this->yyidx >= 0) {
+                $this->yy_pop_parser_stack();
+            }
+            // line 221 "../smarty/lexer/smarty_internal_templateparser.y"
+            $this->internalError = true;
+            $this->compiler->trigger_template_error('Stack overflow in template parser');
+            return;
+        }
+        $yytos = new TP_yyStackEntry;
+        $yytos->stateno = $yyNewState;
+        $yytos->major = $yyMajor;
+        $yytos->minor = $yypMinor;
+        $this->yystack[] = $yytos;
+        if ($this->yyTraceFILE && $this->yyidx > 0) {
+            fprintf($this->yyTraceFILE, "%sShift %d\n", $this->yyTracePrompt,
+                $yyNewState);
+            fprintf($this->yyTraceFILE, "%sStack:", $this->yyTracePrompt);
+            for ($i = 1; $i <= $this->yyidx; $i++) {
+                fprintf($this->yyTraceFILE, " %s",
+                    $this->yyTokenName[ $this->yystack[ $i ]->major ]);
+            }
+            fwrite($this->yyTraceFILE, "\n");
+        }
+    }
+
+    // line 242 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r0()
+    {
+        $this->root_buffer->prepend_array($this, $this->template_prefix);
+        $this->root_buffer->append_array($this, $this->template_postfix);
+        $this->_retvalue = $this->root_buffer->to_smarty_php($this);
+    }
+
+    // line 251 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r1()
+    {
+        $code =
+            $this->compiler->compileTag('private_php',
+                array(array('code' => $this->yystack[ $this->yyidx + 0 ]->minor), array('type' => $this->lex->phpType)),
+                array());
+        if ($this->compiler->has_code && !empty($code)) {
+            $tmp = '';
+            foreach ($this->compiler->prefix_code as $code) {
+                $tmp .= $code;
+            }
+            $this->compiler->prefix_code = array();
+            $this->current_buffer->append_subtree($this,
+                new Smarty_Internal_ParseTree_Tag($this, $this->compiler->processNocacheCode($tmp . $code, true)));
+        }
+    }
+
+    // line 255 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r2()
+    {
+    	$text = $this->yystack[ $this->yyidx + 0 ]->minor;
+
+	    if ((string)$text == '') {
+	    	$this->current_buffer->append_subtree($this, null);
+	    }
+
+	    $this->current_buffer->append_subtree($this, new Smarty_Internal_ParseTree_Text($text, $this->strip));
+    }
+
+    // line 259 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r3()
+    {
+        $this->strip = true;
+    }
+
+    // line 264 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r4()
+    {
+        $this->strip = false;
+    }
+
+    // line 269 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r5()
+    {
+        $this->current_buffer->append_subtree($this,
+            new Smarty_Internal_ParseTree_Text($this->yystack[ $this->yyidx + -1 ]->minor));
+    }
+
+    // line 272 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r6()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -3 ]->minor . $this->yystack[ $this->yyidx + -1 ]->minor;
+    }
+
+    // line 276 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r7()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 281 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r8()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 285 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r9()
+    {
+        $this->_retvalue = '';
+    }
+
+    // line 297 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r10()
+    {
+        if ($this->compiler->has_code) {
+            $this->current_buffer->append_subtree($this,
+                $this->mergePrefixCode($this->yystack[ $this->yyidx + 0 ]->minor));
+        }
+        $this->compiler->has_variable_string = false;
+        $this->block_nesting_level = count($this->compiler->_tag_stack);
+    }
+
+    // line 307 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r12()
+    {
+        $var =
+            trim(substr($this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler->getLdelLength(),
+                -$this->compiler->getRdelLength()), ' $');
+        if (preg_match('/^(.*)(\s+nocache)$/', $var, $match)) {
+            $this->_retvalue =
+                $this->compiler->compileTag('private_print_expression', array('nocache'),
+                    array('value' => $this->compiler->compileVariable('\'' . $match[ 1 ] . '\'')));
+        } else {
+            $this->_retvalue =
+                $this->compiler->compileTag('private_print_expression', array(),
+                    array('value' => $this->compiler->compileVariable('\'' . $var . '\'')));
+        }
+    }
+
+    // line 328 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r13()
+    {
+        $tag =
+            trim(substr($this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler->getLdelLength(),
+                -$this->compiler->getRdelLength()));
+        if ($tag == 'strip') {
+            $this->strip = true;
+            $this->_retvalue = null;
+        } else {
+            if (defined($tag)) {
+                if ($this->security) {
+                    $this->security->isTrustedConstant($tag, $this->compiler);
+                }
+                $this->_retvalue =
+                    $this->compiler->compileTag('private_print_expression', array(), array('value' => $tag));
+            } else {
+                if (preg_match('/^(.*)(\s+nocache)$/', $tag, $match)) {
+                    $this->_retvalue = $this->compiler->compileTag($match[ 1 ], array('\'nocache\''));
+                } else {
+                    $this->_retvalue = $this->compiler->compileTag($tag, array());
+                }
+            }
+        }
+    }
+
+    // line 339 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r14()
+    {
+        $j = strrpos($this->yystack[ $this->yyidx + 0 ]->minor, '.');
+        if ($this->yystack[ $this->yyidx + 0 ]->minor[ $j + 1 ] == 'c') {
+            // {$smarty.block.child}
+            $this->_retvalue =
+                $this->compiler->compileTag('child', array(), array($this->yystack[ $this->yyidx + 0 ]->minor));
+        } else {
+            // {$smarty.block.parent}
+            $this->_retvalue =
+                $this->compiler->compileTag('parent', array(), array($this->yystack[ $this->yyidx + 0 ]->minor));
+        }
+    }
+
+    // line 343 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r15()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor;
+    }
+
+    // line 347 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r16()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor;
+    }
+
+    // line 356 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r17()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('private_print_expression', $this->yystack[ $this->yyidx + 0 ]->minor[ 1 ],
+                array('value' => $this->yystack[ $this->yyidx + 0 ]->minor[ 0 ]));
+    }
+
+    // line 360 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r18()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('assign', array_merge(array(
+                array('value' => $this->yystack[ $this->yyidx + 0 ]->minor[ 0 ]),
+                array('var' => '\'' . substr($this->yystack[ $this->yyidx + -1 ]->minor, 1) . '\'')
+            ), $this->yystack[ $this->yyidx + 0 ]->minor[ 1 ]));
+    }
+
+    // line 364 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r19()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('assign', array_merge(array(
+                array('value' => $this->yystack[ $this->yyidx + 0 ]->minor[ 0 ]),
+                array('var' => $this->yystack[ $this->yyidx + -1 ]->minor[ 'var' ])
+            ), $this->yystack[ $this->yyidx + 0 ]->minor[ 1 ]), array(
+                'smarty_internal_index' => $this->yystack[ $this->yyidx +
+                                                           -1 ]->minor[ 'smarty_internal_index' ]
+            ));
+    }
+
+    // line 368 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r20()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 383 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r21()
+    {
+        $this->_retvalue = array($this->yystack[ $this->yyidx + -1 ]->minor, $this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 393 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r25()
+    {
+        if (defined($this->yystack[ $this->yyidx + -1 ]->minor)) {
+            if ($this->security) {
+                $this->security->isTrustedConstant($this->yystack[ $this->yyidx + -1 ]->minor, $this->compiler);
+            }
+            $this->_retvalue =
+                $this->compiler->compileTag('private_print_expression', $this->yystack[ $this->yyidx + 0 ]->minor,
+                    array('value' => $this->yystack[ $this->yyidx + -1 ]->minor));
+        } else {
+            $this->_retvalue =
+                $this->compiler->compileTag($this->yystack[ $this->yyidx + -1 ]->minor,
+                    $this->yystack[ $this->yyidx + 0 ]->minor);
+        }
+    }
+
+    // line 406 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r26()
+    {
+        if (defined($this->yystack[ $this->yyidx + 0 ]->minor)) {
+            if ($this->security) {
+                $this->security->isTrustedConstant($this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler);
+            }
+            $this->_retvalue =
+                $this->compiler->compileTag('private_print_expression', array(),
+                    array('value' => $this->yystack[ $this->yyidx + 0 ]->minor));
+        } else {
+            $this->_retvalue = $this->compiler->compileTag($this->yystack[ $this->yyidx + 0 ]->minor, array());
+        }
+    }
+
+    // line 418 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r27()
+    {
+        if (defined($this->yystack[ $this->yyidx + -2 ]->minor)) {
+            if ($this->security) {
+                $this->security->isTrustedConstant($this->yystack[ $this->yyidx + -2 ]->minor, $this->compiler);
+            }
+            $this->_retvalue =
+                $this->compiler->compileTag('private_print_expression', $this->yystack[ $this->yyidx + 0 ]->minor,
+                    array(
+                        'value'        => $this->yystack[ $this->yyidx + -2 ]->minor,
+                        'modifierlist' => $this->yystack[ $this->yyidx + -1 ]->minor
+                    ));
+        } else {
+            $this->_retvalue =
+                $this->compiler->compileTag($this->yystack[ $this->yyidx + -2 ]->minor,
+                    $this->yystack[ $this->yyidx + 0 ]->minor,
+                    array('modifierlist' => $this->yystack[ $this->yyidx + -1 ]->minor));
+        }
+    }
+
+    // line 423 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r28()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag($this->yystack[ $this->yyidx + -3 ]->minor,
+                $this->yystack[ $this->yyidx + 0 ]->minor,
+                array('object_method' => $this->yystack[ $this->yyidx + -1 ]->minor));
+    }
+
+    // line 428 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r29()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag($this->yystack[ $this->yyidx + -4 ]->minor,
+                $this->yystack[ $this->yyidx + 0 ]->minor, array(
+                    'modifierlist'  => $this->yystack[ $this->yyidx + -1 ]->minor,
+                    'object_method' => $this->yystack[ $this->yyidx + -2 ]->minor
+                ));
+    }
+
+    // line 433 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r30()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('make_nocache',
+                array(array('var' => '\'' . substr($this->yystack[ $this->yyidx + 0 ]->minor, 1) . '\'')));
+    }
+
+    // line 438 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r31()
+    {
+        $tag = trim(substr($this->yystack[ $this->yyidx + -1 ]->minor, $this->compiler->getLdelLength()));
+        $this->_retvalue =
+            $this->compiler->compileTag(($tag === 'else if') ? 'elseif' : $tag, array(),
+                array('if condition' => $this->yystack[ $this->yyidx + 0 ]->minor));
+    }
+
+    // line 443 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r32()
+    {
+        $tag = trim(substr($this->yystack[ $this->yyidx + -2 ]->minor, $this->compiler->getLdelLength()));
+        $this->_retvalue =
+            $this->compiler->compileTag(($tag === 'else if') ? 'elseif' : $tag,
+                $this->yystack[ $this->yyidx + 0 ]->minor,
+                array('if condition' => $this->yystack[ $this->yyidx + -1 ]->minor));
+    }
+
+    // line 454 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r33()
+    {
+        $tag = trim(substr($this->yystack[ $this->yyidx + -1 ]->minor, $this->compiler->getLdelLength()));
+        $this->_retvalue =
+            $this->compiler->compileTag(($tag === 'else if') ? 'elseif' : $tag, array(),
+                array('if condition' => $this->yystack[ $this->yyidx + 0 ]->minor));
+    }
+
+    // line 458 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r35()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('for', array_merge($this->yystack[ $this->yyidx + 0 ]->minor, array(
+                array('start' => $this->yystack[ $this->yyidx + -6 ]->minor),
+                array('ifexp' => $this->yystack[ $this->yyidx + -4 ]->minor),
+                array('var' => $this->yystack[ $this->yyidx + -2 ]->minor),
+                array('step' => $this->yystack[ $this->yyidx + -1 ]->minor)
+            )), 1);
+    }
+
+    // line 466 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r36()
+    {
+        $this->_retvalue = '=' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 470 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r38()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('for', array_merge($this->yystack[ $this->yyidx + 0 ]->minor, array(
+                array('start' => $this->yystack[ $this->yyidx + -3 ]->minor),
+                array('to' => $this->yystack[ $this->yyidx + -1 ]->minor)
+            )), 0);
+    }
+
+    // line 475 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r39()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('for', array_merge($this->yystack[ $this->yyidx + 0 ]->minor, array(
+                array('start' => $this->yystack[ $this->yyidx + -5 ]->minor),
+                array('to' => $this->yystack[ $this->yyidx + -3 ]->minor),
+                array('step' => $this->yystack[ $this->yyidx + -1 ]->minor)
+            )), 0);
+    }
+
+    // line 479 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r40()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('foreach', array_merge($this->yystack[ $this->yyidx + 0 ]->minor, array(
+                array('from' => $this->yystack[ $this->yyidx + -3 ]->minor),
+                array('item' => $this->yystack[ $this->yyidx + -1 ]->minor)
+            )));
+    }
+
+    // line 482 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r41()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('foreach', array_merge($this->yystack[ $this->yyidx + 0 ]->minor, array(
+                array('from' => $this->yystack[ $this->yyidx + -5 ]->minor),
+                array('item' => $this->yystack[ $this->yyidx + -1 ]->minor),
+                array('key' => $this->yystack[ $this->yyidx + -3 ]->minor)
+            )));
+    }
+
+    // line 487 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r42()
+    {
+        $this->_retvalue = $this->compiler->compileTag('foreach', $this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 491 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r43()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('setfilter', array(), array(
+                'modifier_list' => array(
+                    array_merge(array($this->yystack[ $this->yyidx + -1 ]->minor),
+                        $this->yystack[ $this->yyidx + 0 ]->minor)
+                )
+            ));
+    }
+
+    // line 497 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r44()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('setfilter', array(), array(
+                'modifier_list' => array_merge(array(
+                    array_merge(array(
+                        $this->yystack[ $this->yyidx +
+                                        -2 ]->minor
+                    ), $this->yystack[ $this->yyidx + -1 ]->minor)
+                ), $this->yystack[ $this->yyidx + 0 ]->minor)
+            ));
+    }
+
+    // line 506 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r45()
+    {
+        $tag =
+            trim(substr($this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler->getLdelLength(),
+                -$this->compiler->getRdelLength()), ' /');
+        if ($tag === 'strip') {
+            $this->strip = false;
+            $this->_retvalue = null;
+        } else {
+            $this->_retvalue = $this->compiler->compileTag($tag . 'close', array());
+        }
+    }
+
+    // line 510 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r46()
+    {
+        $this->_retvalue = $this->compiler->compileTag($this->yystack[ $this->yyidx + 0 ]->minor . 'close', array());
+    }
+
+    // line 515 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r47()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag($this->yystack[ $this->yyidx + -1 ]->minor . 'close', array(),
+                array('modifier_list' => $this->yystack[ $this->yyidx + 0 ]->minor));
+    }
+
+    // line 519 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r48()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag($this->yystack[ $this->yyidx + -2 ]->minor . 'close', array(),
+                array('object_method' => $this->yystack[ $this->yyidx + 0 ]->minor));
+    }
+
+    // line 527 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r49()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag($this->yystack[ $this->yyidx + -3 ]->minor . 'close', array(), array(
+                'object_method' => $this->yystack[ $this->yyidx + -1 ]->minor,
+                'modifier_list' => $this->yystack[ $this->yyidx + 0 ]->minor
+            ));
+    }
+
+    // line 533 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r50()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor;
+        $this->_retvalue[] = $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 538 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r51()
+    {
+        $this->_retvalue = array($this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 543 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r52()
+    {
+        $this->_retvalue = array();
+    }
+
+    // line 554 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r53()
+    {
+        if (defined($this->yystack[ $this->yyidx + 0 ]->minor)) {
+            if ($this->security) {
+                $this->security->isTrustedConstant($this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler);
+            }
+            $this->_retvalue =
+                array($this->yystack[ $this->yyidx + -2 ]->minor => $this->yystack[ $this->yyidx + 0 ]->minor);
+        } else {
+            $this->_retvalue =
+                array(
+                    $this->yystack[ $this->yyidx + -2 ]->minor => '\'' .
+                                                                  $this->yystack[ $this->yyidx + 0 ]->minor .
+                                                                  '\''
+                );
+        }
+    }
+
+    // line 562 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r54()
+    {
+        $this->_retvalue =
+            array(
+                trim($this->yystack[ $this->yyidx + -1 ]->minor, " =\n\r\t") => $this->yystack[ $this->yyidx +
+                                                                                                0 ]->minor
+            );
+    }
+
+    // line 574 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r56()
+    {
+        $this->_retvalue = '\'' . $this->yystack[ $this->yyidx + 0 ]->minor . '\'';
+    }
+
+    // line 587 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r59()
+    {
+        $this->_retvalue =
+            array($this->yystack[ $this->yyidx + -2 ]->minor => $this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 592 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r61()
+    {
+        $this->yystack[ $this->yyidx + -2 ]->minor[] = $this->yystack[ $this->yyidx + 0 ]->minor;
+        $this->_retvalue = $this->yystack[ $this->yyidx + -2 ]->minor;
+    }
+
+    // line 599 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r62()
+    {
+        $this->_retvalue =
+            array(
+                'var'   => '\'' . substr($this->yystack[ $this->yyidx + -2 ]->minor, 1) . '\'',
+                'value' => $this->yystack[ $this->yyidx + 0 ]->minor
+            );
+    }
+
+    // line 603 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r64()
+    {
+        $this->_retvalue =
+            array(
+                'var'   => $this->yystack[ $this->yyidx + -2 ]->minor,
+                'value' => $this->yystack[ $this->yyidx + 0 ]->minor
+            );
+    }
+
+    // line 623 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r65()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor;
+    }
+
+    // line 628 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r68()
+    {
+        $this->_retvalue =
+            '$_smarty_tpl->getStreamVariable(\'' .
+            substr($this->yystack[ $this->yyidx + -2 ]->minor, 1) .
+            '://' .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            '\')';
+    }
+
+    // line 638 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r69()
+    {
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            trim($this->yystack[ $this->yyidx + -1 ]->minor) .
+            $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 642 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r71()
+    {
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -1 ]->minor[ 'pre' ] .
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            $this->yystack[ $this->yyidx + -1 ]->minor[ 'op' ] .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            ')';
+    }
+
+    // line 646 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r72()
+    {
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            $this->yystack[ $this->yyidx + -1 ]->minor .
+            $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 650 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r73()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + 0 ]->minor . $this->yystack[ $this->yyidx + -1 ]->minor . ')';
+    }
+
+    // line 654 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r74()
+    {
+        $this->_retvalue =
+            'in_array(' .
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            ',' .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            ')';
+    }
+
+    // line 662 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r75()
+    {
+        $this->_retvalue =
+            'in_array(' .
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            ',(array)' .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            ')';
+    }
+
+    // line 666 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r76()
+    {
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -5 ]->minor .
+            ' ? ' .
+            $this->compiler->compileVariable('\'' . substr($this->yystack[ $this->yyidx + -2 ]->minor, 1) . '\'') .
+            ' : ' .
+            $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 676 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r77()
+    {
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -5 ]->minor .
+            ' ? ' .
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            ' : ' .
+            $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 681 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r79()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 702 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r80()
+    {
+        $this->_retvalue = '!' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 706 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r85()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -2 ]->minor . '.' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 710 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r86()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor . '.';
+    }
+
+    // line 715 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r87()
+    {
+        $this->_retvalue = '.' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 732 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r88()
+    {
+        if (defined($this->yystack[ $this->yyidx + 0 ]->minor)) {
+            if ($this->security) {
+                $this->security->isTrustedConstant($this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler);
+            }
+            $this->_retvalue = $this->yystack[ $this->yyidx + 0 ]->minor;
+        } else {
+            $this->_retvalue = '\'' . $this->yystack[ $this->yyidx + 0 ]->minor . '\'';
+        }
+    }
+
+    // line 736 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r90()
+    {
+        $this->_retvalue = '(' . $this->yystack[ $this->yyidx + -1 ]->minor . ')';
+    }
+
+    // line 754 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r91()
+    {
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            $this->yystack[ $this->yyidx + -1 ]->minor .
+            $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 765 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r95()
+    {
+        if ($this->security && $this->security->static_classes !== array()) {
+            $this->compiler->trigger_template_error('dynamic static class not allowed by security setting');
+        }
+
+        $prefixVar = $this->compiler->getNewPrefixVariable();
+        if ($this->yystack[ $this->yyidx + -2 ]->minor[ 'var' ] === '\'smarty\'') {
+            $this->compiler->appendPrefixCode("<?php {$prefixVar} = " .
+                                              $this->compiler->compileTag('private_special_variable', array(),
+                                                  $this->yystack[ $this->yyidx +
+                                                                  -2 ]->minor[ 'smarty_internal_index' ]) .
+                                              ';?>');
+        } else {
+            $this->compiler->appendPrefixCode("<?php  {$prefixVar} = " .
+                                              $this->compiler->compileVariable($this->yystack[ $this->yyidx +
+                                                                                               -2 ]->minor[ 'var' ]) .
+                                              $this->yystack[ $this->yyidx + -2 ]->minor[ 'smarty_internal_index' ] .
+                                              ';?>');
+        }
+        $this->_retvalue =
+            $prefixVar .
+            '::' .
+            $this->yystack[ $this->yyidx + 0 ]->minor[ 0 ] .
+            $this->yystack[ $this->yyidx + 0 ]->minor[ 1 ];
+    }
+
+    // line 772 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r96()
+    {
+        $prefixVar = $this->compiler->getNewPrefixVariable();
+        $tmp = $this->compiler->appendCode('<?php ob_start();?>', $this->yystack[ $this->yyidx + 0 ]->minor);
+        $this->compiler->appendPrefixCode($this->compiler->appendCode($tmp, "<?php {$prefixVar} = ob_get_clean();?>"));
+        $this->_retvalue = $prefixVar;
+    }
+
+    // line 785 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r97()
+    {
+        $this->_retvalue =
+            $this->compiler->compileTag('private_modifier', array(), array(
+                'value'        => $this->yystack[ $this->yyidx + -1 ]->minor,
+                'modifierlist' => $this->yystack[ $this->yyidx + 0 ]->minor
+            ));
+    }
+
+    // line 804 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r100()
+    {
+        if (!in_array(strtolower($this->yystack[ $this->yyidx + -2 ]->minor), array('self', 'parent')) &&
+            (!$this->security ||
+             $this->security->isTrustedStaticClassAccess($this->yystack[ $this->yyidx + -2 ]->minor,
+                 $this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler))) {
+            if (isset($this->smarty->registered_classes[ $this->yystack[ $this->yyidx + -2 ]->minor ])) {
+                $this->_retvalue =
+                    $this->smarty->registered_classes[ $this->yystack[ $this->yyidx + -2 ]->minor ] .
+                    '::' .
+                    $this->yystack[ $this->yyidx + 0 ]->minor[ 0 ] .
+                    $this->yystack[ $this->yyidx + 0 ]->minor[ 1 ];
+            } else {
+                $this->_retvalue =
+                    $this->yystack[ $this->yyidx + -2 ]->minor .
+                    '::' .
+                    $this->yystack[ $this->yyidx + 0 ]->minor[ 0 ] .
+                    $this->yystack[ $this->yyidx + 0 ]->minor[ 1 ];
+            }
+        } else {
+            $this->compiler->trigger_template_error('static class \'' .
+                                                    $this->yystack[ $this->yyidx + -2 ]->minor .
+                                                    '\' is undefined or not allowed by security setting');
+        }
+    }
+
+    // line 815 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r102()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 818 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r103()
+    {
+        $this->_retvalue =
+            $this->compiler->compileVariable('\'' . substr($this->yystack[ $this->yyidx + 0 ]->minor, 1) . '\'');
+    }
+
+    // line 831 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r104()
+    {
+        if ($this->yystack[ $this->yyidx + 0 ]->minor[ 'var' ] === '\'smarty\'') {
+            $smarty_var =
+                $this->compiler->compileTag('private_special_variable', array(),
+                    $this->yystack[ $this->yyidx + 0 ]->minor[ 'smarty_internal_index' ]);
+            $this->_retvalue = $smarty_var;
+        } else {
+            // used for array reset,next,prev,end,current
+            $this->last_variable = $this->yystack[ $this->yyidx + 0 ]->minor[ 'var' ];
+            $this->last_index = $this->yystack[ $this->yyidx + 0 ]->minor[ 'smarty_internal_index' ];
+            $this->_retvalue =
+                $this->compiler->compileVariable($this->yystack[ $this->yyidx + 0 ]->minor[ 'var' ]) .
+                $this->yystack[ $this->yyidx + 0 ]->minor[ 'smarty_internal_index' ];
+        }
+    }
+
+    // line 841 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r105()
+    {
+        $this->_retvalue =
+            '$_smarty_tpl->tpl_vars[' .
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            ']->' .
+            $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 845 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r107()
+    {
+        $this->_retvalue =
+            $this->compiler->compileConfigVariable('\'' . $this->yystack[ $this->yyidx + -1 ]->minor . '\'');
+    }
+
+    // line 849 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r108()
+    {
+        $this->_retvalue =
+            '(is_array($tmp = ' .
+            $this->compiler->compileConfigVariable('\'' . $this->yystack[ $this->yyidx + -2 ]->minor . '\'') .
+            ') ? $tmp' .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            ' :null)';
+    }
+
+    // line 853 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r109()
+    {
+        $this->_retvalue = $this->compiler->compileConfigVariable($this->yystack[ $this->yyidx + -1 ]->minor);
+    }
+
+    // line 857 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r110()
+    {
+        $this->_retvalue =
+            '(is_array($tmp = ' .
+            $this->compiler->compileConfigVariable($this->yystack[ $this->yyidx + -2 ]->minor) .
+            ') ? $tmp' .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            ' : null)';
+    }
+
+    // line 860 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r111()
+    {
+        $this->_retvalue =
+            array(
+                'var'                   => '\'' . substr($this->yystack[ $this->yyidx + -1 ]->minor, 1) . '\'',
+                'smarty_internal_index' => $this->yystack[ $this->yyidx + 0 ]->minor
+            );
+    }
+
+    // line 873 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r112()
+    {
+        $this->_retvalue =
+            array(
+                'var'                   => $this->yystack[ $this->yyidx + -1 ]->minor,
+                'smarty_internal_index' => $this->yystack[ $this->yyidx + 0 ]->minor
+            );
+    }
+
+    // line 879 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r114()
+    {
+        return;
+    }
+
+    // line 882 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r115()
+    {
+        $this->_retvalue =
+            '[' .
+            $this->compiler->compileVariable('\'' . substr($this->yystack[ $this->yyidx + 0 ]->minor, 1) . '\'') .
+            ']';
+    }
+
+    // line 886 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r116()
+    {
+        $this->_retvalue = '[' . $this->compiler->compileVariable($this->yystack[ $this->yyidx + 0 ]->minor) . ']';
+    }
+
+    // line 890 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r117()
+    {
+        $this->_retvalue =
+            '[' .
+            $this->compiler->compileVariable($this->yystack[ $this->yyidx + -2 ]->minor) .
+            '->' .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            ']';
+    }
+
+    // line 894 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r118()
+    {
+        $this->_retvalue = '[\'' . $this->yystack[ $this->yyidx + 0 ]->minor . '\']';
+    }
+
+    // line 899 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r119()
+    {
+        $this->_retvalue = '[' . $this->yystack[ $this->yyidx + 0 ]->minor . ']';
+    }
+
+    // line 904 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r120()
+    {
+        $this->_retvalue = '[' . $this->yystack[ $this->yyidx + -1 ]->minor . ']';
+    }
+
+    // line 908 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r121()
+    {
+        $this->_retvalue =
+            '[' .
+            $this->compiler->compileTag('private_special_variable', array(),
+                '[\'section\'][\'' . $this->yystack[ $this->yyidx + -1 ]->minor . '\'][\'index\']') .
+            ']';
+    }
+
+    // line 911 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r122()
+    {
+        $this->_retvalue =
+            '[' .
+            $this->compiler->compileTag('private_special_variable', array(), '[\'section\'][\'' .
+                                                                             $this->yystack[ $this->yyidx +
+                                                                                             -3 ]->minor .
+                                                                             '\'][\'' .
+                                                                             $this->yystack[ $this->yyidx +
+                                                                                             -1 ]->minor .
+                                                                             '\']') .
+            ']';
+    }
+
+    // line 917 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r123()
+    {
+        $this->_retvalue = '[' . $this->yystack[ $this->yyidx + -1 ]->minor . ']';
+    }
+
+    // line 933 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r125()
+    {
+        $this->_retvalue =
+            '[' .
+            $this->compiler->compileVariable('\'' . substr($this->yystack[ $this->yyidx + -1 ]->minor, 1) . '\'') .
+            ']';
+    }
+
+    // line 943 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r129()
+    {
+        $this->_retvalue = '[]';
+    }
+
+    // line 947 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r130()
+    {
+        $this->_retvalue = '\'' . substr($this->yystack[ $this->yyidx + 0 ]->minor, 1) . '\'';
+    }
+
+    // line 952 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r131()
+    {
+        $this->_retvalue = '\'\'';
+    }
+
+    // line 960 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r132()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor . '.' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 966 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r134()
+    {
+        $var =
+            trim(substr($this->yystack[ $this->yyidx + 0 ]->minor, $this->compiler->getLdelLength(),
+                -$this->compiler->getRdelLength()), ' $');
+        $this->_retvalue = $this->compiler->compileVariable('\'' . $var . '\'');
+    }
+
+    // line 973 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r135()
+    {
+        $this->_retvalue = '(' . $this->yystack[ $this->yyidx + -1 ]->minor . ')';
+    }
+
+    // line 982 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r136()
+    {
+        if ($this->yystack[ $this->yyidx + -1 ]->minor[ 'var' ] === '\'smarty\'') {
+            $this->_retvalue =
+                $this->compiler->compileTag('private_special_variable', array(),
+                    $this->yystack[ $this->yyidx + -1 ]->minor[ 'smarty_internal_index' ]) .
+                $this->yystack[ $this->yyidx + 0 ]->minor;
+        } else {
+            $this->_retvalue =
+                $this->compiler->compileVariable($this->yystack[ $this->yyidx + -1 ]->minor[ 'var' ]) .
+                $this->yystack[ $this->yyidx + -1 ]->minor[ 'smarty_internal_index' ] .
+                $this->yystack[ $this->yyidx + 0 ]->minor;
+        }
+    }
+
+    // line 987 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r137()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 992 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r138()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 999 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r139()
+    {
+        if ($this->security && substr($this->yystack[ $this->yyidx + -1 ]->minor, 0, 1) === '_') {
+            $this->compiler->trigger_template_error(self::ERR1);
+        }
+        $this->_retvalue =
+            '->' . $this->yystack[ $this->yyidx + -1 ]->minor . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 1006 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r140()
+    {
+        if ($this->security) {
+            $this->compiler->trigger_template_error(self::ERR2);
+        }
+        $this->_retvalue =
+            '->{' .
+            $this->compiler->compileVariable($this->yystack[ $this->yyidx + -1 ]->minor) .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            '}';
+    }
+
+    // line 1013 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r141()
+    {
+        if ($this->security) {
+            $this->compiler->trigger_template_error(self::ERR2);
+        }
+        $this->_retvalue =
+            '->{' . $this->yystack[ $this->yyidx + -2 ]->minor . $this->yystack[ $this->yyidx + 0 ]->minor . '}';
+    }
+
+    // line 1021 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r142()
+    {
+        if ($this->security) {
+            $this->compiler->trigger_template_error(self::ERR2);
+        }
+        $this->_retvalue =
+            '->{\'' .
+            $this->yystack[ $this->yyidx + -4 ]->minor .
+            '\'.' .
+            $this->yystack[ $this->yyidx + -2 ]->minor .
+            $this->yystack[ $this->yyidx + 0 ]->minor .
+            '}';
+    }
+
+    // line 1029 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r143()
+    {
+        $this->_retvalue = '->' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 1037 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r144()
+    {
+        $this->_retvalue =
+            $this->compiler->compilePHPFunctionCall($this->yystack[ $this->yyidx + -3 ]->minor,
+                $this->yystack[ $this->yyidx + -1 ]->minor);
+    }
+
+    // line 1044 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r145()
+    {
+        if ($this->security && substr($this->yystack[ $this->yyidx + -3 ]->minor, 0, 1) === '_') {
+            $this->compiler->trigger_template_error(self::ERR1);
+        }
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -3 ]->minor .
+            '(' .
+            implode(',', $this->yystack[ $this->yyidx + -1 ]->minor) .
+            ')';
+    }
+
+    // line 1055 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r146()
+    {
+        if ($this->security) {
+            $this->compiler->trigger_template_error(self::ERR2);
+        }
+        $prefixVar = $this->compiler->getNewPrefixVariable();
+        $this->compiler->appendPrefixCode("<?php {$prefixVar} = " .
+                                          $this->compiler->compileVariable('\'' .
+                                                                           substr($this->yystack[ $this->yyidx +
+                                                                                                  -3 ]->minor, 1) .
+                                                                           '\'') .
+                                          ';?>');
+        $this->_retvalue = $prefixVar . '(' . implode(',', $this->yystack[ $this->yyidx + -1 ]->minor) . ')';
+    }
+
+    // line 1072 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r147()
+    {
+        $this->_retvalue =
+            array_merge($this->yystack[ $this->yyidx + -2 ]->minor, array($this->yystack[ $this->yyidx + 0 ]->minor));
+    }
+
+    // line 1076 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r150()
+    {
+        $this->_retvalue =
+            array_merge($this->yystack[ $this->yyidx + -2 ]->minor, array(
+                array_merge($this->yystack[ $this->yyidx + -1 ]->minor, $this->yystack[ $this->yyidx + 0 ]->minor)
+            ));
+    }
+
+    // line 1084 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r151()
+    {
+        $this->_retvalue =
+            array(array_merge($this->yystack[ $this->yyidx + -1 ]->minor, $this->yystack[ $this->yyidx + 0 ]->minor));
+    }
+
+    // line 1092 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r153()
+    {
+        $this->_retvalue = array($this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 1105 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r154()
+    {
+        $this->_retvalue =
+            array_merge($this->yystack[ $this->yyidx + -1 ]->minor, $this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 1114 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r157()
+    {
+        $this->_retvalue =
+            array(trim($this->yystack[ $this->yyidx + -1 ]->minor) . $this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 1119 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r159()
+    {
+        $this->_retvalue = array($this->yystack[ $this->yyidx + 0 ]->minor, '', 'method');
+    }
+
+    // line 1124 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r160()
+    {
+        $this->_retvalue =
+            array($this->yystack[ $this->yyidx + -1 ]->minor, $this->yystack[ $this->yyidx + 0 ]->minor, 'method');
+    }
+
+    // line 1129 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r161()
+    {
+        $this->_retvalue = array($this->yystack[ $this->yyidx + 0 ]->minor, '');
+    }
+
+    // line 1134 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r162()
+    {
+        $this->_retvalue =
+            array($this->yystack[ $this->yyidx + -1 ]->minor, $this->yystack[ $this->yyidx + 0 ]->minor, 'property');
+    }
+
+    // line 1140 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r163()
+    {
+        $this->_retvalue =
+            array(
+                $this->yystack[ $this->yyidx + -2 ]->minor,
+                $this->yystack[ $this->yyidx + -1 ]->minor . $this->yystack[ $this->yyidx + 0 ]->minor, 'property'
+            );
+    }
+
+    // line 1144 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r164()
+    {
+        $this->_retvalue = ' ' . trim($this->yystack[ $this->yyidx + 0 ]->minor) . ' ';
+    }
+
+    // line 1163 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r165()
+    {
+        static $lops = array(
+            'eq'  => ' == ',
+            'ne'  => ' != ',
+            'neq' => ' != ',
+            'gt'  => ' > ',
+            'ge'  => ' >= ',
+            'gte' => ' >= ',
+            'lt'  => ' < ',
+            'le'  => ' <= ',
+            'lte' => ' <= ',
+            'mod' => ' % ',
+            'and' => ' && ',
+            'or'  => ' || ',
+            'xor' => ' xor ',
+        );
+        $op = strtolower(preg_replace('/\s*/', '', $this->yystack[ $this->yyidx + 0 ]->minor));
+        $this->_retvalue = $lops[ $op ];
+    }
+
+    // line 1176 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r166()
+    {
+        static $tlops = array(
+            'isdivby'     => array('op' => ' % ', 'pre' => '!('),
+            'isnotdivby'  => array('op' => ' % ', 'pre' => '('),
+            'isevenby'    => array('op' => ' / ', 'pre' => '!(1 & '),
+            'isnotevenby' => array('op' => ' / ', 'pre' => '(1 & '),
+            'isoddby'     => array('op' => ' / ', 'pre' => '(1 & '),
+            'isnotoddby'  => array('op' => ' / ', 'pre' => '!(1 & '),
+        );
+        $op = strtolower(preg_replace('/\s*/', '', $this->yystack[ $this->yyidx + 0 ]->minor));
+        $this->_retvalue = $tlops[ $op ];
+    }
+
+    // line 1190 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r167()
+    {
+        static $scond = array(
+            'iseven'    => '!(1 & ',
+            'isnoteven' => '(1 & ',
+            'isodd'     => '(1 & ',
+            'isnotodd'  => '!(1 & ',
+        );
+        $op = strtolower(str_replace(' ', '', $this->yystack[ $this->yyidx + 0 ]->minor));
+        $this->_retvalue = $scond[ $op ];
+    }
+
+    // line 1201 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r168()
+    {
+        $this->_retvalue = 'array(' . $this->yystack[ $this->yyidx + -1 ]->minor . ')';
+    }
+
+    // line 1209 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r171()
+    {
+        $this->_retvalue = $this->yystack[ $this->yyidx + -2 ]->minor . ',' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 1213 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r173()
+    {
+        $this->_retvalue =
+            $this->yystack[ $this->yyidx + -2 ]->minor . '=>' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 1229 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r174()
+    {
+        $this->_retvalue =
+            '\'' . $this->yystack[ $this->yyidx + -2 ]->minor . '\'=>' . $this->yystack[ $this->yyidx + 0 ]->minor;
+    }
+
+    // line 1235 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r177()
+    {
+        $this->compiler->leaveDoubleQuote();
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor->to_smarty_php($this);
+    }
+
+    // line 1240 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r178()
+    {
+        $this->yystack[ $this->yyidx + -1 ]->minor->append_subtree($this, $this->yystack[ $this->yyidx + 0 ]->minor);
+        $this->_retvalue = $this->yystack[ $this->yyidx + -1 ]->minor;
+    }
+
+    // line 1244 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r179()
+    {
+        $this->_retvalue = new Smarty_Internal_ParseTree_Dq($this, $this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    // line 1248 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r180()
+    {
+        $this->_retvalue = new Smarty_Internal_ParseTree_Code('(string)' . $this->yystack[ $this->yyidx + -1 ]->minor);
+    }
+
+    // line 1252 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r181()
+    {
+        $this->_retvalue =
+            new Smarty_Internal_ParseTree_Code('(string)(' . $this->yystack[ $this->yyidx + -1 ]->minor . ')');
+    }
+
+    // line 1264 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r182()
+    {
+        $this->_retvalue =
+            new Smarty_Internal_ParseTree_Code('(string)$_smarty_tpl->tpl_vars[\'' .
+                                               substr($this->yystack[ $this->yyidx + 0 ]->minor, 1) .
+                                               '\']->value');
+    }
+
+    // line 1268 "../smarty/lexer/smarty_internal_templateparser.y"
+    public function yy_r185()
+    {
+        $this->_retvalue = new Smarty_Internal_ParseTree_Tag($this, $this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    public function yy_r186()
+    {
+        $this->_retvalue = new Smarty_Internal_ParseTree_DqContent($this->yystack[ $this->yyidx + 0 ]->minor);
+    }
+
+    public function yy_reduce($yyruleno)
+    {
+        if ($this->yyTraceFILE && $yyruleno >= 0
+            && $yyruleno < count(self::$yyRuleName)) {
+            fprintf($this->yyTraceFILE, "%sReduce (%d) [%s].\n",
+                $this->yyTracePrompt, $yyruleno,
+                self::$yyRuleName[ $yyruleno ]);
+        }
+        $this->_retvalue = $yy_lefthand_side = null;
+        if (isset(self::$yyReduceMap[ $yyruleno ])) {
+            // call the action
+            $this->_retvalue = null;
+            $this->{'yy_r' . self::$yyReduceMap[ $yyruleno ]}();
+            $yy_lefthand_side = $this->_retvalue;
+        }
+        $yygoto = self::$yyRuleInfo[ $yyruleno ][ 0 ];
+        $yysize = self::$yyRuleInfo[ $yyruleno ][ 1 ];
+        $this->yyidx -= $yysize;
+        for ($i = $yysize; $i; $i--) {
+            // pop all of the right-hand side parameters
+            array_pop($this->yystack);
+        }
+        $yyact = $this->yy_find_reduce_action($this->yystack[ $this->yyidx ]->stateno, $yygoto);
+        if ($yyact < self::YYNSTATE) {
+            if (!$this->yyTraceFILE && $yysize) {
+                $this->yyidx++;
+                $x = new TP_yyStackEntry;
+                $x->stateno = $yyact;
+                $x->major = $yygoto;
+                $x->minor = $yy_lefthand_side;
+                $this->yystack[ $this->yyidx ] = $x;
+            } else {
+                $this->yy_shift($yyact, $yygoto, $yy_lefthand_side);
+            }
+        } elseif ($yyact === self::YYNSTATE + self::YYNRULE + 1) {
+            $this->yy_accept();
+        }
+    }
+
+    public function yy_parse_failed()
+    {
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sFail!\n", $this->yyTracePrompt);
+        }
+        while ($this->yyidx >= 0) {
+            $this->yy_pop_parser_stack();
+        }
+    }
+
+    public function yy_syntax_error($yymajor, $TOKEN)
+    {
+        // line 214 "../smarty/lexer/smarty_internal_templateparser.y"
+        $this->internalError = true;
+        $this->yymajor = $yymajor;
+        $this->compiler->trigger_template_error();
+    }
+
+    public function yy_accept()
+    {
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sAccept!\n", $this->yyTracePrompt);
+        }
+        while ($this->yyidx >= 0) {
+            $this->yy_pop_parser_stack();
+        }
+        // line 207 "../smarty/lexer/smarty_internal_templateparser.y"
+        $this->successful = !$this->internalError;
+        $this->internalError = false;
+        $this->retvalue = $this->_retvalue;
+    }
+
+    public function doParse($yymajor, $yytokenvalue)
+    {
+        $yyerrorhit = 0;   /* True if yymajor has invoked an error */
+        if ($this->yyidx === null || $this->yyidx < 0) {
+            $this->yyidx = 0;
+            $this->yyerrcnt = -1;
+            $x = new TP_yyStackEntry;
+            $x->stateno = 0;
+            $x->major = 0;
+            $this->yystack = array();
+            $this->yystack[] = $x;
+        }
+        $yyendofinput = ($yymajor == 0);
+        if ($this->yyTraceFILE) {
+            fprintf($this->yyTraceFILE, "%sInput %s\n",
+                $this->yyTracePrompt, $this->yyTokenName[ $yymajor ]);
+        }
+        do {
+            $yyact = $this->yy_find_shift_action($yymajor);
+            if ($yymajor < self::YYERRORSYMBOL &&
+                !$this->yy_is_expected_token($yymajor)) {
+                // force a syntax error
+                $yyact = self::YY_ERROR_ACTION;
+            }
+            if ($yyact < self::YYNSTATE) {
+                $this->yy_shift($yyact, $yymajor, $yytokenvalue);
+                $this->yyerrcnt--;
+                if ($yyendofinput && $this->yyidx >= 0) {
+                    $yymajor = 0;
+                } else {
+                    $yymajor = self::YYNOCODE;
+                }
+            } elseif ($yyact < self::YYNSTATE + self::YYNRULE) {
+                $this->yy_reduce($yyact - self::YYNSTATE);
+            } elseif ($yyact === self::YY_ERROR_ACTION) {
+                if ($this->yyTraceFILE) {
+                    fprintf($this->yyTraceFILE, "%sSyntax Error!\n",
+                        $this->yyTracePrompt);
+                }
+                if (self::YYERRORSYMBOL) {
+                    if ($this->yyerrcnt < 0) {
+                        $this->yy_syntax_error($yymajor, $yytokenvalue);
+                    }
+                    $yymx = $this->yystack[ $this->yyidx ]->major;
+                    if ($yymx === self::YYERRORSYMBOL || $yyerrorhit) {
+                        if ($this->yyTraceFILE) {
+                            fprintf($this->yyTraceFILE, "%sDiscard input token %s\n",
+                                $this->yyTracePrompt, $this->yyTokenName[ $yymajor ]);
+                        }
+                        $this->yy_destructor($yymajor, $yytokenvalue);
+                        $yymajor = self::YYNOCODE;
+                    } else {
+                        while ($this->yyidx >= 0 &&
+                               $yymx !== self::YYERRORSYMBOL &&
+                               ($yyact = $this->yy_find_shift_action(self::YYERRORSYMBOL)) >= self::YYNSTATE
+                        ) {
+                            $this->yy_pop_parser_stack();
+                        }
+                        if ($this->yyidx < 0 || $yymajor == 0) {
+                            $this->yy_destructor($yymajor, $yytokenvalue);
+                            $this->yy_parse_failed();
+                            $yymajor = self::YYNOCODE;
+                        } elseif ($yymx !== self::YYERRORSYMBOL) {
+                            $u2 = 0;
+                            $this->yy_shift($yyact, self::YYERRORSYMBOL, $u2);
+                        }
+                    }
+                    $this->yyerrcnt = 3;
+                    $yyerrorhit = 1;
+                } else {
+                    if ($this->yyerrcnt <= 0) {
+                        $this->yy_syntax_error($yymajor, $yytokenvalue);
+                    }
+                    $this->yyerrcnt = 3;
+                    $this->yy_destructor($yymajor, $yytokenvalue);
+                    if ($yyendofinput) {
+                        $this->yy_parse_failed();
+                    }
+                    $yymajor = self::YYNOCODE;
+                }
+            } else {
+                $this->yy_accept();
+                $yymajor = self::YYNOCODE;
+            }
+        } while ($yymajor !== self::YYNOCODE && $this->yyidx >= 0);
+    }
+}
+
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_testinstall.php b/epgrec/Smarty/sysplugins/smarty_internal_testinstall.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_testinstall.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_testinstall.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,609 @@
+<?php
+/**
+ * Smarty Internal TestInstall
+ * Test Smarty installation
+ *
+ * @package    Smarty
+ * @subpackage Utilities
+ * @author     Uwe Tews
+ */
+
+/**
+ * TestInstall class
+ *
+ * @package    Smarty
+ * @subpackage Utilities
+ */
+class Smarty_Internal_TestInstall
+{
+    /**
+     * diagnose Smarty setup
+     * If $errors is secified, the diagnostic report will be appended to the array, rather than being output.
+     *
+     * @param \Smarty $smarty
+     * @param array   $errors array to push results into rather than outputting them
+     *
+     * @return bool status, true if everything is fine, false else
+     */
+    public static function testInstall(Smarty $smarty, &$errors = null)
+    {
+        $status = true;
+        if ($errors === null) {
+            echo "<PRE>\n";
+            echo "Smarty Installation test...\n";
+            echo "Testing template directory...\n";
+        }
+        $_stream_resolve_include_path = function_exists('stream_resolve_include_path');
+        // test if all registered template_dir are accessible
+        foreach ($smarty->getTemplateDir() as $template_dir) {
+            $_template_dir = $template_dir;
+            $template_dir = realpath($template_dir);
+            // resolve include_path or fail existence
+            if (!$template_dir) {
+                if ($smarty->use_include_path && !preg_match('/^([\/\\\\]|[a-zA-Z]:[\/\\\\])/', $_template_dir)) {
+                    // try PHP include_path
+                    if ($_stream_resolve_include_path) {
+                        $template_dir = stream_resolve_include_path($_template_dir);
+                    } else {
+                        $template_dir = $smarty->ext->_getIncludePath->getIncludePath($_template_dir, null, $smarty);
+                    }
+                    if ($template_dir !== false) {
+                        if ($errors === null) {
+                            echo "$template_dir is OK.\n";
+                        }
+                        continue;
+                    } else {
+                        $status = false;
+                        $message =
+                            "FAILED: $_template_dir does not exist (and couldn't be found in include_path either)";
+                        if ($errors === null) {
+                            echo $message . ".\n";
+                        } else {
+                            $errors[ 'template_dir' ] = $message;
+                        }
+                        continue;
+                    }
+                } else {
+                    $status = false;
+                    $message = "FAILED: $_template_dir does not exist";
+                    if ($errors === null) {
+                        echo $message . ".\n";
+                    } else {
+                        $errors[ 'template_dir' ] = $message;
+                    }
+                    continue;
+                }
+            }
+            if (!is_dir($template_dir)) {
+                $status = false;
+                $message = "FAILED: $template_dir is not a directory";
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'template_dir' ] = $message;
+                }
+            } elseif (!is_readable($template_dir)) {
+                $status = false;
+                $message = "FAILED: $template_dir is not readable";
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'template_dir' ] = $message;
+                }
+            } else {
+                if ($errors === null) {
+                    echo "$template_dir is OK.\n";
+                }
+            }
+        }
+        if ($errors === null) {
+            echo "Testing compile directory...\n";
+        }
+        // test if registered compile_dir is accessible
+        $__compile_dir = $smarty->getCompileDir();
+        $_compile_dir = realpath($__compile_dir);
+        if (!$_compile_dir) {
+            $status = false;
+            $message = "FAILED: {$__compile_dir} does not exist";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'compile_dir' ] = $message;
+            }
+        } elseif (!is_dir($_compile_dir)) {
+            $status = false;
+            $message = "FAILED: {$_compile_dir} is not a directory";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'compile_dir' ] = $message;
+            }
+        } elseif (!is_readable($_compile_dir)) {
+            $status = false;
+            $message = "FAILED: {$_compile_dir} is not readable";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'compile_dir' ] = $message;
+            }
+        } elseif (!is_writable($_compile_dir)) {
+            $status = false;
+            $message = "FAILED: {$_compile_dir} is not writable";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'compile_dir' ] = $message;
+            }
+        } else {
+            if ($errors === null) {
+                echo "{$_compile_dir} is OK.\n";
+            }
+        }
+        if ($errors === null) {
+            echo "Testing plugins directory...\n";
+        }
+        // test if all registered plugins_dir are accessible
+        // and if core plugins directory is still registered
+        $_core_plugins_dir = realpath(dirname(__FILE__) . '/../plugins');
+        $_core_plugins_available = false;
+        foreach ($smarty->getPluginsDir() as $plugin_dir) {
+            $_plugin_dir = $plugin_dir;
+            $plugin_dir = realpath($plugin_dir);
+            // resolve include_path or fail existence
+            if (!$plugin_dir) {
+                if ($smarty->use_include_path && !preg_match('/^([\/\\\\]|[a-zA-Z]:[\/\\\\])/', $_plugin_dir)) {
+                    // try PHP include_path
+                    if ($_stream_resolve_include_path) {
+                        $plugin_dir = stream_resolve_include_path($_plugin_dir);
+                    } else {
+                        $plugin_dir = $smarty->ext->_getIncludePath->getIncludePath($_plugin_dir, null, $smarty);
+                    }
+                    if ($plugin_dir !== false) {
+                        if ($errors === null) {
+                            echo "$plugin_dir is OK.\n";
+                        }
+                        continue;
+                    } else {
+                        $status = false;
+                        $message = "FAILED: $_plugin_dir does not exist (and couldn't be found in include_path either)";
+                        if ($errors === null) {
+                            echo $message . ".\n";
+                        } else {
+                            $errors[ 'plugins_dir' ] = $message;
+                        }
+                        continue;
+                    }
+                } else {
+                    $status = false;
+                    $message = "FAILED: $_plugin_dir does not exist";
+                    if ($errors === null) {
+                        echo $message . ".\n";
+                    } else {
+                        $errors[ 'plugins_dir' ] = $message;
+                    }
+                    continue;
+                }
+            }
+            if (!is_dir($plugin_dir)) {
+                $status = false;
+                $message = "FAILED: $plugin_dir is not a directory";
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'plugins_dir' ] = $message;
+                }
+            } elseif (!is_readable($plugin_dir)) {
+                $status = false;
+                $message = "FAILED: $plugin_dir is not readable";
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'plugins_dir' ] = $message;
+                }
+            } elseif ($_core_plugins_dir && $_core_plugins_dir == realpath($plugin_dir)) {
+                $_core_plugins_available = true;
+                if ($errors === null) {
+                    echo "$plugin_dir is OK.\n";
+                }
+            } else {
+                if ($errors === null) {
+                    echo "$plugin_dir is OK.\n";
+                }
+            }
+        }
+        if (!$_core_plugins_available) {
+            $status = false;
+            $message = "WARNING: Smarty's own libs/plugins is not available";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } elseif (!isset($errors[ 'plugins_dir' ])) {
+                $errors[ 'plugins_dir' ] = $message;
+            }
+        }
+        if ($errors === null) {
+            echo "Testing cache directory...\n";
+        }
+        // test if all registered cache_dir is accessible
+        $__cache_dir = $smarty->getCacheDir();
+        $_cache_dir = realpath($__cache_dir);
+        if (!$_cache_dir) {
+            $status = false;
+            $message = "FAILED: {$__cache_dir} does not exist";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'cache_dir' ] = $message;
+            }
+        } elseif (!is_dir($_cache_dir)) {
+            $status = false;
+            $message = "FAILED: {$_cache_dir} is not a directory";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'cache_dir' ] = $message;
+            }
+        } elseif (!is_readable($_cache_dir)) {
+            $status = false;
+            $message = "FAILED: {$_cache_dir} is not readable";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'cache_dir' ] = $message;
+            }
+        } elseif (!is_writable($_cache_dir)) {
+            $status = false;
+            $message = "FAILED: {$_cache_dir} is not writable";
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'cache_dir' ] = $message;
+            }
+        } else {
+            if ($errors === null) {
+                echo "{$_cache_dir} is OK.\n";
+            }
+        }
+        if ($errors === null) {
+            echo "Testing configs directory...\n";
+        }
+        // test if all registered config_dir are accessible
+        foreach ($smarty->getConfigDir() as $config_dir) {
+            $_config_dir = $config_dir;
+            // resolve include_path or fail existence
+            if (!$config_dir) {
+                if ($smarty->use_include_path && !preg_match('/^([\/\\\\]|[a-zA-Z]:[\/\\\\])/', $_config_dir)) {
+                    // try PHP include_path
+                    if ($_stream_resolve_include_path) {
+                        $config_dir = stream_resolve_include_path($_config_dir);
+                    } else {
+                        $config_dir = $smarty->ext->_getIncludePath->getIncludePath($_config_dir, null, $smarty);
+                    }
+                    if ($config_dir !== false) {
+                        if ($errors === null) {
+                            echo "$config_dir is OK.\n";
+                        }
+                        continue;
+                    } else {
+                        $status = false;
+                        $message = "FAILED: $_config_dir does not exist (and couldn't be found in include_path either)";
+                        if ($errors === null) {
+                            echo $message . ".\n";
+                        } else {
+                            $errors[ 'config_dir' ] = $message;
+                        }
+                        continue;
+                    }
+                } else {
+                    $status = false;
+                    $message = "FAILED: $_config_dir does not exist";
+                    if ($errors === null) {
+                        echo $message . ".\n";
+                    } else {
+                        $errors[ 'config_dir' ] = $message;
+                    }
+                    continue;
+                }
+            }
+            if (!is_dir($config_dir)) {
+                $status = false;
+                $message = "FAILED: $config_dir is not a directory";
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'config_dir' ] = $message;
+                }
+            } elseif (!is_readable($config_dir)) {
+                $status = false;
+                $message = "FAILED: $config_dir is not readable";
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'config_dir' ] = $message;
+                }
+            } else {
+                if ($errors === null) {
+                    echo "$config_dir is OK.\n";
+                }
+            }
+        }
+        if ($errors === null) {
+            echo "Testing sysplugin files...\n";
+        }
+        // test if sysplugins are available
+        $source = SMARTY_SYSPLUGINS_DIR;
+        if (is_dir($source)) {
+            $expectedSysplugins = array(
+                'smartycompilerexception.php'                               => true,
+                'smartyexception.php'                                       => true,
+                'smarty_cacheresource.php'                                  => true,
+                'smarty_cacheresource_custom.php'                           => true,
+                'smarty_cacheresource_keyvaluestore.php'                    => true,
+                'smarty_data.php'                                           => true,
+                'smarty_internal_block.php'                                 => true,
+                'smarty_internal_cacheresource_file.php'                    => true,
+                'smarty_internal_compilebase.php'                           => true,
+                'smarty_internal_compile_append.php'                        => true,
+                'smarty_internal_compile_assign.php'                        => true,
+                'smarty_internal_compile_block.php'                         => true,
+                'smarty_internal_compile_block_child.php'                   => true,
+                'smarty_internal_compile_block_parent.php'                  => true,
+                'smarty_internal_compile_child.php'                         => true,
+                'smarty_internal_compile_parent.php'                        => true,
+                'smarty_internal_compile_break.php'                         => true,
+                'smarty_internal_compile_call.php'                          => true,
+                'smarty_internal_compile_capture.php'                       => true,
+                'smarty_internal_compile_config_load.php'                   => true,
+                'smarty_internal_compile_continue.php'                      => true,
+                'smarty_internal_compile_debug.php'                         => true,
+                'smarty_internal_compile_eval.php'                          => true,
+                'smarty_internal_compile_extends.php'                       => true,
+                'smarty_internal_compile_for.php'                           => true,
+                'smarty_internal_compile_foreach.php'                       => true,
+                'smarty_internal_compile_function.php'                      => true,
+                'smarty_internal_compile_if.php'                            => true,
+                'smarty_internal_compile_include.php'                       => true,
+                'smarty_internal_compile_include_php.php'                   => true,
+                'smarty_internal_compile_insert.php'                        => true,
+                'smarty_internal_compile_ldelim.php'                        => true,
+                'smarty_internal_compile_make_nocache.php'                  => true,
+                'smarty_internal_compile_nocache.php'                       => true,
+                'smarty_internal_compile_private_block_plugin.php'          => true,
+                'smarty_internal_compile_private_foreachsection.php'        => true,
+                'smarty_internal_compile_private_function_plugin.php'       => true,
+                'smarty_internal_compile_private_modifier.php'              => true,
+                'smarty_internal_compile_private_object_block_function.php' => true,
+                'smarty_internal_compile_private_object_function.php'       => true,
+                'smarty_internal_compile_private_php.php'                   => true,
+                'smarty_internal_compile_private_print_expression.php'      => true,
+                'smarty_internal_compile_private_registered_block.php'      => true,
+                'smarty_internal_compile_private_registered_function.php'   => true,
+                'smarty_internal_compile_private_special_variable.php'      => true,
+                'smarty_internal_compile_rdelim.php'                        => true,
+                'smarty_internal_compile_section.php'                       => true,
+                'smarty_internal_compile_setfilter.php'                     => true,
+                'smarty_internal_compile_shared_inheritance.php'            => true,
+                'smarty_internal_compile_while.php'                         => true,
+                'smarty_internal_configfilelexer.php'                       => true,
+                'smarty_internal_configfileparser.php'                      => true,
+                'smarty_internal_config_file_compiler.php'                  => true,
+                'smarty_internal_data.php'                                  => true,
+                'smarty_internal_debug.php'                                 => true,
+                'smarty_internal_errorhandler.php'                          => true,
+                'smarty_internal_extension_handler.php'                     => true,
+                'smarty_internal_method_addautoloadfilters.php'             => true,
+                'smarty_internal_method_adddefaultmodifiers.php'            => true,
+                'smarty_internal_method_append.php'                         => true,
+                'smarty_internal_method_appendbyref.php'                    => true,
+                'smarty_internal_method_assignbyref.php'                    => true,
+                'smarty_internal_method_assignglobal.php'                   => true,
+                'smarty_internal_method_clearallassign.php'                 => true,
+                'smarty_internal_method_clearallcache.php'                  => true,
+                'smarty_internal_method_clearassign.php'                    => true,
+                'smarty_internal_method_clearcache.php'                     => true,
+                'smarty_internal_method_clearcompiledtemplate.php'          => true,
+                'smarty_internal_method_clearconfig.php'                    => true,
+                'smarty_internal_method_compileallconfig.php'               => true,
+                'smarty_internal_method_compilealltemplates.php'            => true,
+                'smarty_internal_method_configload.php'                     => true,
+                'smarty_internal_method_createdata.php'                     => true,
+                'smarty_internal_method_getautoloadfilters.php'             => true,
+                'smarty_internal_method_getconfigvariable.php'              => true,
+                'smarty_internal_method_getconfigvars.php'                  => true,
+                'smarty_internal_method_getdebugtemplate.php'               => true,
+                'smarty_internal_method_getdefaultmodifiers.php'            => true,
+                'smarty_internal_method_getglobal.php'                      => true,
+                'smarty_internal_method_getregisteredobject.php'            => true,
+                'smarty_internal_method_getstreamvariable.php'              => true,
+                'smarty_internal_method_gettags.php'                        => true,
+                'smarty_internal_method_gettemplatevars.php'                => true,
+                'smarty_internal_method_literals.php'                       => true,
+                'smarty_internal_method_loadfilter.php'                     => true,
+                'smarty_internal_method_loadplugin.php'                     => true,
+                'smarty_internal_method_mustcompile.php'                    => true,
+                'smarty_internal_method_registercacheresource.php'          => true,
+                'smarty_internal_method_registerclass.php'                  => true,
+                'smarty_internal_method_registerdefaultconfighandler.php'   => true,
+                'smarty_internal_method_registerdefaultpluginhandler.php'   => true,
+                'smarty_internal_method_registerdefaulttemplatehandler.php' => true,
+                'smarty_internal_method_registerfilter.php'                 => true,
+                'smarty_internal_method_registerobject.php'                 => true,
+                'smarty_internal_method_registerplugin.php'                 => true,
+                'smarty_internal_method_registerresource.php'               => true,
+                'smarty_internal_method_setautoloadfilters.php'             => true,
+                'smarty_internal_method_setdebugtemplate.php'               => true,
+                'smarty_internal_method_setdefaultmodifiers.php'            => true,
+                'smarty_internal_method_unloadfilter.php'                   => true,
+                'smarty_internal_method_unregistercacheresource.php'        => true,
+                'smarty_internal_method_unregisterfilter.php'               => true,
+                'smarty_internal_method_unregisterobject.php'               => true,
+                'smarty_internal_method_unregisterplugin.php'               => true,
+                'smarty_internal_method_unregisterresource.php'             => true,
+                'smarty_internal_nocache_insert.php'                        => true,
+                'smarty_internal_parsetree.php'                             => true,
+                'smarty_internal_parsetree_code.php'                        => true,
+                'smarty_internal_parsetree_dq.php'                          => true,
+                'smarty_internal_parsetree_dqcontent.php'                   => true,
+                'smarty_internal_parsetree_tag.php'                         => true,
+                'smarty_internal_parsetree_template.php'                    => true,
+                'smarty_internal_parsetree_text.php'                        => true,
+                'smarty_internal_resource_eval.php'                         => true,
+                'smarty_internal_resource_extends.php'                      => true,
+                'smarty_internal_resource_file.php'                         => true,
+                'smarty_internal_resource_php.php'                          => true,
+                'smarty_internal_resource_registered.php'                   => true,
+                'smarty_internal_resource_stream.php'                       => true,
+                'smarty_internal_resource_string.php'                       => true,
+                'smarty_internal_runtime_cachemodify.php'                   => true,
+                'smarty_internal_runtime_cacheresourcefile.php'             => true,
+                'smarty_internal_runtime_capture.php'                       => true,
+                'smarty_internal_runtime_codeframe.php'                     => true,
+                'smarty_internal_runtime_filterhandler.php'                 => true,
+                'smarty_internal_runtime_foreach.php'                       => true,
+                'smarty_internal_runtime_getincludepath.php'                => true,
+                'smarty_internal_runtime_inheritance.php'                   => true,
+                'smarty_internal_runtime_make_nocache.php'                  => true,
+                'smarty_internal_runtime_tplfunction.php'                   => true,
+                'smarty_internal_runtime_updatecache.php'                   => true,
+                'smarty_internal_runtime_updatescope.php'                   => true,
+                'smarty_internal_runtime_writefile.php'                     => true,
+                'smarty_internal_smartytemplatecompiler.php'                => true,
+                'smarty_internal_template.php'                              => true,
+                'smarty_internal_templatebase.php'                          => true,
+                'smarty_internal_templatecompilerbase.php'                  => true,
+                'smarty_internal_templatelexer.php'                         => true,
+                'smarty_internal_templateparser.php'                        => true,
+                'smarty_internal_testinstall.php'                           => true,
+                'smarty_internal_undefined.php'                             => true,
+                'smarty_resource.php'                                       => true,
+                'smarty_resource_custom.php'                                => true,
+                'smarty_resource_recompiled.php'                            => true,
+                'smarty_resource_uncompiled.php'                            => true,
+                'smarty_security.php'                                       => true,
+                'smarty_template_cached.php'                                => true,
+                'smarty_template_compiled.php'                              => true,
+                'smarty_template_config.php'                                => true,
+                'smarty_template_resource_base.php'                         => true,
+                'smarty_template_source.php'                                => true,
+                'smarty_undefined_variable.php'                             => true,
+                'smarty_variable.php'                                       => true,
+            );
+            $iterator = new DirectoryIterator($source);
+            foreach ($iterator as $file) {
+                if (!$file->isDot()) {
+                    $filename = $file->getFilename();
+                    if (isset($expectedSysplugins[ $filename ])) {
+                        unset($expectedSysplugins[ $filename ]);
+                    }
+                }
+            }
+            if ($expectedSysplugins) {
+                $status = false;
+                $message = "FAILED: files missing from libs/sysplugins: " . join(', ', array_keys($expectedSysplugins));
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'sysplugins' ] = $message;
+                }
+            } elseif ($errors === null) {
+                echo "... OK\n";
+            }
+        } else {
+            $status = false;
+            $message = "FAILED: " . SMARTY_SYSPLUGINS_DIR . ' is not a directory';
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'sysplugins_dir_constant' ] = $message;
+            }
+        }
+        if ($errors === null) {
+            echo "Testing plugin files...\n";
+        }
+        // test if core plugins are available
+        $source = SMARTY_PLUGINS_DIR;
+        if (is_dir($source)) {
+            $expectedPlugins = array(
+                'block.textformat.php'                  => true,
+                'function.counter.php'                  => true,
+                'function.cycle.php'                    => true,
+                'function.fetch.php'                    => true,
+                'function.html_checkboxes.php'          => true,
+                'function.html_image.php'               => true,
+                'function.html_options.php'             => true,
+                'function.html_radios.php'              => true,
+                'function.html_select_date.php'         => true,
+                'function.html_select_time.php'         => true,
+                'function.html_table.php'               => true,
+                'function.mailto.php'                   => true,
+                'function.math.php'                     => true,
+                'modifier.capitalize.php'               => true,
+                'modifier.date_format.php'              => true,
+                'modifier.debug_print_var.php'          => true,
+                'modifier.escape.php'                   => true,
+                'modifier.mb_wordwrap.php'              => true,
+                'modifier.regex_replace.php'            => true,
+                'modifier.replace.php'                  => true,
+                'modifier.spacify.php'                  => true,
+                'modifier.truncate.php'                 => true,
+                'modifiercompiler.cat.php'              => true,
+                'modifiercompiler.count_characters.php' => true,
+                'modifiercompiler.count_paragraphs.php' => true,
+                'modifiercompiler.count_sentences.php'  => true,
+                'modifiercompiler.count_words.php'      => true,
+                'modifiercompiler.default.php'          => true,
+                'modifiercompiler.escape.php'           => true,
+                'modifiercompiler.from_charset.php'     => true,
+                'modifiercompiler.indent.php'           => true,
+                'modifiercompiler.lower.php'            => true,
+                'modifiercompiler.noprint.php'          => true,
+                'modifiercompiler.string_format.php'    => true,
+                'modifiercompiler.strip.php'            => true,
+                'modifiercompiler.strip_tags.php'       => true,
+                'modifiercompiler.to_charset.php'       => true,
+                'modifiercompiler.unescape.php'         => true,
+                'modifiercompiler.upper.php'            => true,
+                'modifiercompiler.wordwrap.php'         => true,
+                'outputfilter.trimwhitespace.php'       => true,
+                'shared.escape_special_chars.php'       => true,
+                'shared.literal_compiler_param.php'     => true,
+                'shared.make_timestamp.php'             => true,
+                'shared.mb_str_replace.php'             => true,
+                'shared.mb_unicode.php'                 => true,
+                'variablefilter.htmlspecialchars.php'   => true,
+            );
+            $iterator = new DirectoryIterator($source);
+            foreach ($iterator as $file) {
+                if (!$file->isDot()) {
+                    $filename = $file->getFilename();
+                    if (isset($expectedPlugins[ $filename ])) {
+                        unset($expectedPlugins[ $filename ]);
+                    }
+                }
+            }
+            if ($expectedPlugins) {
+                $status = false;
+                $message = "FAILED: files missing from libs/plugins: " . join(', ', array_keys($expectedPlugins));
+                if ($errors === null) {
+                    echo $message . ".\n";
+                } else {
+                    $errors[ 'plugins' ] = $message;
+                }
+            } elseif ($errors === null) {
+                echo "... OK\n";
+            }
+        } else {
+            $status = false;
+            $message = "FAILED: " . SMARTY_PLUGINS_DIR . ' is not a directory';
+            if ($errors === null) {
+                echo $message . ".\n";
+            } else {
+                $errors[ 'plugins_dir_constant' ] = $message;
+            }
+        }
+        if ($errors === null) {
+            echo "Tests complete.\n";
+            echo "</PRE>\n";
+        }
+        return $status;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_internal_undefined.php b/epgrec/Smarty/sysplugins/smarty_internal_undefined.php
--- a/epgrec/Smarty/sysplugins/smarty_internal_undefined.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_internal_undefined.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,67 @@
+<?php
+
+/**
+ * Smarty Internal Undefined
+ *
+ * Class to handle undefined method calls or calls to obsolete runtime extensions
+ *
+ * @package    Smarty
+ * @subpackage PluginsInternal
+ * @author     Uwe Tews
+ */
+class Smarty_Internal_Undefined
+{
+    /**
+     * Name of undefined extension class
+     *
+     * @var string|null
+     */
+    public $class = null;
+
+    /**
+     * Smarty_Internal_Undefined constructor.
+     *
+     * @param null|string $class name of undefined extension class
+     */
+    public function __construct($class = null)
+    {
+        $this->class = $class;
+    }
+
+    /**
+     * Wrapper for obsolete class Smarty_Internal_Runtime_ValidateCompiled
+     *
+     * @param \Smarty_Internal_Template $tpl
+     * @param array                     $properties special template properties
+     * @param bool                      $cache      flag if called from cache file
+     *
+     * @return bool false
+     */
+    public function decodeProperties(Smarty_Internal_Template $tpl, $properties, $cache = false)
+    {
+        if ($cache) {
+            $tpl->cached->valid = false;
+        } else {
+            $tpl->mustCompile = true;
+        }
+        return false;
+    }
+
+    /**
+     * Call error handler for undefined method
+     *
+     * @param string $name unknown method-name
+     * @param array  $args argument array
+     *
+     * @return mixed
+     * @throws SmartyException
+     */
+    public function __call($name, $args)
+    {
+        if (isset($this->class)) {
+            throw new SmartyException("undefined extension class '{$this->class}'");
+        } else {
+            throw new SmartyException(get_class($args[ 0 ]) . "->{$name}() undefined method");
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_resource.php b/epgrec/Smarty/sysplugins/smarty_resource.php
--- a/epgrec/Smarty/sysplugins/smarty_resource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_resource.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,262 @@
+<?php
+/**
+ * Smarty Resource Plugin
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Resource Plugin
+ * Base implementation for resource plugins
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ *
+ * @method renderUncompiled(Smarty_Template_Source $source, Smarty_Internal_Template $_template)
+ * @method populateCompiledFilepath(Smarty_Template_Compiled $compiled, Smarty_Internal_Template $_template)
+ * @method process(Smarty_Internal_Template $_smarty_tpl)
+ */
+abstract class Smarty_Resource
+{
+    /**
+     * resource types provided by the core
+     *
+     * @var array
+     */
+    public static $sysplugins = array(
+        'file'    => 'smarty_internal_resource_file.php',
+        'string'  => 'smarty_internal_resource_string.php',
+        'extends' => 'smarty_internal_resource_extends.php',
+        'stream'  => 'smarty_internal_resource_stream.php',
+        'eval'    => 'smarty_internal_resource_eval.php',
+        'php'     => 'smarty_internal_resource_php.php'
+    );
+
+    /**
+     * Source is bypassing compiler
+     *
+     * @var boolean
+     */
+    public $uncompiled = false;
+
+    /**
+     * Source must be recompiled on every occasion
+     *
+     * @var boolean
+     */
+    public $recompiled = false;
+
+    /**
+     * Flag if resource does implement populateCompiledFilepath() method
+     *
+     * @var bool
+     */
+    public $hasCompiledHandler = false;
+
+    /**
+     * Load Resource Handler
+     *
+     * @param Smarty $smarty smarty object
+     * @param string $type   name of the resource
+     *
+     * @throws SmartyException
+     * @return Smarty_Resource Resource Handler
+     */
+    public static function load(Smarty $smarty, $type)
+    {
+        // try smarty's cache
+        if (isset($smarty->_cache[ 'resource_handlers' ][ $type ])) {
+            return $smarty->_cache[ 'resource_handlers' ][ $type ];
+        }
+        // try registered resource
+        if (isset($smarty->registered_resources[ $type ])) {
+            return $smarty->_cache[ 'resource_handlers' ][ $type ] =
+                $smarty->registered_resources[ $type ] instanceof Smarty_Resource ?
+                    $smarty->registered_resources[ $type ] : new Smarty_Internal_Resource_Registered();
+        }
+        // try sysplugins dir
+        if (isset(self::$sysplugins[ $type ])) {
+            $_resource_class = 'Smarty_Internal_Resource_' . ucfirst($type);
+            return $smarty->_cache[ 'resource_handlers' ][ $type ] = new $_resource_class();
+        }
+        // try plugins dir
+        $_resource_class = 'Smarty_Resource_' . ucfirst($type);
+        if ($smarty->loadPlugin($_resource_class)) {
+            if (class_exists($_resource_class, false)) {
+                return $smarty->_cache[ 'resource_handlers' ][ $type ] = new $_resource_class();
+            } else {
+                $smarty->registerResource(
+                    $type,
+                    array(
+                        "smarty_resource_{$type}_source", "smarty_resource_{$type}_timestamp",
+                        "smarty_resource_{$type}_secure", "smarty_resource_{$type}_trusted"
+                    )
+                );
+                // give it another try, now that the resource is registered properly
+                return self::load($smarty, $type);
+            }
+        }
+        // try streams
+        $_known_stream = stream_get_wrappers();
+        if (in_array($type, $_known_stream)) {
+            // is known stream
+            if (is_object($smarty->security_policy)) {
+                $smarty->security_policy->isTrustedStream($type);
+            }
+            return $smarty->_cache[ 'resource_handlers' ][ $type ] = new Smarty_Internal_Resource_Stream();
+        }
+        // TODO: try default_(template|config)_handler
+        // give up
+        throw new SmartyException("Unknown resource type '{$type}'");
+    }
+
+    /**
+     * extract resource_type and resource_name from template_resource and config_resource
+     *
+     * @note "C:/foo.tpl" was forced to file resource up till Smarty 3.1.3 (including).
+     *
+     * @param string $resource_name    template_resource or config_resource to parse
+     * @param string $default_resource the default resource_type defined in $smarty
+     *
+     * @return array with parsed resource name and type
+     */
+    public static function parseResourceName($resource_name, $default_resource)
+    {
+        if (preg_match('/^([A-Za-z0-9_\-]{2,})[:]/', $resource_name, $match)) {
+            $type = $match[ 1 ];
+            $name = substr($resource_name, strlen($match[ 0 ]));
+        } else {
+            // no resource given, use default
+            // or single character before the colon is not a resource type, but part of the filepath
+            $type = $default_resource;
+            $name = $resource_name;
+        }
+        return array($name, $type);
+    }
+
+    /**
+     * modify template_resource according to resource handlers specifications
+     *
+     * @param \Smarty_Internal_Template|\Smarty $obj               Smarty instance
+     * @param string                            $template_resource template_resource to extract resource handler and
+     *                                                             name of
+     *
+     * @return string unique resource name
+     * @throws \SmartyException
+     */
+    public static function getUniqueTemplateName($obj, $template_resource)
+    {
+        $smarty = $obj->_getSmartyObj();
+        list($name, $type) = self::parseResourceName($template_resource, $smarty->default_resource_type);
+        // TODO: optimize for Smarty's internal resource types
+        $resource = Smarty_Resource::load($smarty, $type);
+        // go relative to a given template?
+        $_file_is_dotted = $name[ 0 ] === '.' && ($name[ 1 ] === '.' || $name[ 1 ] === '/');
+        if ($obj->_isTplObj() && $_file_is_dotted
+            && ($obj->source->type === 'file' || $obj->parent->source->type === 'extends')
+        ) {
+            $name = $smarty->_realpath(dirname($obj->parent->source->filepath) . DIRECTORY_SEPARATOR . $name);
+        }
+        return $resource->buildUniqueResourceName($smarty, $name);
+    }
+
+    /**
+     * initialize Source Object for given resource
+     * wrapper for backward compatibility to versions < 3.1.22
+     * Either [$_template] or [$smarty, $template_resource] must be specified
+     *
+     * @param Smarty_Internal_Template $_template         template object
+     * @param Smarty                   $smarty            smarty object
+     * @param string                   $template_resource resource identifier
+     *
+     * @return \Smarty_Template_Source Source Object
+     * @throws \SmartyException
+     */
+    public static function source(
+        Smarty_Internal_Template $_template = null,
+        Smarty $smarty = null,
+        $template_resource = null
+    ) {
+        return Smarty_Template_Source::load($_template, $smarty, $template_resource);
+    }
+
+    /**
+     * Load template's source into current template object
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 template source
+     * @throws SmartyException        if source cannot be loaded
+     */
+    abstract public function getContent(Smarty_Template_Source $source);
+
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     */
+    abstract public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null);
+
+    /**
+     * populate Source Object with timestamp and exists from Resource
+     *
+     * @param Smarty_Template_Source $source source object
+     */
+    public function populateTimestamp(Smarty_Template_Source $source)
+    {
+        // intentionally left blank
+    }
+
+    /**
+     * modify resource_name according to resource handlers specifications
+     *
+     * @param Smarty  $smarty        Smarty instance
+     * @param string  $resource_name resource_name to make unique
+     * @param boolean $isConfig      flag for config resource
+     *
+     * @return string unique resource name
+     */
+    public function buildUniqueResourceName(Smarty $smarty, $resource_name, $isConfig = false)
+    {
+        if ($isConfig) {
+            if (!isset($smarty->_joined_config_dir)) {
+                $smarty->getTemplateDir(null, true);
+            }
+            return get_class($this) . '#' . $smarty->_joined_config_dir . '#' . $resource_name;
+        } else {
+            if (!isset($smarty->_joined_template_dir)) {
+                $smarty->getTemplateDir();
+            }
+            return get_class($this) . '#' . $smarty->_joined_template_dir . '#' . $resource_name;
+        }
+    }
+
+    /*
+     * Check if resource must check time stamps when when loading complied or cached templates.
+     * Resources like 'extends' which use source components my disable timestamp checks on own resource.
+     *
+     * @return bool
+     */
+    /**
+     * Determine basename for compiled filename
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 resource's basename
+     */
+    public function getBasename(Smarty_Template_Source $source)
+    {
+        return basename(preg_replace('![^\w]+!', '_', $source->name));
+    }
+
+    /**
+     * @return bool
+     */
+    public function checkTimestamps()
+    {
+        return true;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_resource_custom.php b/epgrec/Smarty/sysplugins/smarty_resource_custom.php
--- a/epgrec/Smarty/sysplugins/smarty_resource_custom.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_resource_custom.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,93 @@
+<?php
+/**
+ * Smarty Resource Plugin
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Resource Plugin
+ * Wrapper Implementation for custom resource plugins
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+abstract class Smarty_Resource_Custom extends Smarty_Resource
+{
+    /**
+     * fetch template and its modification time from data source
+     *
+     * @param string  $name    template name
+     * @param string  &$source template source
+     * @param integer &$mtime  template modification timestamp (epoch)
+     */
+    abstract protected function fetch($name, &$source, &$mtime);
+
+    /**
+     * Fetch template's modification timestamp from data source
+     * {@internal implementing this method is optional.
+     *  Only implement it if modification times can be accessed faster than loading the complete template source.}}
+     *
+     * @param string $name template name
+     *
+     * @return integer|boolean timestamp (epoch) the template was modified, or false if not found
+     */
+    protected function fetchTimestamp($name)
+    {
+        return null;
+    }
+
+    /**
+     * populate Source Object with meta data from Resource
+     *
+     * @param Smarty_Template_Source   $source    source object
+     * @param Smarty_Internal_Template $_template template object
+     */
+    public function populate(Smarty_Template_Source $source, Smarty_Internal_Template $_template = null)
+    {
+        $source->filepath = $source->type . ':' . substr(preg_replace('/[^A-Za-z0-9.]/', '', $source->name), 0, 25);
+        $source->uid = sha1($source->type . ':' . $source->name);
+        $mtime = $this->fetchTimestamp($source->name);
+        if ($mtime !== null) {
+            $source->timestamp = $mtime;
+        } else {
+            $this->fetch($source->name, $content, $timestamp);
+            $source->timestamp = isset($timestamp) ? $timestamp : false;
+            if (isset($content)) {
+                $source->content = $content;
+            }
+        }
+        $source->exists = !!$source->timestamp;
+    }
+
+    /**
+     * Load template's source into current template object
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 template source
+     * @throws SmartyException        if source cannot be loaded
+     */
+    public function getContent(Smarty_Template_Source $source)
+    {
+        $this->fetch($source->name, $content, $timestamp);
+        if (isset($content)) {
+            return $content;
+        }
+        throw new SmartyException("Unable to read template {$source->type} '{$source->name}'");
+    }
+
+    /**
+     * Determine basename for compiled filename
+     *
+     * @param Smarty_Template_Source $source source object
+     *
+     * @return string                 resource's basename
+     */
+    public function getBasename(Smarty_Template_Source $source)
+    {
+        return basename(substr(preg_replace('/[^A-Za-z0-9.]/', '', $source->name), 0, 25));
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_resource_recompiled.php b/epgrec/Smarty/sysplugins/smarty_resource_recompiled.php
--- a/epgrec/Smarty/sysplugins/smarty_resource_recompiled.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_resource_recompiled.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,94 @@
+<?php
+/**
+ * Smarty Resource Plugin
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Resource Plugin
+ * Base implementation for resource plugins that don't compile cache
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+abstract class Smarty_Resource_Recompiled extends Smarty_Resource
+{
+    /**
+     * Flag that it's an recompiled resource
+     *
+     * @var bool
+     */
+    public $recompiled = true;
+
+    /**
+     * Resource does implement populateCompiledFilepath() method
+     *
+     * @var bool
+     */
+    public $hasCompiledHandler = true;
+
+    /**
+     * compile template from source
+     *
+     * @param Smarty_Internal_Template $_smarty_tpl do not change variable name, is used by compiled template
+     *
+     * @throws Exception
+     */
+    public function process(Smarty_Internal_Template $_smarty_tpl)
+    {
+        $compiled = &$_smarty_tpl->compiled;
+        $compiled->file_dependency = array();
+        $compiled->includes = array();
+        $compiled->nocache_hash = null;
+        $compiled->unifunc = null;
+        $level = ob_get_level();
+        ob_start();
+        $_smarty_tpl->loadCompiler();
+        // call compiler
+        try {
+            eval('?>' . $_smarty_tpl->compiler->compileTemplate($_smarty_tpl));
+        } catch (Exception $e) {
+            unset($_smarty_tpl->compiler);
+            while (ob_get_level() > $level) {
+                ob_end_clean();
+            }
+            throw $e;
+        }
+        // release compiler object to free memory
+        unset($_smarty_tpl->compiler);
+        ob_get_clean();
+        $compiled->timestamp = time();
+        $compiled->exists = true;
+    }
+
+    /**
+     * populate Compiled Object with compiled filepath
+     *
+     * @param Smarty_Template_Compiled $compiled  compiled object
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return void
+     */
+    public function populateCompiledFilepath(Smarty_Template_Compiled $compiled, Smarty_Internal_Template $_template)
+    {
+        $compiled->filepath = false;
+        $compiled->timestamp = false;
+        $compiled->exists = false;
+    }
+
+    /*
+       * Disable timestamp checks for recompiled resource.
+       *
+       * @return bool
+       */
+    /**
+     * @return bool
+     */
+    public function checkTimestamps()
+    {
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_resource_uncompiled.php b/epgrec/Smarty/sysplugins/smarty_resource_uncompiled.php
--- a/epgrec/Smarty/sysplugins/smarty_resource_uncompiled.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_resource_uncompiled.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,49 @@
+<?php
+/**
+ * Smarty Resource Plugin
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ */
+
+/**
+ * Smarty Resource Plugin
+ * Base implementation for resource plugins that don't use the compiler
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ */
+abstract class Smarty_Resource_Uncompiled extends Smarty_Resource
+{
+    /**
+     * Flag that it's an uncompiled resource
+     *
+     * @var bool
+     */
+    public $uncompiled = true;
+
+    /**
+     * Resource does implement populateCompiledFilepath() method
+     *
+     * @var bool
+     */
+    public $hasCompiledHandler = true;
+
+    /**
+     * populate compiled object with compiled filepath
+     *
+     * @param Smarty_Template_Compiled $compiled  compiled object
+     * @param Smarty_Internal_Template $_template template object
+     */
+    public function populateCompiledFilepath(Smarty_Template_Compiled $compiled, Smarty_Internal_Template $_template)
+    {
+        $compiled->filepath = $_template->source->filepath;
+        $compiled->timestamp = $_template->source->timestamp;
+        $compiled->exists = $_template->source->exists;
+        if ($_template->smarty->merge_compiled_includes || $_template->source->handler->checkTimestamps()) {
+            $compiled->file_dependency[ $_template->source->uid ] =
+                array($compiled->filepath, $compiled->timestamp, $_template->source->type,);
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_security.php b/epgrec/Smarty/sysplugins/smarty_security.php
--- a/epgrec/Smarty/sysplugins/smarty_security.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_security.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,721 @@
+<?php
+/**
+ * Smarty plugin
+ *
+ * @package    Smarty
+ * @subpackage Security
+ * @author     Uwe Tews
+ */
+/**
+ * FIXME: Smarty_Security API
+ *      - getter and setter instead of public properties would allow cultivating an internal cache properly
+ *      - current implementation of isTrustedResourceDir() assumes that Smarty::$template_dir and Smarty::$config_dir
+ *      are immutable the cache is killed every time either of the variables change. That means that two distinct
+ *      Smarty objects with differing
+ *        $template_dir or $config_dir should NOT share the same Smarty_Security instance,
+ *        as this would lead to (severe) performance penalty! how should this be handled?
+ */
+
+/**
+ * This class does contain the security settings
+ */
+class Smarty_Security
+{
+    /**
+     * This determines how Smarty handles "<?php ... ?>" tags in templates.
+     * possible values:
+     * <ul>
+     *   <li>Smarty::PHP_PASSTHRU -> echo PHP tags as they are</li>
+     *   <li>Smarty::PHP_QUOTE    -> escape tags as entities</li>
+     *   <li>Smarty::PHP_REMOVE   -> remove php tags</li>
+     *   <li>Smarty::PHP_ALLOW    -> execute php tags</li>
+     * </ul>
+     *
+     * @var integer
+     */
+    public $php_handling = Smarty::PHP_PASSTHRU;
+
+    /**
+     * This is the list of template directories that are considered secure.
+     * $template_dir is in this list implicitly.
+     *
+     * @var array
+     */
+    public $secure_dir = array();
+
+    /**
+     * This is an array of directories where trusted php scripts reside.
+     * {@link $security} is disabled during their inclusion/execution.
+     *
+     * @var array
+     */
+    public $trusted_dir = array();
+
+    /**
+     * List of regular expressions (PCRE) that include trusted URIs
+     *
+     * @var array
+     */
+    public $trusted_uri = array();
+
+    /**
+     * List of trusted constants names
+     *
+     * @var array
+     */
+    public $trusted_constants = array();
+
+    /**
+     * This is an array of trusted static classes.
+     * If empty access to all static classes is allowed.
+     * If set to 'none' none is allowed.
+     *
+     * @var array
+     */
+    public $static_classes = array();
+
+    /**
+     * This is an nested array of trusted classes and static methods.
+     * If empty access to all static classes and methods is allowed.
+     * Format:
+     * array (
+     *         'class_1' => array('method_1', 'method_2'), // allowed methods listed
+     *         'class_2' => array(),                       // all methods of class allowed
+     *       )
+     * If set to null none is allowed.
+     *
+     * @var array
+     */
+    public $trusted_static_methods = array();
+
+    /**
+     * This is an array of trusted static properties.
+     * If empty access to all static classes and properties is allowed.
+     * Format:
+     * array (
+     *         'class_1' => array('prop_1', 'prop_2'), // allowed properties listed
+     *         'class_2' => array(),                   // all properties of class allowed
+     *       )
+     * If set to null none is allowed.
+     *
+     * @var array
+     */
+    public $trusted_static_properties = array();
+
+    /**
+     * This is an array of trusted PHP functions.
+     * If empty all functions are allowed.
+     * To disable all PHP functions set $php_functions = null.
+     *
+     * @var array
+     */
+    public $php_functions = array('isset', 'empty', 'count', 'sizeof', 'in_array', 'is_array', 'time',);
+
+    /**
+     * This is an array of trusted PHP modifiers.
+     * If empty all modifiers are allowed.
+     * To disable all modifier set $php_modifiers = null.
+     *
+     * @var array
+     */
+    public $php_modifiers = array('escape', 'count', 'nl2br',);
+
+    /**
+     * This is an array of allowed tags.
+     * If empty no restriction by allowed_tags.
+     *
+     * @var array
+     */
+    public $allowed_tags = array();
+
+    /**
+     * This is an array of disabled tags.
+     * If empty no restriction by disabled_tags.
+     *
+     * @var array
+     */
+    public $disabled_tags = array();
+
+    /**
+     * This is an array of allowed modifier plugins.
+     * If empty no restriction by allowed_modifiers.
+     *
+     * @var array
+     */
+    public $allowed_modifiers = array();
+
+    /**
+     * This is an array of disabled modifier plugins.
+     * If empty no restriction by disabled_modifiers.
+     *
+     * @var array
+     */
+    public $disabled_modifiers = array();
+
+    /**
+     * This is an array of disabled special $smarty variables.
+     *
+     * @var array
+     */
+    public $disabled_special_smarty_vars = array();
+
+    /**
+     * This is an array of trusted streams.
+     * If empty all streams are allowed.
+     * To disable all streams set $streams = null.
+     *
+     * @var array
+     */
+    public $streams = array('file');
+
+    /**
+     * + flag if constants can be accessed from template
+     *
+     * @var boolean
+     */
+    public $allow_constants = true;
+
+    /**
+     * + flag if super globals can be accessed from template
+     *
+     * @var boolean
+     */
+    public $allow_super_globals = true;
+
+    /**
+     * max template nesting level
+     *
+     * @var int
+     */
+    public $max_template_nesting = 0;
+
+    /**
+     * current template nesting level
+     *
+     * @var int
+     */
+    private $_current_template_nesting = 0;
+
+    /**
+     * Cache for $resource_dir lookup
+     *
+     * @var array
+     */
+    protected $_resource_dir = array();
+
+    /**
+     * Cache for $template_dir lookup
+     *
+     * @var array
+     */
+    protected $_template_dir = array();
+
+    /**
+     * Cache for $config_dir lookup
+     *
+     * @var array
+     */
+    protected $_config_dir = array();
+
+    /**
+     * Cache for $secure_dir lookup
+     *
+     * @var array
+     */
+    protected $_secure_dir = array();
+
+    /**
+     * Cache for $php_resource_dir lookup
+     *
+     * @var array
+     */
+    protected $_php_resource_dir = null;
+
+    /**
+     * Cache for $trusted_dir lookup
+     *
+     * @var array
+     */
+    protected $_trusted_dir = null;
+
+    /**
+     * Cache for include path status
+     *
+     * @var bool
+     */
+    protected $_include_path_status = false;
+
+    /**
+     * Cache for $_include_array lookup
+     *
+     * @var array
+     */
+    protected $_include_dir = array();
+
+    /**
+     * @param Smarty $smarty
+     */
+    public function __construct($smarty)
+    {
+        $this->smarty = $smarty;
+    }
+
+    /**
+     * Check if PHP function is trusted.
+     *
+     * @param string $function_name
+     * @param object $compiler compiler object
+     *
+     * @return boolean                 true if function is trusted
+     */
+    public function isTrustedPhpFunction($function_name, $compiler)
+    {
+        if (isset($this->php_functions)
+            && (empty($this->php_functions) || in_array($function_name, $this->php_functions))
+        ) {
+            return true;
+        }
+        $compiler->trigger_template_error("PHP function '{$function_name}' not allowed by security setting");
+        return false; // should not, but who knows what happens to the compiler in the future?
+    }
+
+    /**
+     * Check if static class is trusted.
+     *
+     * @param string $class_name
+     * @param object $compiler compiler object
+     *
+     * @return boolean                 true if class is trusted
+     */
+    public function isTrustedStaticClass($class_name, $compiler)
+    {
+        if (isset($this->static_classes)
+            && (empty($this->static_classes) || in_array($class_name, $this->static_classes))
+        ) {
+            return true;
+        }
+        $compiler->trigger_template_error("access to static class '{$class_name}' not allowed by security setting");
+        return false; // should not, but who knows what happens to the compiler in the future?
+    }
+
+    /**
+     * Check if static class method/property is trusted.
+     *
+     * @param string $class_name
+     * @param string $params
+     * @param object $compiler compiler object
+     *
+     * @return boolean                 true if class method is trusted
+     */
+    public function isTrustedStaticClassAccess($class_name, $params, $compiler)
+    {
+        if (!isset($params[ 2 ])) {
+            // fall back
+            return $this->isTrustedStaticClass($class_name, $compiler);
+        }
+        if ($params[ 2 ] === 'method') {
+            $allowed = $this->trusted_static_methods;
+            $name = substr($params[ 0 ], 0, strpos($params[ 0 ], '('));
+        } else {
+            $allowed = $this->trusted_static_properties;
+            // strip '$'
+            $name = substr($params[ 0 ], 1);
+        }
+        if (isset($allowed)) {
+            if (empty($allowed)) {
+                // fall back
+                return $this->isTrustedStaticClass($class_name, $compiler);
+            }
+            if (isset($allowed[ $class_name ])
+                && (empty($allowed[ $class_name ]) || in_array($name, $allowed[ $class_name ]))
+            ) {
+                return true;
+            }
+        }
+        $compiler->trigger_template_error("access to static class '{$class_name}' {$params[2]} '{$name}' not allowed by security setting");
+        return false; // should not, but who knows what happens to the compiler in the future?
+    }
+
+    /**
+     * Check if PHP modifier is trusted.
+     *
+     * @param string $modifier_name
+     * @param object $compiler compiler object
+     *
+     * @return boolean                 true if modifier is trusted
+     */
+    public function isTrustedPhpModifier($modifier_name, $compiler)
+    {
+        if (isset($this->php_modifiers)
+            && (empty($this->php_modifiers) || in_array($modifier_name, $this->php_modifiers))
+        ) {
+            return true;
+        }
+        $compiler->trigger_template_error("modifier '{$modifier_name}' not allowed by security setting");
+        return false; // should not, but who knows what happens to the compiler in the future?
+    }
+
+    /**
+     * Check if tag is trusted.
+     *
+     * @param string $tag_name
+     * @param object $compiler compiler object
+     *
+     * @return boolean                 true if tag is trusted
+     */
+    public function isTrustedTag($tag_name, $compiler)
+    {
+        // check for internal always required tags
+        if (in_array(
+            $tag_name,
+            array(
+                'assign', 'call', 'private_filter', 'private_block_plugin', 'private_function_plugin',
+                'private_object_block_function', 'private_object_function', 'private_registered_function',
+                'private_registered_block', 'private_special_variable', 'private_print_expression',
+                'private_modifier'
+            )
+        )
+        ) {
+            return true;
+        }
+        // check security settings
+        if (empty($this->allowed_tags)) {
+            if (empty($this->disabled_tags) || !in_array($tag_name, $this->disabled_tags)) {
+                return true;
+            } else {
+                $compiler->trigger_template_error("tag '{$tag_name}' disabled by security setting", null, true);
+            }
+        } elseif (in_array($tag_name, $this->allowed_tags) && !in_array($tag_name, $this->disabled_tags)) {
+            return true;
+        } else {
+            $compiler->trigger_template_error("tag '{$tag_name}' not allowed by security setting", null, true);
+        }
+        return false; // should not, but who knows what happens to the compiler in the future?
+    }
+
+    /**
+     * Check if special $smarty variable is trusted.
+     *
+     * @param string $var_name
+     * @param object $compiler compiler object
+     *
+     * @return boolean                 true if tag is trusted
+     */
+    public function isTrustedSpecialSmartyVar($var_name, $compiler)
+    {
+        if (!in_array($var_name, $this->disabled_special_smarty_vars)) {
+            return true;
+        } else {
+            $compiler->trigger_template_error(
+                "special variable '\$smarty.{$var_name}' not allowed by security setting",
+                null,
+                true
+            );
+        }
+        return false; // should not, but who knows what happens to the compiler in the future?
+    }
+
+    /**
+     * Check if modifier plugin is trusted.
+     *
+     * @param string $modifier_name
+     * @param object $compiler compiler object
+     *
+     * @return boolean                 true if tag is trusted
+     */
+    public function isTrustedModifier($modifier_name, $compiler)
+    {
+        // check for internal always allowed modifier
+        if (in_array($modifier_name, array('default'))) {
+            return true;
+        }
+        // check security settings
+        if (empty($this->allowed_modifiers)) {
+            if (empty($this->disabled_modifiers) || !in_array($modifier_name, $this->disabled_modifiers)) {
+                return true;
+            } else {
+                $compiler->trigger_template_error(
+                    "modifier '{$modifier_name}' disabled by security setting",
+                    null,
+                    true
+                );
+            }
+        } elseif (in_array($modifier_name, $this->allowed_modifiers)
+                  && !in_array($modifier_name, $this->disabled_modifiers)
+        ) {
+            return true;
+        } else {
+            $compiler->trigger_template_error(
+                "modifier '{$modifier_name}' not allowed by security setting",
+                null,
+                true
+            );
+        }
+        return false; // should not, but who knows what happens to the compiler in the future?
+    }
+
+    /**
+     * Check if constants are enabled or trusted
+     *
+     * @param string $const    constant name
+     * @param object $compiler compiler object
+     *
+     * @return bool
+     */
+    public function isTrustedConstant($const, $compiler)
+    {
+        if (in_array($const, array('true', 'false', 'null'))) {
+            return true;
+        }
+        if (!empty($this->trusted_constants)) {
+            if (!in_array(strtolower($const), $this->trusted_constants)) {
+                $compiler->trigger_template_error("Security: access to constant '{$const}' not permitted");
+                return false;
+            }
+            return true;
+        }
+        if ($this->allow_constants) {
+            return true;
+        }
+        $compiler->trigger_template_error("Security: access to constants not permitted");
+        return false;
+    }
+
+    /**
+     * Check if stream is trusted.
+     *
+     * @param string $stream_name
+     *
+     * @return boolean         true if stream is trusted
+     * @throws SmartyException if stream is not trusted
+     */
+    public function isTrustedStream($stream_name)
+    {
+        if (isset($this->streams) && (empty($this->streams) || in_array($stream_name, $this->streams))) {
+            return true;
+        }
+        throw new SmartyException("stream '{$stream_name}' not allowed by security setting");
+    }
+
+    /**
+     * Check if directory of file resource is trusted.
+     *
+     * @param string    $filepath
+     * @param null|bool $isConfig
+     *
+     * @return bool true if directory is trusted
+     * @throws \SmartyException if directory is not trusted
+     */
+    public function isTrustedResourceDir($filepath, $isConfig = null)
+    {
+        if ($this->_include_path_status !== $this->smarty->use_include_path) {
+            $_dir =
+                $this->smarty->use_include_path ? $this->smarty->ext->_getIncludePath->getIncludePathDirs($this->smarty) : array();
+            if ($this->_include_dir !== $_dir) {
+                $this->_updateResourceDir($this->_include_dir, $_dir);
+                $this->_include_dir = $_dir;
+            }
+            $this->_include_path_status = $this->smarty->use_include_path;
+        }
+        $_dir = $this->smarty->getTemplateDir();
+        if ($this->_template_dir !== $_dir) {
+            $this->_updateResourceDir($this->_template_dir, $_dir);
+            $this->_template_dir = $_dir;
+        }
+        $_dir = $this->smarty->getConfigDir();
+        if ($this->_config_dir !== $_dir) {
+            $this->_updateResourceDir($this->_config_dir, $_dir);
+            $this->_config_dir = $_dir;
+        }
+        if ($this->_secure_dir !== $this->secure_dir) {
+            $this->secure_dir = (array)$this->secure_dir;
+            foreach ($this->secure_dir as $k => $d) {
+                $this->secure_dir[ $k ] = $this->smarty->_realpath($d . DIRECTORY_SEPARATOR, true);
+            }
+            $this->_updateResourceDir($this->_secure_dir, $this->secure_dir);
+            $this->_secure_dir = $this->secure_dir;
+        }
+        $addPath = $this->_checkDir($filepath, $this->_resource_dir);
+        if ($addPath !== false) {
+            $this->_resource_dir = array_merge($this->_resource_dir, $addPath);
+        }
+        return true;
+    }
+
+    /**
+     * Check if URI (e.g. {fetch} or {html_image}) is trusted
+     * To simplify things, isTrustedUri() resolves all input to "{$PROTOCOL}://{$HOSTNAME}".
+     * So "http://username:password@hello.world.example.org:8080/some-path?some=query-string"
+     * is reduced to "http://hello.world.example.org" prior to applying the patters from {@link $trusted_uri}.
+     *
+     * @param string $uri
+     *
+     * @return boolean         true if URI is trusted
+     * @throws SmartyException if URI is not trusted
+     * @uses   $trusted_uri for list of patterns to match against $uri
+     */
+    public function isTrustedUri($uri)
+    {
+        $_uri = parse_url($uri);
+        if (!empty($_uri[ 'scheme' ]) && !empty($_uri[ 'host' ])) {
+            $_uri = $_uri[ 'scheme' ] . '://' . $_uri[ 'host' ];
+            foreach ($this->trusted_uri as $pattern) {
+                if (preg_match($pattern, $_uri)) {
+                    return true;
+                }
+            }
+        }
+        throw new SmartyException("URI '{$uri}' not allowed by security setting");
+    }
+
+    /**
+     * Check if directory of file resource is trusted.
+     *
+     * @param string $filepath
+     *
+     * @return boolean         true if directory is trusted
+     * @throws SmartyException if PHP directory is not trusted
+     */
+    public function isTrustedPHPDir($filepath)
+    {
+        if (empty($this->trusted_dir)) {
+            throw new SmartyException("directory '{$filepath}' not allowed by security setting (no trusted_dir specified)");
+        }
+        // check if index is outdated
+        if (!$this->_trusted_dir || $this->_trusted_dir !== $this->trusted_dir) {
+            $this->_php_resource_dir = array();
+            $this->_trusted_dir = $this->trusted_dir;
+            foreach ((array)$this->trusted_dir as $directory) {
+                $directory = $this->smarty->_realpath($directory . '/', true);
+                $this->_php_resource_dir[ $directory ] = true;
+            }
+        }
+        $addPath = $this->_checkDir($filepath, $this->_php_resource_dir);
+        if ($addPath !== false) {
+            $this->_php_resource_dir = array_merge($this->_php_resource_dir, $addPath);
+        }
+        return true;
+    }
+
+    /**
+     * Remove old directories and its sub folders, add new directories
+     *
+     * @param array $oldDir
+     * @param array $newDir
+     */
+    private function _updateResourceDir($oldDir, $newDir)
+    {
+        foreach ($oldDir as $directory) {
+            //           $directory = $this->smarty->_realpath($directory, true);
+            $length = strlen($directory);
+            foreach ($this->_resource_dir as $dir) {
+                if (substr($dir, 0, $length) === $directory) {
+                    unset($this->_resource_dir[ $dir ]);
+                }
+            }
+        }
+        foreach ($newDir as $directory) {
+            //           $directory = $this->smarty->_realpath($directory, true);
+            $this->_resource_dir[ $directory ] = true;
+        }
+    }
+
+    /**
+     * Check if file is inside a valid directory
+     *
+     * @param string $filepath
+     * @param array  $dirs valid directories
+     *
+     * @return array|bool
+     * @throws \SmartyException
+     */
+    private function _checkDir($filepath, $dirs)
+    {
+        $directory = dirname($this->smarty->_realpath($filepath, true)) . DIRECTORY_SEPARATOR;
+        $_directory = array();
+        if (!preg_match('#[\\\\/][.][.][\\\\/]#', $directory)) {
+            while (true) {
+                // test if the directory is trusted
+                if (isset($dirs[ $directory ])) {
+                    return $_directory;
+                }
+                // abort if we've reached root
+                if (!preg_match('#[\\\\/][^\\\\/]+[\\\\/]$#', $directory)) {
+                    // give up
+                    break;
+                }
+                // remember the directory to add it to _resource_dir in case we're successful
+                $_directory[ $directory ] = true;
+                // bubble up one level
+                $directory = preg_replace('#[\\\\/][^\\\\/]+[\\\\/]$#', DIRECTORY_SEPARATOR, $directory);
+            }
+        }
+        // give up
+        throw new SmartyException(sprintf('Smarty Security: not trusted file path \'%s\' ', $filepath));
+    }
+
+    /**
+     * Loads security class and enables security
+     *
+     * @param \Smarty                $smarty
+     * @param string|Smarty_Security $security_class if a string is used, it must be class-name
+     *
+     * @return \Smarty current Smarty instance for chaining
+     * @throws \SmartyException when an invalid class name is provided
+     */
+    public static function enableSecurity(Smarty $smarty, $security_class)
+    {
+        if ($security_class instanceof Smarty_Security) {
+            $smarty->security_policy = $security_class;
+            return $smarty;
+        } elseif (is_object($security_class)) {
+            throw new SmartyException("Class '" . get_class($security_class) . "' must extend Smarty_Security.");
+        }
+        if ($security_class === null) {
+            $security_class = $smarty->security_class;
+        }
+        if (!class_exists($security_class)) {
+            throw new SmartyException("Security class '$security_class' is not defined");
+        } elseif ($security_class !== 'Smarty_Security' && !is_subclass_of($security_class, 'Smarty_Security')) {
+            throw new SmartyException("Class '$security_class' must extend Smarty_Security.");
+        } else {
+            $smarty->security_policy = new $security_class($smarty);
+        }
+        return $smarty;
+    }
+
+    /**
+     * Start template processing
+     *
+     * @param $template
+     *
+     * @throws SmartyException
+     */
+    public function startTemplate($template)
+    {
+        if ($this->max_template_nesting > 0 && $this->_current_template_nesting++ >= $this->max_template_nesting) {
+            throw new SmartyException("maximum template nesting level of '{$this->max_template_nesting}' exceeded when calling '{$template->template_resource}'");
+        }
+    }
+
+    /**
+     * Exit template processing
+     */
+    public function endTemplate()
+    {
+        if ($this->max_template_nesting > 0) {
+            $this->_current_template_nesting--;
+        }
+    }
+
+    /**
+     * Register callback functions call at start/end of template rendering
+     *
+     * @param \Smarty_Internal_Template $template
+     */
+    public function registerCallBacks(Smarty_Internal_Template $template)
+    {
+        $template->startRenderCallbacks[] = array($this, 'startTemplate');
+        $template->endRenderCallbacks[] = array($this, 'endTemplate');
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_template_cached.php b/epgrec/Smarty/sysplugins/smarty_template_cached.php
--- a/epgrec/Smarty/sysplugins/smarty_template_cached.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_template_cached.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,257 @@
+<?php
+/**
+ * Created by PhpStorm.
+ * User: Uwe Tews
+ * Date: 04.12.2014
+ * Time: 06:08
+ */
+
+/**
+ * Smarty Resource Data Object
+ * Cache Data Container for Template Files
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ */
+class Smarty_Template_Cached extends Smarty_Template_Resource_Base
+{
+    /**
+     * Cache Is Valid
+     *
+     * @var boolean
+     */
+    public $valid = null;
+
+    /**
+     * CacheResource Handler
+     *
+     * @var Smarty_CacheResource
+     */
+    public $handler = null;
+
+    /**
+     * Template Cache Id (Smarty_Internal_Template::$cache_id)
+     *
+     * @var string
+     */
+    public $cache_id = null;
+
+    /**
+     * saved cache lifetime in seconds
+     *
+     * @var integer
+     */
+    public $cache_lifetime = 0;
+
+    /**
+     * Id for cache locking
+     *
+     * @var string
+     */
+    public $lock_id = null;
+
+    /**
+     * flag that cache is locked by this instance
+     *
+     * @var bool
+     */
+    public $is_locked = false;
+
+    /**
+     * Source Object
+     *
+     * @var Smarty_Template_Source
+     */
+    public $source = null;
+
+    /**
+     * Nocache hash codes of processed compiled templates
+     *
+     * @var array
+     */
+    public $hashes = array();
+
+    /**
+     * Flag if this is a cache resource
+     *
+     * @var bool
+     */
+    public $isCache = true;
+
+    /**
+     * create Cached Object container
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @throws \SmartyException
+     */
+    public function __construct(Smarty_Internal_Template $_template)
+    {
+        $this->compile_id = $_template->compile_id;
+        $this->cache_id = $_template->cache_id;
+        $this->source = $_template->source;
+        if (!class_exists('Smarty_CacheResource', false)) {
+            include SMARTY_SYSPLUGINS_DIR . 'smarty_cacheresource.php';
+        }
+        $this->handler = Smarty_CacheResource::load($_template->smarty);
+    }
+
+    /**
+     * @param Smarty_Internal_Template $_template
+     *
+     * @return Smarty_Template_Cached
+     */
+    public static function load(Smarty_Internal_Template $_template)
+    {
+        $_template->cached = new Smarty_Template_Cached($_template);
+        $_template->cached->handler->populate($_template->cached, $_template);
+        // caching enabled ?
+        if (!$_template->caching || $_template->source->handler->recompiled
+        ) {
+            $_template->cached->valid = false;
+        }
+        return $_template->cached;
+    }
+
+    /**
+     * Render cache template
+     *
+     * @param \Smarty_Internal_Template $_template
+     * @param bool                      $no_output_filter
+     *
+     * @throws \Exception
+     */
+    public function render(Smarty_Internal_Template $_template, $no_output_filter = true)
+    {
+        if ($this->isCached($_template)) {
+            if ($_template->smarty->debugging) {
+                if (!isset($_template->smarty->_debug)) {
+                    $_template->smarty->_debug = new Smarty_Internal_Debug();
+                }
+                $_template->smarty->_debug->start_cache($_template);
+            }
+            if (!$this->processed) {
+                $this->process($_template);
+            }
+            $this->getRenderedTemplateCode($_template);
+            if ($_template->smarty->debugging) {
+                $_template->smarty->_debug->end_cache($_template);
+            }
+            return;
+        } else {
+            $_template->smarty->ext->_updateCache->updateCache($this, $_template, $no_output_filter);
+        }
+    }
+
+    /**
+     * Check if cache is valid, lock cache if required
+     *
+     * @param \Smarty_Internal_Template $_template
+     *
+     * @return bool flag true if cache is valid
+     */
+    public function isCached(Smarty_Internal_Template $_template)
+    {
+        if ($this->valid !== null) {
+            return $this->valid;
+        }
+        while (true) {
+            while (true) {
+                if ($this->exists === false || $_template->smarty->force_compile || $_template->smarty->force_cache) {
+                    $this->valid = false;
+                } else {
+                    $this->valid = true;
+                }
+                if ($this->valid && $_template->caching === Smarty::CACHING_LIFETIME_CURRENT
+                    && $_template->cache_lifetime >= 0 && time() > ($this->timestamp + $_template->cache_lifetime)
+                ) {
+                    // lifetime expired
+                    $this->valid = false;
+                }
+                if ($this->valid && $_template->compile_check === Smarty::COMPILECHECK_ON
+                    && $_template->source->getTimeStamp() > $this->timestamp
+                ) {
+                    $this->valid = false;
+                }
+                if ($this->valid || !$_template->smarty->cache_locking) {
+                    break;
+                }
+                if (!$this->handler->locked($_template->smarty, $this)) {
+                    $this->handler->acquireLock($_template->smarty, $this);
+                    break 2;
+                }
+                $this->handler->populate($this, $_template);
+            }
+            if ($this->valid) {
+                if (!$_template->smarty->cache_locking || $this->handler->locked($_template->smarty, $this) === null) {
+                    // load cache file for the following checks
+                    if ($_template->smarty->debugging) {
+                        $_template->smarty->_debug->start_cache($_template);
+                    }
+                    if ($this->handler->process($_template, $this) === false) {
+                        $this->valid = false;
+                    } else {
+                        $this->processed = true;
+                    }
+                    if ($_template->smarty->debugging) {
+                        $_template->smarty->_debug->end_cache($_template);
+                    }
+                } else {
+                    $this->is_locked = true;
+                    continue;
+                }
+            } else {
+                return $this->valid;
+            }
+            if ($this->valid && $_template->caching === Smarty::CACHING_LIFETIME_SAVED
+                && $_template->cached->cache_lifetime >= 0
+                && (time() > ($_template->cached->timestamp + $_template->cached->cache_lifetime))
+            ) {
+                $this->valid = false;
+            }
+            if ($_template->smarty->cache_locking) {
+                if (!$this->valid) {
+                    $this->handler->acquireLock($_template->smarty, $this);
+                } elseif ($this->is_locked) {
+                    $this->handler->releaseLock($_template->smarty, $this);
+                }
+            }
+            return $this->valid;
+        }
+        return $this->valid;
+    }
+
+    /**
+     * Process cached template
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param bool                     $update    flag if called because cache update
+     */
+    public function process(Smarty_Internal_Template $_template, $update = false)
+    {
+        if ($this->handler->process($_template, $this, $update) === false) {
+            $this->valid = false;
+        }
+        if ($this->valid) {
+            $this->processed = true;
+        } else {
+            $this->processed = false;
+        }
+    }
+
+    /**
+     * Read cache content from handler
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return string|false content
+     */
+    public function read(Smarty_Internal_Template $_template)
+    {
+        if (!$_template->source->handler->recompiled) {
+            return $this->handler->readCachedContent($_template);
+        }
+        return false;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_template_compiled.php b/epgrec/Smarty/sysplugins/smarty_template_compiled.php
--- a/epgrec/Smarty/sysplugins/smarty_template_compiled.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_template_compiled.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,257 @@
+<?php
+
+/**
+ * Smarty Resource Data Object
+ * Meta Data Container for Template Files
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ * @property   string $content compiled content
+ */
+class Smarty_Template_Compiled extends Smarty_Template_Resource_Base
+{
+    /**
+     * nocache hash
+     *
+     * @var string|null
+     */
+    public $nocache_hash = null;
+
+    /**
+     * get a Compiled Object of this source
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return Smarty_Template_Compiled compiled object
+     */
+    public static function load($_template)
+    {
+        $compiled = new Smarty_Template_Compiled();
+        if ($_template->source->handler->hasCompiledHandler) {
+            $_template->source->handler->populateCompiledFilepath($compiled, $_template);
+        } else {
+            $compiled->populateCompiledFilepath($_template);
+        }
+        return $compiled;
+    }
+
+    /**
+     * populate Compiled Object with compiled filepath
+     *
+     * @param Smarty_Internal_Template $_template template object
+     **/
+    public function populateCompiledFilepath(Smarty_Internal_Template $_template)
+    {
+        $source = &$_template->source;
+        $smarty = &$_template->smarty;
+        $this->filepath = $smarty->getCompileDir();
+        if (isset($_template->compile_id)) {
+            $this->filepath .= preg_replace('![^\w]+!', '_', $_template->compile_id) .
+                               ($smarty->use_sub_dirs ? DIRECTORY_SEPARATOR : '^');
+        }
+        // if use_sub_dirs, break file into directories
+        if ($smarty->use_sub_dirs) {
+            $this->filepath .= $source->uid[ 0 ] . $source->uid[ 1 ] . DIRECTORY_SEPARATOR . $source->uid[ 2 ] .
+                               $source->uid[ 3 ] . DIRECTORY_SEPARATOR . $source->uid[ 4 ] . $source->uid[ 5 ] .
+                               DIRECTORY_SEPARATOR;
+        }
+        $this->filepath .= $source->uid . '_';
+        if ($source->isConfig) {
+            $this->filepath .= (int)$smarty->config_read_hidden + (int)$smarty->config_booleanize * 2 +
+                               (int)$smarty->config_overwrite * 4;
+        } else {
+            $this->filepath .= (int)$smarty->merge_compiled_includes + (int)$smarty->escape_html * 2 +
+                               (($smarty->merge_compiled_includes && $source->type === 'extends') ?
+                                   (int)$smarty->extends_recursion * 4 : 0);
+        }
+        $this->filepath .= '.' . $source->type;
+        $basename = $source->handler->getBasename($source);
+        if (!empty($basename)) {
+            $this->filepath .= '.' . $basename;
+        }
+        if ($_template->caching) {
+            $this->filepath .= '.cache';
+        }
+        $this->filepath .= '.php';
+        $this->timestamp = $this->exists = is_file($this->filepath);
+        if ($this->exists) {
+            $this->timestamp = filemtime($this->filepath);
+        }
+    }
+
+    /**
+     * render compiled template code
+     *
+     * @param Smarty_Internal_Template $_template
+     *
+     * @return string
+     * @throws Exception
+     */
+    public function render(Smarty_Internal_Template $_template)
+    {
+        // checks if template exists
+        if (!$_template->source->exists) {
+            $type = $_template->source->isConfig ? 'config' : 'template';
+            throw new SmartyException("Unable to load {$type} '{$_template->source->type}:{$_template->source->name}'");
+        }
+        if ($_template->smarty->debugging) {
+            if (!isset($_template->smarty->_debug)) {
+                $_template->smarty->_debug = new Smarty_Internal_Debug();
+            }
+            $_template->smarty->_debug->start_render($_template);
+        }
+        if (!$this->processed) {
+            $this->process($_template);
+        }
+        if (isset($_template->cached)) {
+            $_template->cached->file_dependency =
+                array_merge($_template->cached->file_dependency, $this->file_dependency);
+        }
+        if ($_template->source->handler->uncompiled) {
+            $_template->source->handler->renderUncompiled($_template->source, $_template);
+        } else {
+            $this->getRenderedTemplateCode($_template);
+        }
+        if ($_template->caching && $this->has_nocache_code) {
+            $_template->cached->hashes[ $this->nocache_hash ] = true;
+        }
+        if ($_template->smarty->debugging) {
+            $_template->smarty->_debug->end_render($_template);
+        }
+    }
+
+    /**
+     * load compiled template or compile from source
+     *
+     * @param Smarty_Internal_Template $_smarty_tpl do not change variable name, is used by compiled template
+     *
+     * @throws Exception
+     */
+    public function process(Smarty_Internal_Template $_smarty_tpl)
+    {
+        $source = &$_smarty_tpl->source;
+        $smarty = &$_smarty_tpl->smarty;
+        if ($source->handler->recompiled) {
+            $source->handler->process($_smarty_tpl);
+        } elseif (!$source->handler->uncompiled) {
+            if (!$this->exists || $smarty->force_compile
+                || ($_smarty_tpl->compile_check && $source->getTimeStamp() > $this->getTimeStamp())
+            ) {
+                $this->compileTemplateSource($_smarty_tpl);
+                $compileCheck = $_smarty_tpl->compile_check;
+                $_smarty_tpl->compile_check = Smarty::COMPILECHECK_OFF;
+                $this->loadCompiledTemplate($_smarty_tpl);
+                $_smarty_tpl->compile_check = $compileCheck;
+            } else {
+                $_smarty_tpl->mustCompile = true;
+                @include $this->filepath;
+                if ($_smarty_tpl->mustCompile) {
+                    $this->compileTemplateSource($_smarty_tpl);
+                    $compileCheck = $_smarty_tpl->compile_check;
+                    $_smarty_tpl->compile_check = Smarty::COMPILECHECK_OFF;
+                    $this->loadCompiledTemplate($_smarty_tpl);
+                    $_smarty_tpl->compile_check = $compileCheck;
+                }
+            }
+            $_smarty_tpl->_subTemplateRegister();
+            $this->processed = true;
+        }
+    }
+
+    /**
+     * compile template from source
+     *
+     * @param Smarty_Internal_Template $_template
+     *
+     * @throws Exception
+     */
+    public function compileTemplateSource(Smarty_Internal_Template $_template)
+    {
+        $this->file_dependency = array();
+        $this->includes = array();
+        $this->nocache_hash = null;
+        $this->unifunc = null;
+        // compile locking
+        if ($saved_timestamp = (!$_template->source->handler->recompiled && is_file($this->filepath))) {
+            $saved_timestamp = $this->getTimeStamp();
+            touch($this->filepath);
+        }
+        // compile locking
+        try {
+            // call compiler
+            $_template->loadCompiler();
+            $this->write($_template, $_template->compiler->compileTemplate($_template));
+        } catch (Exception $e) {
+            // restore old timestamp in case of error
+            if ($saved_timestamp && is_file($this->filepath)) {
+                touch($this->filepath, $saved_timestamp);
+            }
+            unset($_template->compiler);
+            throw $e;
+        }
+        // release compiler object to free memory
+        unset($_template->compiler);
+    }
+
+    /**
+     * Write compiled code by handler
+     *
+     * @param Smarty_Internal_Template $_template template object
+     * @param string                   $code      compiled code
+     *
+     * @return bool success
+     * @throws \SmartyException
+     */
+    public function write(Smarty_Internal_Template $_template, $code)
+    {
+        if (!$_template->source->handler->recompiled) {
+            if ($_template->smarty->ext->_writeFile->writeFile($this->filepath, $code, $_template->smarty) === true) {
+                $this->timestamp = $this->exists = is_file($this->filepath);
+                if ($this->exists) {
+                    $this->timestamp = filemtime($this->filepath);
+                    return true;
+                }
+            }
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Read compiled content from handler
+     *
+     * @param Smarty_Internal_Template $_template template object
+     *
+     * @return string content
+     */
+    public function read(Smarty_Internal_Template $_template)
+    {
+        if (!$_template->source->handler->recompiled) {
+            return file_get_contents($this->filepath);
+        }
+        return isset($this->content) ? $this->content : false;
+    }
+
+    /**
+     * Load fresh compiled template by including the PHP file
+     * HHVM requires a work around because of a PHP incompatibility
+     *
+     * @param \Smarty_Internal_Template $_smarty_tpl do not change variable name, is used by compiled template
+     */
+    private function loadCompiledTemplate(Smarty_Internal_Template $_smarty_tpl)
+    {
+        if (function_exists('opcache_invalidate')
+            && (!function_exists('ini_get') || strlen(ini_get("opcache.restrict_api")) < 1)
+        ) {
+            opcache_invalidate($this->filepath, true);
+        } elseif (function_exists('apc_compile_file')) {
+            apc_compile_file($this->filepath);
+        }
+        if (defined('HHVM_VERSION')) {
+            eval('?>' . file_get_contents($this->filepath));
+        } else {
+            include $this->filepath;
+        }
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_template_config.php b/epgrec/Smarty/sysplugins/smarty_template_config.php
--- a/epgrec/Smarty/sysplugins/smarty_template_config.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_template_config.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,100 @@
+<?php
+/**
+ * Smarty Config Source Plugin
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ */
+
+/**
+ * Smarty Config Resource Data Object
+ * Meta Data Container for Template Files
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Uwe Tews
+ */
+class Smarty_Template_Config extends Smarty_Template_Source
+{
+    /**
+     * array of section names, single section or null
+     *
+     * @var null|string|array
+     */
+    public $config_sections = null;
+
+    /**
+     * scope into which the config variables shall be loaded
+     *
+     * @var int
+     */
+    public $scope = 0;
+
+    /**
+     * Flag that source is a config file
+     *
+     * @var bool
+     */
+    public $isConfig = true;
+
+    /**
+     * Name of the Class to compile this resource's contents with
+     *
+     * @var string
+     */
+    public $compiler_class = 'Smarty_Internal_Config_File_Compiler';
+
+    /**
+     * Name of the Class to tokenize this resource's contents with
+     *
+     * @var string
+     */
+    public $template_lexer_class = 'Smarty_Internal_Configfilelexer';
+
+    /**
+     * Name of the Class to parse this resource's contents with
+     *
+     * @var string
+     */
+    public $template_parser_class = 'Smarty_Internal_Configfileparser';
+
+    /**
+     * initialize Source Object for given resource
+     * Either [$_template] or [$smarty, $template_resource] must be specified
+     *
+     * @param Smarty_Internal_Template $_template         template object
+     * @param Smarty                   $smarty            smarty object
+     * @param string                   $template_resource resource identifier
+     *
+     * @return Smarty_Template_Config Source Object
+     * @throws SmartyException
+     */
+    public static function load(
+        Smarty_Internal_Template $_template = null,
+        Smarty $smarty = null,
+        $template_resource = null
+    ) {
+        static $_incompatible_resources = array('extends' => true, 'php' => true);
+        if ($_template) {
+            $smarty = $_template->smarty;
+            $template_resource = $_template->template_resource;
+        }
+        if (empty($template_resource)) {
+            throw new SmartyException('Source: Missing  name');
+        }
+        // parse resource_name, load resource handler
+        list($name, $type) = Smarty_Resource::parseResourceName($template_resource, $smarty->default_config_type);
+        // make sure configs are not loaded via anything smarty can't handle
+        if (isset($_incompatible_resources[ $type ])) {
+            throw new SmartyException("Unable to use resource '{$type}' for config");
+        }
+        $source = new Smarty_Template_Config($smarty, $template_resource, $type, $name);
+        $source->handler->populate($source, $_template);
+        if (!$source->exists && isset($smarty->default_config_handler_func)) {
+            Smarty_Internal_Method_RegisterDefaultTemplateHandler::_getDefaultTemplate($source);
+            $source->handler->populate($source, $_template);
+        }
+        return $source;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_template_resource_base.php b/epgrec/Smarty/sysplugins/smarty_template_resource_base.php
--- a/epgrec/Smarty/sysplugins/smarty_template_resource_base.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_template_resource_base.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,152 @@
+<?php
+
+/**
+ * Smarty Template Resource Base Object
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ */
+abstract class Smarty_Template_Resource_Base
+{
+    /**
+     * Compiled Filepath
+     *
+     * @var string
+     */
+    public $filepath = null;
+
+    /**
+     * Compiled Timestamp
+     *
+     * @var integer|bool
+     */
+    public $timestamp = false;
+
+    /**
+     * Compiled Existence
+     *
+     * @var boolean
+     */
+    public $exists = false;
+
+    /**
+     * Template Compile Id (Smarty_Internal_Template::$compile_id)
+     *
+     * @var string
+     */
+    public $compile_id = null;
+
+    /**
+     * Compiled Content Loaded
+     *
+     * @var boolean
+     */
+    public $processed = false;
+
+    /**
+     * unique function name for compiled template code
+     *
+     * @var string
+     */
+    public $unifunc = '';
+
+    /**
+     * flag if template does contain nocache code sections
+     *
+     * @var bool
+     */
+    public $has_nocache_code = false;
+
+    /**
+     * resource file dependency
+     *
+     * @var array
+     */
+    public $file_dependency = array();
+
+    /**
+     * Content buffer
+     *
+     * @var string
+     */
+    public $content = null;
+
+    /**
+     * Included sub templates
+     * - index name
+     * - value use count
+     *
+     * @var int[]
+     */
+    public $includes = array();
+
+    /**
+     * Flag if this is a cache resource
+     *
+     * @var bool
+     */
+    public $isCache = false;
+
+    /**
+     * Process resource
+     *
+     * @param Smarty_Internal_Template $_template template object
+     */
+    abstract public function process(Smarty_Internal_Template $_template);
+
+    /**
+     * get rendered template content by calling compiled or cached template code
+     *
+     * @param \Smarty_Internal_Template $_template
+     * @param string                    $unifunc function with template code
+     *
+     * @throws \Exception
+     */
+    public function getRenderedTemplateCode(Smarty_Internal_Template $_template, $unifunc = null)
+    {
+        $smarty = &$_template->smarty;
+        $_template->isRenderingCache = $this->isCache;
+        $level = ob_get_level();
+        try {
+            if (!isset($unifunc)) {
+                $unifunc = $this->unifunc;
+            }
+            if (empty($unifunc) || !function_exists($unifunc)) {
+                throw new SmartyException("Invalid compiled template for '{$_template->template_resource}'");
+            }
+            if ($_template->startRenderCallbacks) {
+                foreach ($_template->startRenderCallbacks as $callback) {
+                    call_user_func($callback, $_template);
+                }
+            }
+            $unifunc($_template);
+            foreach ($_template->endRenderCallbacks as $callback) {
+                call_user_func($callback, $_template);
+            }
+            $_template->isRenderingCache = false;
+        } catch (Exception $e) {
+            $_template->isRenderingCache = false;
+            while (ob_get_level() > $level) {
+                ob_end_clean();
+            }
+            if (isset($smarty->security_policy)) {
+                $smarty->security_policy->endTemplate();
+            }
+            throw $e;
+        }
+    }
+
+    /**
+     * Get compiled time stamp
+     *
+     * @return int
+     */
+    public function getTimeStamp()
+    {
+        if ($this->exists && !$this->timestamp) {
+            $this->timestamp = filemtime($this->filepath);
+        }
+        return $this->timestamp;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_template_source.php b/epgrec/Smarty/sysplugins/smarty_template_source.php
--- a/epgrec/Smarty/sysplugins/smarty_template_source.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_template_source.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,213 @@
+<?php
+
+/**
+ * Smarty Resource Data Object
+ * Meta Data Container for Template Files
+ *
+ * @package    Smarty
+ * @subpackage TemplateResources
+ * @author     Rodney Rehm
+ */
+class Smarty_Template_Source
+{
+    /**
+     * Unique Template ID
+     *
+     * @var string
+     */
+    public $uid = null;
+
+    /**
+     * Template Resource (Smarty_Internal_Template::$template_resource)
+     *
+     * @var string
+     */
+    public $resource = null;
+
+    /**
+     * Resource Type
+     *
+     * @var string
+     */
+    public $type = null;
+
+    /**
+     * Resource Name
+     *
+     * @var string
+     */
+    public $name = null;
+
+    /**
+     * Source Filepath
+     *
+     * @var string
+     */
+    public $filepath = null;
+
+    /**
+     * Source Timestamp
+     *
+     * @var integer
+     */
+    public $timestamp = null;
+
+    /**
+     * Source Existence
+     *
+     * @var boolean
+     */
+    public $exists = false;
+
+    /**
+     * Source File Base name
+     *
+     * @var string
+     */
+    public $basename = null;
+
+    /**
+     * The Components an extended template is made of
+     *
+     * @var \Smarty_Template_Source[]
+     */
+    public $components = null;
+
+    /**
+     * Resource Handler
+     *
+     * @var \Smarty_Resource
+     */
+    public $handler = null;
+
+    /**
+     * Smarty instance
+     *
+     * @var Smarty
+     */
+    public $smarty = null;
+
+    /**
+     * Resource is source
+     *
+     * @var bool
+     */
+    public $isConfig = false;
+
+    /**
+     * Template source content eventually set by default handler
+     *
+     * @var string
+     */
+    public $content = null;
+
+    /**
+     * Name of the Class to compile this resource's contents with
+     *
+     * @var string
+     */
+    public $compiler_class = 'Smarty_Internal_SmartyTemplateCompiler';
+
+    /**
+     * Name of the Class to tokenize this resource's contents with
+     *
+     * @var string
+     */
+    public $template_lexer_class = 'Smarty_Internal_Templatelexer';
+
+    /**
+     * Name of the Class to parse this resource's contents with
+     *
+     * @var string
+     */
+    public $template_parser_class = 'Smarty_Internal_Templateparser';
+
+    /**
+     * create Source Object container
+     *
+     * @param Smarty $smarty   Smarty instance this source object belongs to
+     * @param string $resource full template_resource
+     * @param string $type     type of resource
+     * @param string $name     resource name
+     *
+     * @throws   \SmartyException
+     * @internal param \Smarty_Resource $handler Resource Handler this source object communicates with
+     */
+    public function __construct(Smarty $smarty, $resource, $type, $name)
+    {
+        $this->handler =
+            isset($smarty->_cache[ 'resource_handlers' ][ $type ]) ? $smarty->_cache[ 'resource_handlers' ][ $type ] :
+                Smarty_Resource::load($smarty, $type);
+        $this->smarty = $smarty;
+        $this->resource = $resource;
+        $this->type = $type;
+        $this->name = $name;
+    }
+
+    /**
+     * initialize Source Object for given resource
+     * Either [$_template] or [$smarty, $template_resource] must be specified
+     *
+     * @param Smarty_Internal_Template $_template         template object
+     * @param Smarty                   $smarty            smarty object
+     * @param string                   $template_resource resource identifier
+     *
+     * @return Smarty_Template_Source Source Object
+     * @throws SmartyException
+     */
+    public static function load(
+        Smarty_Internal_Template $_template = null,
+        Smarty $smarty = null,
+        $template_resource = null
+    ) {
+        if ($_template) {
+            $smarty = $_template->smarty;
+            $template_resource = $_template->template_resource;
+        }
+        if (empty($template_resource)) {
+            throw new SmartyException('Source: Missing  name');
+        }
+        // parse resource_name, load resource handler, identify unique resource name
+        if (preg_match('/^([A-Za-z0-9_\-]{2,})[:]([\s\S]*)$/', $template_resource, $match)) {
+            $type = $match[ 1 ];
+            $name = $match[ 2 ];
+        } else {
+            // no resource given, use default
+            // or single character before the colon is not a resource type, but part of the filepath
+            $type = $smarty->default_resource_type;
+            $name = $template_resource;
+        }
+        // create new source  object
+        $source = new Smarty_Template_Source($smarty, $template_resource, $type, $name);
+        $source->handler->populate($source, $_template);
+        if (!$source->exists && isset($_template->smarty->default_template_handler_func)) {
+            Smarty_Internal_Method_RegisterDefaultTemplateHandler::_getDefaultTemplate($source);
+            $source->handler->populate($source, $_template);
+        }
+        return $source;
+    }
+
+    /**
+     * Get source time stamp
+     *
+     * @return int
+     */
+    public function getTimeStamp()
+    {
+        if (!isset($this->timestamp)) {
+            $this->handler->populateTimestamp($this);
+        }
+        return $this->timestamp;
+    }
+
+    /**
+     * Get source content
+     *
+     * @return string
+     * @throws \SmartyException
+     */
+    public function getContent()
+    {
+        return isset($this->content) ? $this->content : $this->handler->getContent($this);
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_undefined_variable.php b/epgrec/Smarty/sysplugins/smarty_undefined_variable.php
--- a/epgrec/Smarty/sysplugins/smarty_undefined_variable.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_undefined_variable.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,33 @@
+<?php
+
+/**
+ * class for undefined variable object
+ * This class defines an object for undefined variable handling
+ *
+ * @package    Smarty
+ * @subpackage Template
+ */
+class Smarty_Undefined_Variable extends Smarty_Variable
+{
+    /**
+     * Returns null for not existing properties
+     *
+     * @param string $name
+     *
+     * @return null
+     */
+    public function __get($name)
+    {
+        return null;
+    }
+
+    /**
+     * Always returns an empty string.
+     *
+     * @return string
+     */
+    public function __toString()
+    {
+        return '';
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smarty_variable.php b/epgrec/Smarty/sysplugins/smarty_variable.php
--- a/epgrec/Smarty/sysplugins/smarty_variable.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smarty_variable.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,47 @@
+<?php
+
+/**
+ * class for the Smarty variable object
+ * This class defines the Smarty variable object
+ *
+ * @package    Smarty
+ * @subpackage Template
+ */
+class Smarty_Variable
+{
+    /**
+     * template variable
+     *
+     * @var mixed
+     */
+    public $value = null;
+
+    /**
+     * if true any output of this variable will be not cached
+     *
+     * @var boolean
+     */
+    public $nocache = false;
+
+    /**
+     * create Smarty variable object
+     *
+     * @param mixed   $value   the value to assign
+     * @param boolean $nocache if true any output of this variable will be not cached
+     */
+    public function __construct($value = null, $nocache = false)
+    {
+        $this->value = $value;
+        $this->nocache = $nocache;
+    }
+
+    /**
+     * <<magic>> String conversion
+     *
+     * @return string
+     */
+    public function __toString()
+    {
+        return (string)$this->value;
+    }
+}
diff -urN a/epgrec/Smarty/sysplugins/smartycompilerexception.php b/epgrec/Smarty/sysplugins/smartycompilerexception.php
--- a/epgrec/Smarty/sysplugins/smartycompilerexception.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smartycompilerexception.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,45 @@
+<?php
+
+/**
+ * Smarty compiler exception class
+ *
+ * @package Smarty
+ */
+class SmartyCompilerException extends SmartyException
+{
+    /**
+     * @return string
+     */
+    public function __toString()
+    {
+        return ' --> Smarty Compiler: ' . $this->message . ' <-- ';
+    }
+
+    /**
+     * The line number of the template error
+     *
+     * @type int|null
+     */
+    public $line = null;
+
+    /**
+     * The template source snippet relating to the error
+     *
+     * @type string|null
+     */
+    public $source = null;
+
+    /**
+     * The raw text of the error message
+     *
+     * @type string|null
+     */
+    public $desc = null;
+
+    /**
+     * The resource identifier or template name
+     *
+     * @type string|null
+     */
+    public $template = null;
+}
diff -urN a/epgrec/Smarty/sysplugins/smartyexception.php b/epgrec/Smarty/sysplugins/smartyexception.php
--- a/epgrec/Smarty/sysplugins/smartyexception.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty/sysplugins/smartyexception.php	2022-09-14 20:29:00.000000000 +0900
@@ -0,0 +1,19 @@
+<?php
+
+/**
+ * Smarty exception class
+ *
+ * @package Smarty
+ */
+class SmartyException extends Exception
+{
+    public static $escape = false;
+
+    /**
+     * @return string
+     */
+    public function __toString()
+    {
+        return ' --> Smarty: ' . (self::$escape ? htmlentities($this->message) : $this->message) . ' <-- ';
+    }
+}
diff -urN a/epgrec/Smarty.v2/Config_File.class.php b/epgrec/Smarty.v2/Config_File.class.php
--- a/epgrec/Smarty.v2/Config_File.class.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/Config_File.class.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,393 @@
+<?php
+
+/**
+ * Config_File class.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * For questions, help, comments, discussion, etc., please join the
+ * Smarty mailing list. Send a blank e-mail to
+ * smarty-discussion-subscribe@googlegroups.com 
+ *
+ * @link http://www.smarty.net/
+ * @version 2.6.25-dev
+ * @copyright Copyright: 2001-2005 New Digital Group, Inc.
+ * @author Andrei Zmievski <andrei@php.net>
+ * @access public
+ * @package Smarty
+ */
+
+/* $Id$ */
+
+/**
+ * Config file reading class
+ * @package Smarty
+ */
+class Config_File {
+    /**#@+
+     * Options
+     * @var boolean
+     */
+    /**
+     * Controls whether variables with the same name overwrite each other.
+     */
+    var $overwrite        =    true;
+
+    /**
+     * Controls whether config values of on/true/yes and off/false/no get
+     * converted to boolean values automatically.
+     */
+    var $booleanize        =    true;
+
+    /**
+     * Controls whether hidden config sections/vars are read from the file.
+     */
+    var $read_hidden     =    true;
+
+    /**
+     * Controls whether or not to fix mac or dos formatted newlines.
+     * If set to true, \r or \r\n will be changed to \n.
+     */
+    var $fix_newlines =    true;
+    /**#@-*/
+
+    /** @access private */
+    var $_config_path    = "";
+    var $_config_data    = array();
+    /**#@-*/
+
+    /**
+     * Constructs a new config file class.
+     *
+     * @param string $config_path (optional) path to the config files
+     */
+    public function __construct($config_path = NULL)
+    {
+        if (isset($config_path))
+            $this->set_path($config_path);
+    }
+
+
+    /**
+     * Set the path where configuration files can be found.
+     *
+     * @param string $config_path path to the config files
+     */
+    function set_path($config_path)
+    {
+        if (!empty($config_path)) {
+            if (!is_string($config_path) || !file_exists($config_path) || !is_dir($config_path)) {
+                $this->_trigger_error_msg("Bad config file path '$config_path'");
+                return;
+            }
+            if(substr($config_path, -1) != DIRECTORY_SEPARATOR) {
+                $config_path .= DIRECTORY_SEPARATOR;
+            }
+
+            $this->_config_path = $config_path;
+        }
+    }
+
+
+    /**
+     * Retrieves config info based on the file, section, and variable name.
+     *
+     * @param string $file_name config file to get info for
+     * @param string $section_name (optional) section to get info for
+     * @param string $var_name (optional) variable to get info for
+     * @return string|array a value or array of values
+     */
+    function get($file_name, $section_name = NULL, $var_name = NULL)
+    {
+        if (empty($file_name)) {
+            $this->_trigger_error_msg('Empty config file name');
+            return;
+        } else {
+            $file_name = $this->_config_path . $file_name;
+            if (!isset($this->_config_data[$file_name]))
+                $this->load_file($file_name, false);
+        }
+
+        if (!empty($var_name)) {
+            if (empty($section_name)) {
+                return $this->_config_data[$file_name]["vars"][$var_name];
+            } else {
+                if(isset($this->_config_data[$file_name]["sections"][$section_name]["vars"][$var_name]))
+                    return $this->_config_data[$file_name]["sections"][$section_name]["vars"][$var_name];
+                else
+                    return array();
+            }
+        } else {
+            if (empty($section_name)) {
+                return (array)$this->_config_data[$file_name]["vars"];
+            } else {
+                if(isset($this->_config_data[$file_name]["sections"][$section_name]["vars"]))
+                    return (array)$this->_config_data[$file_name]["sections"][$section_name]["vars"];
+                else
+                    return array();
+            }
+        }
+    }
+
+
+    /**
+     * Retrieves config info based on the key.
+     *
+     * @param $file_name string config key (filename/section/var)
+     * @return string|array same as get()
+     * @uses get() retrieves information from config file and returns it
+     */
+    function &get_key($config_key)
+    {
+        list($file_name, $section_name, $var_name) = explode('/', $config_key, 3);
+        $result = &$this->get($file_name, $section_name, $var_name);
+        return $result;
+    }
+
+    /**
+     * Get all loaded config file names.
+     *
+     * @return array an array of loaded config file names
+     */
+    function get_file_names()
+    {
+        return array_keys($this->_config_data);
+    }
+
+
+    /**
+     * Get all section names from a loaded file.
+     *
+     * @param string $file_name config file to get section names from
+     * @return array an array of section names from the specified file
+     */
+    function get_section_names($file_name)
+    {
+        $file_name = $this->_config_path . $file_name;
+        if (!isset($this->_config_data[$file_name])) {
+            $this->_trigger_error_msg("Unknown config file '$file_name'");
+            return;
+        }
+
+        return array_keys($this->_config_data[$file_name]["sections"]);
+    }
+
+
+    /**
+     * Get all global or section variable names.
+     *
+     * @param string $file_name config file to get info for
+     * @param string $section_name (optional) section to get info for
+     * @return array an array of variables names from the specified file/section
+     */
+    function get_var_names($file_name, $section = NULL)
+    {
+        if (empty($file_name)) {
+            $this->_trigger_error_msg('Empty config file name');
+            return;
+        } else if (!isset($this->_config_data[$file_name])) {
+            $this->_trigger_error_msg("Unknown config file '$file_name'");
+            return;
+        }
+
+        if (empty($section))
+            return array_keys($this->_config_data[$file_name]["vars"]);
+        else
+            return array_keys($this->_config_data[$file_name]["sections"][$section]["vars"]);
+    }
+
+
+    /**
+     * Clear loaded config data for a certain file or all files.
+     *
+     * @param string $file_name file to clear config data for
+     */
+    function clear($file_name = NULL)
+    {
+        if ($file_name === NULL)
+            $this->_config_data = array();
+        else if (isset($this->_config_data[$file_name]))
+            $this->_config_data[$file_name] = array();
+    }
+
+
+    /**
+     * Load a configuration file manually.
+     *
+     * @param string $file_name file name to load
+     * @param boolean $prepend_path whether current config path should be
+     *                              prepended to the filename
+     */
+    function load_file($file_name, $prepend_path = true)
+    {
+        if ($prepend_path && $this->_config_path != "")
+            $config_file = $this->_config_path . $file_name;
+        else
+            $config_file = $file_name;
+
+        ini_set('track_errors', true);
+        $fp = @fopen($config_file, "r");
+        if (!is_resource($fp)) {
+            $this->_trigger_error_msg("Could not open config file '$config_file'");
+            return false;
+        }
+
+        $contents = ($size = filesize($config_file)) ? fread($fp, $size) : '';
+        fclose($fp);
+
+        $this->_config_data[$config_file] = $this->parse_contents($contents);
+        return true;
+    }
+
+    /**
+     * Store the contents of a file manually.
+     *
+     * @param string $config_file file name of the related contents
+     * @param string $contents the file-contents to parse
+     */
+    function set_file_contents($config_file, $contents)
+    {
+        $this->_config_data[$config_file] = $this->parse_contents($contents);
+        return true;
+    }
+
+    /**
+     * parse the source of a configuration file manually.
+     *
+     * @param string $contents the file-contents to parse
+     */
+    function parse_contents($contents)
+    {
+        if($this->fix_newlines) {
+            // fix mac/dos formatted newlines
+            $contents = preg_replace('!\r\n?!', "\n", $contents);
+        }
+
+        $config_data = array();
+        $config_data['sections'] = array();
+        $config_data['vars'] = array();
+
+        /* reference to fill with data */
+        $vars =& $config_data['vars'];
+
+        /* parse file line by line */
+        preg_match_all('!^.*\r?\n?!m', $contents, $match);
+        $lines = $match[0];
+        for ($i=0, $count=count($lines); $i<$count; $i++) {
+            $line = $lines[$i];
+            if (empty($line)) continue;
+
+            if ( substr($line, 0, 1) == '[' && preg_match('!^\[(.*?)\]!', $line, $match) ) {
+                /* section found */
+                if (substr($match[1], 0, 1) == '.') {
+                    /* hidden section */
+                    if ($this->read_hidden) {
+                        $section_name = substr($match[1], 1);
+                    } else {
+                        /* break reference to $vars to ignore hidden section */
+                        unset($vars);
+                        $vars = array();
+                        continue;
+                    }
+                } else {                    
+                    $section_name = $match[1];
+                }
+                if (!isset($config_data['sections'][$section_name]))
+                    $config_data['sections'][$section_name] = array('vars' => array());
+                $vars =& $config_data['sections'][$section_name]['vars'];
+                continue;
+            }
+
+            if (preg_match('/^\s*(\.?\w+)\s*=\s*(.*)/s', $line, $match)) {
+                /* variable found */
+                $var_name = rtrim($match[1]);
+                if (strpos($match[2], '"""') === 0) {
+                    /* handle multiline-value */
+                    $lines[$i] = substr($match[2], 3);
+                    $var_value = '';
+                    while ($i<$count) {
+                        if (($pos = strpos($lines[$i], '"""')) === false) {
+                            $var_value .= $lines[$i++];
+                        } else {
+                            /* end of multiline-value */
+                            $var_value .= substr($lines[$i], 0, $pos);
+                            break;
+                        }
+                    }
+                    $booleanize = false;
+
+                } else {
+                    /* handle simple value */
+                    $var_value = preg_replace('/^([\'"])(.*)\1$/', '\2', rtrim($match[2]));
+                    $booleanize = $this->booleanize;
+
+                }
+                $this->_set_config_var($vars, $var_name, $var_value, $booleanize);
+            }
+            /* else unparsable line / means it is a comment / means ignore it */
+        }
+        return $config_data;
+    }
+
+    /**#@+ @access private */
+    /**
+     * @param array &$container
+     * @param string $var_name
+     * @param mixed $var_value
+     * @param boolean $booleanize determines whether $var_value is converted to
+     *                            to true/false
+     */
+    function _set_config_var(&$container, $var_name, $var_value, $booleanize)
+    {
+        if (substr($var_name, 0, 1) == '.') {
+            if (!$this->read_hidden)
+                return;
+            else
+                $var_name = substr($var_name, 1);
+        }
+
+        if (!preg_match("/^[a-zA-Z_]\w*$/", $var_name)) {
+            $this->_trigger_error_msg("Bad variable name '$var_name'");
+            return;
+        }
+
+        if ($booleanize) {
+            if (preg_match("/^(on|true|yes)$/i", $var_value))
+                $var_value = true;
+            else if (preg_match("/^(off|false|no)$/i", $var_value))
+                $var_value = false;
+        }
+
+        if (!isset($container[$var_name]) || $this->overwrite)
+            $container[$var_name] = $var_value;
+        else {
+            settype($container[$var_name], 'array');
+            $container[$var_name][] = $var_value;
+        }
+    }
+
+    /**
+     * @uses trigger_error() creates a PHP warning/error
+     * @param string $error_msg
+     * @param integer $error_type one of
+     */
+    function _trigger_error_msg($error_msg, $error_type = E_USER_WARNING)
+    {
+        trigger_error("Config_File error: $error_msg", $error_type);
+    }
+    /**#@-*/
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/Smarty.class.php b/epgrec/Smarty.v2/Smarty.class.php
--- a/epgrec/Smarty.v2/Smarty.class.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/Smarty.class.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,1962 @@
+<?php
+
+/**
+ * Project:     Smarty: the PHP compiling template engine
+ * File:        Smarty.class.php
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * For questions, help, comments, discussion, etc., please join the
+ * Smarty mailing list. Send a blank e-mail to
+ * smarty-discussion-subscribe@googlegroups.com
+ *
+ * @link http://www.smarty.net/
+ * @copyright 2001-2005 New Digital Group, Inc.
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @author Andrei Zmievski <andrei@php.net>
+ * @package Smarty
+ * @version 2.6.29
+ */
+
+/* $Id$ */
+
+/**
+ * DIR_SEP isn't used anymore, but third party apps might
+ */
+if(!defined('DIR_SEP')) {
+    define('DIR_SEP', DIRECTORY_SEPARATOR);
+}
+
+/**
+ * set SMARTY_DIR to absolute path to Smarty library files.
+ * if not defined, include_path will be used. Sets SMARTY_DIR only if user
+ * application has not already defined it.
+ */
+
+if (!defined('SMARTY_DIR')) {
+    define('SMARTY_DIR', dirname(__FILE__) . DIRECTORY_SEPARATOR);
+}
+
+if (!defined('SMARTY_CORE_DIR')) {
+    define('SMARTY_CORE_DIR', SMARTY_DIR . 'internals' . DIRECTORY_SEPARATOR);
+}
+
+define('SMARTY_PHP_PASSTHRU',   0);
+define('SMARTY_PHP_QUOTE',      1);
+define('SMARTY_PHP_REMOVE',     2);
+define('SMARTY_PHP_ALLOW',      3);
+
+/**
+ * @package Smarty
+ */
+class Smarty
+{
+    /**#@+
+     * Smarty Configuration Section
+     */
+
+    /**
+     * The name of the directory where templates are located.
+     *
+     * @var string
+     */
+    var $template_dir    =  'templates';
+
+    /**
+     * The directory where compiled templates are located.
+     *
+     * @var string
+     */
+    var $compile_dir     =  'templates_c';
+
+    /**
+     * The directory where config files are located.
+     *
+     * @var string
+     */
+    var $config_dir      =  'configs';
+
+    /**
+     * An array of directories searched for plugins.
+     *
+     * @var array
+     */
+    var $plugins_dir     =  array('plugins');
+
+    /**
+     * If debugging is enabled, a debug console window will display
+     * when the page loads (make sure your browser allows unrequested
+     * popup windows)
+     *
+     * @var boolean
+     */
+    var $debugging       =  false;
+
+    /**
+     * When set, smarty does uses this value as error_reporting-level.
+     *
+     * @var integer
+     */
+    var $error_reporting  =  null;
+
+    /**
+     * This is the path to the debug console template. If not set,
+     * the default one will be used.
+     *
+     * @var string
+     */
+    var $debug_tpl       =  '';
+
+    /**
+     * This determines if debugging is enable-able from the browser.
+     * <ul>
+     *  <li>NONE => no debugging control allowed</li>
+     *  <li>URL => enable debugging when SMARTY_DEBUG is found in the URL.</li>
+     * </ul>
+     * @link http://www.foo.dom/index.php?SMARTY_DEBUG
+     * @var string
+     */
+    var $debugging_ctrl  =  'NONE';
+
+    /**
+     * This tells Smarty whether to check for recompiling or not. Recompiling
+     * does not need to happen unless a template or config file is changed.
+     * Typically you enable this during development, and disable for
+     * production.
+     *
+     * @var boolean
+     */
+    var $compile_check   =  true;
+
+    /**
+     * This forces templates to compile every time. Useful for development
+     * or debugging.
+     *
+     * @var boolean
+     */
+    var $force_compile   =  false;
+
+    /**
+     * This enables template caching.
+     * <ul>
+     *  <li>0 = no caching</li>
+     *  <li>1 = use class cache_lifetime value</li>
+     *  <li>2 = use cache_lifetime in cache file</li>
+     * </ul>
+     * @var integer
+     */
+    var $caching         =  0;
+
+    /**
+     * The name of the directory for cache files.
+     *
+     * @var string
+     */
+    var $cache_dir       =  'cache';
+
+    /**
+     * This is the number of seconds cached content will persist.
+     * <ul>
+     *  <li>0 = always regenerate cache</li>
+     *  <li>-1 = never expires</li>
+     * </ul>
+     *
+     * @var integer
+     */
+    var $cache_lifetime  =  3600;
+
+    /**
+     * Only used when $caching is enabled. If true, then If-Modified-Since headers
+     * are respected with cached content, and appropriate HTTP headers are sent.
+     * This way repeated hits to a cached page do not send the entire page to the
+     * client every time.
+     *
+     * @var boolean
+     */
+    var $cache_modified_check = false;
+
+    /**
+     * This determines how Smarty handles "<?php ... ?>" tags in templates.
+     * possible values:
+     * <ul>
+     *  <li>SMARTY_PHP_PASSTHRU -> print tags as plain text</li>
+     *  <li>SMARTY_PHP_QUOTE    -> escape tags as entities</li>
+     *  <li>SMARTY_PHP_REMOVE   -> remove php tags</li>
+     *  <li>SMARTY_PHP_ALLOW    -> execute php tags</li>
+     * </ul>
+     *
+     * @var integer
+     */
+    var $php_handling    =  SMARTY_PHP_PASSTHRU;
+
+    /**
+     * This enables template security. When enabled, many things are restricted
+     * in the templates that normally would go unchecked. This is useful when
+     * untrusted parties are editing templates and you want a reasonable level
+     * of security. (no direct execution of PHP in templates for example)
+     *
+     * @var boolean
+     */
+    var $security       =   false;
+
+    /**
+     * This is the list of template directories that are considered secure. This
+     * is used only if {@link $security} is enabled. One directory per array
+     * element.  {@link $template_dir} is in this list implicitly.
+     *
+     * @var array
+     */
+    var $secure_dir     =   array();
+
+    /**
+     * These are the security settings for Smarty. They are used only when
+     * {@link $security} is enabled.
+     *
+     * @var array
+     */
+    var $security_settings  = array(
+                                    'PHP_HANDLING'    => false,
+                                    'IF_FUNCS'        => array('array', 'list',
+                                                               'isset', 'empty',
+                                                               'count', 'sizeof',
+                                                               'in_array', 'is_array',
+                                                               'true', 'false', 'null'),
+                                    'INCLUDE_ANY'     => false,
+                                    'PHP_TAGS'        => false,
+                                    'MODIFIER_FUNCS'  => array('count'),
+                                    'ALLOW_CONSTANTS'  => false,
+                                    'ALLOW_SUPER_GLOBALS' => true
+                                   );
+
+    /**
+     * This is an array of directories where trusted php scripts reside.
+     * {@link $security} is disabled during their inclusion/execution.
+     *
+     * @var array
+     */
+    var $trusted_dir        = array();
+
+    /**
+     * The left delimiter used for the template tags.
+     *
+     * @var string
+     */
+    var $left_delimiter  =  '{';
+
+    /**
+     * The right delimiter used for the template tags.
+     *
+     * @var string
+     */
+    var $right_delimiter =  '}';
+
+    /**
+     * The order in which request variables are registered, similar to
+     * variables_order in php.ini E = Environment, G = GET, P = POST,
+     * C = Cookies, S = Server
+     *
+     * @var string
+     */
+    var $request_vars_order    = 'EGPCS';
+
+    /**
+     * Indicates wether $HTTP_*_VARS[] (request_use_auto_globals=false)
+     * are uses as request-vars or $_*[]-vars. note: if
+     * request_use_auto_globals is true, then $request_vars_order has
+     * no effect, but the php-ini-value "gpc_order"
+     *
+     * @var boolean
+     */
+    var $request_use_auto_globals      = true;
+
+    /**
+     * Set this if you want different sets of compiled files for the same
+     * templates. This is useful for things like different languages.
+     * Instead of creating separate sets of templates per language, you
+     * set different compile_ids like 'en' and 'de'.
+     *
+     * @var string
+     */
+    var $compile_id            = null;
+
+    /**
+     * This tells Smarty whether or not to use sub dirs in the cache/ and
+     * templates_c/ directories. sub directories better organized, but
+     * may not work well with PHP safe mode enabled.
+     *
+     * @var boolean
+     *
+     */
+    var $use_sub_dirs          = false;
+
+    /**
+     * This is a list of the modifiers to apply to all template variables.
+     * Put each modifier in a separate array element in the order you want
+     * them applied. example: <code>array('escape:"htmlall"');</code>
+     *
+     * @var array
+     */
+    var $default_modifiers        = array();
+
+    /**
+     * This is the resource type to be used when not specified
+     * at the beginning of the resource path. examples:
+     * $smarty->display('file:index.tpl');
+     * $smarty->display('db:index.tpl');
+     * $smarty->display('index.tpl'); // will use default resource type
+     * {include file="file:index.tpl"}
+     * {include file="db:index.tpl"}
+     * {include file="index.tpl"} {* will use default resource type *}
+     *
+     * @var array
+     */
+    var $default_resource_type    = 'file';
+
+    /**
+     * The function used for cache file handling. If not set, built-in caching is used.
+     *
+     * @var null|string function name
+     */
+    var $cache_handler_func   = null;
+
+    /**
+     * This indicates which filters are automatically loaded into Smarty.
+     *
+     * @var array array of filter names
+     */
+    var $autoload_filters = array();
+
+    /**#@+
+     * @var boolean
+     */
+    /**
+     * This tells if config file vars of the same name overwrite each other or not.
+     * if disabled, same name variables are accumulated in an array.
+     */
+    var $config_overwrite = true;
+
+    /**
+     * This tells whether or not to automatically booleanize config file variables.
+     * If enabled, then the strings "on", "true", and "yes" are treated as boolean
+     * true, and "off", "false" and "no" are treated as boolean false.
+     */
+    var $config_booleanize = true;
+
+    /**
+     * This tells whether hidden sections [.foobar] are readable from the
+     * tempalates or not. Normally you would never allow this since that is
+     * the point behind hidden sections: the application can access them, but
+     * the templates cannot.
+     */
+    var $config_read_hidden = false;
+
+    /**
+     * This tells whether or not automatically fix newlines in config files.
+     * It basically converts \r (mac) or \r\n (dos) to \n
+     */
+    var $config_fix_newlines = true;
+    /**#@-*/
+
+    /**
+     * If a template cannot be found, this PHP function will be executed.
+     * Useful for creating templates on-the-fly or other special action.
+     *
+     * @var string function name
+     */
+    var $default_template_handler_func = '';
+
+    /**
+     * The file that contains the compiler class. This can a full
+     * pathname, or relative to the php_include path.
+     *
+     * @var string
+     */
+    var $compiler_file        =    'Smarty_Compiler.class.php';
+
+    /**
+     * The class used for compiling templates.
+     *
+     * @var string
+     */
+    var $compiler_class        =   'Smarty_Compiler';
+
+    /**
+     * The class used to load config vars.
+     *
+     * @var string
+     */
+    var $config_class          =   'Config_File';
+
+/**#@+
+ * END Smarty Configuration Section
+ * There should be no need to touch anything below this line.
+ * @access private
+ */
+    /**
+     * where assigned template vars are kept
+     *
+     * @var array
+     */
+    var $_tpl_vars             = array();
+
+    /**
+     * stores run-time $smarty.* vars
+     *
+     * @var null|array
+     */
+    var $_smarty_vars          = null;
+
+    /**
+     * keeps track of sections
+     *
+     * @var array
+     */
+    var $_sections             = array();
+
+    /**
+     * keeps track of foreach blocks
+     *
+     * @var array
+     */
+    var $_foreach              = array();
+
+    /**
+     * keeps track of tag hierarchy
+     *
+     * @var array
+     */
+    var $_tag_stack            = array();
+
+    /**
+     * configuration object
+     *
+     * @var Config_file
+     */
+    var $_conf_obj             = null;
+
+    /**
+     * loaded configuration settings
+     *
+     * @var array
+     */
+    var $_config               = array(array('vars'  => array(), 'files' => array()));
+
+    /**
+     * md5 checksum of the string 'Smarty'
+     *
+     * @var string
+     */
+    var $_smarty_md5           = 'f8d698aea36fcbead2b9d5359ffca76f';
+
+    /**
+     * Smarty version number
+     *
+     * @var string
+     */
+    var $_version              = '2.6.29';
+
+    /**
+     * current template inclusion depth
+     *
+     * @var integer
+     */
+    var $_inclusion_depth      = 0;
+
+    /**
+     * for different compiled templates
+     *
+     * @var string
+     */
+    var $_compile_id           = null;
+
+    /**
+     * text in URL to enable debug mode
+     *
+     * @var string
+     */
+    var $_smarty_debug_id      = 'SMARTY_DEBUG';
+
+    /**
+     * debugging information for debug console
+     *
+     * @var array
+     */
+    var $_smarty_debug_info    = array();
+
+    /**
+     * info that makes up a cache file
+     *
+     * @var array
+     */
+    var $_cache_info           = array();
+
+    /**
+     * default file permissions
+     *
+     * @var integer
+     */
+    var $_file_perms           = 0644;
+
+    /**
+     * default dir permissions
+     *
+     * @var integer
+     */
+    var $_dir_perms               = 0771;
+
+    /**
+     * registered objects
+     *
+     * @var array
+     */
+    var $_reg_objects           = array();
+
+    /**
+     * table keeping track of plugins
+     *
+     * @var array
+     */
+    var $_plugins              = array(
+                                       'modifier'      => array(),
+                                       'function'      => array(),
+                                       'block'         => array(),
+                                       'compiler'      => array(),
+                                       'prefilter'     => array(),
+                                       'postfilter'    => array(),
+                                       'outputfilter'  => array(),
+                                       'resource'      => array(),
+                                       'insert'        => array());
+
+
+    /**
+     * cache serials
+     *
+     * @var array
+     */
+    var $_cache_serials = array();
+
+    /**
+     * name of optional cache include file
+     *
+     * @var string
+     */
+    var $_cache_include = null;
+
+    /**
+     * indicate if the current code is used in a compiled
+     * include
+     *
+     * @var string
+     */
+    var $_cache_including = false;
+
+    /**#@-*/
+    /**
+     * The class constructor.
+     */
+    public function __construct()
+    {
+      $this->assign('SCRIPT_NAME', isset($_SERVER['SCRIPT_NAME']) ? $_SERVER['SCRIPT_NAME']
+                    : @$GLOBALS['HTTP_SERVER_VARS']['SCRIPT_NAME']);
+    }
+
+    /**
+     * assigns values to template variables
+     *
+     * @param array|string $tpl_var the template variable name(s)
+     * @param mixed $value the value to assign
+     */
+    function assign($tpl_var, $value = null)
+    {
+        if (is_array($tpl_var)){
+            foreach ($tpl_var as $key => $val) {
+                if ($key != '') {
+                    $this->_tpl_vars[$key] = $val;
+                }
+            }
+        } else {
+            if ($tpl_var != '')
+                $this->_tpl_vars[$tpl_var] = $value;
+        }
+    }
+
+    /**
+     * assigns values to template variables by reference
+     *
+     * @param string $tpl_var the template variable name
+     * @param mixed $value the referenced value to assign
+     */
+    function assign_by_ref($tpl_var, &$value)
+    {
+        if ($tpl_var != '')
+            $this->_tpl_vars[$tpl_var] = &$value;
+    }
+
+    /**
+     * appends values to template variables
+     *
+     * @param array|string $tpl_var the template variable name(s)
+     * @param mixed $value the value to append
+     */
+    function append($tpl_var, $value=null, $merge=false)
+    {
+        if (is_array($tpl_var)) {
+            // $tpl_var is an array, ignore $value
+            foreach ($tpl_var as $_key => $_val) {
+                if ($_key != '') {
+                    if(!@is_array($this->_tpl_vars[$_key])) {
+                        settype($this->_tpl_vars[$_key],'array');
+                    }
+                    if($merge && is_array($_val)) {
+                        foreach($_val as $_mkey => $_mval) {
+                            $this->_tpl_vars[$_key][$_mkey] = $_mval;
+                        }
+                    } else {
+                        $this->_tpl_vars[$_key][] = $_val;
+                    }
+                }
+            }
+        } else {
+            if ($tpl_var != '' && isset($value)) {
+                if(!@is_array($this->_tpl_vars[$tpl_var])) {
+                    settype($this->_tpl_vars[$tpl_var],'array');
+                }
+                if($merge && is_array($value)) {
+                    foreach($value as $_mkey => $_mval) {
+                        $this->_tpl_vars[$tpl_var][$_mkey] = $_mval;
+                    }
+                } else {
+                    $this->_tpl_vars[$tpl_var][] = $value;
+                }
+            }
+        }
+    }
+
+    /**
+     * appends values to template variables by reference
+     *
+     * @param string $tpl_var the template variable name
+     * @param mixed $value the referenced value to append
+     */
+    function append_by_ref($tpl_var, &$value, $merge=false)
+    {
+        if ($tpl_var != '' && isset($value)) {
+            if(!@is_array($this->_tpl_vars[$tpl_var])) {
+             settype($this->_tpl_vars[$tpl_var],'array');
+            }
+            if ($merge && is_array($value)) {
+                foreach($value as $_key => $_val) {
+                    $this->_tpl_vars[$tpl_var][$_key] = &$value[$_key];
+                }
+            } else {
+                $this->_tpl_vars[$tpl_var][] = &$value;
+            }
+        }
+    }
+
+
+    /**
+     * clear the given assigned template variable.
+     *
+     * @param string $tpl_var the template variable to clear
+     */
+    function clear_assign($tpl_var)
+    {
+        if (is_array($tpl_var))
+            foreach ($tpl_var as $curr_var)
+                unset($this->_tpl_vars[$curr_var]);
+        else
+            unset($this->_tpl_vars[$tpl_var]);
+    }
+
+
+    /**
+     * Registers custom function to be used in templates
+     *
+     * @param string $function the name of the template function
+     * @param string $function_impl the name of the PHP function to register
+     */
+    function register_function($function, $function_impl, $cacheable=true, $cache_attrs=null)
+    {
+        $this->_plugins['function'][$function] =
+            array($function_impl, null, null, false, $cacheable, $cache_attrs);
+
+    }
+
+    /**
+     * Unregisters custom function
+     *
+     * @param string $function name of template function
+     */
+    function unregister_function($function)
+    {
+        unset($this->_plugins['function'][$function]);
+    }
+
+    /**
+     * Registers object to be used in templates
+     *
+     * @param string $object name of template object
+     * @param object &$object_impl the referenced PHP object to register
+     * @param null|array $allowed list of allowed methods (empty = all)
+     * @param boolean $smarty_args smarty argument format, else traditional
+     * @param null|array $block_functs list of methods that are block format
+     */
+    function register_object($object, &$object_impl, $allowed = array(), $smarty_args = true, $block_methods = array())
+    {
+        settype($allowed, 'array');
+        settype($smarty_args, 'boolean');
+        $this->_reg_objects[$object] =
+            array(&$object_impl, $allowed, $smarty_args, $block_methods);
+    }
+
+    /**
+     * Unregisters object
+     *
+     * @param string $object name of template object
+     */
+    function unregister_object($object)
+    {
+        unset($this->_reg_objects[$object]);
+    }
+
+
+    /**
+     * Registers block function to be used in templates
+     *
+     * @param string $block name of template block
+     * @param string $block_impl PHP function to register
+     */
+    function register_block($block, $block_impl, $cacheable=true, $cache_attrs=null)
+    {
+        $this->_plugins['block'][$block] =
+            array($block_impl, null, null, false, $cacheable, $cache_attrs);
+    }
+
+    /**
+     * Unregisters block function
+     *
+     * @param string $block name of template function
+     */
+    function unregister_block($block)
+    {
+        unset($this->_plugins['block'][$block]);
+    }
+
+    /**
+     * Registers compiler function
+     *
+     * @param string $function name of template function
+     * @param string $function_impl name of PHP function to register
+     */
+    function register_compiler_function($function, $function_impl, $cacheable=true)
+    {
+        $this->_plugins['compiler'][$function] =
+            array($function_impl, null, null, false, $cacheable);
+    }
+
+    /**
+     * Unregisters compiler function
+     *
+     * @param string $function name of template function
+     */
+    function unregister_compiler_function($function)
+    {
+        unset($this->_plugins['compiler'][$function]);
+    }
+
+    /**
+     * Registers modifier to be used in templates
+     *
+     * @param string $modifier name of template modifier
+     * @param string $modifier_impl name of PHP function to register
+     */
+    function register_modifier($modifier, $modifier_impl)
+    {
+        $this->_plugins['modifier'][$modifier] =
+            array($modifier_impl, null, null, false);
+    }
+
+    /**
+     * Unregisters modifier
+     *
+     * @param string $modifier name of template modifier
+     */
+    function unregister_modifier($modifier)
+    {
+        unset($this->_plugins['modifier'][$modifier]);
+    }
+
+    /**
+     * Registers a resource to fetch a template
+     *
+     * @param string $type name of resource
+     * @param array $functions array of functions to handle resource
+     */
+    function register_resource($type, $functions)
+    {
+        if (count($functions)==4) {
+            $this->_plugins['resource'][$type] =
+                array($functions, false);
+
+        } elseif (count($functions)==5) {
+            $this->_plugins['resource'][$type] =
+                array(array(array(&$functions[0], $functions[1])
+                            ,array(&$functions[0], $functions[2])
+                            ,array(&$functions[0], $functions[3])
+                            ,array(&$functions[0], $functions[4]))
+                      ,false);
+
+        } else {
+            $this->trigger_error("malformed function-list for '$type' in register_resource");
+
+        }
+    }
+
+    /**
+     * Unregisters a resource
+     *
+     * @param string $type name of resource
+     */
+    function unregister_resource($type)
+    {
+        unset($this->_plugins['resource'][$type]);
+    }
+
+    /**
+     * Registers a prefilter function to apply
+     * to a template before compiling
+     *
+     * @param callback $function
+     */
+    function register_prefilter($function)
+    {
+        $this->_plugins['prefilter'][$this->_get_filter_name($function)]
+            = array($function, null, null, false);
+    }
+
+    /**
+     * Unregisters a prefilter function
+     *
+     * @param callback $function
+     */
+    function unregister_prefilter($function)
+    {
+        unset($this->_plugins['prefilter'][$this->_get_filter_name($function)]);
+    }
+
+    /**
+     * Registers a postfilter function to apply
+     * to a compiled template after compilation
+     *
+     * @param callback $function
+     */
+    function register_postfilter($function)
+    {
+        $this->_plugins['postfilter'][$this->_get_filter_name($function)]
+            = array($function, null, null, false);
+    }
+
+    /**
+     * Unregisters a postfilter function
+     *
+     * @param callback $function
+     */
+    function unregister_postfilter($function)
+    {
+        unset($this->_plugins['postfilter'][$this->_get_filter_name($function)]);
+    }
+
+    /**
+     * Registers an output filter function to apply
+     * to a template output
+     *
+     * @param callback $function
+     */
+    function register_outputfilter($function)
+    {
+        $this->_plugins['outputfilter'][$this->_get_filter_name($function)]
+            = array($function, null, null, false);
+    }
+
+    /**
+     * Unregisters an outputfilter function
+     *
+     * @param callback $function
+     */
+    function unregister_outputfilter($function)
+    {
+        unset($this->_plugins['outputfilter'][$this->_get_filter_name($function)]);
+    }
+
+    /**
+     * load a filter of specified type and name
+     *
+     * @param string $type filter type
+     * @param string $name filter name
+     */
+    function load_filter($type, $name)
+    {
+        switch ($type) {
+            case 'output':
+                $_params = array('plugins' => array(array($type . 'filter', $name, null, null, false)));
+                require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
+                smarty_core_load_plugins($_params, $this);
+                break;
+
+            case 'pre':
+            case 'post':
+                if (!isset($this->_plugins[$type . 'filter'][$name]))
+                    $this->_plugins[$type . 'filter'][$name] = false;
+                break;
+        }
+    }
+
+    /**
+     * clear cached content for the given template and cache id
+     *
+     * @param string $tpl_file name of template file
+     * @param string $cache_id name of cache_id
+     * @param string $compile_id name of compile_id
+     * @param string $exp_time expiration time
+     * @return boolean
+     */
+    function clear_cache($tpl_file = null, $cache_id = null, $compile_id = null, $exp_time = null)
+    {
+
+        if (!isset($compile_id))
+            $compile_id = $this->compile_id;
+
+        if (!isset($tpl_file))
+            $compile_id = null;
+
+        $_auto_id = $this->_get_auto_id($cache_id, $compile_id);
+
+        if (!empty($this->cache_handler_func)) {
+            return call_user_func_array($this->cache_handler_func,
+                                  array('clear', &$this, &$dummy, $tpl_file, $cache_id, $compile_id, $exp_time));
+        } else {
+            $_params = array('auto_base' => $this->cache_dir,
+                            'auto_source' => $tpl_file,
+                            'auto_id' => $_auto_id,
+                            'exp_time' => $exp_time);
+            require_once(SMARTY_CORE_DIR . 'core.rm_auto.php');
+            return smarty_core_rm_auto($_params, $this);
+        }
+
+    }
+
+
+    /**
+     * clear the entire contents of cache (all templates)
+     *
+     * @param string $exp_time expire time
+     * @return boolean results of {@link smarty_core_rm_auto()}
+     */
+    function clear_all_cache($exp_time = null)
+    {
+        return $this->clear_cache(null, null, null, $exp_time);
+    }
+
+
+    /**
+     * test to see if valid cache exists for this template
+     *
+     * @param string $tpl_file name of template file
+     * @param string $cache_id
+     * @param string $compile_id
+     * @return string|false results of {@link _read_cache_file()}
+     */
+    function is_cached($tpl_file, $cache_id = null, $compile_id = null)
+    {
+        if (!$this->caching)
+            return false;
+
+        if (!isset($compile_id))
+            $compile_id = $this->compile_id;
+
+        $_params = array(
+            'tpl_file' => $tpl_file,
+            'cache_id' => $cache_id,
+            'compile_id' => $compile_id
+        );
+        require_once(SMARTY_CORE_DIR . 'core.read_cache_file.php');
+        return smarty_core_read_cache_file($_params, $this);
+    }
+
+
+    /**
+     * clear all the assigned template variables.
+     *
+     */
+    function clear_all_assign()
+    {
+        $this->_tpl_vars = array();
+    }
+
+    /**
+     * clears compiled version of specified template resource,
+     * or all compiled template files if one is not specified.
+     * This function is for advanced use only, not normally needed.
+     *
+     * @param string $tpl_file
+     * @param string $compile_id
+     * @param string $exp_time
+     * @return boolean results of {@link smarty_core_rm_auto()}
+     */
+    function clear_compiled_tpl($tpl_file = null, $compile_id = null, $exp_time = null)
+    {
+        if (!isset($compile_id)) {
+            $compile_id = $this->compile_id;
+        }
+        $_params = array('auto_base' => $this->compile_dir,
+                        'auto_source' => $tpl_file,
+                        'auto_id' => $compile_id,
+                        'exp_time' => $exp_time,
+                        'extensions' => array('.inc', '.php'));
+        require_once(SMARTY_CORE_DIR . 'core.rm_auto.php');
+        return smarty_core_rm_auto($_params, $this);
+    }
+
+    /**
+     * Checks whether requested template exists.
+     *
+     * @param string $tpl_file
+     * @return boolean
+     */
+    function template_exists($tpl_file)
+    {
+        $_params = array('resource_name' => $tpl_file, 'quiet'=>true, 'get_source'=>false);
+        return $this->_fetch_resource_info($_params);
+    }
+
+    /**
+     * Returns an array containing template variables
+     *
+     * @param string $name
+     * @param string $type
+     * @return array
+     */
+    function &get_template_vars($name=null)
+    {
+        if(!isset($name)) {
+            return $this->_tpl_vars;
+        } elseif(isset($this->_tpl_vars[$name])) {
+            return $this->_tpl_vars[$name];
+        } else {
+            // var non-existant, return valid reference
+            $_tmp = null;
+            return $_tmp;
+        }
+    }
+
+    /**
+     * Returns an array containing config variables
+     *
+     * @param string $name
+     * @param string $type
+     * @return array
+     */
+    function &get_config_vars($name=null)
+    {
+        if(!isset($name) && is_array($this->_config[0])) {
+            return $this->_config[0]['vars'];
+        } else if(isset($this->_config[0]['vars'][$name])) {
+            return $this->_config[0]['vars'][$name];
+        } else {
+            // var non-existant, return valid reference
+            $_tmp = null;
+            return $_tmp;
+        }
+    }
+
+    /**
+     * trigger Smarty error
+     *
+     * @param string $error_msg
+     * @param integer $error_type
+     */
+    function trigger_error($error_msg, $error_type = E_USER_WARNING)
+    {
+        $msg = htmlentities($error_msg);
+        trigger_error("Smarty error: $msg", $error_type);
+    }
+
+
+    /**
+     * executes & displays the template results
+     *
+     * @param string $resource_name
+     * @param string $cache_id
+     * @param string $compile_id
+     */
+    function display($resource_name, $cache_id = null, $compile_id = null)
+    {
+        $this->fetch($resource_name, $cache_id, $compile_id, true);
+    }
+
+    /**
+     * executes & returns or displays the template results
+     *
+     * @param string $resource_name
+     * @param string $cache_id
+     * @param string $compile_id
+     * @param boolean $display
+     */
+    function fetch($resource_name, $cache_id = null, $compile_id = null, $display = false)
+    {
+        static $_cache_info = array();
+
+        $_smarty_old_error_level = $this->debugging ? error_reporting() : error_reporting(isset($this->error_reporting)
+               ? $this->error_reporting : error_reporting() & ~E_NOTICE);
+
+        if (!$this->debugging && $this->debugging_ctrl == 'URL') {
+            $_query_string = $this->request_use_auto_globals ? $_SERVER['QUERY_STRING'] : $GLOBALS['HTTP_SERVER_VARS']['QUERY_STRING'];
+            if (@strstr($_query_string, $this->_smarty_debug_id)) {
+                if (@strstr($_query_string, $this->_smarty_debug_id . '=on')) {
+                    // enable debugging for this browser session
+                    @setcookie('SMARTY_DEBUG', true);
+                    $this->debugging = true;
+                } elseif (@strstr($_query_string, $this->_smarty_debug_id . '=off')) {
+                    // disable debugging for this browser session
+                    @setcookie('SMARTY_DEBUG', false);
+                    $this->debugging = false;
+                } else {
+                    // enable debugging for this page
+                    $this->debugging = true;
+                }
+            } else {
+                $this->debugging = (bool)($this->request_use_auto_globals ? @$_COOKIE['SMARTY_DEBUG'] : @$GLOBALS['HTTP_COOKIE_VARS']['SMARTY_DEBUG']);
+            }
+        }
+
+        if ($this->debugging) {
+            // capture time for debugging info
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $_debug_start_time = smarty_core_get_microtime($_params, $this);
+            $this->_smarty_debug_info[] = array('type'      => 'template',
+                                                'filename'  => $resource_name,
+                                                'depth'     => 0);
+            $_included_tpls_idx = count($this->_smarty_debug_info) - 1;
+        }
+
+        if (!isset($compile_id)) {
+            $compile_id = $this->compile_id;
+        }
+
+        $this->_compile_id = $compile_id;
+        $this->_inclusion_depth = 0;
+
+        if ($this->caching) {
+            // save old cache_info, initialize cache_info
+            array_push($_cache_info, $this->_cache_info);
+            $this->_cache_info = array();
+            $_params = array(
+                'tpl_file' => $resource_name,
+                'cache_id' => $cache_id,
+                'compile_id' => $compile_id,
+                'results' => null
+            );
+            require_once(SMARTY_CORE_DIR . 'core.read_cache_file.php');
+            if (smarty_core_read_cache_file($_params, $this)) {
+                $_smarty_results = $_params['results'];
+                if (!empty($this->_cache_info['insert_tags'])) {
+                    $_params = array('plugins' => $this->_cache_info['insert_tags']);
+                    require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
+                    smarty_core_load_plugins($_params, $this);
+                    $_params = array('results' => $_smarty_results);
+                    require_once(SMARTY_CORE_DIR . 'core.process_cached_inserts.php');
+                    $_smarty_results = smarty_core_process_cached_inserts($_params, $this);
+                }
+                if (!empty($this->_cache_info['cache_serials'])) {
+                    $_params = array('results' => $_smarty_results);
+                    require_once(SMARTY_CORE_DIR . 'core.process_compiled_include.php');
+                    $_smarty_results = smarty_core_process_compiled_include($_params, $this);
+                }
+
+
+                if ($display) {
+                    if ($this->debugging)
+                    {
+                        // capture time for debugging info
+                        $_params = array();
+                        require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+                        $this->_smarty_debug_info[$_included_tpls_idx]['exec_time'] = smarty_core_get_microtime($_params, $this) - $_debug_start_time;
+                        require_once(SMARTY_CORE_DIR . 'core.display_debug_console.php');
+                        $_smarty_results .= smarty_core_display_debug_console($_params, $this);
+                    }
+                    if ($this->cache_modified_check) {
+                        $_server_vars = ($this->request_use_auto_globals) ? $_SERVER : $GLOBALS['HTTP_SERVER_VARS'];
+                        $_last_modified_date = @substr($_server_vars['HTTP_IF_MODIFIED_SINCE'], 0, strpos($_server_vars['HTTP_IF_MODIFIED_SINCE'], 'GMT') + 3);
+                        $_gmt_mtime = gmdate('D, d M Y H:i:s', $this->_cache_info['timestamp']).' GMT';
+                        if (@count($this->_cache_info['insert_tags']) == 0
+                            && !$this->_cache_serials
+                            && $_gmt_mtime == $_last_modified_date) {
+                            if (php_sapi_name()=='cgi')
+                                header('Status: 304 Not Modified');
+                            else
+                                header('HTTP/1.1 304 Not Modified');
+
+                        } else {
+                            header('Last-Modified: '.$_gmt_mtime);
+                            echo $_smarty_results;
+                        }
+                    } else {
+                            echo $_smarty_results;
+                    }
+                    error_reporting($_smarty_old_error_level);
+                    // restore initial cache_info
+                    $this->_cache_info = array_pop($_cache_info);
+                    return true;
+                } else {
+                    error_reporting($_smarty_old_error_level);
+                    // restore initial cache_info
+                    $this->_cache_info = array_pop($_cache_info);
+                    return $_smarty_results;
+                }
+            } else {
+                $this->_cache_info['template'][$resource_name] = true;
+                if ($this->cache_modified_check && $display) {
+                    header('Last-Modified: '.gmdate('D, d M Y H:i:s', time()).' GMT');
+                }
+            }
+        }
+
+        // load filters that are marked as autoload
+        if (count($this->autoload_filters)) {
+            foreach ($this->autoload_filters as $_filter_type => $_filters) {
+                foreach ($_filters as $_filter) {
+                    $this->load_filter($_filter_type, $_filter);
+                }
+            }
+        }
+
+        $_smarty_compile_path = $this->_get_compile_path($resource_name);
+
+        // if we just need to display the results, don't perform output
+        // buffering - for speed
+        $_cache_including = $this->_cache_including;
+        $this->_cache_including = false;
+        if ($display && !$this->caching && count($this->_plugins['outputfilter']) == 0) {
+            if ($this->_is_compiled($resource_name, $_smarty_compile_path)
+                    || $this->_compile_resource($resource_name, $_smarty_compile_path))
+            {
+                include($_smarty_compile_path);
+            }
+        } else {
+            ob_start();
+            if ($this->_is_compiled($resource_name, $_smarty_compile_path)
+                    || $this->_compile_resource($resource_name, $_smarty_compile_path))
+            {
+                include($_smarty_compile_path);
+            }
+            $_smarty_results = ob_get_contents();
+            ob_end_clean();
+
+            foreach ((array)$this->_plugins['outputfilter'] as $_output_filter) {
+                $_smarty_results = call_user_func_array($_output_filter[0], array($_smarty_results, &$this));
+            }
+        }
+
+        if ($this->caching) {
+            $_params = array('tpl_file' => $resource_name,
+                        'cache_id' => $cache_id,
+                        'compile_id' => $compile_id,
+                        'results' => $_smarty_results);
+            require_once(SMARTY_CORE_DIR . 'core.write_cache_file.php');
+            smarty_core_write_cache_file($_params, $this);
+            require_once(SMARTY_CORE_DIR . 'core.process_cached_inserts.php');
+            $_smarty_results = smarty_core_process_cached_inserts($_params, $this);
+
+            if ($this->_cache_serials) {
+                // strip nocache-tags from output
+                $_smarty_results = preg_replace('!(\{/?nocache\:[0-9a-f]{32}#\d+\})!s'
+                                                ,''
+                                                ,$_smarty_results);
+            }
+            // restore initial cache_info
+            $this->_cache_info = array_pop($_cache_info);
+        }
+        $this->_cache_including = $_cache_including;
+
+        if ($display) {
+            if (isset($_smarty_results)) { echo $_smarty_results; }
+            if ($this->debugging) {
+                // capture time for debugging info
+                $_params = array();
+                require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+                $this->_smarty_debug_info[$_included_tpls_idx]['exec_time'] = (smarty_core_get_microtime($_params, $this) - $_debug_start_time);
+                require_once(SMARTY_CORE_DIR . 'core.display_debug_console.php');
+                echo smarty_core_display_debug_console($_params, $this);
+            }
+            error_reporting($_smarty_old_error_level);
+            return;
+        } else {
+            error_reporting($_smarty_old_error_level);
+            if (isset($_smarty_results)) { return $_smarty_results; }
+        }
+    }
+
+    /**
+     * load configuration values
+     *
+     * @param string $file
+     * @param string $section
+     * @param string $scope
+     */
+    function config_load($file, $section = null, $scope = 'global')
+    {
+        require_once($this->_get_plugin_filepath('function', 'config_load'));
+        smarty_function_config_load(array('file' => $file, 'section' => $section, 'scope' => $scope), $this);
+    }
+
+    /**
+     * return a reference to a registered object
+     *
+     * @param string $name
+     * @return object
+     */
+    function &get_registered_object($name) {
+        if (!isset($this->_reg_objects[$name]))
+        $this->_trigger_fatal_error("'$name' is not a registered object");
+
+        if (!is_object($this->_reg_objects[$name][0]))
+        $this->_trigger_fatal_error("registered '$name' is not an object");
+
+        return $this->_reg_objects[$name][0];
+    }
+
+    /**
+     * clear configuration values
+     *
+     * @param string $var
+     */
+    function clear_config($var = null)
+    {
+        if(!isset($var)) {
+            // clear all values
+            $this->_config = array(array('vars'  => array(),
+                                         'files' => array()));
+        } else {
+            unset($this->_config[0]['vars'][$var]);
+        }
+    }
+
+    /**
+     * get filepath of requested plugin
+     *
+     * @param string $type
+     * @param string $name
+     * @return string|false
+     */
+    function _get_plugin_filepath($type, $name)
+    {
+        $_params = array('type' => $type, 'name' => $name);
+        require_once(SMARTY_CORE_DIR . 'core.assemble_plugin_filepath.php');
+        return smarty_core_assemble_plugin_filepath($_params, $this);
+    }
+
+   /**
+     * test if resource needs compiling
+     *
+     * @param string $resource_name
+     * @param string $compile_path
+     * @return boolean
+     */
+    function _is_compiled($resource_name, $compile_path)
+    {
+        if (!$this->force_compile && file_exists($compile_path)) {
+            if (!$this->compile_check) {
+                // no need to check compiled file
+                return true;
+            } else {
+                // get file source and timestamp
+                $_params = array('resource_name' => $resource_name, 'get_source'=>false);
+                if (!$this->_fetch_resource_info($_params)) {
+                    return false;
+                }
+                if ($_params['resource_timestamp'] <= filemtime($compile_path)) {
+                    // template not expired, no recompile
+                    return true;
+                } else {
+                    // compile template
+                    return false;
+                }
+            }
+        } else {
+            // compiled template does not exist, or forced compile
+            return false;
+        }
+    }
+
+   /**
+     * compile the template
+     *
+     * @param string $resource_name
+     * @param string $compile_path
+     * @return boolean
+     */
+    function _compile_resource($resource_name, $compile_path)
+    {
+
+        $_params = array('resource_name' => $resource_name);
+        if (!$this->_fetch_resource_info($_params)) {
+            return false;
+        }
+
+        $_source_content = $_params['source_content'];
+        $_cache_include    = substr($compile_path, 0, -4).'.inc';
+
+        if ($this->_compile_source($resource_name, $_source_content, $_compiled_content, $_cache_include)) {
+            // if a _cache_serial was set, we also have to write an include-file:
+            if ($this->_cache_include_info) {
+                require_once(SMARTY_CORE_DIR . 'core.write_compiled_include.php');
+                smarty_core_write_compiled_include(array_merge($this->_cache_include_info, array('compiled_content'=>$_compiled_content, 'resource_name'=>$resource_name)),  $this);
+            }
+
+            $_params = array('compile_path'=>$compile_path, 'compiled_content' => $_compiled_content);
+            require_once(SMARTY_CORE_DIR . 'core.write_compiled_resource.php');
+            smarty_core_write_compiled_resource($_params, $this);
+
+            return true;
+        } else {
+            return false;
+        }
+
+    }
+
+   /**
+     * compile the given source
+     *
+     * @param string $resource_name
+     * @param string $source_content
+     * @param string $compiled_content
+     * @return boolean
+     */
+    function _compile_source($resource_name, &$source_content, &$compiled_content, $cache_include_path=null)
+    {
+        if (file_exists(SMARTY_DIR . $this->compiler_file)) {
+            require_once(SMARTY_DIR . $this->compiler_file);
+        } else {
+            // use include_path
+            require_once($this->compiler_file);
+        }
+
+
+        $smarty_compiler = new $this->compiler_class;
+
+        $smarty_compiler->template_dir      = $this->template_dir;
+        $smarty_compiler->compile_dir       = $this->compile_dir;
+        $smarty_compiler->plugins_dir       = $this->plugins_dir;
+        $smarty_compiler->config_dir        = $this->config_dir;
+        $smarty_compiler->force_compile     = $this->force_compile;
+        $smarty_compiler->caching           = $this->caching;
+        $smarty_compiler->php_handling      = $this->php_handling;
+        $smarty_compiler->left_delimiter    = $this->left_delimiter;
+        $smarty_compiler->right_delimiter   = $this->right_delimiter;
+        $smarty_compiler->_version          = $this->_version;
+        $smarty_compiler->security          = $this->security;
+        $smarty_compiler->secure_dir        = $this->secure_dir;
+        $smarty_compiler->security_settings = $this->security_settings;
+        $smarty_compiler->trusted_dir       = $this->trusted_dir;
+        $smarty_compiler->use_sub_dirs      = $this->use_sub_dirs;
+        $smarty_compiler->_reg_objects      = &$this->_reg_objects;
+        $smarty_compiler->_plugins          = &$this->_plugins;
+        $smarty_compiler->_tpl_vars         = &$this->_tpl_vars;
+        $smarty_compiler->default_modifiers = $this->default_modifiers;
+        $smarty_compiler->compile_id        = $this->_compile_id;
+        $smarty_compiler->_config            = $this->_config;
+        $smarty_compiler->request_use_auto_globals  = $this->request_use_auto_globals;
+
+        if (isset($cache_include_path) && isset($this->_cache_serials[$cache_include_path])) {
+            $smarty_compiler->_cache_serial = $this->_cache_serials[$cache_include_path];
+        }
+        $smarty_compiler->_cache_include = $cache_include_path;
+
+
+        $_results = $smarty_compiler->_compile_file($resource_name, $source_content, $compiled_content);
+
+        if ($smarty_compiler->_cache_serial) {
+            $this->_cache_include_info = array(
+                'cache_serial'=>$smarty_compiler->_cache_serial
+                ,'plugins_code'=>$smarty_compiler->_plugins_code
+                ,'include_file_path' => $cache_include_path);
+
+        } else {
+            $this->_cache_include_info = null;
+
+        }
+
+        return $_results;
+    }
+
+    /**
+     * Get the compile path for this resource
+     *
+     * @param string $resource_name
+     * @return string results of {@link _get_auto_filename()}
+     */
+    function _get_compile_path($resource_name)
+    {
+        return $this->_get_auto_filename($this->compile_dir, $resource_name,
+                                         $this->_compile_id) . '.php';
+    }
+
+    /**
+     * fetch the template info. Gets timestamp, and source
+     * if get_source is true
+     *
+     * sets $source_content to the source of the template, and
+     * $resource_timestamp to its time stamp
+     * @param string $resource_name
+     * @param string $source_content
+     * @param integer $resource_timestamp
+     * @param boolean $get_source
+     * @param boolean $quiet
+     * @return boolean
+     */
+
+    function _fetch_resource_info(&$params)
+    {
+        if(!isset($params['get_source'])) { $params['get_source'] = true; }
+        if(!isset($params['quiet'])) { $params['quiet'] = false; }
+
+        $_return = false;
+        $_params = array('resource_name' => $params['resource_name']) ;
+        if (isset($params['resource_base_path']))
+            $_params['resource_base_path'] = $params['resource_base_path'];
+        else
+            $_params['resource_base_path'] = $this->template_dir;
+
+        if ($this->_parse_resource_name($_params)) {
+            $_resource_type = $_params['resource_type'];
+            $_resource_name = $_params['resource_name'];
+            switch ($_resource_type) {
+                case 'file':
+                    if ($params['get_source']) {
+                        $params['source_content'] = $this->_read_file($_resource_name);
+                    }
+                    $params['resource_timestamp'] = filemtime($_resource_name);
+                    $_return = is_file($_resource_name) && is_readable($_resource_name);
+                    break;
+
+                default:
+                    // call resource functions to fetch the template source and timestamp
+                    if ($params['get_source']) {
+                        $_source_return = isset($this->_plugins['resource'][$_resource_type]) &&
+                            call_user_func_array($this->_plugins['resource'][$_resource_type][0][0],
+                                                 array($_resource_name, &$params['source_content'], &$this));
+                    } else {
+                        $_source_return = true;
+                    }
+
+                    $_timestamp_return = isset($this->_plugins['resource'][$_resource_type]) &&
+                        call_user_func_array($this->_plugins['resource'][$_resource_type][0][1],
+                                             array($_resource_name, &$params['resource_timestamp'], &$this));
+
+                    $_return = $_source_return && $_timestamp_return;
+                    break;
+            }
+        }
+
+        if (!$_return) {
+            // see if we can get a template with the default template handler
+            if (!empty($this->default_template_handler_func)) {
+                if (!is_callable($this->default_template_handler_func)) {
+                    $this->trigger_error("default template handler function \"$this->default_template_handler_func\" doesn't exist.");
+                } else {
+                    $_return = call_user_func_array(
+                        $this->default_template_handler_func,
+                        array($_params['resource_type'], $_params['resource_name'], &$params['source_content'], &$params['resource_timestamp'], &$this));
+                }
+            }
+        }
+
+        if (!$_return) {
+            if (!$params['quiet']) {
+                $this->trigger_error('unable to read resource: "' . $params['resource_name'] . '"');
+            }
+        } else if ($_return && $this->security) {
+            require_once(SMARTY_CORE_DIR . 'core.is_secure.php');
+            if (!smarty_core_is_secure($_params, $this)) {
+                if (!$params['quiet'])
+                    $this->trigger_error('(secure mode) accessing "' . $params['resource_name'] . '" is not allowed');
+                $params['source_content'] = null;
+                $params['resource_timestamp'] = null;
+                return false;
+            }
+        }
+        return $_return;
+    }
+
+
+    /**
+     * parse out the type and name from the resource
+     *
+     * @param string $resource_base_path
+     * @param string $resource_name
+     * @param string $resource_type
+     * @param string $resource_name
+     * @return boolean
+     */
+
+    function _parse_resource_name(&$params)
+    {
+
+        // split tpl_path by the first colon
+        $_resource_name_parts = explode(':', $params['resource_name'], 2);
+
+        if (count($_resource_name_parts) == 1) {
+            // no resource type given
+            $params['resource_type'] = $this->default_resource_type;
+            $params['resource_name'] = $_resource_name_parts[0];
+        } else {
+            if(strlen($_resource_name_parts[0]) == 1) {
+                // 1 char is not resource type, but part of filepath
+                $params['resource_type'] = $this->default_resource_type;
+                $params['resource_name'] = $params['resource_name'];
+            } else {
+                $params['resource_type'] = $_resource_name_parts[0];
+                $params['resource_name'] = $_resource_name_parts[1];
+            }
+        }
+
+        if ($params['resource_type'] == 'file') {
+            if (!preg_match('/^([\/\\\\]|[a-zA-Z]:[\/\\\\])/', $params['resource_name'])) {
+                // relative pathname to $params['resource_base_path']
+                // use the first directory where the file is found
+                foreach ((array)$params['resource_base_path'] as $_curr_path) {
+                    $_fullpath = $_curr_path . DIRECTORY_SEPARATOR . $params['resource_name'];
+                    if (file_exists($_fullpath) && is_file($_fullpath)) {
+                        $params['resource_name'] = $_fullpath;
+                        return true;
+                    }
+                    // didn't find the file, try include_path
+                    $_params = array('file_path' => $_fullpath);
+                    require_once(SMARTY_CORE_DIR . 'core.get_include_path.php');
+                    if(smarty_core_get_include_path($_params, $this)) {
+                        $params['resource_name'] = $_params['new_file_path'];
+                        return true;
+                    }
+                }
+                return false;
+            } else {
+                /* absolute path */
+                return file_exists($params['resource_name']);
+            }
+        } elseif (empty($this->_plugins['resource'][$params['resource_type']])) {
+            $_params = array('type' => $params['resource_type']);
+            require_once(SMARTY_CORE_DIR . 'core.load_resource_plugin.php');
+            smarty_core_load_resource_plugin($_params, $this);
+        }
+
+        return true;
+    }
+
+
+    /**
+     * Handle modifiers
+     *
+     * @param string|null $modifier_name
+     * @param array|null $map_array
+     * @return string result of modifiers
+     */
+    function _run_mod_handler()
+    {
+        $_args = func_get_args();
+        list($_modifier_name, $_map_array) = array_splice($_args, 0, 2);
+        list($_func_name, $_tpl_file, $_tpl_line) =
+            $this->_plugins['modifier'][$_modifier_name];
+
+        $_var = $_args[0];
+        foreach ($_var as $_key => $_val) {
+            $_args[0] = $_val;
+            $_var[$_key] = call_user_func_array($_func_name, $_args);
+        }
+        return $_var;
+    }
+
+    /**
+     * Remove starting and ending quotes from the string
+     *
+     * @param string $string
+     * @return string
+     */
+    function _dequote($string)
+    {
+        if ((substr($string, 0, 1) == "'" || substr($string, 0, 1) == '"') &&
+            substr($string, -1) == substr($string, 0, 1))
+            return substr($string, 1, -1);
+        else
+            return $string;
+    }
+
+
+    /**
+     * read in a file
+     *
+     * @param string $filename
+     * @return string
+     */
+    function _read_file($filename)
+    {
+        if ( file_exists($filename) && is_readable($filename) && ($fd = @fopen($filename, 'rb')) ) {
+            $contents = '';
+            while (!feof($fd)) {
+                $contents .= fread($fd, 8192);
+            }
+            fclose($fd);
+            return $contents;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * get a concrete filename for automagically created content
+     *
+     * @param string $auto_base
+     * @param string $auto_source
+     * @param string $auto_id
+     * @return string
+     * @staticvar string|null
+     * @staticvar string|null
+     */
+    function _get_auto_filename($auto_base, $auto_source = null, $auto_id = null)
+    {
+        $_compile_dir_sep =  $this->use_sub_dirs ? DIRECTORY_SEPARATOR : '^';
+        $_return = $auto_base . DIRECTORY_SEPARATOR;
+
+        if(isset($auto_id)) {
+            // make auto_id safe for directory names
+            $auto_id = str_replace('%7C',$_compile_dir_sep,(urlencode($auto_id)));
+            // split into separate directories
+            $_return .= $auto_id . $_compile_dir_sep;
+        }
+
+        if(isset($auto_source)) {
+            // make source name safe for filename
+            $_filename = urlencode(basename($auto_source));
+            $_crc32 = sprintf('%08X', crc32($auto_source));
+            // prepend %% to avoid name conflicts with
+            // with $params['auto_id'] names
+            $_crc32 = substr($_crc32, 0, 2) . $_compile_dir_sep .
+                      substr($_crc32, 0, 3) . $_compile_dir_sep . $_crc32;
+            $_return .= '%%' . $_crc32 . '%%' . $_filename;
+        }
+
+        return $_return;
+    }
+
+    /**
+     * unlink a file, possibly using expiration time
+     *
+     * @param string $resource
+     * @param integer $exp_time
+     */
+    function _unlink($resource, $exp_time = null)
+    {
+        if(isset($exp_time)) {
+            if(time() - @filemtime($resource) >= $exp_time) {
+                return @unlink($resource);
+            }
+        } else {
+            return @unlink($resource);
+        }
+    }
+
+    /**
+     * returns an auto_id for auto-file-functions
+     *
+     * @param string $cache_id
+     * @param string $compile_id
+     * @return string|null
+     */
+    function _get_auto_id($cache_id=null, $compile_id=null) {
+    if (isset($cache_id))
+        return (isset($compile_id)) ? $cache_id . '|' . $compile_id  : $cache_id;
+    elseif(isset($compile_id))
+        return $compile_id;
+    else
+        return null;
+    }
+
+    /**
+     * trigger Smarty plugin error
+     *
+     * @param string $error_msg
+     * @param string $tpl_file
+     * @param integer $tpl_line
+     * @param string $file
+     * @param integer $line
+     * @param integer $error_type
+     */
+    function _trigger_fatal_error($error_msg, $tpl_file = null, $tpl_line = null,
+            $file = null, $line = null, $error_type = E_USER_ERROR)
+    {
+        if(isset($file) && isset($line)) {
+            $info = ' ('.basename($file).", line $line)";
+        } else {
+            $info = '';
+        }
+        if (isset($tpl_line) && isset($tpl_file)) {
+            $this->trigger_error('[in ' . $tpl_file . ' line ' . $tpl_line . "]: $error_msg$info", $error_type);
+        } else {
+            $this->trigger_error($error_msg . $info, $error_type);
+        }
+    }
+
+
+    /**
+     * callback function for preg_replace, to call a non-cacheable block
+     * @return string
+     */
+    function _process_compiled_include_callback($match) {
+        $_func = '_smarty_tplfunc_'.$match[2].'_'.$match[3];
+        ob_start();
+        $_func($this);
+        $_ret = ob_get_contents();
+        ob_end_clean();
+        return $_ret;
+    }
+
+
+    /**
+     * called for included templates
+     *
+     * @param string $_smarty_include_tpl_file
+     * @param string $_smarty_include_vars
+     */
+
+    // $_smarty_include_tpl_file, $_smarty_include_vars
+
+    function _smarty_include($params)
+    {
+        if ($this->debugging) {
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $debug_start_time = smarty_core_get_microtime($_params, $this);
+            $this->_smarty_debug_info[] = array('type'      => 'template',
+                                                  'filename'  => $params['smarty_include_tpl_file'],
+                                                  'depth'     => ++$this->_inclusion_depth);
+            $included_tpls_idx = count($this->_smarty_debug_info) - 1;
+        }
+
+        $this->_tpl_vars = array_merge($this->_tpl_vars, $params['smarty_include_vars']);
+
+        // config vars are treated as local, so push a copy of the
+        // current ones onto the front of the stack
+        array_unshift($this->_config, $this->_config[0]);
+
+        $_smarty_compile_path = $this->_get_compile_path($params['smarty_include_tpl_file']);
+
+
+        if ($this->_is_compiled($params['smarty_include_tpl_file'], $_smarty_compile_path)
+            || $this->_compile_resource($params['smarty_include_tpl_file'], $_smarty_compile_path))
+        {
+            include($_smarty_compile_path);
+        }
+
+        // pop the local vars off the front of the stack
+        array_shift($this->_config);
+
+        $this->_inclusion_depth--;
+
+        if ($this->debugging) {
+            // capture time for debugging info
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $this->_smarty_debug_info[$included_tpls_idx]['exec_time'] = smarty_core_get_microtime($_params, $this) - $debug_start_time;
+        }
+
+        if ($this->caching) {
+            $this->_cache_info['template'][$params['smarty_include_tpl_file']] = true;
+        }
+    }
+
+
+    /**
+     * get or set an array of cached attributes for function that is
+     * not cacheable
+     * @return array
+     */
+    function &_smarty_cache_attrs($cache_serial, $count) {
+        $_cache_attrs =& $this->_cache_info['cache_attrs'][$cache_serial][$count];
+
+        if ($this->_cache_including) {
+            /* return next set of cache_attrs */
+            $_return = current($_cache_attrs);
+            next($_cache_attrs);
+            return $_return;
+
+        } else {
+            /* add a reference to a new set of cache_attrs */
+            $_cache_attrs[] = array();
+            return $_cache_attrs[count($_cache_attrs)-1];
+
+        }
+
+    }
+
+
+    /**
+     * wrapper for include() retaining $this
+     * @return mixed
+     */
+    function _include($filename, $once=false, $params=null)
+    {
+        if ($once) {
+            return include_once($filename);
+        } else {
+            return include($filename);
+        }
+    }
+
+
+    /**
+     * wrapper for eval() retaining $this
+     * @return mixed
+     */
+    function _eval($code, $params=null)
+    {
+        return eval($code);
+    }
+
+    /**
+     * Extracts the filter name from the given callback
+     *
+     * @param callback $function
+     * @return string
+     */
+	function _get_filter_name($function)
+	{
+		if (is_array($function)) {
+			$_class_name = (is_object($function[0]) ?
+				get_class($function[0]) : $function[0]);
+			return $_class_name . '_' . $function[1];
+		}
+		else {
+			return $function;
+		}
+	}
+
+    /**#@-*/
+
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/Smarty_Compiler.class.php b/epgrec/Smarty.v2/Smarty_Compiler.class.php
--- a/epgrec/Smarty.v2/Smarty_Compiler.class.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/Smarty_Compiler.class.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,2365 @@
+<?php
+
+/**
+ * Project:     Smarty: the PHP compiling template engine
+ * File:        Smarty_Compiler.class.php
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * @link http://smarty.php.net/
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @author Andrei Zmievski <andrei@php.net>
+ * @version 2.6.25-dev
+ * @copyright 2001-2005 New Digital Group, Inc.
+ * @package Smarty
+ */
+
+/* $Id$ */
+
+/**
+ * Template compiling class
+ * @package Smarty
+ */
+class Smarty_Compiler extends Smarty {
+
+    // internal vars
+    /**#@+
+     * @access private
+     */
+    var $_folded_blocks         =   array();    // keeps folded template blocks
+    var $_current_file          =   null;       // the current template being compiled
+    var $_current_line_no       =   1;          // line number for error messages
+    var $_capture_stack         =   array();    // keeps track of nested capture buffers
+    var $_plugin_info           =   array();    // keeps track of plugins to load
+    var $_init_smarty_vars      =   false;
+    var $_permitted_tokens      =   array('true','false','yes','no','on','off','null');
+    var $_db_qstr_regexp        =   null;        // regexps are setup in the constructor
+    var $_si_qstr_regexp        =   null;
+    var $_qstr_regexp           =   null;
+    var $_func_regexp           =   null;
+    var $_reg_obj_regexp        =   null;
+    var $_var_bracket_regexp    =   null;
+    var $_num_const_regexp      =   null;
+    var $_dvar_guts_regexp      =   null;
+    var $_dvar_regexp           =   null;
+    var $_cvar_regexp           =   null;
+    var $_svar_regexp           =   null;
+    var $_avar_regexp           =   null;
+    var $_mod_regexp            =   null;
+    var $_var_regexp            =   null;
+    var $_parenth_param_regexp  =   null;
+    var $_func_call_regexp      =   null;
+    var $_obj_ext_regexp        =   null;
+    var $_obj_start_regexp      =   null;
+    var $_obj_params_regexp     =   null;
+    var $_obj_call_regexp       =   null;
+    var $_cacheable_state       =   0;
+    var $_cache_attrs_count     =   0;
+    var $_nocache_count         =   0;
+    var $_cache_serial          =   null;
+    var $_cache_include         =   null;
+
+    var $_strip_depth           =   0;
+    var $_additional_newline    =   "\n";
+
+    /**#@-*/
+    /**
+     * The class constructor.
+     */
+    public function __construct()
+    {
+        // matches double quoted strings:
+        // "foobar"
+        // "foo\"bar"
+        $this->_db_qstr_regexp = '"[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
+
+        // matches single quoted strings:
+        // 'foobar'
+        // 'foo\'bar'
+        $this->_si_qstr_regexp = '\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'';
+
+        // matches single or double quoted strings
+        $this->_qstr_regexp = '(?:' . $this->_db_qstr_regexp . '|' . $this->_si_qstr_regexp . ')';
+
+        // matches bracket portion of vars
+        // [0]
+        // [foo]
+        // [$bar]
+        $this->_var_bracket_regexp = '\[\$?[\w\.]+\]';
+
+        // matches numerical constants
+        // 30
+        // -12
+        // 13.22
+        $this->_num_const_regexp = '(?:\-?\d+(?:\.\d+)?)';
+
+        // matches $ vars (not objects):
+        // $foo
+        // $foo.bar
+        // $foo.bar.foobar
+        // $foo[0]
+        // $foo[$bar]
+        // $foo[5][blah]
+        // $foo[5].bar[$foobar][4]
+        $this->_dvar_math_regexp = '(?:[\+\*\/\%]|(?:-(?!>)))';
+        $this->_dvar_math_var_regexp = '[\$\w\.\+\-\*\/\%\d\>\[\]]';
+        $this->_dvar_guts_regexp = '\w+(?:' . $this->_var_bracket_regexp
+                . ')*(?:\.\$?\w+(?:' . $this->_var_bracket_regexp . ')*)*(?:' . $this->_dvar_math_regexp . '(?:' . $this->_num_const_regexp . '|' . $this->_dvar_math_var_regexp . ')*)?';
+        $this->_dvar_regexp = '\$' . $this->_dvar_guts_regexp;
+
+        // matches config vars:
+        // #foo#
+        // #foobar123_foo#
+        $this->_cvar_regexp = '\#\w+\#';
+
+        // matches section vars:
+        // %foo.bar%
+        $this->_svar_regexp = '\%\w+\.\w+\%';
+
+        // matches all valid variables (no quotes, no modifiers)
+        $this->_avar_regexp = '(?:' . $this->_dvar_regexp . '|'
+           . $this->_cvar_regexp . '|' . $this->_svar_regexp . ')';
+
+        // matches valid variable syntax:
+        // $foo
+        // $foo
+        // #foo#
+        // #foo#
+        // "text"
+        // "text"
+        $this->_var_regexp = '(?:' . $this->_avar_regexp . '|' . $this->_qstr_regexp . ')';
+
+        // matches valid object call (one level of object nesting allowed in parameters):
+        // $foo->bar
+        // $foo->bar()
+        // $foo->bar("text")
+        // $foo->bar($foo, $bar, "text")
+        // $foo->bar($foo, "foo")
+        // $foo->bar->foo()
+        // $foo->bar->foo->bar()
+        // $foo->bar($foo->bar)
+        // $foo->bar($foo->bar())
+        // $foo->bar($foo->bar($blah,$foo,44,"foo",$foo[0].bar))
+        $this->_obj_ext_regexp = '\->(?:\$?' . $this->_dvar_guts_regexp . ')';
+        $this->_obj_restricted_param_regexp = '(?:'
+                . '(?:' . $this->_var_regexp . '|' . $this->_num_const_regexp . ')(?:' . $this->_obj_ext_regexp . '(?:\((?:(?:' . $this->_var_regexp . '|' . $this->_num_const_regexp . ')'
+                . '(?:\s*,\s*(?:' . $this->_var_regexp . '|' . $this->_num_const_regexp . '))*)?\))?)*)';
+        $this->_obj_single_param_regexp = '(?:\w+|' . $this->_obj_restricted_param_regexp . '(?:\s*,\s*(?:(?:\w+|'
+                . $this->_var_regexp . $this->_obj_restricted_param_regexp . ')))*)';
+        $this->_obj_params_regexp = '\((?:' . $this->_obj_single_param_regexp
+                . '(?:\s*,\s*' . $this->_obj_single_param_regexp . ')*)?\)';
+        $this->_obj_start_regexp = '(?:' . $this->_dvar_regexp . '(?:' . $this->_obj_ext_regexp . ')+)';
+        $this->_obj_call_regexp = '(?:' . $this->_obj_start_regexp . '(?:' . $this->_obj_params_regexp . ')?(?:' . $this->_dvar_math_regexp . '(?:' . $this->_num_const_regexp . '|' . $this->_dvar_math_var_regexp . ')*)?)';
+        
+        // matches valid modifier syntax:
+        // |foo
+        // |@foo
+        // |foo:"bar"
+        // |foo:$bar
+        // |foo:"bar":$foobar
+        // |foo|bar
+        // |foo:$foo->bar
+        $this->_mod_regexp = '(?:\|@?\w+(?::(?:\w+|' . $this->_num_const_regexp . '|'
+           . $this->_obj_call_regexp . '|' . $this->_avar_regexp . '|' . $this->_qstr_regexp .'))*)';
+
+        // matches valid function name:
+        // foo123
+        // _foo_bar
+        $this->_func_regexp = '[a-zA-Z_]\w*';
+
+        // matches valid registered object:
+        // foo->bar
+        $this->_reg_obj_regexp = '[a-zA-Z_]\w*->[a-zA-Z_]\w*';
+
+        // matches valid parameter values:
+        // true
+        // $foo
+        // $foo|bar
+        // #foo#
+        // #foo#|bar
+        // "text"
+        // "text"|bar
+        // $foo->bar
+        $this->_param_regexp = '(?:\s*(?:' . $this->_obj_call_regexp . '|'
+           . $this->_var_regexp . '|' . $this->_num_const_regexp  . '|\w+)(?>' . $this->_mod_regexp . '*)\s*)';
+
+        // matches valid parenthesised function parameters:
+        //
+        // "text"
+        //    $foo, $bar, "text"
+        // $foo|bar, "foo"|bar, $foo->bar($foo)|bar
+        $this->_parenth_param_regexp = '(?:\((?:\w+|'
+                . $this->_param_regexp . '(?:\s*,\s*(?:(?:\w+|'
+                . $this->_param_regexp . ')))*)?\))';
+
+        // matches valid function call:
+        // foo()
+        // foo_bar($foo)
+        // _foo_bar($foo,"bar")
+        // foo123($foo,$foo->bar(),"foo")
+        $this->_func_call_regexp = '(?:' . $this->_func_regexp . '\s*(?:'
+           . $this->_parenth_param_regexp . '))';
+    }
+
+    /**
+     * compile a resource
+     *
+     * sets $compiled_content to the compiled source
+     * @param string $resource_name
+     * @param string $source_content
+     * @param string $compiled_content
+     * @return true
+     */
+    function _compile_file($resource_name, $source_content, &$compiled_content)
+    {
+
+        if ($this->security) {
+            // do not allow php syntax to be executed unless specified
+            if ($this->php_handling == SMARTY_PHP_ALLOW &&
+                !$this->security_settings['PHP_HANDLING']) {
+                $this->php_handling = SMARTY_PHP_PASSTHRU;
+            }
+        }
+
+        $this->_load_filters();
+
+        $this->_current_file = $resource_name;
+        $this->_current_line_no = 1;
+        $ldq = preg_quote($this->left_delimiter, '~');
+        $rdq = preg_quote($this->right_delimiter, '~');
+
+        // run template source through prefilter functions
+        if (count($this->_plugins['prefilter']) > 0) {
+            foreach ($this->_plugins['prefilter'] as $filter_name => $prefilter) {
+                if ($prefilter === false) continue;
+                if ($prefilter[3] || is_callable($prefilter[0])) {
+                    $source_content = call_user_func_array($prefilter[0],
+                                                            array($source_content, &$this));
+                    $this->_plugins['prefilter'][$filter_name][3] = true;
+                } else {
+                    $this->_trigger_fatal_error("[plugin] prefilter '$filter_name' is not implemented");
+                }
+            }
+        }
+
+        /* fetch all special blocks */
+        $search = "~{$ldq}\*(.*?)\*{$rdq}|{$ldq}\s*literal\s*{$rdq}(.*?){$ldq}\s*/literal\s*{$rdq}|{$ldq}\s*php\s*{$rdq}(.*?){$ldq}\s*/php\s*{$rdq}~s";
+
+        preg_match_all($search, $source_content, $match,  PREG_SET_ORDER);
+        $this->_folded_blocks = $match;
+        reset($this->_folded_blocks);
+
+        /* replace special blocks by "{php}" */
+        $source_content = preg_replace_callback($search, create_function ('$matches', "return '"
+                                       . $this->_quote_replace($this->left_delimiter) . 'php'
+                                       . "' . str_repeat(\"\n\", substr_count('\$matches[1]', \"\n\")) .'"
+                                       . $this->_quote_replace($this->right_delimiter)
+                                       . "';")
+                                       , $source_content);
+
+        /* Gather all template tags. */
+        preg_match_all("~{$ldq}\s*(.*?)\s*{$rdq}~s", $source_content, $_match);
+        $template_tags = $_match[1];
+        /* Split content by template tags to obtain non-template content. */
+        $text_blocks = preg_split("~{$ldq}.*?{$rdq}~s", $source_content);
+
+        /* loop through text blocks */
+        for ($curr_tb = 0, $for_max = count($text_blocks); $curr_tb < $for_max; $curr_tb++) {
+            /* match anything resembling php tags */
+            if (preg_match_all('~(<\?(?:\w+|=)?|\?>|language\s*=\s*[\"\']?\s*php\s*[\"\']?)~is', $text_blocks[$curr_tb], $sp_match)) {
+                /* replace tags with placeholders to prevent recursive replacements */
+                $sp_match[1] = array_unique($sp_match[1]);
+                usort($sp_match[1], '_smarty_sort_length');
+                for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp < $for_max2; $curr_sp++) {
+                    $text_blocks[$curr_tb] = str_replace($sp_match[1][$curr_sp],'%%%SMARTYSP'.$curr_sp.'%%%',$text_blocks[$curr_tb]);
+                }
+                /* process each one */
+                for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp < $for_max2; $curr_sp++) {
+                    if ($this->php_handling == SMARTY_PHP_PASSTHRU) {
+                        /* echo php contents */
+                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', '<?php echo \''.str_replace("'", "\'", $sp_match[1][$curr_sp]).'\'; ?>'."\n", $text_blocks[$curr_tb]);
+                    } else if ($this->php_handling == SMARTY_PHP_QUOTE) {
+                        /* quote php tags */
+                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', htmlspecialchars($sp_match[1][$curr_sp]), $text_blocks[$curr_tb]);
+                    } else if ($this->php_handling == SMARTY_PHP_REMOVE) {
+                        /* remove php tags */
+                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', '', $text_blocks[$curr_tb]);
+                    } else {
+                        /* SMARTY_PHP_ALLOW, but echo non php starting tags */
+                        $sp_match[1][$curr_sp] = preg_replace('~(<\?(?!php|=|$))~i', '<?php echo \'\\1\'?>'."\n", $sp_match[1][$curr_sp]);
+                        $text_blocks[$curr_tb] = str_replace('%%%SMARTYSP'.$curr_sp.'%%%', $sp_match[1][$curr_sp], $text_blocks[$curr_tb]);
+                    }
+                }
+            }
+        }
+        
+        /* Compile the template tags into PHP code. */
+        $compiled_tags = array();
+        for ($i = 0, $for_max = count($template_tags); $i < $for_max; $i++) {
+            $this->_current_line_no += substr_count($text_blocks[$i], "\n");
+            $compiled_tags[] = $this->_compile_tag($template_tags[$i]);
+            $this->_current_line_no += substr_count($template_tags[$i], "\n");
+        }
+        if (count($this->_tag_stack)>0) {
+            list($_open_tag, $_line_no) = end($this->_tag_stack);
+            $this->_syntax_error("unclosed tag \{$_open_tag} (opened line $_line_no).", E_USER_ERROR, __FILE__, __LINE__);
+            return;
+        }
+
+        /* Reformat $text_blocks between 'strip' and '/strip' tags,
+           removing spaces, tabs and newlines. */
+        $strip = false;
+        for ($i = 0, $for_max = count($compiled_tags); $i < $for_max; $i++) {
+            if ($compiled_tags[$i] == '{strip}') {
+                $compiled_tags[$i] = '';
+                $strip = true;
+                /* remove leading whitespaces */
+                $text_blocks[$i + 1] = ltrim($text_blocks[$i + 1]);
+            }
+            if ($strip) {
+                /* strip all $text_blocks before the next '/strip' */
+                for ($j = $i + 1; $j < $for_max; $j++) {
+                    /* remove leading and trailing whitespaces of each line */
+                    $text_blocks[$j] = preg_replace('![\t ]*[\r\n]+[\t ]*!', '', $text_blocks[$j]);
+                    if ($compiled_tags[$j] == '{/strip}') {                       
+                        /* remove trailing whitespaces from the last text_block */
+                        $text_blocks[$j] = rtrim($text_blocks[$j]);
+                    }
+                    $text_blocks[$j] = "<?php echo '" . strtr($text_blocks[$j], array("'"=>"\'", "\\"=>"\\\\")) . "'; ?>";
+                    if ($compiled_tags[$j] == '{/strip}') {
+                        $compiled_tags[$j] = "\n"; /* slurped by php, but necessary
+                                    if a newline is following the closing strip-tag */
+                        $strip = false;
+                        $i = $j;
+                        break;
+                    }
+                }
+            }
+        }
+        $compiled_content = '';
+        
+        $tag_guard = '%%%SMARTYOTG' . md5(uniqid(rand(), true)) . '%%%';
+        
+        /* Interleave the compiled contents and text blocks to get the final result. */
+        for ($i = 0, $for_max = count($compiled_tags); $i < $for_max; $i++) {
+            if ($compiled_tags[$i] == '') {
+                // tag result empty, remove first newline from following text block
+                $text_blocks[$i+1] = preg_replace('~^(\r\n|\r|\n)~', '', $text_blocks[$i+1]);
+            }
+            // replace legit PHP tags with placeholder
+            $text_blocks[$i] = str_replace('<?', $tag_guard, $text_blocks[$i]);
+            $compiled_tags[$i] = str_replace('<?', $tag_guard, $compiled_tags[$i]);
+            
+            $compiled_content .= $text_blocks[$i] . $compiled_tags[$i];
+        }
+        $compiled_content .= str_replace('<?', $tag_guard, $text_blocks[$i]);
+
+        // escape php tags created by interleaving
+        $compiled_content = str_replace('<?', "<?php echo '<?' ?>\n", $compiled_content);
+        $compiled_content = preg_replace("~(?<!')language\s*=\s*[\"\']?\s*php\s*[\"\']?~", "<?php echo 'language=php' ?>\n", $compiled_content);
+
+        // recover legit tags
+        $compiled_content = str_replace($tag_guard, '<?', $compiled_content); 
+        
+        // remove \n from the end of the file, if any
+        if (strlen($compiled_content) && (substr($compiled_content, -1) == "\n") ) {
+            $compiled_content = substr($compiled_content, 0, -1);
+        }
+
+        if (!empty($this->_cache_serial)) {
+            $compiled_content = "<?php \$this->_cache_serials['".$this->_cache_include."'] = '".$this->_cache_serial."'; ?>" . $compiled_content;
+        }
+
+        // run compiled template through postfilter functions
+        if (count($this->_plugins['postfilter']) > 0) {
+            foreach ($this->_plugins['postfilter'] as $filter_name => $postfilter) {
+                if ($postfilter === false) continue;
+                if ($postfilter[3] || is_callable($postfilter[0])) {
+                    $compiled_content = call_user_func_array($postfilter[0],
+                                                              array($compiled_content, &$this));
+                    $this->_plugins['postfilter'][$filter_name][3] = true;
+                } else {
+                    $this->_trigger_fatal_error("Smarty plugin error: postfilter '$filter_name' is not implemented");
+                }
+            }
+        }
+
+        // put header at the top of the compiled template
+        $template_header = "<?php /* Smarty version ".$this->_version.", created on ".strftime("%Y-%m-%d %H:%M:%S")."\n";
+        $template_header .= "         compiled from ".strtr(urlencode($resource_name), array('%2F'=>'/', '%3A'=>':'))." */ ?>\n";
+
+        /* Emit code to load needed plugins. */
+        $this->_plugins_code = '';
+        if (count($this->_plugin_info)) {
+            $_plugins_params = "array('plugins' => array(";
+            foreach ($this->_plugin_info as $plugin_type => $plugins) {
+                foreach ($plugins as $plugin_name => $plugin_info) {
+                    $_plugins_params .= "array('$plugin_type', '$plugin_name', '" . strtr($plugin_info[0], array("'" => "\\'", "\\" => "\\\\")) . "', $plugin_info[1], ";
+                    $_plugins_params .= $plugin_info[2] ? 'true),' : 'false),';
+                }
+            }
+            $_plugins_params .= '))';
+            $plugins_code = "<?php require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');\nsmarty_core_load_plugins($_plugins_params, \$this); ?>\n";
+            $template_header .= $plugins_code;
+            $this->_plugin_info = array();
+            $this->_plugins_code = $plugins_code;
+        }
+
+        if ($this->_init_smarty_vars) {
+            $template_header .= "<?php require_once(SMARTY_CORE_DIR . 'core.assign_smarty_interface.php');\nsmarty_core_assign_smarty_interface(null, \$this); ?>\n";
+            $this->_init_smarty_vars = false;
+        }
+
+        $compiled_content = $template_header . $compiled_content;
+        return true;
+    }
+
+    /**
+     * Compile a template tag
+     *
+     * @param string $template_tag
+     * @return string
+     */
+    function _compile_tag($template_tag)
+    {
+        /* Matched comment. */
+        if (substr($template_tag, 0, 1) == '*' && substr($template_tag, -1) == '*')
+            return '';
+        
+        /* Split tag into two three parts: command, command modifiers and the arguments. */
+        if(! preg_match('~^(?:(' . $this->_num_const_regexp . '|' . $this->_obj_call_regexp . '|' . $this->_var_regexp
+                . '|\/?' . $this->_reg_obj_regexp . '|\/?' . $this->_func_regexp . ')(' . $this->_mod_regexp . '*))
+                      (?:\s+(.*))?$
+                    ~xs', $template_tag, $match)) {
+            $this->_syntax_error("unrecognized tag: $template_tag", E_USER_ERROR, __FILE__, __LINE__);
+        }
+        
+        $tag_command = $match[1];
+        $tag_modifier = isset($match[2]) ? $match[2] : null;
+        $tag_args = isset($match[3]) ? $match[3] : null;
+
+        if (preg_match('~^' . $this->_num_const_regexp . '|' . $this->_obj_call_regexp . '|' . $this->_var_regexp . '$~', $tag_command)) {
+            /* tag name is a variable or object */
+            $_return = $this->_parse_var_props($tag_command . $tag_modifier);
+            return "<?php echo $_return; ?>" . $this->_additional_newline;
+        }
+
+        /* If the tag name is a registered object, we process it. */
+        if (preg_match('~^\/?' . $this->_reg_obj_regexp . '$~', $tag_command)) {
+            return $this->_compile_registered_object_tag($tag_command, $this->_parse_attrs($tag_args), $tag_modifier);
+        }
+
+        switch ($tag_command) {
+            case 'include':
+                return $this->_compile_include_tag($tag_args);
+
+            case 'include_php':
+                return $this->_compile_include_php_tag($tag_args);
+
+            case 'if':
+                $this->_push_tag('if');
+                return $this->_compile_if_tag($tag_args);
+
+            case 'else':
+                list($_open_tag) = end($this->_tag_stack);
+                if ($_open_tag != 'if' && $_open_tag != 'elseif')
+                    $this->_syntax_error('unexpected {else}', E_USER_ERROR, __FILE__, __LINE__);
+                else
+                    $this->_push_tag('else');
+                return '<?php else: ?>';
+
+            case 'elseif':
+                list($_open_tag) = end($this->_tag_stack);
+                if ($_open_tag != 'if' && $_open_tag != 'elseif')
+                    $this->_syntax_error('unexpected {elseif}', E_USER_ERROR, __FILE__, __LINE__);
+                if ($_open_tag == 'if')
+                    $this->_push_tag('elseif');
+                return $this->_compile_if_tag($tag_args, true);
+
+            case '/if':
+                $this->_pop_tag('if');
+                return '<?php endif; ?>';
+
+            case 'capture':
+                return $this->_compile_capture_tag(true, $tag_args);
+
+            case '/capture':
+                return $this->_compile_capture_tag(false);
+
+            case 'ldelim':
+                return $this->left_delimiter;
+
+            case 'rdelim':
+                return $this->right_delimiter;
+
+            case 'section':
+                $this->_push_tag('section');
+                return $this->_compile_section_start($tag_args);
+
+            case 'sectionelse':
+                $this->_push_tag('sectionelse');
+                return "<?php endfor; else: ?>";
+                break;
+
+            case '/section':
+                $_open_tag = $this->_pop_tag('section');
+                if ($_open_tag == 'sectionelse')
+                    return "<?php endif; ?>";
+                else
+                    return "<?php endfor; endif; ?>";
+
+            case 'foreach':
+                $this->_push_tag('foreach');
+                return $this->_compile_foreach_start($tag_args);
+                break;
+
+            case 'foreachelse':
+                $this->_push_tag('foreachelse');
+                return "<?php endforeach; else: ?>";
+
+            case '/foreach':
+                $_open_tag = $this->_pop_tag('foreach');
+                if ($_open_tag == 'foreachelse')
+                    return "<?php endif; unset(\$_from); ?>";
+                else
+                    return "<?php endforeach; endif; unset(\$_from); ?>";
+                break;
+
+            case 'strip':
+            case '/strip':
+                if (substr($tag_command, 0, 1)=='/') {
+                    $this->_pop_tag('strip');
+                    if (--$this->_strip_depth==0) { /* outermost closing {/strip} */
+                        $this->_additional_newline = "\n";
+                        return '{' . $tag_command . '}';
+                    }
+                } else {
+                    $this->_push_tag('strip');
+                    if ($this->_strip_depth++==0) { /* outermost opening {strip} */
+                        $this->_additional_newline = "";
+                        return '{' . $tag_command . '}';
+                    }
+                }
+                return '';
+
+            case 'php':
+                /* handle folded tags replaced by {php} */
+                list(, $block) = each($this->_folded_blocks);
+                $this->_current_line_no += substr_count($block[0], "\n");
+                /* the number of matched elements in the regexp in _compile_file()
+                   determins the type of folded tag that was found */
+                switch (count($block)) {
+                    case 2: /* comment */
+                        return '';
+
+                    case 3: /* literal */
+                        return "<?php echo '" . strtr($block[2], array("'"=>"\'", "\\"=>"\\\\")) . "'; ?>" . $this->_additional_newline;
+
+                    case 4: /* php */
+                        if ($this->security && !$this->security_settings['PHP_TAGS']) {
+                            $this->_syntax_error("(secure mode) php tags not permitted", E_USER_WARNING, __FILE__, __LINE__);
+                            return;
+                        }
+                        return '<?php ' . $block[3] .' ?>';
+                }
+                break;
+
+            case 'insert':
+                return $this->_compile_insert_tag($tag_args);
+
+            default:
+                if ($this->_compile_compiler_tag($tag_command, $tag_args, $output)) {
+                    return $output;
+                } else if ($this->_compile_block_tag($tag_command, $tag_args, $tag_modifier, $output)) {
+                    return $output;
+                } else if ($this->_compile_custom_tag($tag_command, $tag_args, $tag_modifier, $output)) {
+                    return $output;                    
+                } else {
+                    $this->_syntax_error("unrecognized tag '$tag_command'", E_USER_ERROR, __FILE__, __LINE__);
+                }
+
+        }
+    }
+
+
+    /**
+     * compile the custom compiler tag
+     *
+     * sets $output to the compiled custom compiler tag
+     * @param string $tag_command
+     * @param string $tag_args
+     * @param string $output
+     * @return boolean
+     */
+    function _compile_compiler_tag($tag_command, $tag_args, &$output)
+    {
+        $found = false;
+        $have_function = true;
+
+        /*
+         * First we check if the compiler function has already been registered
+         * or loaded from a plugin file.
+         */
+        if (isset($this->_plugins['compiler'][$tag_command])) {
+            $found = true;
+            $plugin_func = $this->_plugins['compiler'][$tag_command][0];
+            if (!is_callable($plugin_func)) {
+                $message = "compiler function '$tag_command' is not implemented";
+                $have_function = false;
+            }
+        }
+        /*
+         * Otherwise we need to load plugin file and look for the function
+         * inside it.
+         */
+        else if ($plugin_file = $this->_get_plugin_filepath('compiler', $tag_command)) {
+            $found = true;
+
+            include_once $plugin_file;
+
+            $plugin_func = 'smarty_compiler_' . $tag_command;
+            if (!is_callable($plugin_func)) {
+                $message = "plugin function $plugin_func() not found in $plugin_file\n";
+                $have_function = false;
+            } else {
+                $this->_plugins['compiler'][$tag_command] = array($plugin_func, null, null, null, true);
+            }
+        }
+
+        /*
+         * True return value means that we either found a plugin or a
+         * dynamically registered function. False means that we didn't and the
+         * compiler should now emit code to load custom function plugin for this
+         * tag.
+         */
+        if ($found) {
+            if ($have_function) {
+                $output = call_user_func_array($plugin_func, array($tag_args, &$this));
+                if($output != '') {
+                $output = '<?php ' . $this->_push_cacheable_state('compiler', $tag_command)
+                                   . $output
+                                   . $this->_pop_cacheable_state('compiler', $tag_command) . ' ?>';
+                }
+            } else {
+                $this->_syntax_error($message, E_USER_WARNING, __FILE__, __LINE__);
+            }
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+
+    /**
+     * compile block function tag
+     *
+     * sets $output to compiled block function tag
+     * @param string $tag_command
+     * @param string $tag_args
+     * @param string $tag_modifier
+     * @param string $output
+     * @return boolean
+     */
+    function _compile_block_tag($tag_command, $tag_args, $tag_modifier, &$output)
+    {
+        if (substr($tag_command, 0, 1) == '/') {
+            $start_tag = false;
+            $tag_command = substr($tag_command, 1);
+        } else
+            $start_tag = true;
+
+        $found = false;
+        $have_function = true;
+
+        /*
+         * First we check if the block function has already been registered
+         * or loaded from a plugin file.
+         */
+        if (isset($this->_plugins['block'][$tag_command])) {
+            $found = true;
+            $plugin_func = $this->_plugins['block'][$tag_command][0];
+            if (!is_callable($plugin_func)) {
+                $message = "block function '$tag_command' is not implemented";
+                $have_function = false;
+            }
+        }
+        /*
+         * Otherwise we need to load plugin file and look for the function
+         * inside it.
+         */
+        else if ($plugin_file = $this->_get_plugin_filepath('block', $tag_command)) {
+            $found = true;
+
+            include_once $plugin_file;
+
+            $plugin_func = 'smarty_block_' . $tag_command;
+            if (!function_exists($plugin_func)) {
+                $message = "plugin function $plugin_func() not found in $plugin_file\n";
+                $have_function = false;
+            } else {
+                $this->_plugins['block'][$tag_command] = array($plugin_func, null, null, null, true);
+
+            }
+        }
+
+        if (!$found) {
+            return false;
+        } else if (!$have_function) {
+            $this->_syntax_error($message, E_USER_WARNING, __FILE__, __LINE__);
+            return true;
+        }
+
+        /*
+         * Even though we've located the plugin function, compilation
+         * happens only once, so the plugin will still need to be loaded
+         * at runtime for future requests.
+         */
+        $this->_add_plugin('block', $tag_command);
+
+        if ($start_tag)
+            $this->_push_tag($tag_command);
+        else
+            $this->_pop_tag($tag_command);
+
+        if ($start_tag) {
+            $output = '<?php ' . $this->_push_cacheable_state('block', $tag_command);
+            $attrs = $this->_parse_attrs($tag_args);
+            $_cache_attrs='';
+            $arg_list = $this->_compile_arg_list('block', $tag_command, $attrs, $_cache_attrs);
+            $output .= "$_cache_attrs\$this->_tag_stack[] = array('$tag_command', array(".implode(',', $arg_list).')); ';
+            $output .= '$_block_repeat=true;' . $this->_compile_plugin_call('block', $tag_command).'($this->_tag_stack[count($this->_tag_stack)-1][1], null, $this, $_block_repeat);';
+            $output .= 'while ($_block_repeat) { ob_start(); ?>';
+        } else {
+            $output = '<?php $_block_content = ob_get_contents(); ob_end_clean(); ';
+            $_out_tag_text = $this->_compile_plugin_call('block', $tag_command).'($this->_tag_stack[count($this->_tag_stack)-1][1], $_block_content, $this, $_block_repeat)';
+            if ($tag_modifier != '') {
+                $this->_parse_modifiers($_out_tag_text, $tag_modifier);
+            }
+            $output .= '$_block_repeat=false;echo ' . $_out_tag_text . '; } ';
+            $output .= " array_pop(\$this->_tag_stack); " . $this->_pop_cacheable_state('block', $tag_command) . '?>';
+        }
+
+        return true;
+    }
+
+
+    /**
+     * compile custom function tag
+     *
+     * @param string $tag_command
+     * @param string $tag_args
+     * @param string $tag_modifier
+     * @return string
+     */
+    function _compile_custom_tag($tag_command, $tag_args, $tag_modifier, &$output)
+    {
+        $found = false;
+        $have_function = true;
+
+        /*
+         * First we check if the custom function has already been registered
+         * or loaded from a plugin file.
+         */
+        if (isset($this->_plugins['function'][$tag_command])) {
+            $found = true;
+            $plugin_func = $this->_plugins['function'][$tag_command][0];
+            if (!is_callable($plugin_func)) {
+                $message = "custom function '$tag_command' is not implemented";
+                $have_function = false;
+            }
+        }
+        /*
+         * Otherwise we need to load plugin file and look for the function
+         * inside it.
+         */
+        else if ($plugin_file = $this->_get_plugin_filepath('function', $tag_command)) {
+            $found = true;
+
+            include_once $plugin_file;
+
+            $plugin_func = 'smarty_function_' . $tag_command;
+            if (!function_exists($plugin_func)) {
+                $message = "plugin function $plugin_func() not found in $plugin_file\n";
+                $have_function = false;
+            } else {
+                $this->_plugins['function'][$tag_command] = array($plugin_func, null, null, null, true);
+
+            }
+        }
+
+        if (!$found) {
+            return false;
+        } else if (!$have_function) {
+            $this->_syntax_error($message, E_USER_WARNING, __FILE__, __LINE__);
+            return true;
+        }
+
+        /* declare plugin to be loaded on display of the template that
+           we compile right now */
+        $this->_add_plugin('function', $tag_command);
+
+        $_cacheable_state = $this->_push_cacheable_state('function', $tag_command);
+        $attrs = $this->_parse_attrs($tag_args);
+        $_cache_attrs = '';
+        $arg_list = $this->_compile_arg_list('function', $tag_command, $attrs, $_cache_attrs);
+
+        $output = $this->_compile_plugin_call('function', $tag_command).'(array('.implode(',', $arg_list)."), \$this)";
+        if($tag_modifier != '') {
+            $this->_parse_modifiers($output, $tag_modifier);
+        }
+
+        if($output != '') {
+            $output =  '<?php ' . $_cacheable_state . $_cache_attrs . 'echo ' . $output . ';'
+                . $this->_pop_cacheable_state('function', $tag_command) . "?>" . $this->_additional_newline;
+        }
+
+        return true;
+    }
+
+    /**
+     * compile a registered object tag
+     *
+     * @param string $tag_command
+     * @param array $attrs
+     * @param string $tag_modifier
+     * @return string
+     */
+    function _compile_registered_object_tag($tag_command, $attrs, $tag_modifier)
+    {
+        if (substr($tag_command, 0, 1) == '/') {
+            $start_tag = false;
+            $tag_command = substr($tag_command, 1);
+        } else {
+            $start_tag = true;
+        }
+
+        list($object, $obj_comp) = explode('->', $tag_command);
+
+        $arg_list = array();
+        if(count($attrs)) {
+            $_assign_var = false;
+            foreach ($attrs as $arg_name => $arg_value) {
+                if($arg_name == 'assign') {
+                    $_assign_var = $arg_value;
+                    unset($attrs['assign']);
+                    continue;
+                }
+                if (is_bool($arg_value))
+                    $arg_value = $arg_value ? 'true' : 'false';
+                $arg_list[] = "'$arg_name' => $arg_value";
+            }
+        }
+
+        if($this->_reg_objects[$object][2]) {
+            // smarty object argument format
+            $args = "array(".implode(',', (array)$arg_list)."), \$this";
+        } else {
+            // traditional argument format
+            $args = implode(',', array_values($attrs));
+            if (empty($args)) {
+                $args = '';
+            }
+        }
+
+        $prefix = '';
+        $postfix = '';
+        $newline = '';
+        if(!is_object($this->_reg_objects[$object][0])) {
+            $this->_trigger_fatal_error("registered '$object' is not an object" , $this->_current_file, $this->_current_line_no, __FILE__, __LINE__);
+        } elseif(!empty($this->_reg_objects[$object][1]) && !in_array($obj_comp, $this->_reg_objects[$object][1])) {
+            $this->_trigger_fatal_error("'$obj_comp' is not a registered component of object '$object'", $this->_current_file, $this->_current_line_no, __FILE__, __LINE__);
+        } elseif(method_exists($this->_reg_objects[$object][0], $obj_comp)) {
+            // method
+            if(in_array($obj_comp, $this->_reg_objects[$object][3])) {
+                // block method
+                if ($start_tag) {
+                    $prefix = "\$this->_tag_stack[] = array('$obj_comp', $args); ";
+                    $prefix .= "\$_block_repeat=true; \$this->_reg_objects['$object'][0]->$obj_comp(\$this->_tag_stack[count(\$this->_tag_stack)-1][1], null, \$this, \$_block_repeat); ";
+                    $prefix .= "while (\$_block_repeat) { ob_start();";
+                    $return = null;
+                    $postfix = '';
+                } else {
+                    $prefix = "\$_obj_block_content = ob_get_contents(); ob_end_clean(); \$_block_repeat=false;";
+                    $return = "\$this->_reg_objects['$object'][0]->$obj_comp(\$this->_tag_stack[count(\$this->_tag_stack)-1][1], \$_obj_block_content, \$this, \$_block_repeat)";
+                    $postfix = "} array_pop(\$this->_tag_stack);";
+                }
+            } else {
+                // non-block method
+                $return = "\$this->_reg_objects['$object'][0]->$obj_comp($args)";
+            }
+        } else {
+            // property
+            $return = "\$this->_reg_objects['$object'][0]->$obj_comp";
+        }
+
+        if($return != null) {
+            if($tag_modifier != '') {
+                $this->_parse_modifiers($return, $tag_modifier);
+            }
+
+            if(!empty($_assign_var)) {
+                $output = "\$this->assign('" . $this->_dequote($_assign_var) ."',  $return);";
+            } else {
+                $output = 'echo ' . $return . ';';
+                $newline = $this->_additional_newline;
+            }
+        } else {
+            $output = '';
+        }
+
+        return '<?php ' . $prefix . $output . $postfix . "?>" . $newline;
+    }
+
+    /**
+     * Compile {insert ...} tag
+     *
+     * @param string $tag_args
+     * @return string
+     */
+    function _compile_insert_tag($tag_args)
+    {
+        $attrs = $this->_parse_attrs($tag_args);
+        $name = $this->_dequote($attrs['name']);
+
+        if (empty($name)) {
+            return $this->_syntax_error("missing insert name", E_USER_ERROR, __FILE__, __LINE__);
+        }
+        
+        if (!preg_match('~^\w+$~', $name)) {
+            return $this->_syntax_error("'insert: 'name' must be an insert function name", E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        if (!empty($attrs['script'])) {
+            $delayed_loading = true;
+        } else {
+            $delayed_loading = false;
+        }
+
+        foreach ($attrs as $arg_name => $arg_value) {
+            if (is_bool($arg_value))
+                $arg_value = $arg_value ? 'true' : 'false';
+            $arg_list[] = "'$arg_name' => $arg_value";
+        }
+
+        $this->_add_plugin('insert', $name, $delayed_loading);
+
+        $_params = "array('args' => array(".implode(', ', (array)$arg_list)."))";
+
+        return "<?php require_once(SMARTY_CORE_DIR . 'core.run_insert_handler.php');\necho smarty_core_run_insert_handler($_params, \$this); ?>" . $this->_additional_newline;
+    }
+
+    /**
+     * Compile {include ...} tag
+     *
+     * @param string $tag_args
+     * @return string
+     */
+    function _compile_include_tag($tag_args)
+    {
+        $attrs = $this->_parse_attrs($tag_args);
+        $arg_list = array();
+
+        if (empty($attrs['file'])) {
+            $this->_syntax_error("missing 'file' attribute in include tag", E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        foreach ($attrs as $arg_name => $arg_value) {
+            if ($arg_name == 'file') {
+                $include_file = $arg_value;
+                continue;
+            } else if ($arg_name == 'assign') {
+                $assign_var = $arg_value;
+                continue;
+            }
+            if (is_bool($arg_value))
+                $arg_value = $arg_value ? 'true' : 'false';
+            $arg_list[] = "'$arg_name' => $arg_value";
+        }
+
+        $output = '<?php ';
+
+        if (isset($assign_var)) {
+            $output .= "ob_start();\n";
+        }
+
+        $output .=
+            "\$_smarty_tpl_vars = \$this->_tpl_vars;\n";
+
+
+        $_params = "array('smarty_include_tpl_file' => " . $include_file . ", 'smarty_include_vars' => array(".implode(',', (array)$arg_list)."))";
+        $output .= "\$this->_smarty_include($_params);\n" .
+        "\$this->_tpl_vars = \$_smarty_tpl_vars;\n" .
+        "unset(\$_smarty_tpl_vars);\n";
+
+        if (isset($assign_var)) {
+            $output .= "\$this->assign(" . $assign_var . ", ob_get_contents()); ob_end_clean();\n";
+        }
+
+        $output .= ' ?>';
+
+        return $output;
+
+    }
+
+    /**
+     * Compile {include ...} tag
+     *
+     * @param string $tag_args
+     * @return string
+     */
+    function _compile_include_php_tag($tag_args)
+    {
+        $attrs = $this->_parse_attrs($tag_args);
+
+        if (empty($attrs['file'])) {
+            $this->_syntax_error("missing 'file' attribute in include_php tag", E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        $assign_var = (empty($attrs['assign'])) ? '' : $this->_dequote($attrs['assign']);
+        $once_var = (empty($attrs['once']) || $attrs['once']=='false') ? 'false' : 'true';
+
+        $arg_list = array();
+        foreach($attrs as $arg_name => $arg_value) {
+            if($arg_name != 'file' AND $arg_name != 'once' AND $arg_name != 'assign') {
+                if(is_bool($arg_value))
+                    $arg_value = $arg_value ? 'true' : 'false';
+                $arg_list[] = "'$arg_name' => $arg_value";
+            }
+        }
+
+        $_params = "array('smarty_file' => " . $attrs['file'] . ", 'smarty_assign' => '$assign_var', 'smarty_once' => $once_var, 'smarty_include_vars' => array(".implode(',', $arg_list)."))";
+
+        return "<?php require_once(SMARTY_CORE_DIR . 'core.smarty_include_php.php');\nsmarty_core_smarty_include_php($_params, \$this); ?>" . $this->_additional_newline;
+    }
+
+
+    /**
+     * Compile {section ...} tag
+     *
+     * @param string $tag_args
+     * @return string
+     */
+    function _compile_section_start($tag_args)
+    {
+        $attrs = $this->_parse_attrs($tag_args);
+        $arg_list = array();
+
+        $output = '<?php ';
+        $section_name = $attrs['name'];
+        if (empty($section_name)) {
+            $this->_syntax_error("missing section name", E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        $output .= "unset(\$this->_sections[$section_name]);\n";
+        $section_props = "\$this->_sections[$section_name]";
+
+        foreach ($attrs as $attr_name => $attr_value) {
+            switch ($attr_name) {
+                case 'loop':
+                    $output .= "{$section_props}['loop'] = is_array(\$_loop=$attr_value) ? count(\$_loop) : max(0, (int)\$_loop); unset(\$_loop);\n";
+                    break;
+
+                case 'show':
+                    if (is_bool($attr_value))
+                        $show_attr_value = $attr_value ? 'true' : 'false';
+                    else
+                        $show_attr_value = "(bool)$attr_value";
+                    $output .= "{$section_props}['show'] = $show_attr_value;\n";
+                    break;
+
+                case 'name':
+                    $output .= "{$section_props}['$attr_name'] = $attr_value;\n";
+                    break;
+
+                case 'max':
+                case 'start':
+                    $output .= "{$section_props}['$attr_name'] = (int)$attr_value;\n";
+                    break;
+
+                case 'step':
+                    $output .= "{$section_props}['$attr_name'] = ((int)$attr_value) == 0 ? 1 : (int)$attr_value;\n";
+                    break;
+
+                default:
+                    $this->_syntax_error("unknown section attribute - '$attr_name'", E_USER_ERROR, __FILE__, __LINE__);
+                    break;
+            }
+        }
+
+        if (!isset($attrs['show']))
+            $output .= "{$section_props}['show'] = true;\n";
+
+        if (!isset($attrs['loop']))
+            $output .= "{$section_props}['loop'] = 1;\n";
+
+        if (!isset($attrs['max']))
+            $output .= "{$section_props}['max'] = {$section_props}['loop'];\n";
+        else
+            $output .= "if ({$section_props}['max'] < 0)\n" .
+                       "    {$section_props}['max'] = {$section_props}['loop'];\n";
+
+        if (!isset($attrs['step']))
+            $output .= "{$section_props}['step'] = 1;\n";
+
+        if (!isset($attrs['start']))
+            $output .= "{$section_props}['start'] = {$section_props}['step'] > 0 ? 0 : {$section_props}['loop']-1;\n";
+        else {
+            $output .= "if ({$section_props}['start'] < 0)\n" .
+                       "    {$section_props}['start'] = max({$section_props}['step'] > 0 ? 0 : -1, {$section_props}['loop'] + {$section_props}['start']);\n" .
+                       "else\n" .
+                       "    {$section_props}['start'] = min({$section_props}['start'], {$section_props}['step'] > 0 ? {$section_props}['loop'] : {$section_props}['loop']-1);\n";
+        }
+
+        $output .= "if ({$section_props}['show']) {\n";
+        if (!isset($attrs['start']) && !isset($attrs['step']) && !isset($attrs['max'])) {
+            $output .= "    {$section_props}['total'] = {$section_props}['loop'];\n";
+        } else {
+            $output .= "    {$section_props}['total'] = min(ceil(({$section_props}['step'] > 0 ? {$section_props}['loop'] - {$section_props}['start'] : {$section_props}['start']+1)/abs({$section_props}['step'])), {$section_props}['max']);\n";
+        }
+        $output .= "    if ({$section_props}['total'] == 0)\n" .
+                   "        {$section_props}['show'] = false;\n" .
+                   "} else\n" .
+                   "    {$section_props}['total'] = 0;\n";
+
+        $output .= "if ({$section_props}['show']):\n";
+        $output .= "
+            for ({$section_props}['index'] = {$section_props}['start'], {$section_props}['iteration'] = 1;
+                 {$section_props}['iteration'] <= {$section_props}['total'];
+                 {$section_props}['index'] += {$section_props}['step'], {$section_props}['iteration']++):\n";
+        $output .= "{$section_props}['rownum'] = {$section_props}['iteration'];\n";
+        $output .= "{$section_props}['index_prev'] = {$section_props}['index'] - {$section_props}['step'];\n";
+        $output .= "{$section_props}['index_next'] = {$section_props}['index'] + {$section_props}['step'];\n";
+        $output .= "{$section_props}['first']      = ({$section_props}['iteration'] == 1);\n";
+        $output .= "{$section_props}['last']       = ({$section_props}['iteration'] == {$section_props}['total']);\n";
+
+        $output .= "?>";
+
+        return $output;
+    }
+
+
+    /**
+     * Compile {foreach ...} tag.
+     *
+     * @param string $tag_args
+     * @return string
+     */
+    function _compile_foreach_start($tag_args)
+    {
+        $attrs = $this->_parse_attrs($tag_args);
+        $arg_list = array();
+
+        if (empty($attrs['from'])) {
+            return $this->_syntax_error("foreach: missing 'from' attribute", E_USER_ERROR, __FILE__, __LINE__);
+        }
+        $from = $attrs['from'];
+
+        if (empty($attrs['item'])) {
+            return $this->_syntax_error("foreach: missing 'item' attribute", E_USER_ERROR, __FILE__, __LINE__);
+        }
+        $item = $this->_dequote($attrs['item']);
+        if (!preg_match('~^\w+$~', $item)) {
+            return $this->_syntax_error("foreach: 'item' must be a variable name (literal string)", E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        if (isset($attrs['key'])) {
+            $key  = $this->_dequote($attrs['key']);
+            if (!preg_match('~^\w+$~', $key)) {
+                return $this->_syntax_error("foreach: 'key' must to be a variable name (literal string)", E_USER_ERROR, __FILE__, __LINE__);
+            }
+            $key_part = "\$this->_tpl_vars['$key'] => ";
+        } else {
+            $key = null;
+            $key_part = '';
+        }
+
+        if (isset($attrs['name'])) {
+            $name = $attrs['name'];
+        } else {
+            $name = null;
+        }
+
+        $output = '<?php ';
+        $output .= "\$_from = $from; if (!is_array(\$_from) && !is_object(\$_from)) { settype(\$_from, 'array'); }";
+        if (isset($name)) {
+            $foreach_props = "\$this->_foreach[$name]";
+            $output .= "{$foreach_props} = array('total' => count(\$_from), 'iteration' => 0);\n";
+            $output .= "if ({$foreach_props}['total'] > 0):\n";
+            $output .= "    foreach (\$_from as $key_part\$this->_tpl_vars['$item']):\n";
+            $output .= "        {$foreach_props}['iteration']++;\n";
+        } else {
+            $output .= "if (count(\$_from)):\n";
+            $output .= "    foreach (\$_from as $key_part\$this->_tpl_vars['$item']):\n";
+        }
+        $output .= '?>';
+
+        return $output;
+    }
+
+
+    /**
+     * Compile {capture} .. {/capture} tags
+     *
+     * @param boolean $start true if this is the {capture} tag
+     * @param string $tag_args
+     * @return string
+     */
+
+    function _compile_capture_tag($start, $tag_args = '')
+    {
+        $attrs = $this->_parse_attrs($tag_args);
+
+        if ($start) {
+            $buffer = isset($attrs['name']) ? $attrs['name'] : "'default'";
+            $assign = isset($attrs['assign']) ? $attrs['assign'] : null;
+            $append = isset($attrs['append']) ? $attrs['append'] : null;
+            
+            $output = "<?php ob_start(); ?>";
+            $this->_capture_stack[] = array($buffer, $assign, $append);
+        } else {
+            list($buffer, $assign, $append) = array_pop($this->_capture_stack);
+            $output = "<?php \$this->_smarty_vars['capture'][$buffer] = ob_get_contents(); ";
+            if (isset($assign)) {
+                $output .= " \$this->assign($assign, ob_get_contents());";
+            }
+            if (isset($append)) {
+                $output .= " \$this->append($append, ob_get_contents());";
+            }
+            $output .= "ob_end_clean(); ?>";
+        }
+
+        return $output;
+    }
+
+    /**
+     * Compile {if ...} tag
+     *
+     * @param string $tag_args
+     * @param boolean $elseif if true, uses elseif instead of if
+     * @return string
+     */
+    function _compile_if_tag($tag_args, $elseif = false)
+    {
+
+        /* Tokenize args for 'if' tag. */
+        preg_match_all('~(?>
+                ' . $this->_obj_call_regexp . '(?:' . $this->_mod_regexp . '*)? | # valid object call
+                ' . $this->_var_regexp . '(?:' . $this->_mod_regexp . '*)?    | # var or quoted string
+                \-?0[xX][0-9a-fA-F]+|\-?\d+(?:\.\d+)?|\.\d+|!==|===|==|!=|<>|<<|>>|<=|>=|\&\&|\|\||\(|\)|,|\!|\^|=|\&|\~|<|>|\||\%|\+|\-|\/|\*|\@    | # valid non-word token
+                \b\w+\b                                                        | # valid word token
+                \S+                                                           # anything else
+                )~x', $tag_args, $match);
+
+        $tokens = $match[0];
+
+        if(empty($tokens)) {
+            $_error_msg = $elseif ? "'elseif'" : "'if'";
+            $_error_msg .= ' statement requires arguments'; 
+            $this->_syntax_error($_error_msg, E_USER_ERROR, __FILE__, __LINE__);
+        }
+            
+                
+        // make sure we have balanced parenthesis
+        $token_count = array_count_values($tokens);
+        if(isset($token_count['(']) && $token_count['('] != $token_count[')']) {
+            $this->_syntax_error("unbalanced parenthesis in if statement", E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        $is_arg_stack = array();
+
+        for ($i = 0; $i < count($tokens); $i++) {
+
+            $token = &$tokens[$i];
+
+            switch (strtolower($token)) {
+                case '!':
+                case '%':
+                case '!==':
+                case '==':
+                case '===':
+                case '>':
+                case '<':
+                case '!=':
+                case '<>':
+                case '<<':
+                case '>>':
+                case '<=':
+                case '>=':
+                case '&&':
+                case '||':
+                case '|':
+                case '^':
+                case '&':
+                case '~':
+                case ')':
+                case ',':
+                case '+':
+                case '-':
+                case '*':
+                case '/':
+                case '@':
+                    break;
+
+                case 'eq':
+                    $token = '==';
+                    break;
+
+                case 'ne':
+                case 'neq':
+                    $token = '!=';
+                    break;
+
+                case 'lt':
+                    $token = '<';
+                    break;
+
+                case 'le':
+                case 'lte':
+                    $token = '<=';
+                    break;
+
+                case 'gt':
+                    $token = '>';
+                    break;
+
+                case 'ge':
+                case 'gte':
+                    $token = '>=';
+                    break;
+
+                case 'and':
+                    $token = '&&';
+                    break;
+
+                case 'or':
+                    $token = '||';
+                    break;
+
+                case 'not':
+                    $token = '!';
+                    break;
+
+                case 'mod':
+                    $token = '%';
+                    break;
+
+                case '(':
+                    array_push($is_arg_stack, $i);
+                    break;
+
+                case 'is':
+                    /* If last token was a ')', we operate on the parenthesized
+                       expression. The start of the expression is on the stack.
+                       Otherwise, we operate on the last encountered token. */
+                    if ($tokens[$i-1] == ')') {
+                        $is_arg_start = array_pop($is_arg_stack);
+                        if ($is_arg_start != 0) {
+                            if (preg_match('~^' . $this->_func_regexp . '$~', $tokens[$is_arg_start-1])) {
+                                $is_arg_start--;
+                            } 
+                        } 
+                    } else
+                        $is_arg_start = $i-1;
+                    /* Construct the argument for 'is' expression, so it knows
+                       what to operate on. */
+                    $is_arg = implode(' ', array_slice($tokens, $is_arg_start, $i - $is_arg_start));
+
+                    /* Pass all tokens from next one until the end to the
+                       'is' expression parsing function. The function will
+                       return modified tokens, where the first one is the result
+                       of the 'is' expression and the rest are the tokens it
+                       didn't touch. */
+                    $new_tokens = $this->_parse_is_expr($is_arg, array_slice($tokens, $i+1));
+
+                    /* Replace the old tokens with the new ones. */
+                    array_splice($tokens, $is_arg_start, count($tokens), $new_tokens);
+
+                    /* Adjust argument start so that it won't change from the
+                       current position for the next iteration. */
+                    $i = $is_arg_start;
+                    break;
+
+                default:
+                    if(preg_match('~^' . $this->_func_regexp . '$~', $token) ) {
+                            // function call
+                            if($this->security &&
+                               !in_array($token, $this->security_settings['IF_FUNCS'])) {
+                                $this->_syntax_error("(secure mode) '$token' not allowed in if statement", E_USER_ERROR, __FILE__, __LINE__);
+                            }
+                    } elseif(preg_match('~^' . $this->_var_regexp . '$~', $token) && (strpos('+-*/^%&|', substr($token, -1)) === false) && isset($tokens[$i+1]) && $tokens[$i+1] == '(') {
+                        // variable function call
+                        $this->_syntax_error("variable function call '$token' not allowed in if statement", E_USER_ERROR, __FILE__, __LINE__);                      
+                    } elseif(preg_match('~^' . $this->_obj_call_regexp . '|' . $this->_var_regexp . '(?:' . $this->_mod_regexp . '*)$~', $token)) {
+                        // object or variable
+                        $token = $this->_parse_var_props($token);
+                    } elseif(is_numeric($token)) {
+                        // number, skip it
+                    } else {
+                        $this->_syntax_error("unidentified token '$token'", E_USER_ERROR, __FILE__, __LINE__);
+                    }
+                    break;
+            }
+        }
+
+        if ($elseif)
+            return '<?php elseif ('.implode(' ', $tokens).'): ?>';
+        else
+            return '<?php if ('.implode(' ', $tokens).'): ?>';
+    }
+
+
+    function _compile_arg_list($type, $name, $attrs, &$cache_code) {
+        $arg_list = array();
+
+        if (isset($type) && isset($name)
+            && isset($this->_plugins[$type])
+            && isset($this->_plugins[$type][$name])
+            && empty($this->_plugins[$type][$name][4])
+            && is_array($this->_plugins[$type][$name][5])
+            ) {
+            /* we have a list of parameters that should be cached */
+            $_cache_attrs = $this->_plugins[$type][$name][5];
+            $_count = $this->_cache_attrs_count++;
+            $cache_code = "\$_cache_attrs =& \$this->_smarty_cache_attrs('$this->_cache_serial','$_count');";
+
+        } else {
+            /* no parameters are cached */
+            $_cache_attrs = null;
+        }
+
+        foreach ($attrs as $arg_name => $arg_value) {
+            if (is_bool($arg_value))
+                $arg_value = $arg_value ? 'true' : 'false';
+            if (is_null($arg_value))
+                $arg_value = 'null';
+            if ($_cache_attrs && in_array($arg_name, $_cache_attrs)) {
+                $arg_list[] = "'$arg_name' => (\$this->_cache_including) ? \$_cache_attrs['$arg_name'] : (\$_cache_attrs['$arg_name']=$arg_value)";
+            } else {
+                $arg_list[] = "'$arg_name' => $arg_value";
+            }
+        }
+        return $arg_list;
+    }
+
+    /**
+     * Parse is expression
+     *
+     * @param string $is_arg
+     * @param array $tokens
+     * @return array
+     */
+    function _parse_is_expr($is_arg, $tokens)
+    {
+        $expr_end = 0;
+        $negate_expr = false;
+
+        if (($first_token = array_shift($tokens)) == 'not') {
+            $negate_expr = true;
+            $expr_type = array_shift($tokens);
+        } else
+            $expr_type = $first_token;
+
+        switch ($expr_type) {
+            case 'even':
+                if (isset($tokens[$expr_end]) && $tokens[$expr_end] == 'by') {
+                    $expr_end++;
+                    $expr_arg = $tokens[$expr_end++];
+                    $expr = "!(1 & ($is_arg / " . $this->_parse_var_props($expr_arg) . "))";
+                } else
+                    $expr = "!(1 & $is_arg)";
+                break;
+
+            case 'odd':
+                if (isset($tokens[$expr_end]) && $tokens[$expr_end] == 'by') {
+                    $expr_end++;
+                    $expr_arg = $tokens[$expr_end++];
+                    $expr = "(1 & ($is_arg / " . $this->_parse_var_props($expr_arg) . "))";
+                } else
+                    $expr = "(1 & $is_arg)";
+                break;
+
+            case 'div':
+                if (@$tokens[$expr_end] == 'by') {
+                    $expr_end++;
+                    $expr_arg = $tokens[$expr_end++];
+                    $expr = "!($is_arg % " . $this->_parse_var_props($expr_arg) . ")";
+                } else {
+                    $this->_syntax_error("expecting 'by' after 'div'", E_USER_ERROR, __FILE__, __LINE__);
+                }
+                break;
+
+            default:
+                $this->_syntax_error("unknown 'is' expression - '$expr_type'", E_USER_ERROR, __FILE__, __LINE__);
+                break;
+        }
+
+        if ($negate_expr) {
+            $expr = "!($expr)";
+        }
+
+        array_splice($tokens, 0, $expr_end, $expr);
+
+        return $tokens;
+    }
+
+
+    /**
+     * Parse attribute string
+     *
+     * @param string $tag_args
+     * @return array
+     */
+    function _parse_attrs($tag_args)
+    {
+
+        /* Tokenize tag attributes. */
+        preg_match_all('~(?:' . $this->_obj_call_regexp . '|' . $this->_qstr_regexp . ' | (?>[^"\'=\s]+)
+                         )+ |
+                         [=]
+                        ~x', $tag_args, $match);
+        $tokens       = $match[0];
+
+        $attrs = array();
+        /* Parse state:
+            0 - expecting attribute name
+            1 - expecting '='
+            2 - expecting attribute value (not '=') */
+        $state = 0;
+
+        foreach ($tokens as $token) {
+            switch ($state) {
+                case 0:
+                    /* If the token is a valid identifier, we set attribute name
+                       and go to state 1. */
+                    if (preg_match('~^\w+$~', $token)) {
+                        $attr_name = $token;
+                        $state = 1;
+                    } else
+                        $this->_syntax_error("invalid attribute name: '$token'", E_USER_ERROR, __FILE__, __LINE__);
+                    break;
+
+                case 1:
+                    /* If the token is '=', then we go to state 2. */
+                    if ($token == '=') {
+                        $state = 2;
+                    } else
+                        $this->_syntax_error("expecting '=' after attribute name '$last_token'", E_USER_ERROR, __FILE__, __LINE__);
+                    break;
+
+                case 2:
+                    /* If token is not '=', we set the attribute value and go to
+                       state 0. */
+                    if ($token != '=') {
+                        /* We booleanize the token if it's a non-quoted possible
+                           boolean value. */
+                        if (preg_match('~^(on|yes|true)$~', $token)) {
+                            $token = 'true';
+                        } else if (preg_match('~^(off|no|false)$~', $token)) {
+                            $token = 'false';
+                        } else if ($token == 'null') {
+                            $token = 'null';
+                        } else if (preg_match('~^' . $this->_num_const_regexp . '|0[xX][0-9a-fA-F]+$~', $token)) {
+                            /* treat integer literally */
+                        } else if (!preg_match('~^' . $this->_obj_call_regexp . '|' . $this->_var_regexp . '(?:' . $this->_mod_regexp . ')*$~', $token)) {
+                            /* treat as a string, double-quote it escaping quotes */
+                            $token = '"'.addslashes($token).'"';
+                        }
+
+                        $attrs[$attr_name] = $token;
+                        $state = 0;
+                    } else
+                        $this->_syntax_error("'=' cannot be an attribute value", E_USER_ERROR, __FILE__, __LINE__);
+                    break;
+            }
+            $last_token = $token;
+        }
+
+        if($state != 0) {
+            if($state == 1) {
+                $this->_syntax_error("expecting '=' after attribute name '$last_token'", E_USER_ERROR, __FILE__, __LINE__);
+            } else {
+                $this->_syntax_error("missing attribute value", E_USER_ERROR, __FILE__, __LINE__);
+            }
+        }
+
+        $this->_parse_vars_props($attrs);
+
+        return $attrs;
+    }
+
+    /**
+     * compile multiple variables and section properties tokens into
+     * PHP code
+     *
+     * @param array $tokens
+     */
+    function _parse_vars_props(&$tokens)
+    {
+        foreach($tokens as $key => $val) {
+            $tokens[$key] = $this->_parse_var_props($val);
+        }
+    }
+
+    /**
+     * compile single variable and section properties token into
+     * PHP code
+     *
+     * @param string $val
+     * @param string $tag_attrs
+     * @return string
+     */
+    function _parse_var_props($val)
+    {
+        $val = trim($val);
+
+        if(preg_match('~^(' . $this->_obj_call_regexp . '|' . $this->_dvar_regexp . ')(' . $this->_mod_regexp . '*)$~', $val, $match)) {
+            // $ variable or object
+            $return = $this->_parse_var($match[1]);
+            $modifiers = $match[2];
+            if (!empty($this->default_modifiers) && !preg_match('~(^|\|)smarty:nodefaults($|\|)~',$modifiers)) {
+                $_default_mod_string = implode('|',(array)$this->default_modifiers);
+                $modifiers = empty($modifiers) ? $_default_mod_string : $_default_mod_string . '|' . $modifiers;
+            }
+            $this->_parse_modifiers($return, $modifiers);
+            return $return;
+        } elseif (preg_match('~^' . $this->_db_qstr_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
+                // double quoted text
+                preg_match('~^(' . $this->_db_qstr_regexp . ')('. $this->_mod_regexp . '*)$~', $val, $match);
+                $return = $this->_expand_quoted_text($match[1]);
+                if($match[2] != '') {
+                    $this->_parse_modifiers($return, $match[2]);
+                }
+                return $return;
+            }
+        elseif(preg_match('~^' . $this->_num_const_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
+                // numerical constant
+                preg_match('~^(' . $this->_num_const_regexp . ')('. $this->_mod_regexp . '*)$~', $val, $match);
+                if($match[2] != '') {
+                    $this->_parse_modifiers($match[1], $match[2]);
+                    return $match[1];
+                }
+            }
+        elseif(preg_match('~^' . $this->_si_qstr_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
+                // single quoted text
+                preg_match('~^(' . $this->_si_qstr_regexp . ')('. $this->_mod_regexp . '*)$~', $val, $match);
+                if($match[2] != '') {
+                    $this->_parse_modifiers($match[1], $match[2]);
+                    return $match[1];
+                }
+            }
+        elseif(preg_match('~^' . $this->_cvar_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
+                // config var
+                return $this->_parse_conf_var($val);
+            }
+        elseif(preg_match('~^' . $this->_svar_regexp . '(?:' . $this->_mod_regexp . '*)$~', $val)) {
+                // section var
+                return $this->_parse_section_prop($val);
+            }
+        elseif(!in_array($val, $this->_permitted_tokens) && !is_numeric($val)) {
+            // literal string
+            return $this->_expand_quoted_text('"' . strtr($val, array('\\' => '\\\\', '"' => '\\"')) .'"');
+        }
+        return $val;
+    }
+
+    /**
+     * expand quoted text with embedded variables
+     *
+     * @param string $var_expr
+     * @return string
+     */
+    function _expand_quoted_text($var_expr)
+    {
+        // if contains unescaped $, expand it
+        if(preg_match_all('~(?:\`(?<!\\\\)\$' . $this->_dvar_guts_regexp . '(?:' . $this->_obj_ext_regexp . ')*\`)|(?:(?<!\\\\)\$\w+(\[[a-zA-Z0-9]+\])*)~', $var_expr, $_match)) {
+            $_match = $_match[0];
+            $_replace = array();
+            foreach($_match as $_var) {
+                $_replace[$_var] = '".(' . $this->_parse_var(str_replace('`','',$_var)) . ')."';
+            }
+            $var_expr = strtr($var_expr, $_replace);
+            $_return = preg_replace('~\.""|(?<!\\\\)""\.~', '', $var_expr);
+        } else {
+            $_return = $var_expr;
+        }
+        // replace double quoted literal string with single quotes
+        $_return = preg_replace('~^"([\s\w]+)"$~',"'\\1'",$_return);
+        return $_return;
+    }
+
+    /**
+     * parse variable expression into PHP code
+     *
+     * @param string $var_expr
+     * @param string $output
+     * @return string
+     */
+    function _parse_var($var_expr)
+    {
+        $_has_math = false;
+        $_math_vars = preg_split('~('.$this->_dvar_math_regexp.'|'.$this->_qstr_regexp.')~', $var_expr, -1, PREG_SPLIT_DELIM_CAPTURE);
+
+        if(count($_math_vars) > 1) {
+            $_first_var = "";
+            $_complete_var = "";
+            $_output = "";
+            // simple check if there is any math, to stop recursion (due to modifiers with "xx % yy" as parameter)
+            foreach($_math_vars as $_k => $_math_var) {
+                $_math_var = $_math_vars[$_k];
+
+                if(!empty($_math_var) || is_numeric($_math_var)) {
+                    // hit a math operator, so process the stuff which came before it
+                    if(preg_match('~^' . $this->_dvar_math_regexp . '$~', $_math_var)) {
+                        $_has_math = true;
+                        if(!empty($_complete_var) || is_numeric($_complete_var)) {
+                            $_output .= $this->_parse_var($_complete_var);
+                        }
+
+                        // just output the math operator to php
+                        $_output .= $_math_var;
+
+                        if(empty($_first_var))
+                            $_first_var = $_complete_var;
+
+                        $_complete_var = "";
+                    } else {
+                        $_complete_var .= $_math_var;
+                    }
+                }
+            }
+            if($_has_math) {
+                if(!empty($_complete_var) || is_numeric($_complete_var))
+                    $_output .= $this->_parse_var($_complete_var);
+
+                // get the modifiers working (only the last var from math + modifier is left)
+                $var_expr = $_complete_var;
+            }
+        }
+
+        // prevent cutting of first digit in the number (we _definitly_ got a number if the first char is a digit)
+        if(is_numeric(substr($var_expr, 0, 1)))
+            $_var_ref = $var_expr;
+        else
+            $_var_ref = substr($var_expr, 1);
+        
+        if(!$_has_math) {
+            
+            // get [foo] and .foo and ->foo and (...) pieces
+            preg_match_all('~(?:^\w+)|' . $this->_obj_params_regexp . '|(?:' . $this->_var_bracket_regexp . ')|->\$?\w+|\.\$?\w+|\S+~', $_var_ref, $match);
+                        
+            $_indexes = $match[0];
+            $_var_name = array_shift($_indexes);
+
+            /* Handle $smarty.* variable references as a special case. */
+            if ($_var_name == 'smarty') {
+                /*
+                 * If the reference could be compiled, use the compiled output;
+                 * otherwise, fall back on the $smarty variable generated at
+                 * run-time.
+                 */
+                if (($smarty_ref = $this->_compile_smarty_ref($_indexes)) !== null) {
+                    $_output = $smarty_ref;
+                } else {
+                    $_var_name = substr(array_shift($_indexes), 1);
+                    $_output = "\$this->_smarty_vars['$_var_name']";
+                }
+            } elseif(is_numeric($_var_name) && is_numeric(substr($var_expr, 0, 1))) {
+                // because . is the operator for accessing arrays thru inidizes we need to put it together again for floating point numbers
+                if(count($_indexes) > 0)
+                {
+                    $_var_name .= implode("", $_indexes);
+                    $_indexes = array();
+                }
+                $_output = $_var_name;
+            } else {
+                $_output = "\$this->_tpl_vars['$_var_name']";
+            }
+
+            foreach ($_indexes as $_index) {
+                if (substr($_index, 0, 1) == '[') {
+                    $_index = substr($_index, 1, -1);
+                    if (is_numeric($_index)) {
+                        $_output .= "[$_index]";
+                    } elseif (substr($_index, 0, 1) == '$') {
+                        if (strpos($_index, '.') !== false) {
+                            $_output .= '[' . $this->_parse_var($_index) . ']';
+                        } else {
+                            $_output .= "[\$this->_tpl_vars['" . substr($_index, 1) . "']]";
+                        }
+                    } else {
+                        $_var_parts = explode('.', $_index);
+                        $_var_section = $_var_parts[0];
+                        $_var_section_prop = isset($_var_parts[1]) ? $_var_parts[1] : 'index';
+                        $_output .= "[\$this->_sections['$_var_section']['$_var_section_prop']]";
+                    }
+                } else if (substr($_index, 0, 1) == '.') {
+                    if (substr($_index, 1, 1) == '$')
+                        $_output .= "[\$this->_tpl_vars['" . substr($_index, 2) . "']]";
+                    else
+                        $_output .= "['" . substr($_index, 1) . "']";
+                } else if (substr($_index,0,2) == '->') {
+                    if(substr($_index,2,2) == '__') {
+                        $this->_syntax_error('call to internal object members is not allowed', E_USER_ERROR, __FILE__, __LINE__);
+                    } elseif($this->security && substr($_index, 2, 1) == '_') {
+                        $this->_syntax_error('(secure) call to private object member is not allowed', E_USER_ERROR, __FILE__, __LINE__);
+                    } elseif (substr($_index, 2, 1) == '$') {
+                        if ($this->security) {
+                            $this->_syntax_error('(secure) call to dynamic object member is not allowed', E_USER_ERROR, __FILE__, __LINE__);
+                        } else {
+                            $_output .= '->{(($_var=$this->_tpl_vars[\''.substr($_index,3).'\']) && substr($_var,0,2)!=\'__\') ? $_var : $this->trigger_error("cannot access property \\"$_var\\"")}';
+                        }
+                    } else {
+                        $_output .= $_index;
+                    }
+                } elseif (substr($_index, 0, 1) == '(') {
+                    $_index = $this->_parse_parenth_args($_index);
+                    $_output .= $_index;
+                } else {
+                    $_output .= $_index;
+                }
+            }
+        }
+
+        return $_output;
+    }
+
+    /**
+     * parse arguments in function call parenthesis
+     *
+     * @param string $parenth_args
+     * @return string
+     */
+    function _parse_parenth_args($parenth_args)
+    {
+        preg_match_all('~' . $this->_param_regexp . '~',$parenth_args, $match);
+        $orig_vals = $match = $match[0];
+        $this->_parse_vars_props($match);
+        $replace = array();
+        for ($i = 0, $count = count($match); $i < $count; $i++) {
+            $replace[$orig_vals[$i]] = $match[$i];
+        }
+        return strtr($parenth_args, $replace);
+    }
+
+    /**
+     * parse configuration variable expression into PHP code
+     *
+     * @param string $conf_var_expr
+     */
+    function _parse_conf_var($conf_var_expr)
+    {
+        $parts = explode('|', $conf_var_expr, 2);
+        $var_ref = $parts[0];
+        $modifiers = isset($parts[1]) ? $parts[1] : '';
+
+        $var_name = substr($var_ref, 1, -1);
+
+        $output = "\$this->_config[0]['vars']['$var_name']";
+
+        $this->_parse_modifiers($output, $modifiers);
+
+        return $output;
+    }
+
+    /**
+     * parse section property expression into PHP code
+     *
+     * @param string $section_prop_expr
+     * @return string
+     */
+    function _parse_section_prop($section_prop_expr)
+    {
+        $parts = explode('|', $section_prop_expr, 2);
+        $var_ref = $parts[0];
+        $modifiers = isset($parts[1]) ? $parts[1] : '';
+
+        preg_match('!%(\w+)\.(\w+)%!', $var_ref, $match);
+        $section_name = $match[1];
+        $prop_name = $match[2];
+
+        $output = "\$this->_sections['$section_name']['$prop_name']";
+
+        $this->_parse_modifiers($output, $modifiers);
+
+        return $output;
+    }
+
+
+    /**
+     * parse modifier chain into PHP code
+     *
+     * sets $output to parsed modified chain
+     * @param string $output
+     * @param string $modifier_string
+     */
+    function _parse_modifiers(&$output, $modifier_string)
+    {
+        preg_match_all('~\|(@?\w+)((?>:(?:'. $this->_qstr_regexp . '|[^|]+))*)~', '|' . $modifier_string, $_match);
+        list(, $_modifiers, $modifier_arg_strings) = $_match;
+
+        for ($_i = 0, $_for_max = count($_modifiers); $_i < $_for_max; $_i++) {
+            $_modifier_name = $_modifiers[$_i];
+
+            if($_modifier_name == 'smarty') {
+                // skip smarty modifier
+                continue;
+            }
+
+            preg_match_all('~:(' . $this->_qstr_regexp . '|[^:]+)~', $modifier_arg_strings[$_i], $_match);
+            $_modifier_args = $_match[1];
+
+            if (substr($_modifier_name, 0, 1) == '@') {
+                $_map_array = false;
+                $_modifier_name = substr($_modifier_name, 1);
+            } else {
+                $_map_array = true;
+            }
+
+            if (empty($this->_plugins['modifier'][$_modifier_name])
+                && !$this->_get_plugin_filepath('modifier', $_modifier_name)
+                && function_exists($_modifier_name)) {
+                if ($this->security && !in_array($_modifier_name, $this->security_settings['MODIFIER_FUNCS'])) {
+                    $this->_trigger_fatal_error("[plugin] (secure mode) modifier '$_modifier_name' is not allowed" , $this->_current_file, $this->_current_line_no, __FILE__, __LINE__);
+                } else {
+                    $this->_plugins['modifier'][$_modifier_name] = array($_modifier_name,  null, null, false);
+                }
+            }
+            $this->_add_plugin('modifier', $_modifier_name);
+
+            $this->_parse_vars_props($_modifier_args);
+
+            if($_modifier_name == 'default') {
+                // supress notifications of default modifier vars and args
+                if(substr($output, 0, 1) == '$') {
+                    $output = '@' . $output;
+                }
+                if(isset($_modifier_args[0]) && substr($_modifier_args[0], 0, 1) == '$') {
+                    $_modifier_args[0] = '@' . $_modifier_args[0];
+                }
+            }
+            if (count($_modifier_args) > 0)
+                $_modifier_args = ', '.implode(', ', $_modifier_args);
+            else
+                $_modifier_args = '';
+
+            if ($_map_array) {
+                $output = "((is_array(\$_tmp=$output)) ? \$this->_run_mod_handler('$_modifier_name', true, \$_tmp$_modifier_args) : " . $this->_compile_plugin_call('modifier', $_modifier_name) . "(\$_tmp$_modifier_args))";
+
+            } else {
+
+                $output = $this->_compile_plugin_call('modifier', $_modifier_name)."($output$_modifier_args)";
+
+            }
+        }
+    }
+
+
+    /**
+     * add plugin
+     *
+     * @param string $type
+     * @param string $name
+     * @param boolean? $delayed_loading
+     */
+    function _add_plugin($type, $name, $delayed_loading = null)
+    {
+        if (!isset($this->_plugin_info[$type])) {
+            $this->_plugin_info[$type] = array();
+        }
+        if (!isset($this->_plugin_info[$type][$name])) {
+            $this->_plugin_info[$type][$name] = array($this->_current_file,
+                                                      $this->_current_line_no,
+                                                      $delayed_loading);
+        }
+    }
+
+
+    /**
+     * Compiles references of type $smarty.foo
+     *
+     * @param string $indexes
+     * @return string
+     */
+    function _compile_smarty_ref(&$indexes)
+    {
+        /* Extract the reference name. */
+        $_ref = substr($indexes[0], 1);
+        foreach($indexes as $_index_no=>$_index) {
+            if (substr($_index, 0, 1) != '.' && $_index_no<2 || !preg_match('~^(\.|\[|->)~', $_index)) {
+                $this->_syntax_error('$smarty' . implode('', array_slice($indexes, 0, 2)) . ' is an invalid reference', E_USER_ERROR, __FILE__, __LINE__);
+            }
+        }
+
+        switch ($_ref) {
+            case 'now':
+                $compiled_ref = 'time()';
+                $_max_index = 1;
+                break;
+
+            case 'foreach':
+                array_shift($indexes);
+                $_var = $this->_parse_var_props(substr($indexes[0], 1));
+                $_propname = substr($indexes[1], 1);
+                $_max_index = 1;
+                switch ($_propname) {
+                    case 'index':
+                        array_shift($indexes);
+                        $compiled_ref = "(\$this->_foreach[$_var]['iteration']-1)";
+                        break;
+                        
+                    case 'first':
+                        array_shift($indexes);
+                        $compiled_ref = "(\$this->_foreach[$_var]['iteration'] <= 1)";
+                        break;
+
+                    case 'last':
+                        array_shift($indexes);
+                        $compiled_ref = "(\$this->_foreach[$_var]['iteration'] == \$this->_foreach[$_var]['total'])";
+                        break;
+                        
+                    case 'show':
+                        array_shift($indexes);
+                        $compiled_ref = "(\$this->_foreach[$_var]['total'] > 0)";
+                        break;
+                        
+                    default:
+                        unset($_max_index);
+                        $compiled_ref = "\$this->_foreach[$_var]";
+                }
+                break;
+
+            case 'section':
+                array_shift($indexes);
+                $_var = $this->_parse_var_props(substr($indexes[0], 1));
+                $compiled_ref = "\$this->_sections[$_var]";
+                break;
+
+            case 'get':
+                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
+                    $this->_syntax_error("(secure mode) super global access not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                $compiled_ref = "\$_GET";
+                break;
+
+            case 'post':
+                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
+                    $this->_syntax_error("(secure mode) super global access not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                $compiled_ref = "\$_POST";
+                break;
+
+            case 'cookies':
+                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
+                    $this->_syntax_error("(secure mode) super global access not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                $compiled_ref = "\$_COOKIE";
+                break;
+
+            case 'env':
+                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
+                    $this->_syntax_error("(secure mode) super global access not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                $compiled_ref = "\$_ENV";
+                break;
+
+            case 'server':
+                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
+                    $this->_syntax_error("(secure mode) super global access not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                $compiled_ref = "\$_SERVER";
+                break;
+
+            case 'session':
+                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
+                    $this->_syntax_error("(secure mode) super global access not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                $compiled_ref = "\$_SESSION";
+                break;
+
+            /*
+             * These cases are handled either at run-time or elsewhere in the
+             * compiler.
+             */
+            case 'request':
+                if ($this->security && !$this->security_settings['ALLOW_SUPER_GLOBALS']) {
+                    $this->_syntax_error("(secure mode) super global access not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                if ($this->request_use_auto_globals) {
+                    $compiled_ref = "\$_REQUEST";
+                    break;
+                } else {
+                    $this->_init_smarty_vars = true;
+                }
+                return null;
+
+            case 'capture':
+                return null;
+
+            case 'template':
+                $compiled_ref = "'" . addslashes($this->_current_file) . "'";
+                $_max_index = 1;
+                break;
+
+            case 'version':
+                $compiled_ref = "'$this->_version'";
+                $_max_index = 1;
+                break;
+
+            case 'const':
+                if ($this->security && !$this->security_settings['ALLOW_CONSTANTS']) {
+                    $this->_syntax_error("(secure mode) constants not permitted",
+                                         E_USER_WARNING, __FILE__, __LINE__);
+                    return;
+                }
+                array_shift($indexes);
+                if (preg_match('!^\.\w+$!', $indexes[0])) {
+                    $compiled_ref = '@' . substr($indexes[0], 1);
+                } else {
+                    $_val = $this->_parse_var_props(substr($indexes[0], 1));
+                    $compiled_ref = '@constant(' . $_val . ')';
+                }
+                $_max_index = 1;
+                break;
+
+            case 'config':
+                $compiled_ref = "\$this->_config[0]['vars']";
+                $_max_index = 3;
+                break;
+
+            case 'ldelim':
+                $compiled_ref = "'$this->left_delimiter'";
+                break;
+
+            case 'rdelim':
+                $compiled_ref = "'$this->right_delimiter'";
+                break;
+                
+            default:
+                $this->_syntax_error('$smarty.' . $_ref . ' is an unknown reference', E_USER_ERROR, __FILE__, __LINE__);
+                break;
+        }
+
+        if (isset($_max_index) && count($indexes) > $_max_index) {
+            $this->_syntax_error('$smarty' . implode('', $indexes) .' is an invalid reference', E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        array_shift($indexes);
+        return $compiled_ref;
+    }
+
+    /**
+     * compiles call to plugin of type $type with name $name
+     * returns a string containing the function-name or method call
+     * without the paramter-list that would have follow to make the
+     * call valid php-syntax
+     *
+     * @param string $type
+     * @param string $name
+     * @return string
+     */
+    function _compile_plugin_call($type, $name) {
+        if (isset($this->_plugins[$type][$name])) {
+            /* plugin loaded */
+            if (is_array($this->_plugins[$type][$name][0])) {
+                return ((is_object($this->_plugins[$type][$name][0][0])) ?
+                        "\$this->_plugins['$type']['$name'][0][0]->"    /* method callback */
+                        : (string)($this->_plugins[$type][$name][0][0]).'::'    /* class callback */
+                       ). $this->_plugins[$type][$name][0][1];
+
+            } else {
+                /* function callback */
+                return $this->_plugins[$type][$name][0];
+
+            }
+        } else {
+            /* plugin not loaded -> auto-loadable-plugin */
+            return 'smarty_'.$type.'_'.$name;
+
+        }
+    }
+
+    /**
+     * load pre- and post-filters
+     */
+    function _load_filters()
+    {
+        if (count($this->_plugins['prefilter']) > 0) {
+            foreach ($this->_plugins['prefilter'] as $filter_name => $prefilter) {
+                if ($prefilter === false) {
+                    unset($this->_plugins['prefilter'][$filter_name]);
+                    $_params = array('plugins' => array(array('prefilter', $filter_name, null, null, false)));
+                    require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
+                    smarty_core_load_plugins($_params, $this);
+                }
+            }
+        }
+        if (count($this->_plugins['postfilter']) > 0) {
+            foreach ($this->_plugins['postfilter'] as $filter_name => $postfilter) {
+                if ($postfilter === false) {
+                    unset($this->_plugins['postfilter'][$filter_name]);
+                    $_params = array('plugins' => array(array('postfilter', $filter_name, null, null, false)));
+                    require_once(SMARTY_CORE_DIR . 'core.load_plugins.php');
+                    smarty_core_load_plugins($_params, $this);
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Quote subpattern references
+     *
+     * @param string $string
+     * @return string
+     */
+    function _quote_replace($string)
+    {
+        return strtr($string, array('\\' => '\\\\', '$' => '\\$'));
+    }
+
+    /**
+     * display Smarty syntax error
+     *
+     * @param string $error_msg
+     * @param integer $error_type
+     * @param string $file
+     * @param integer $line
+     */
+    function _syntax_error($error_msg, $error_type = E_USER_ERROR, $file=null, $line=null)
+    {
+        $this->_trigger_fatal_error("syntax error: $error_msg", $this->_current_file, $this->_current_line_no, $file, $line, $error_type);
+    }
+
+
+    /**
+     * check if the compilation changes from cacheable to
+     * non-cacheable state with the beginning of the current
+     * plugin. return php-code to reflect the transition.
+     * @return string
+     */
+    function _push_cacheable_state($type, $name) {
+        $_cacheable = !isset($this->_plugins[$type][$name]) || $this->_plugins[$type][$name][4];
+        if ($_cacheable
+            || 0<$this->_cacheable_state++) return '';
+        if (!isset($this->_cache_serial)) $this->_cache_serial = md5(uniqid('Smarty'));
+        $_ret = 'if ($this->caching && !$this->_cache_including): echo \'{nocache:'
+            . $this->_cache_serial . '#' . $this->_nocache_count
+            . '}\'; endif;';
+        return $_ret;
+    }
+
+
+    /**
+     * check if the compilation changes from non-cacheable to
+     * cacheable state with the end of the current plugin return
+     * php-code to reflect the transition.
+     * @return string
+     */
+    function _pop_cacheable_state($type, $name) {
+        $_cacheable = !isset($this->_plugins[$type][$name]) || $this->_plugins[$type][$name][4];
+        if ($_cacheable
+            || --$this->_cacheable_state>0) return '';
+        return 'if ($this->caching && !$this->_cache_including): echo \'{/nocache:'
+            . $this->_cache_serial . '#' . ($this->_nocache_count++)
+            . '}\'; endif;';
+    }
+
+
+    /**
+     * push opening tag-name, file-name and line-number on the tag-stack
+     * @param string the opening tag's name
+     */
+    function _push_tag($open_tag)
+    {
+        array_push($this->_tag_stack, array($open_tag, $this->_current_line_no));
+    }
+
+    /**
+     * pop closing tag-name
+     * raise an error if this stack-top doesn't match with the closing tag
+     * @param string the closing tag's name
+     * @return string the opening tag's name
+     */
+    function _pop_tag($close_tag)
+    {
+        $message = '';
+        if (count($this->_tag_stack)>0) {
+            list($_open_tag, $_line_no) = array_pop($this->_tag_stack);
+            if ($close_tag == $_open_tag) {
+                return $_open_tag;
+            }
+            if ($close_tag == 'if' && ($_open_tag == 'else' || $_open_tag == 'elseif' )) {
+                return $this->_pop_tag($close_tag);
+            }
+            if ($close_tag == 'section' && $_open_tag == 'sectionelse') {
+                $this->_pop_tag($close_tag);
+                return $_open_tag;
+            }
+            if ($close_tag == 'foreach' && $_open_tag == 'foreachelse') {
+                $this->_pop_tag($close_tag);
+                return $_open_tag;
+            }
+            if ($_open_tag == 'else' || $_open_tag == 'elseif') {
+                $_open_tag = 'if';
+            } elseif ($_open_tag == 'sectionelse') {
+                $_open_tag = 'section';
+            } elseif ($_open_tag == 'foreachelse') {
+                $_open_tag = 'foreach';
+            }
+            $message = " expected {/$_open_tag} (opened line $_line_no).";
+        }
+        $this->_syntax_error("mismatched tag {/$close_tag}.$message",
+                             E_USER_ERROR, __FILE__, __LINE__);
+    }
+
+}
+
+/**
+ * compare to values by their string length
+ *
+ * @access private
+ * @param string $a
+ * @param string $b
+ * @return 0|-1|1
+ */
+function _smarty_sort_length($a, $b)
+{
+    if($a == $b)
+        return 0;
+
+    if(strlen($a) == strlen($b))
+        return ($a > $b) ? -1 : 1;
+
+    return (strlen($a) > strlen($b)) ? -1 : 1;
+}
+
+
+/* vim: set et: */
+
+?>
diff -urN a/epgrec/Smarty.v2/debug.tpl b/epgrec/Smarty.v2/debug.tpl
--- a/epgrec/Smarty.v2/debug.tpl	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/debug.tpl	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,157 @@
+{* Smarty *}
+{* debug.tpl, last updated version 2.1.0 *}
+{assign_debug_info}
+{capture assign=debug_output}
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
+<head>
+    <title>Smarty Debug Console</title>
+{literal}
+<style type="text/css">
+/* <![CDATA[ */
+body, h1, h2, td, th, p {
+    font-family: sans-serif;
+    font-weight: normal;
+    font-size: 0.9em;
+    margin: 1px;
+    padding: 0;
+}
+
+h1 {
+    margin: 0;
+    text-align: left;
+    padding: 2px;
+    background-color: #f0c040;
+    color:  black;
+    font-weight: bold;
+    font-size: 1.2em;
+ }
+
+h2 {
+    background-color: #9B410E;
+    color: white;
+    text-align: left;
+    font-weight: bold;
+    padding: 2px;
+    border-top: 1px solid black;
+}
+
+body {
+    background: black; 
+}
+
+p, table, div {
+    background: #f0ead8;
+} 
+
+p {
+    margin: 0;
+    font-style: italic;
+    text-align: center;
+}
+
+table {
+    width: 100%;
+}
+
+th, td {
+    font-family: monospace;
+    vertical-align: top;
+    text-align: left;
+    width: 50%;
+}
+
+td {
+    color: green;
+}
+
+.odd {
+    background-color: #eeeeee;
+}
+
+.even {
+    background-color: #fafafa;
+}
+
+.exectime {
+    font-size: 0.8em;
+    font-style: italic;
+}
+
+#table_assigned_vars th {
+    color: blue;
+}
+
+#table_config_vars th {
+    color: maroon;
+}
+/* ]]> */
+</style>
+{/literal}
+</head>
+<body>
+
+<h1>Smarty Debug Console</h1>
+
+<h2>included templates &amp; config files (load time in seconds)</h2>
+
+<div>
+{section name=templates loop=$_debug_tpls}
+    {section name=indent loop=$_debug_tpls[templates].depth}&nbsp;&nbsp;&nbsp;{/section}
+    <font color={if $_debug_tpls[templates].type eq "template"}brown{elseif $_debug_tpls[templates].type eq "insert"}black{else}green{/if}>
+        {$_debug_tpls[templates].filename|escape:html}</font>
+    {if isset($_debug_tpls[templates].exec_time)}
+        <span class="exectime">
+        ({$_debug_tpls[templates].exec_time|string_format:"%.5f"})
+        {if %templates.index% eq 0}(total){/if}
+        </span>
+    {/if}
+    <br />
+{sectionelse}
+    <p>no templates included</p>
+{/section}
+</div>
+
+<h2>assigned template variables</h2>
+
+<table id="table_assigned_vars">
+    {section name=vars loop=$_debug_keys}
+        <tr class="{cycle values="odd,even"}">
+            <th>{ldelim}${$_debug_keys[vars]|escape:'html'}{rdelim}</th>
+            <td>{$_debug_vals[vars]|@debug_print_var}</td></tr>
+    {sectionelse}
+        <tr><td><p>no template variables assigned</p></td></tr>
+    {/section}
+</table>
+
+<h2>assigned config file variables (outer template scope)</h2>
+
+<table id="table_config_vars">
+    {section name=config_vars loop=$_debug_config_keys}
+        <tr class="{cycle values="odd,even"}">
+            <th>{ldelim}#{$_debug_config_keys[config_vars]|escape:'html'}#{rdelim}</th>
+            <td>{$_debug_config_vals[config_vars]|@debug_print_var}</td></tr>
+    {sectionelse}
+        <tr><td><p>no config vars assigned</p></td></tr>
+    {/section}
+</table>
+</body>
+</html>
+{/capture}
+{if isset($_smarty_debug_output) and $_smarty_debug_output eq "html"}
+    {$debug_output}
+{else}
+<script type="text/javascript">
+// <![CDATA[
+    if ( self.name == '' ) {ldelim}
+       var title = 'Console';
+    {rdelim}
+    else {ldelim}
+       var title = 'Console_' + self.name;
+    {rdelim}
+    _smarty_console = window.open("",title.value,"width=680,height=600,resizable,scrollbars=yes");
+    _smarty_console.document.write('{$debug_output|escape:'javascript'}');
+    _smarty_console.document.close();
+// ]]>
+</script>
+{/if}
\ 
diff -urN a/epgrec/Smarty.v2/internals/core.assemble_plugin_filepath.php b/epgrec/Smarty.v2/internals/core.assemble_plugin_filepath.php
--- a/epgrec/Smarty.v2/internals/core.assemble_plugin_filepath.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.assemble_plugin_filepath.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,67 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * assemble filepath of requested plugin
+ *
+ * @param string $type
+ * @param string $name
+ * @return string|false
+ */
+function smarty_core_assemble_plugin_filepath($params, &$smarty)
+{
+    static $_filepaths_cache = array();
+
+    $_plugin_filename = $params['type'] . '.' . $params['name'] . '.php';
+    if (isset($_filepaths_cache[$_plugin_filename])) {
+        return $_filepaths_cache[$_plugin_filename];
+    }
+    $_return = false;
+
+    foreach ((array)$smarty->plugins_dir as $_plugin_dir) {
+
+        $_plugin_filepath = $_plugin_dir . DIRECTORY_SEPARATOR . $_plugin_filename;
+
+        // see if path is relative
+        if (!preg_match("/^([\/\\\\]|[a-zA-Z]:[\/\\\\])/", $_plugin_dir)) {
+            $_relative_paths[] = $_plugin_dir;
+            // relative path, see if it is in the SMARTY_DIR
+            if (@is_readable(SMARTY_DIR . $_plugin_filepath)) {
+                $_return = SMARTY_DIR . $_plugin_filepath;
+                break;
+            }
+        }
+        // try relative to cwd (or absolute)
+        if (@is_readable($_plugin_filepath)) {
+            $_return = $_plugin_filepath;
+            break;
+        }
+    }
+
+    if($_return === false) {
+        // still not found, try PHP include_path
+        if(isset($_relative_paths)) {
+            foreach ((array)$_relative_paths as $_plugin_dir) {
+
+                $_plugin_filepath = $_plugin_dir . DIRECTORY_SEPARATOR . $_plugin_filename;
+
+                $_params = array('file_path' => $_plugin_filepath);
+                require_once(SMARTY_CORE_DIR . 'core.get_include_path.php');
+                if(smarty_core_get_include_path($_params, $smarty)) {
+                    $_return = $_params['new_file_path'];
+                    break;
+                }
+            }
+        }
+    }
+    $_filepaths_cache[$_plugin_filename] = $_return;
+    return $_return;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.assign_smarty_interface.php b/epgrec/Smarty.v2/internals/core.assign_smarty_interface.php
--- a/epgrec/Smarty.v2/internals/core.assign_smarty_interface.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.assign_smarty_interface.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,43 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty assign_smarty_interface core plugin
+ *
+ * Type:     core<br>
+ * Name:     assign_smarty_interface<br>
+ * Purpose:  assign the $smarty interface variable
+ * @param array Format: null
+ * @param Smarty
+ */
+function smarty_core_assign_smarty_interface($params, &$smarty)
+{
+        if (isset($smarty->_smarty_vars) && isset($smarty->_smarty_vars['request'])) {
+            return;
+        }
+
+        $_globals_map = array('g'  => 'HTTP_GET_VARS',
+                             'p'  => 'HTTP_POST_VARS',
+                             'c'  => 'HTTP_COOKIE_VARS',
+                             's'  => 'HTTP_SERVER_VARS',
+                             'e'  => 'HTTP_ENV_VARS');
+
+        $_smarty_vars_request  = array();
+
+        foreach (preg_split('!!', strtolower($smarty->request_vars_order)) as $_c) {
+            if (isset($_globals_map[$_c])) {
+                $_smarty_vars_request = array_merge($_smarty_vars_request, $GLOBALS[$_globals_map[$_c]]);
+            }
+        }
+        $_smarty_vars_request = @array_merge($_smarty_vars_request, $GLOBALS['HTTP_SESSION_VARS']);
+
+        $smarty->_smarty_vars['request'] = $_smarty_vars_request;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.create_dir_structure.php b/epgrec/Smarty.v2/internals/core.create_dir_structure.php
--- a/epgrec/Smarty.v2/internals/core.create_dir_structure.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.create_dir_structure.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,79 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * create full directory structure
+ *
+ * @param string $dir
+ */
+
+// $dir
+
+function smarty_core_create_dir_structure($params, &$smarty)
+{
+    if (!file_exists($params['dir'])) {
+        $_open_basedir_ini = ini_get('open_basedir');
+
+        if (DIRECTORY_SEPARATOR=='/') {
+            /* unix-style paths */
+            $_dir = $params['dir'];
+            $_dir_parts = preg_split('!/+!', $_dir, -1, PREG_SPLIT_NO_EMPTY);
+            $_new_dir = (substr($_dir, 0, 1)=='/') ? '/' : getcwd().'/';
+            if($_use_open_basedir = !empty($_open_basedir_ini)) {
+                $_open_basedirs = explode(':', $_open_basedir_ini);
+            }
+
+        } else {
+            /* other-style paths */
+            $_dir = str_replace('\\','/', $params['dir']);
+            $_dir_parts = preg_split('!/+!', $_dir, -1, PREG_SPLIT_NO_EMPTY);
+            if (preg_match('!^((//)|([a-zA-Z]:/))!', $_dir, $_root_dir)) {
+                /* leading "//" for network volume, or "[letter]:/" for full path */
+                $_new_dir = $_root_dir[1];
+                /* remove drive-letter from _dir_parts */
+                if (isset($_root_dir[3])) array_shift($_dir_parts);
+
+            } else {
+                $_new_dir = str_replace('\\', '/', getcwd()).'/';
+
+            }
+
+            if($_use_open_basedir = !empty($_open_basedir_ini)) {
+                $_open_basedirs = explode(';', str_replace('\\', '/', $_open_basedir_ini));
+            }
+
+        }
+
+        /* all paths use "/" only from here */
+        foreach ($_dir_parts as $_dir_part) {
+            $_new_dir .= $_dir_part;
+
+            if ($_use_open_basedir) {
+                // do not attempt to test or make directories outside of open_basedir
+                $_make_new_dir = false;
+                foreach ($_open_basedirs as $_open_basedir) {
+                    if (substr($_new_dir, 0, strlen($_open_basedir)) == $_open_basedir) {
+                        $_make_new_dir = true;
+                        break;
+                    }
+                }
+            } else {
+                $_make_new_dir = true;
+            }
+
+            if ($_make_new_dir && !file_exists($_new_dir) && !@mkdir($_new_dir, $smarty->_dir_perms) && !is_dir($_new_dir)) {
+                $smarty->trigger_error("problem creating directory '" . $_new_dir . "'");
+                return false;
+            }
+            $_new_dir .= '/';
+        }
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.display_debug_console.php b/epgrec/Smarty.v2/internals/core.display_debug_console.php
--- a/epgrec/Smarty.v2/internals/core.display_debug_console.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.display_debug_console.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,61 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty debug_console function plugin
+ *
+ * Type:     core<br>
+ * Name:     display_debug_console<br>
+ * Purpose:  display the javascript debug console window
+ * @param array Format: null
+ * @param Smarty
+ */
+function smarty_core_display_debug_console($params, &$smarty)
+{
+    // we must force compile the debug template in case the environment
+    // changed between separate applications.
+
+    if(empty($smarty->debug_tpl)) {
+        // set path to debug template from SMARTY_DIR
+        $smarty->debug_tpl = SMARTY_DIR . 'debug.tpl';
+        if($smarty->security && is_file($smarty->debug_tpl)) {
+            $smarty->secure_dir[] = realpath($smarty->debug_tpl);
+        }
+        $smarty->debug_tpl = 'file:' . SMARTY_DIR . 'debug.tpl';
+    }
+
+    $_ldelim_orig = $smarty->left_delimiter;
+    $_rdelim_orig = $smarty->right_delimiter;
+
+    $smarty->left_delimiter = '{';
+    $smarty->right_delimiter = '}';
+
+    $_compile_id_orig = $smarty->_compile_id;
+    $smarty->_compile_id = null;
+
+    $_compile_path = $smarty->_get_compile_path($smarty->debug_tpl);
+    if ($smarty->_compile_resource($smarty->debug_tpl, $_compile_path))
+    {
+        ob_start();
+        $smarty->_include($_compile_path);
+        $_results = ob_get_contents();
+        ob_end_clean();
+    } else {
+        $_results = '';
+    }
+
+    $smarty->_compile_id = $_compile_id_orig;
+
+    $smarty->left_delimiter = $_ldelim_orig;
+    $smarty->right_delimiter = $_rdelim_orig;
+
+    return $_results;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.get_include_path.php b/epgrec/Smarty.v2/internals/core.get_include_path.php
--- a/epgrec/Smarty.v2/internals/core.get_include_path.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.get_include_path.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,44 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Get path to file from include_path
+ *
+ * @param string $file_path
+ * @param string $new_file_path
+ * @return boolean
+ * @staticvar array|null
+ */
+
+//  $file_path, &$new_file_path
+
+function smarty_core_get_include_path(&$params, &$smarty)
+{
+    static $_path_array = null;
+
+    if(!isset($_path_array)) {
+        $_ini_include_path = ini_get('include_path');
+
+        if(strstr($_ini_include_path,';')) {
+            // windows pathnames
+            $_path_array = explode(';',$_ini_include_path);
+        } else {
+            $_path_array = explode(':',$_ini_include_path);
+        }
+    }
+    foreach ($_path_array as $_include_path) {
+        if (@is_readable($_include_path . DIRECTORY_SEPARATOR . $params['file_path'])) {
+               $params['new_file_path'] = $_include_path . DIRECTORY_SEPARATOR . $params['file_path'];
+            return true;
+        }
+    }
+    return false;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.get_microtime.php b/epgrec/Smarty.v2/internals/core.get_microtime.php
--- a/epgrec/Smarty.v2/internals/core.get_microtime.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.get_microtime.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,23 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Get seconds and microseconds
+ * @return double
+ */
+function smarty_core_get_microtime($params, &$smarty)
+{
+    $mtime = microtime();
+    $mtime = explode(" ", $mtime);
+    $mtime = (double)($mtime[1]) + (double)($mtime[0]);
+    return ($mtime);
+}
+
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.get_php_resource.php b/epgrec/Smarty.v2/internals/core.get_php_resource.php
--- a/epgrec/Smarty.v2/internals/core.get_php_resource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.get_php_resource.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,80 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Retrieves PHP script resource
+ *
+ * sets $php_resource to the returned resource
+ * @param string $resource
+ * @param string $resource_type
+ * @param  $php_resource
+ * @return boolean
+ */
+
+function smarty_core_get_php_resource(&$params, &$smarty)
+{
+
+    $params['resource_base_path'] = $smarty->trusted_dir;
+    $smarty->_parse_resource_name($params, $smarty);
+
+    /*
+     * Find out if the resource exists.
+     */
+
+    if ($params['resource_type'] == 'file') {
+        $_readable = false;
+        if(file_exists($params['resource_name']) && is_readable($params['resource_name'])) {
+            $_readable = true;
+        } else {
+            // test for file in include_path
+            $_params = array('file_path' => $params['resource_name']);
+            require_once(SMARTY_CORE_DIR . 'core.get_include_path.php');
+            if(smarty_core_get_include_path($_params, $smarty)) {
+                $_include_path = $_params['new_file_path'];
+                $_readable = true;
+            }
+        }
+    } else if ($params['resource_type'] != 'file') {
+        $_template_source = null;
+        $_readable = is_callable($smarty->_plugins['resource'][$params['resource_type']][0][0])
+            && call_user_func_array($smarty->_plugins['resource'][$params['resource_type']][0][0],
+                                    array($params['resource_name'], &$_template_source, &$smarty));
+    }
+
+    /*
+     * Set the error function, depending on which class calls us.
+     */
+    if (method_exists($smarty, '_syntax_error')) {
+        $_error_funcc = '_syntax_error';
+    } else {
+        $_error_funcc = 'trigger_error';
+    }
+
+    if ($_readable) {
+        if ($smarty->security) {
+            require_once(SMARTY_CORE_DIR . 'core.is_trusted.php');
+            if (!smarty_core_is_trusted($params, $smarty)) {
+                $smarty->$_error_funcc('(secure mode) ' . $params['resource_type'] . ':' . $params['resource_name'] . ' is not trusted');
+                return false;
+            }
+        }
+    } else {
+        $smarty->$_error_funcc($params['resource_type'] . ':' . $params['resource_name'] . ' is not readable');
+        return false;
+    }
+
+    if ($params['resource_type'] == 'file') {
+        $params['php_resource'] = $params['resource_name'];
+    } else {
+        $params['php_resource'] = $_template_source;
+    }
+    return true;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.is_secure.php b/epgrec/Smarty.v2/internals/core.is_secure.php
--- a/epgrec/Smarty.v2/internals/core.is_secure.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.is_secure.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,59 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * determines if a resource is secure or not.
+ *
+ * @param string $resource_type
+ * @param string $resource_name
+ * @return boolean
+ */
+
+//  $resource_type, $resource_name
+
+function smarty_core_is_secure($params, &$smarty)
+{
+    if (!$smarty->security || $smarty->security_settings['INCLUDE_ANY']) {
+        return true;
+    }
+
+    if ($params['resource_type'] == 'file') {
+        $_rp = realpath($params['resource_name']);
+        if (isset($params['resource_base_path'])) {
+            foreach ((array)$params['resource_base_path'] as $curr_dir) {
+                if ( ($_cd = realpath($curr_dir)) !== false &&
+                     strncmp($_rp, $_cd, strlen($_cd)) == 0 &&
+                     substr($_rp, strlen($_cd), 1) == DIRECTORY_SEPARATOR ) {
+                    return true;
+                }
+            }
+        }
+        if (!empty($smarty->secure_dir)) {
+            foreach ((array)$smarty->secure_dir as $curr_dir) {
+                if ( ($_cd = realpath($curr_dir)) !== false) {
+                    if($_cd == $_rp) {
+                        return true;
+                    } elseif (strncmp($_rp, $_cd, strlen($_cd)) == 0 &&
+                        substr($_rp, strlen($_cd), 1) == DIRECTORY_SEPARATOR) {
+                        return true;
+                    }
+                }
+            }
+        }
+    } else {
+        // resource is not on local file system
+        return call_user_func_array(
+            $smarty->_plugins['resource'][$params['resource_type']][0][2],
+            array($params['resource_name'], &$smarty));
+    }
+
+    return false;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.is_trusted.php b/epgrec/Smarty.v2/internals/core.is_trusted.php
--- a/epgrec/Smarty.v2/internals/core.is_trusted.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.is_trusted.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,47 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * determines if a resource is trusted or not
+ *
+ * @param string $resource_type
+ * @param string $resource_name
+ * @return boolean
+ */
+
+ // $resource_type, $resource_name
+
+function smarty_core_is_trusted($params, &$smarty)
+{
+    $_smarty_trusted = false;
+    if ($params['resource_type'] == 'file') {
+        if (!empty($smarty->trusted_dir)) {
+            $_rp = realpath($params['resource_name']);
+            foreach ((array)$smarty->trusted_dir as $curr_dir) {
+                if (!empty($curr_dir) && is_readable ($curr_dir)) {
+                    $_cd = realpath($curr_dir);
+                    if (strncmp($_rp, $_cd, strlen($_cd)) == 0
+                        && substr($_rp, strlen($_cd), 1) == DIRECTORY_SEPARATOR ) {
+                        $_smarty_trusted = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+    } else {
+        // resource is not on local file system
+        $_smarty_trusted = call_user_func_array($smarty->_plugins['resource'][$params['resource_type']][0][3],
+                                                array($params['resource_name'], $smarty));
+    }
+
+    return $_smarty_trusted;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.load_plugins.php b/epgrec/Smarty.v2/internals/core.load_plugins.php
--- a/epgrec/Smarty.v2/internals/core.load_plugins.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.load_plugins.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,125 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Load requested plugins
+ *
+ * @param array $plugins
+ */
+
+// $plugins
+
+function smarty_core_load_plugins($params, &$smarty)
+{
+
+    foreach ($params['plugins'] as $_plugin_info) {
+        list($_type, $_name, $_tpl_file, $_tpl_line, $_delayed_loading) = $_plugin_info;
+        $_plugin = &$smarty->_plugins[$_type][$_name];
+
+        /*
+         * We do not load plugin more than once for each instance of Smarty.
+         * The following code checks for that. The plugin can also be
+         * registered dynamically at runtime, in which case template file
+         * and line number will be unknown, so we fill them in.
+         *
+         * The final element of the info array is a flag that indicates
+         * whether the dynamically registered plugin function has been
+         * checked for existence yet or not.
+         */
+        if (isset($_plugin)) {
+            if (empty($_plugin[3])) {
+                if (!is_callable($_plugin[0])) {
+                    $smarty->_trigger_fatal_error("[plugin] $_type '$_name' is not implemented", $_tpl_file, $_tpl_line, __FILE__, __LINE__);
+                } else {
+                    $_plugin[1] = $_tpl_file;
+                    $_plugin[2] = $_tpl_line;
+                    $_plugin[3] = true;
+                    if (!isset($_plugin[4])) $_plugin[4] = true; /* cacheable */
+                }
+            }
+            continue;
+        } else if ($_type == 'insert') {
+            /*
+             * For backwards compatibility, we check for insert functions in
+             * the symbol table before trying to load them as a plugin.
+             */
+            $_plugin_func = 'insert_' . $_name;
+            if (function_exists($_plugin_func)) {
+                $_plugin = array($_plugin_func, $_tpl_file, $_tpl_line, true, false);
+                continue;
+            }
+        }
+
+        $_plugin_file = $smarty->_get_plugin_filepath($_type, $_name);
+
+        if (! $_found = ($_plugin_file != false)) {
+            $_message = "could not load plugin file '$_type.$_name.php'\n";
+        }
+
+        /*
+         * If plugin file is found, it -must- provide the properly named
+         * plugin function. In case it doesn't, simply output the error and
+         * do not fall back on any other method.
+         */
+        if ($_found) {
+            include_once $_plugin_file;
+
+            $_plugin_func = 'smarty_' . $_type . '_' . $_name;
+            if (!function_exists($_plugin_func)) {
+                $smarty->_trigger_fatal_error("[plugin] function $_plugin_func() not found in $_plugin_file", $_tpl_file, $_tpl_line, __FILE__, __LINE__);
+                continue;
+            }
+        }
+        /*
+         * In case of insert plugins, their code may be loaded later via
+         * 'script' attribute.
+         */
+        else if ($_type == 'insert' && $_delayed_loading) {
+            $_plugin_func = 'smarty_' . $_type . '_' . $_name;
+            $_found = true;
+        }
+
+        /*
+         * Plugin specific processing and error checking.
+         */
+        if (!$_found) {
+            if ($_type == 'modifier') {
+                /*
+                 * In case modifier falls back on using PHP functions
+                 * directly, we only allow those specified in the security
+                 * context.
+                 */
+                if ($smarty->security && !in_array($_name, $smarty->security_settings['MODIFIER_FUNCS'])) {
+                    $_message = "(secure mode) modifier '$_name' is not allowed";
+                } else {
+                    if (!function_exists($_name)) {
+                        $_message = "modifier '$_name' is not implemented";
+                    } else {
+                        $_plugin_func = $_name;
+                        $_found = true;
+                    }
+                }
+            } else if ($_type == 'function') {
+                /*
+                 * This is a catch-all situation.
+                 */
+                $_message = "unknown tag - '$_name'";
+            }
+        }
+
+        if ($_found) {
+            $smarty->_plugins[$_type][$_name] = array($_plugin_func, $_tpl_file, $_tpl_line, true, true);
+        } else {
+            // output error
+            $smarty->_trigger_fatal_error('[plugin] ' . $_message, $_tpl_file, $_tpl_line, __FILE__, __LINE__);
+        }
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.load_resource_plugin.php b/epgrec/Smarty.v2/internals/core.load_resource_plugin.php
--- a/epgrec/Smarty.v2/internals/core.load_resource_plugin.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.load_resource_plugin.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,74 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * load a resource plugin
+ *
+ * @param string $type
+ */
+
+// $type
+
+function smarty_core_load_resource_plugin($params, &$smarty)
+{
+    /*
+     * Resource plugins are not quite like the other ones, so they are
+     * handled differently. The first element of plugin info is the array of
+     * functions provided by the plugin, the second one indicates whether
+     * all of them exist or not.
+     */
+
+    $_plugin = &$smarty->_plugins['resource'][$params['type']];
+    if (isset($_plugin)) {
+        if (!$_plugin[1] && count($_plugin[0])) {
+            $_plugin[1] = true;
+            foreach ($_plugin[0] as $_plugin_func) {
+                if (!is_callable($_plugin_func)) {
+                    $_plugin[1] = false;
+                    break;
+                }
+            }
+        }
+
+        if (!$_plugin[1]) {
+            $smarty->_trigger_fatal_error("[plugin] resource '" . $params['type'] . "' is not implemented", null, null, __FILE__, __LINE__);
+        }
+
+        return;
+    }
+
+    $_plugin_file = $smarty->_get_plugin_filepath('resource', $params['type']);
+    $_found = ($_plugin_file != false);
+
+    if ($_found) {            /*
+         * If the plugin file is found, it -must- provide the properly named
+         * plugin functions.
+         */
+        include_once($_plugin_file);
+
+        /*
+         * Locate functions that we require the plugin to provide.
+         */
+        $_resource_ops = array('source', 'timestamp', 'secure', 'trusted');
+        $_resource_funcs = array();
+        foreach ($_resource_ops as $_op) {
+            $_plugin_func = 'smarty_resource_' . $params['type'] . '_' . $_op;
+            if (!function_exists($_plugin_func)) {
+                $smarty->_trigger_fatal_error("[plugin] function $_plugin_func() not found in $_plugin_file", null, null, __FILE__, __LINE__);
+                return;
+            } else {
+                $_resource_funcs[] = $_plugin_func;
+            }
+        }
+
+        $smarty->_plugins['resource'][$params['type']] = array($_resource_funcs, true);
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.process_cached_inserts.php b/epgrec/Smarty.v2/internals/core.process_cached_inserts.php
--- a/epgrec/Smarty.v2/internals/core.process_cached_inserts.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.process_cached_inserts.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,71 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Replace cached inserts with the actual results
+ *
+ * @param string $results
+ * @return string
+ */
+function smarty_core_process_cached_inserts($params, &$smarty)
+{
+    preg_match_all('!'.$smarty->_smarty_md5.'{insert_cache (.*)}'.$smarty->_smarty_md5.'!Uis',
+                   $params['results'], $match);
+    list($cached_inserts, $insert_args) = $match;
+
+    for ($i = 0, $for_max = count($cached_inserts); $i < $for_max; $i++) {
+        if ($smarty->debugging) {
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $debug_start_time = smarty_core_get_microtime($_params, $smarty);
+        }
+
+        $args = unserialize($insert_args[$i]);
+        $name = $args['name'];
+
+        if (isset($args['script'])) {
+            $_params = array('resource_name' => $smarty->_dequote($args['script']));
+            require_once(SMARTY_CORE_DIR . 'core.get_php_resource.php');
+            if(!smarty_core_get_php_resource($_params, $smarty)) {
+                return false;
+            }
+            $resource_type = $_params['resource_type'];
+            $php_resource = $_params['php_resource'];
+
+
+            if ($resource_type == 'file') {
+                $smarty->_include($php_resource, true);
+            } else {
+                $smarty->_eval($php_resource);
+            }
+        }
+
+        $function_name = $smarty->_plugins['insert'][$name][0];
+        if (empty($args['assign'])) {
+            $replace = $function_name($args, $smarty);
+        } else {
+            $smarty->assign($args['assign'], $function_name($args, $smarty));
+            $replace = '';
+        }
+
+        $params['results'] = substr_replace($params['results'], $replace, strpos($params['results'], $cached_inserts[$i]), strlen($cached_inserts[$i]));
+        if ($smarty->debugging) {
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $smarty->_smarty_debug_info[] = array('type'      => 'insert',
+                                                'filename'  => 'insert_'.$name,
+                                                'depth'     => $smarty->_inclusion_depth,
+                                                'exec_time' => smarty_core_get_microtime($_params, $smarty) - $debug_start_time);
+        }
+    }
+
+    return $params['results'];
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.process_compiled_include.php b/epgrec/Smarty.v2/internals/core.process_compiled_include.php
--- a/epgrec/Smarty.v2/internals/core.process_compiled_include.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.process_compiled_include.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,37 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Replace nocache-tags by results of the corresponding non-cacheable
+ * functions and return it
+ *
+ * @param string $compiled_tpl
+ * @param string $cached_source
+ * @return string
+ */
+
+function smarty_core_process_compiled_include($params, &$smarty)
+{
+    $_cache_including = $smarty->_cache_including;
+    $smarty->_cache_including = true;
+
+    $_return = $params['results'];
+
+    foreach ($smarty->_cache_info['cache_serials'] as $_include_file_path=>$_cache_serial) {
+        $smarty->_include($_include_file_path, true);
+    }
+
+    foreach ($smarty->_cache_info['cache_serials'] as $_include_file_path=>$_cache_serial) {
+        $_return = preg_replace_callback('!(\{nocache\:('.$_cache_serial.')#(\d+)\})!s',
+                                         array(&$smarty, '_process_compiled_include_callback'),
+                                         $_return);
+    }
+    $smarty->_cache_including = $_cache_including;
+    return $_return;
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.read_cache_file.php b/epgrec/Smarty.v2/internals/core.read_cache_file.php
--- a/epgrec/Smarty.v2/internals/core.read_cache_file.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.read_cache_file.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,101 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * read a cache file, determine if it needs to be
+ * regenerated or not
+ *
+ * @param string $tpl_file
+ * @param string $cache_id
+ * @param string $compile_id
+ * @param string $results
+ * @return boolean
+ */
+
+//  $tpl_file, $cache_id, $compile_id, &$results
+
+function smarty_core_read_cache_file(&$params, &$smarty)
+{
+    static  $content_cache = array();
+
+    if ($smarty->force_compile) {
+        // force compile enabled, always regenerate
+        return false;
+    }
+
+    if (isset($content_cache[$params['tpl_file'].','.$params['cache_id'].','.$params['compile_id']])) {
+        list($params['results'], $smarty->_cache_info) = $content_cache[$params['tpl_file'].','.$params['cache_id'].','.$params['compile_id']];
+        return true;
+    }
+
+    if (!empty($smarty->cache_handler_func)) {
+        // use cache_handler function
+        call_user_func_array($smarty->cache_handler_func,
+                             array('read', &$smarty, &$params['results'], $params['tpl_file'], $params['cache_id'], $params['compile_id'], null));
+    } else {
+        // use local cache file
+        $_auto_id = $smarty->_get_auto_id($params['cache_id'], $params['compile_id']);
+        $_cache_file = $smarty->_get_auto_filename($smarty->cache_dir, $params['tpl_file'], $_auto_id);
+        $params['results'] = $smarty->_read_file($_cache_file);
+    }
+
+    if (empty($params['results'])) {
+        // nothing to parse (error?), regenerate cache
+        return false;
+    }
+
+    $_contents = $params['results'];
+    $_info_start = strpos($_contents, "\n") + 1;
+    $_info_len = (int)substr($_contents, 0, $_info_start - 1);
+    $_cache_info = unserialize(substr($_contents, $_info_start, $_info_len));
+    $params['results'] = substr($_contents, $_info_start + $_info_len);
+
+    if ($smarty->caching == 2 && isset ($_cache_info['expires'])){
+        // caching by expiration time
+        if ($_cache_info['expires'] > -1 && (time() > $_cache_info['expires'])) {
+            // cache expired, regenerate
+            return false;
+        }
+    } else {
+        // caching by lifetime
+        if ($smarty->cache_lifetime > -1 && (time() - $_cache_info['timestamp'] > $smarty->cache_lifetime)) {
+            // cache expired, regenerate
+            return false;
+        }
+    }
+
+    if ($smarty->compile_check) {
+        $_params = array('get_source' => false, 'quiet'=>true);
+        foreach (array_keys($_cache_info['template']) as $_template_dep) {
+            $_params['resource_name'] = $_template_dep;
+            if (!$smarty->_fetch_resource_info($_params) || $_cache_info['timestamp'] < $_params['resource_timestamp']) {
+                // template file has changed, regenerate cache
+                return false;
+            }
+        }
+
+        if (isset($_cache_info['config'])) {
+            $_params = array('resource_base_path' => $smarty->config_dir, 'get_source' => false, 'quiet'=>true);
+            foreach (array_keys($_cache_info['config']) as $_config_dep) {
+                $_params['resource_name'] = $_config_dep;
+                if (!$smarty->_fetch_resource_info($_params) || $_cache_info['timestamp'] < $_params['resource_timestamp']) {
+                    // config file has changed, regenerate cache
+                    return false;
+                }
+            }
+        }
+    }
+
+    $content_cache[$params['tpl_file'].','.$params['cache_id'].','.$params['compile_id']] = array($params['results'], $_cache_info);
+
+    $smarty->_cache_info = $_cache_info;
+    return true;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.rm_auto.php b/epgrec/Smarty.v2/internals/core.rm_auto.php
--- a/epgrec/Smarty.v2/internals/core.rm_auto.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.rm_auto.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,71 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * delete an automagically created file by name and id
+ *
+ * @param string $auto_base
+ * @param string $auto_source
+ * @param string $auto_id
+ * @param integer $exp_time
+ * @return boolean
+ */
+
+// $auto_base, $auto_source = null, $auto_id = null, $exp_time = null
+
+function smarty_core_rm_auto($params, &$smarty)
+{
+    if (!@is_dir($params['auto_base']))
+      return false;
+
+    if(!isset($params['auto_id']) && !isset($params['auto_source'])) {
+        $_params = array(
+            'dirname' => $params['auto_base'],
+            'level' => 0,
+            'exp_time' => $params['exp_time']
+        );
+        require_once(SMARTY_CORE_DIR . 'core.rmdir.php');
+        $_res = smarty_core_rmdir($_params, $smarty);
+    } else {
+        $_tname = $smarty->_get_auto_filename($params['auto_base'], $params['auto_source'], $params['auto_id']);
+
+        if(isset($params['auto_source'])) {
+            if (isset($params['extensions'])) {
+                $_res = false;
+                foreach ((array)$params['extensions'] as $_extension)
+                    $_res |= $smarty->_unlink($_tname.$_extension, $params['exp_time']);
+            } else {
+                $_res = $smarty->_unlink($_tname, $params['exp_time']);
+            }
+        } elseif ($smarty->use_sub_dirs) {
+            $_params = array(
+                'dirname' => $_tname,
+                'level' => 1,
+                'exp_time' => $params['exp_time']
+            );
+            require_once(SMARTY_CORE_DIR . 'core.rmdir.php');
+            $_res = smarty_core_rmdir($_params, $smarty);
+        } else {
+            // remove matching file names
+            $_handle = opendir($params['auto_base']);
+            $_res = true;
+            while (false !== ($_filename = readdir($_handle))) {
+                if($_filename == '.' || $_filename == '..') {
+                    continue;
+                } elseif (substr($params['auto_base'] . DIRECTORY_SEPARATOR . $_filename, 0, strlen($_tname)) == $_tname) {
+                    $_res &= (bool)$smarty->_unlink($params['auto_base'] . DIRECTORY_SEPARATOR . $_filename, $params['exp_time']);
+                }
+            }
+        }
+    }
+
+    return $_res;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.rmdir.php b/epgrec/Smarty.v2/internals/core.rmdir.php
--- a/epgrec/Smarty.v2/internals/core.rmdir.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.rmdir.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,54 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * delete a dir recursively (level=0 -> keep root)
+ * WARNING: no tests, it will try to remove what you tell it!
+ *
+ * @param string $dirname
+ * @param integer $level
+ * @param integer $exp_time
+ * @return boolean
+ */
+
+//  $dirname, $level = 1, $exp_time = null
+
+function smarty_core_rmdir($params, &$smarty)
+{
+   if(!isset($params['level'])) { $params['level'] = 1; }
+   if(!isset($params['exp_time'])) { $params['exp_time'] = null; }
+
+   if($_handle = @opendir($params['dirname'])) {
+
+        while (false !== ($_entry = readdir($_handle))) {
+            if ($_entry != '.' && $_entry != '..') {
+                if (@is_dir($params['dirname'] . DIRECTORY_SEPARATOR . $_entry)) {
+                    $_params = array(
+                        'dirname' => $params['dirname'] . DIRECTORY_SEPARATOR . $_entry,
+                        'level' => $params['level'] + 1,
+                        'exp_time' => $params['exp_time']
+                    );
+                    smarty_core_rmdir($_params, $smarty);
+                }
+                else {
+                    $smarty->_unlink($params['dirname'] . DIRECTORY_SEPARATOR . $_entry, $params['exp_time']);
+                }
+            }
+        }
+        closedir($_handle);
+   }
+
+   if ($params['level']) {
+       return @rmdir($params['dirname']);
+   }
+   return (bool)$_handle;
+
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.run_insert_handler.php b/epgrec/Smarty.v2/internals/core.run_insert_handler.php
--- a/epgrec/Smarty.v2/internals/core.run_insert_handler.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.run_insert_handler.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,71 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Handle insert tags
+ *
+ * @param array $args
+ * @return string
+ */
+function smarty_core_run_insert_handler($params, &$smarty)
+{
+
+    require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+    if ($smarty->debugging) {
+        $_params = array();
+        $_debug_start_time = smarty_core_get_microtime($_params, $smarty);
+    }
+
+    if ($smarty->caching) {
+        $_arg_string = serialize($params['args']);
+        $_name = $params['args']['name'];
+        if (!isset($smarty->_cache_info['insert_tags'][$_name])) {
+            $smarty->_cache_info['insert_tags'][$_name] = array('insert',
+                                                             $_name,
+                                                             $smarty->_plugins['insert'][$_name][1],
+                                                             $smarty->_plugins['insert'][$_name][2],
+                                                             !empty($params['args']['script']) ? true : false);
+        }
+        return $smarty->_smarty_md5."{insert_cache $_arg_string}".$smarty->_smarty_md5;
+    } else {
+        if (isset($params['args']['script'])) {
+            $_params = array('resource_name' => $smarty->_dequote($params['args']['script']));
+            require_once(SMARTY_CORE_DIR . 'core.get_php_resource.php');
+            if(!smarty_core_get_php_resource($_params, $smarty)) {
+                return false;
+            }
+
+            if ($_params['resource_type'] == 'file') {
+                $smarty->_include($_params['php_resource'], true);
+            } else {
+                $smarty->_eval($_params['php_resource']);
+            }
+            unset($params['args']['script']);
+        }
+
+        $_funcname = $smarty->_plugins['insert'][$params['args']['name']][0];
+        $_content = $_funcname($params['args'], $smarty);
+        if ($smarty->debugging) {
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $smarty->_smarty_debug_info[] = array('type'      => 'insert',
+                                                'filename'  => 'insert_'.$params['args']['name'],
+                                                'depth'     => $smarty->_inclusion_depth,
+                                                'exec_time' => smarty_core_get_microtime($_params, $smarty) - $_debug_start_time);
+        }
+
+        if (!empty($params['args']["assign"])) {
+            $smarty->assign($params['args']["assign"], $_content);
+        } else {
+            return $_content;
+        }
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.smarty_include_php.php b/epgrec/Smarty.v2/internals/core.smarty_include_php.php
--- a/epgrec/Smarty.v2/internals/core.smarty_include_php.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.smarty_include_php.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,50 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * called for included php files within templates
+ *
+ * @param string $smarty_file
+ * @param string $smarty_assign variable to assign the included template's
+ *               output into
+ * @param boolean $smarty_once uses include_once if this is true
+ * @param array $smarty_include_vars associative array of vars from
+ *              {include file="blah" var=$var}
+ */
+
+//  $file, $assign, $once, $_smarty_include_vars
+
+function smarty_core_smarty_include_php($params, &$smarty)
+{
+    $_params = array('resource_name' => $params['smarty_file']);
+    require_once(SMARTY_CORE_DIR . 'core.get_php_resource.php');
+    smarty_core_get_php_resource($_params, $smarty);
+    $_smarty_resource_type = $_params['resource_type'];
+    $_smarty_php_resource = $_params['php_resource'];
+
+    if (!empty($params['smarty_assign'])) {
+        ob_start();
+        if ($_smarty_resource_type == 'file') {
+            $smarty->_include($_smarty_php_resource, $params['smarty_once'], $params['smarty_include_vars']);
+        } else {
+            $smarty->_eval($_smarty_php_resource, $params['smarty_include_vars']);
+        }
+        $smarty->assign($params['smarty_assign'], ob_get_contents());
+        ob_end_clean();
+    } else {
+        if ($_smarty_resource_type == 'file') {
+            $smarty->_include($_smarty_php_resource, $params['smarty_once'], $params['smarty_include_vars']);
+        } else {
+            $smarty->_eval($_smarty_php_resource, $params['smarty_include_vars']);
+        }
+    }
+}
+
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.write_cache_file.php b/epgrec/Smarty.v2/internals/core.write_cache_file.php
--- a/epgrec/Smarty.v2/internals/core.write_cache_file.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.write_cache_file.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,96 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Prepend the cache information to the cache file
+ * and write it
+ *
+ * @param string $tpl_file
+ * @param string $cache_id
+ * @param string $compile_id
+ * @param string $results
+ * @return true|null
+ */
+
+ // $tpl_file, $cache_id, $compile_id, $results
+
+function smarty_core_write_cache_file($params, &$smarty)
+{
+
+    // put timestamp in cache header
+    $smarty->_cache_info['timestamp'] = time();
+    if ($smarty->cache_lifetime > -1){
+        // expiration set
+        $smarty->_cache_info['expires'] = $smarty->_cache_info['timestamp'] + $smarty->cache_lifetime;
+    } else {
+        // cache will never expire
+        $smarty->_cache_info['expires'] = -1;
+    }
+
+    // collapse nocache.../nocache-tags
+    if (preg_match_all('!\{(/?)nocache\:[0-9a-f]{32}#\d+\}!', $params['results'], $match, PREG_PATTERN_ORDER)) {
+        // remove everything between every pair of outermost noache.../nocache-tags
+        // and replace it by a single nocache-tag
+        // this new nocache-tag will be replaced by dynamic contents in
+        // smarty_core_process_compiled_includes() on a cache-read
+        
+        $match_count = count($match[0]);
+        $results = preg_split('!(\{/?nocache\:[0-9a-f]{32}#\d+\})!', $params['results'], -1, PREG_SPLIT_DELIM_CAPTURE);
+        
+        $level = 0;
+        $j = 0;
+        for ($i=0, $results_count = count($results); $i < $results_count && $j < $match_count; $i++) {
+            if ($results[$i] == $match[0][$j]) {
+                // nocache tag
+                if ($match[1][$j]) { // closing tag
+                    $level--;
+                    unset($results[$i]);
+                } else { // opening tag
+                    if ($level++ > 0) unset($results[$i]);
+                }
+                $j++;
+            } elseif ($level > 0) {
+                unset($results[$i]);
+            }
+        }
+        $params['results'] = implode('', $results);
+    }
+    $smarty->_cache_info['cache_serials'] = $smarty->_cache_serials;
+
+    // prepend the cache header info into cache file
+    $_cache_info = serialize($smarty->_cache_info);
+    $params['results'] = strlen($_cache_info) . "\n" . $_cache_info . $params['results'];
+
+    if (!empty($smarty->cache_handler_func)) {
+        // use cache_handler function
+        call_user_func_array($smarty->cache_handler_func,
+                             array('write', &$smarty, &$params['results'], $params['tpl_file'], $params['cache_id'], $params['compile_id'], $smarty->_cache_info['expires']));
+    } else {
+        // use local cache file
+
+        if(!@is_writable($smarty->cache_dir)) {
+            // cache_dir not writable, see if it exists
+            if(!@is_dir($smarty->cache_dir)) {
+                $smarty->trigger_error('the $cache_dir \'' . $smarty->cache_dir . '\' does not exist, or is not a directory.', E_USER_ERROR);
+                return false;
+            }
+            $smarty->trigger_error('unable to write to $cache_dir \'' . realpath($smarty->cache_dir) . '\'. Be sure $cache_dir is writable by the web server user.', E_USER_ERROR);
+            return false;
+        }
+
+        $_auto_id = $smarty->_get_auto_id($params['cache_id'], $params['compile_id']);
+        $_cache_file = $smarty->_get_auto_filename($smarty->cache_dir, $params['tpl_file'], $_auto_id);
+        $_params = array('filename' => $_cache_file, 'contents' => $params['results'], 'create_dirs' => true);
+        require_once(SMARTY_CORE_DIR . 'core.write_file.php');
+        smarty_core_write_file($_params, $smarty);
+        return true;
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.write_compiled_include.php b/epgrec/Smarty.v2/internals/core.write_compiled_include.php
--- a/epgrec/Smarty.v2/internals/core.write_compiled_include.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.write_compiled_include.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,91 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Extract non-cacheable parts out of compiled template and write it
+ *
+ * @param string $compile_path
+ * @param string $template_compiled
+ * @return boolean
+ */
+
+function smarty_core_write_compiled_include($params, &$smarty)
+{
+    $_tag_start = 'if \(\$this->caching && \!\$this->_cache_including\)\: echo \'\{nocache\:('.$params['cache_serial'].')#(\d+)\}\'; endif;';
+    $_tag_end   = 'if \(\$this->caching && \!\$this->_cache_including\)\: echo \'\{/nocache\:(\\2)#(\\3)\}\'; endif;';
+
+    preg_match_all('!('.$_tag_start.'(.*)'.$_tag_end.')!Us',
+                   $params['compiled_content'], $_match_source, PREG_SET_ORDER);
+    
+    // no nocache-parts found: done
+    if (count($_match_source)==0) return;
+
+    // convert the matched php-code to functions
+    $_include_compiled =  "<?php /* Smarty version ".$smarty->_version.", created on ".strftime("%Y-%m-%d %H:%M:%S")."\n";
+    $_include_compiled .= "         compiled from " . strtr(urlencode($params['resource_name']), array('%2F'=>'/', '%3A'=>':')) . " */\n\n";
+
+    $_compile_path = $params['include_file_path'];
+
+    $smarty->_cache_serials[$_compile_path] = $params['cache_serial'];
+    $_include_compiled .= "\$this->_cache_serials['".$_compile_path."'] = '".$params['cache_serial']."';\n\n?>";
+
+    $_include_compiled .= $params['plugins_code'];
+    $_include_compiled .= "<?php";
+
+    $this_varname = ((double)phpversion() >= 5.0) ? '_smarty' : 'this';
+    for ($_i = 0, $_for_max = count($_match_source); $_i < $_for_max; $_i++) {
+        $_match =& $_match_source[$_i];
+        $source = $_match[4];
+        if ($this_varname == '_smarty') {
+            /* rename $this to $_smarty in the sourcecode */
+            $tokens = token_get_all('<?php ' . $_match[4]);
+
+            /* remove trailing <?php */
+            $open_tag = '';
+            while ($tokens) {
+                $token = array_shift($tokens);
+                if (is_array($token)) {
+                    $open_tag .= $token[1];
+                } else {
+                    $open_tag .= $token;
+                }
+                if ($open_tag == '<?php ') break;
+            }
+
+            for ($i=0, $count = count($tokens); $i < $count; $i++) {
+                if (is_array($tokens[$i])) {
+                    if ($tokens[$i][0] == T_VARIABLE && $tokens[$i][1] == '$this') {
+                        $tokens[$i] = '$' . $this_varname;
+                    } else {
+                        $tokens[$i] = $tokens[$i][1];
+                    }                   
+                }
+            }
+            $source = implode('', $tokens);
+        }
+
+        /* add function to compiled include */
+        $_include_compiled .= "
+function _smarty_tplfunc_$_match[2]_$_match[3](&\$$this_varname)
+{
+$source
+}
+
+";
+    }
+    $_include_compiled .= "\n\n?>\n";
+
+    $_params = array('filename' => $_compile_path,
+                     'contents' => $_include_compiled, 'create_dirs' => true);
+
+    require_once(SMARTY_CORE_DIR . 'core.write_file.php');
+    smarty_core_write_file($_params, $smarty);
+    return true;
+}
+
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.write_compiled_resource.php b/epgrec/Smarty.v2/internals/core.write_compiled_resource.php
--- a/epgrec/Smarty.v2/internals/core.write_compiled_resource.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.write_compiled_resource.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,35 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * write the compiled resource
+ *
+ * @param string $compile_path
+ * @param string $compiled_content
+ * @return true
+ */
+function smarty_core_write_compiled_resource($params, &$smarty)
+{
+    if(!@is_writable($smarty->compile_dir)) {
+        // compile_dir not writable, see if it exists
+        if(!@is_dir($smarty->compile_dir)) {
+            $smarty->trigger_error('the $compile_dir \'' . $smarty->compile_dir . '\' does not exist, or is not a directory.', E_USER_ERROR);
+            return false;
+        }
+        $smarty->trigger_error('unable to write to $compile_dir \'' . realpath($smarty->compile_dir) . '\'. Be sure $compile_dir is writable by the web server user.', E_USER_ERROR);
+        return false;
+    }
+
+    $_params = array('filename' => $params['compile_path'], 'contents' => $params['compiled_content'], 'create_dirs' => true);
+    require_once(SMARTY_CORE_DIR . 'core.write_file.php');
+    smarty_core_write_file($_params, $smarty);
+    return true;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/internals/core.write_file.php b/epgrec/Smarty.v2/internals/core.write_file.php
--- a/epgrec/Smarty.v2/internals/core.write_file.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/internals/core.write_file.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,54 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * write out a file to disk
+ *
+ * @param string $filename
+ * @param string $contents
+ * @param boolean $create_dirs
+ * @return boolean
+ */
+function smarty_core_write_file($params, &$smarty)
+{
+    $_dirname = dirname($params['filename']);
+
+    if ($params['create_dirs']) {
+        $_params = array('dir' => $_dirname);
+        require_once(SMARTY_CORE_DIR . 'core.create_dir_structure.php');
+        smarty_core_create_dir_structure($_params, $smarty);
+    }
+
+    // write to tmp file, then rename it to avoid file locking race condition
+    $_tmp_file = tempnam($_dirname, 'wrt');
+
+    if (!($fd = @fopen($_tmp_file, 'wb'))) {
+        $_tmp_file = $_dirname . DIRECTORY_SEPARATOR . uniqid('wrt');
+        if (!($fd = @fopen($_tmp_file, 'wb'))) {
+            $smarty->trigger_error("problem writing temporary file '$_tmp_file'");
+            return false;
+        }
+    }
+
+    fwrite($fd, $params['contents']);
+    fclose($fd);
+
+    if (DIRECTORY_SEPARATOR == '\\' || !@rename($_tmp_file, $params['filename'])) {
+        // On platforms and filesystems that cannot overwrite with rename() 
+        // delete the file before renaming it -- because windows always suffers
+        // this, it is short-circuited to avoid the initial rename() attempt
+        @unlink($params['filename']);
+        @rename($_tmp_file, $params['filename']);
+    }
+    @chmod($params['filename'], $smarty->_file_perms);
+
+    return true;
+}
+
+/* vim: set expandtab: */
+
+?>
\ 
diff -urN a/epgrec/Smarty.v2/plugins/block.textformat.php b/epgrec/Smarty.v2/plugins/block.textformat.php
--- a/epgrec/Smarty.v2/plugins/block.textformat.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/block.textformat.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,103 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty {textformat}{/textformat} block plugin
+ *
+ * Type:     block function<br>
+ * Name:     textformat<br>
+ * Purpose:  format text a certain way with preset styles
+ *           or custom wrap/indent settings<br>
+ * @link http://smarty.php.net/manual/en/language.function.textformat.php {textformat}
+ *       (Smarty online manual)
+ * @param array
+ * <pre>
+ * Params:   style: string (email)
+ *           indent: integer (0)
+ *           wrap: integer (80)
+ *           wrap_char string ("\n")
+ *           indent_char: string (" ")
+ *           wrap_boundary: boolean (true)
+ * </pre>
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @param string contents of the block
+ * @param Smarty clever simulation of a method
+ * @return string string $content re-formatted
+ */
+function smarty_block_textformat($params, $content, &$smarty)
+{
+    if (is_null($content)) {
+        return;
+    }
+
+    $style = null;
+    $indent = 0;
+    $indent_first = 0;
+    $indent_char = ' ';
+    $wrap = 80;
+    $wrap_char = "\n";
+    $wrap_cut = false;
+    $assign = null;
+    
+    foreach ($params as $_key => $_val) {
+        switch ($_key) {
+            case 'style':
+            case 'indent_char':
+            case 'wrap_char':
+            case 'assign':
+                $$_key = (string)$_val;
+                break;
+
+            case 'indent':
+            case 'indent_first':
+            case 'wrap':
+                $$_key = (int)$_val;
+                break;
+
+            case 'wrap_cut':
+                $$_key = (bool)$_val;
+                break;
+
+            default:
+                $smarty->trigger_error("textformat: unknown attribute '$_key'");
+        }
+    }
+
+    if ($style == 'email') {
+        $wrap = 72;
+    }
+
+    // split into paragraphs
+    $_paragraphs = preg_split('![\r\n][\r\n]!',$content);
+    $_output = '';
+
+    for($_x = 0, $_y = count($_paragraphs); $_x < $_y; $_x++) {
+        if ($_paragraphs[$_x] == '') {
+            continue;
+        }
+        // convert mult. spaces & special chars to single space
+        $_paragraphs[$_x] = preg_replace(array('!\s+!','!(^\s+)|(\s+$)!'), array(' ',''), $_paragraphs[$_x]);
+        // indent first line
+        if($indent_first > 0) {
+            $_paragraphs[$_x] = str_repeat($indent_char, $indent_first) . $_paragraphs[$_x];
+        }
+        // wordwrap sentences
+        $_paragraphs[$_x] = wordwrap($_paragraphs[$_x], $wrap - $indent, $wrap_char, $wrap_cut);
+        // indent lines
+        if($indent > 0) {
+            $_paragraphs[$_x] = preg_replace('!^!m', str_repeat($indent_char, $indent), $_paragraphs[$_x]);
+        }
+    }
+    $_output = implode($wrap_char . $wrap_char, $_paragraphs);
+
+    return $assign ? $smarty->assign($assign, $_output) : $_output;
+
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/compiler.assign.php b/epgrec/Smarty.v2/plugins/compiler.assign.php
--- a/epgrec/Smarty.v2/plugins/compiler.assign.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/compiler.assign.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,40 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty {assign} compiler function plugin
+ *
+ * Type:     compiler function<br>
+ * Name:     assign<br>
+ * Purpose:  assign a value to a template variable
+ * @link http://smarty.php.net/manual/en/language.custom.functions.php#LANGUAGE.FUNCTION.ASSIGN {assign}
+ *       (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com> (initial author)
+ * @author messju mohr <messju at lammfellpuschen dot de> (conversion to compiler function)
+ * @param string containing var-attribute and value-attribute
+ * @param Smarty_Compiler
+ */
+function smarty_compiler_assign($tag_attrs, &$compiler)
+{
+    $_params = $compiler->_parse_attrs($tag_attrs);
+
+    if (!isset($_params['var'])) {
+        $compiler->_syntax_error("assign: missing 'var' parameter", E_USER_WARNING);
+        return;
+    }
+
+    if (!isset($_params['value'])) {
+        $compiler->_syntax_error("assign: missing 'value' parameter", E_USER_WARNING);
+        return;
+    }
+
+    return "\$this->assign({$_params['var']}, {$_params['value']});";
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.assign_debug_info.php b/epgrec/Smarty.v2/plugins/function.assign_debug_info.php
--- a/epgrec/Smarty.v2/plugins/function.assign_debug_info.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.assign_debug_info.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,40 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty {assign_debug_info} function plugin
+ *
+ * Type:     function<br>
+ * Name:     assign_debug_info<br>
+ * Purpose:  assign debug info to the template<br>
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @param array unused in this plugin, this plugin uses {@link Smarty::$_config},
+ *              {@link Smarty::$_tpl_vars} and {@link Smarty::$_smarty_debug_info}
+ * @param Smarty
+ */
+function smarty_function_assign_debug_info($params, &$smarty)
+{
+    $assigned_vars = $smarty->_tpl_vars;
+    ksort($assigned_vars);
+    if (@is_array($smarty->_config[0])) {
+        $config_vars = $smarty->_config[0];
+        ksort($config_vars);
+        $smarty->assign("_debug_config_keys", array_keys($config_vars));
+        $smarty->assign("_debug_config_vals", array_values($config_vars));
+    }
+    
+    $included_templates = $smarty->_smarty_debug_info;
+    
+    $smarty->assign("_debug_keys", array_keys($assigned_vars));
+    $smarty->assign("_debug_vals", array_values($assigned_vars));
+    
+    $smarty->assign("_debug_tpls", $included_templates);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.config_load.php b/epgrec/Smarty.v2/plugins/function.config_load.php
--- a/epgrec/Smarty.v2/plugins/function.config_load.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.config_load.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,142 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty {config_load} function plugin
+ *
+ * Type:     function<br>
+ * Name:     config_load<br>
+ * Purpose:  load config file vars
+ * @link http://smarty.php.net/manual/en/language.function.config.load.php {config_load}
+ *       (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @author messju mohr <messju at lammfellpuschen dot de> (added use of resources)
+ * @param array Format:
+ * <pre>
+ * array('file' => required config file name,
+ *       'section' => optional config file section to load
+ *       'scope' => local/parent/global
+ *       'global' => overrides scope, setting to parent if true)
+ * </pre>
+ * @param Smarty
+ */
+function smarty_function_config_load($params, &$smarty)
+{
+        if ($smarty->debugging) {
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $_debug_start_time = smarty_core_get_microtime($_params, $smarty);
+        }
+
+        $_file = isset($params['file']) ? $smarty->_dequote($params['file']) : null;
+        $_section = isset($params['section']) ? $smarty->_dequote($params['section']) : null;
+        $_scope = isset($params['scope']) ? $smarty->_dequote($params['scope']) : 'global';
+        $_global = isset($params['global']) ? $smarty->_dequote($params['global']) : false;
+
+        if (!isset($_file) || strlen($_file) == 0) {
+            $smarty->trigger_error("missing 'file' attribute in config_load tag", E_USER_ERROR, __FILE__, __LINE__);
+        }
+
+        if (isset($_scope)) {
+            if ($_scope != 'local' &&
+                $_scope != 'parent' &&
+                $_scope != 'global') {
+                $smarty->trigger_error("invalid 'scope' attribute value", E_USER_ERROR, __FILE__, __LINE__);
+            }
+        } else {
+            if ($_global) {
+                $_scope = 'parent';
+            } else {
+                $_scope = 'local';
+            }
+        }
+
+        $_params = array('resource_name' => $_file,
+                         'resource_base_path' => $smarty->config_dir,
+                         'get_source' => false);
+        $smarty->_parse_resource_name($_params);
+        $_file_path = $_params['resource_type'] . ':' . $_params['resource_name'];
+        if (isset($_section))
+            $_compile_file = $smarty->_get_compile_path($_file_path.'|'.$_section);
+        else
+            $_compile_file = $smarty->_get_compile_path($_file_path);
+
+        if($smarty->force_compile || !file_exists($_compile_file)) {
+            $_compile = true;
+        } elseif ($smarty->compile_check) {
+            $_params = array('resource_name' => $_file,
+                             'resource_base_path' => $smarty->config_dir,
+                             'get_source' => false);
+            $_compile = $smarty->_fetch_resource_info($_params) &&
+                $_params['resource_timestamp'] > filemtime($_compile_file);
+        } else {
+            $_compile = false;
+        }
+
+        if($_compile) {
+            // compile config file
+            if(!is_object($smarty->_conf_obj)) {
+                require_once SMARTY_DIR . $smarty->config_class . '.class.php';
+                $smarty->_conf_obj = new $smarty->config_class();
+                $smarty->_conf_obj->overwrite = $smarty->config_overwrite;
+                $smarty->_conf_obj->booleanize = $smarty->config_booleanize;
+                $smarty->_conf_obj->read_hidden = $smarty->config_read_hidden;
+                $smarty->_conf_obj->fix_newlines = $smarty->config_fix_newlines;
+            }
+
+            $_params = array('resource_name' => $_file,
+                             'resource_base_path' => $smarty->config_dir,
+                             $_params['get_source'] = true);
+            if (!$smarty->_fetch_resource_info($_params)) {
+                return;
+            }
+            $smarty->_conf_obj->set_file_contents($_file, $_params['source_content']);
+            $_config_vars = array_merge($smarty->_conf_obj->get($_file),
+                    $smarty->_conf_obj->get($_file, $_section));
+            if(function_exists('var_export')) {
+                $_output = '<?php $_config_vars = ' . var_export($_config_vars, true) . '; ?>';
+            } else {
+                $_output = '<?php $_config_vars = unserialize(\'' . strtr(serialize($_config_vars),array('\''=>'\\\'', '\\'=>'\\\\')) . '\'); ?>';
+            }
+            $_params = (array('compile_path' => $_compile_file, 'compiled_content' => $_output, 'resource_timestamp' => $_params['resource_timestamp']));
+            require_once(SMARTY_CORE_DIR . 'core.write_compiled_resource.php');
+            smarty_core_write_compiled_resource($_params, $smarty);
+        } else {
+            include($_compile_file);
+        }
+
+        if ($smarty->caching) {
+            $smarty->_cache_info['config'][$_file] = true;
+        }
+
+        $smarty->_config[0]['vars'] = @array_merge($smarty->_config[0]['vars'], $_config_vars);
+        $smarty->_config[0]['files'][$_file] = true;
+
+        if ($_scope == 'parent') {
+                $smarty->_config[1]['vars'] = @array_merge($smarty->_config[1]['vars'], $_config_vars);
+                $smarty->_config[1]['files'][$_file] = true;
+        } else if ($_scope == 'global') {
+            for ($i = 1, $for_max = count($smarty->_config); $i < $for_max; $i++) {
+                $smarty->_config[$i]['vars'] = @array_merge($smarty->_config[$i]['vars'], $_config_vars);
+                $smarty->_config[$i]['files'][$_file] = true;
+            }
+        }
+
+        if ($smarty->debugging) {
+            $_params = array();
+            require_once(SMARTY_CORE_DIR . 'core.get_microtime.php');
+            $smarty->_smarty_debug_info[] = array('type'      => 'config',
+                                                'filename'  => $_file.' ['.$_section.'] '.$_scope,
+                                                'depth'     => $smarty->_inclusion_depth,
+                                                'exec_time' => smarty_core_get_microtime($_params, $smarty) - $_debug_start_time);
+        }
+
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.counter.php b/epgrec/Smarty.v2/plugins/function.counter.php
--- a/epgrec/Smarty.v2/plugins/function.counter.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.counter.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,80 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {counter} function plugin
+ *
+ * Type:     function<br>
+ * Name:     counter<br>
+ * Purpose:  print out a counter value
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @link http://smarty.php.net/manual/en/language.function.counter.php {counter}
+ *       (Smarty online manual)
+ * @param array parameters
+ * @param Smarty
+ * @return string|null
+ */
+function smarty_function_counter($params, &$smarty)
+{
+    static $counters = array();
+
+    $name = (isset($params['name'])) ? $params['name'] : 'default';
+    if (!isset($counters[$name])) {
+        $counters[$name] = array(
+            'start'=>1,
+            'skip'=>1,
+            'direction'=>'up',
+            'count'=>1
+            );
+    }
+    $counter =& $counters[$name];
+
+    if (isset($params['start'])) {
+        $counter['start'] = $counter['count'] = (int)$params['start'];
+    }
+
+    if (!empty($params['assign'])) {
+        $counter['assign'] = $params['assign'];
+    }
+
+    if (isset($counter['assign'])) {
+        $smarty->assign($counter['assign'], $counter['count']);
+    }
+    
+    if (isset($params['print'])) {
+        $print = (bool)$params['print'];
+    } else {
+        $print = empty($counter['assign']);
+    }
+
+    if ($print) {
+        $retval = $counter['count'];
+    } else {
+        $retval = null;
+    }
+
+    if (isset($params['skip'])) {
+        $counter['skip'] = $params['skip'];
+    }
+    
+    if (isset($params['direction'])) {
+        $counter['direction'] = $params['direction'];
+    }
+
+    if ($counter['direction'] == "down")
+        $counter['count'] -= $counter['skip'];
+    else
+        $counter['count'] += $counter['skip'];
+    
+    return $retval;
+    
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.cycle.php b/epgrec/Smarty.v2/plugins/function.cycle.php
--- a/epgrec/Smarty.v2/plugins/function.cycle.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.cycle.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,106 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty {cycle} function plugin
+ *
+ * Type:     function<br>
+ * Name:     cycle<br>
+ * Date:     May 3, 2002<br>
+ * Purpose:  cycle through given values<br>
+ * Input:
+ *         - name = name of cycle (optional)
+ *         - values = comma separated list of values to cycle,
+ *                    or an array of values to cycle
+ *                    (this can be left out for subsequent calls)
+ *         - reset = boolean - resets given var to true
+ *         - print = boolean - print var or not. default is true
+ *         - advance = boolean - whether or not to advance the cycle
+ *         - delimiter = the value delimiter, default is ","
+ *         - assign = boolean, assigns to template var instead of
+ *                    printed.
+ *
+ * Examples:<br>
+ * <pre>
+ * {cycle values="#eeeeee,#d0d0d0d"}
+ * {cycle name=row values="one,two,three" reset=true}
+ * {cycle name=row}
+ * </pre>
+ * @link http://smarty.php.net/manual/en/language.function.cycle.php {cycle}
+ *       (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @author credit to Mark Priatel <mpriatel@rogers.com>
+ * @author credit to Gerard <gerard@interfold.com>
+ * @author credit to Jason Sweat <jsweat_php@yahoo.com>
+ * @version  1.3
+ * @param array
+ * @param Smarty
+ * @return string|null
+ */
+function smarty_function_cycle($params, &$smarty)
+{
+    static $cycle_vars;
+    
+    $name = (empty($params['name'])) ? 'default' : $params['name'];
+    $print = (isset($params['print'])) ? (bool)$params['print'] : true;
+    $advance = (isset($params['advance'])) ? (bool)$params['advance'] : true;
+    $reset = (isset($params['reset'])) ? (bool)$params['reset'] : false;
+            
+    if (!in_array('values', array_keys($params))) {
+        if(!isset($cycle_vars[$name]['values'])) {
+            $smarty->trigger_error("cycle: missing 'values' parameter");
+            return;
+        }
+    } else {
+        if(isset($cycle_vars[$name]['values'])
+            && $cycle_vars[$name]['values'] != $params['values'] ) {
+            $cycle_vars[$name]['index'] = 0;
+        }
+        $cycle_vars[$name]['values'] = $params['values'];
+    }
+
+    if (isset($params['delimiter'])) {
+        $cycle_vars[$name]['delimiter'] = $params['delimiter'];
+    } elseif (!isset($cycle_vars[$name]['delimiter'])) {
+        $cycle_vars[$name]['delimiter'] = ',';       
+    }
+    
+    if(is_array($cycle_vars[$name]['values'])) {
+        $cycle_array = $cycle_vars[$name]['values'];
+    } else {
+        $cycle_array = explode($cycle_vars[$name]['delimiter'],$cycle_vars[$name]['values']);
+    }
+    
+    if(!isset($cycle_vars[$name]['index']) || $reset ) {
+        $cycle_vars[$name]['index'] = 0;
+    }
+    
+    if (isset($params['assign'])) {
+        $print = false;
+        $smarty->assign($params['assign'], $cycle_array[$cycle_vars[$name]['index']]);
+    }
+        
+    if($print) {
+        $retval = $cycle_array[$cycle_vars[$name]['index']];
+    } else {
+        $retval = null;
+    }
+
+    if($advance) {
+        if ( $cycle_vars[$name]['index'] >= count($cycle_array) -1 ) {
+            $cycle_vars[$name]['index'] = 0;
+        } else {
+            $cycle_vars[$name]['index']++;
+        }
+    }
+    
+    return $retval;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.debug.php b/epgrec/Smarty.v2/plugins/function.debug.php
--- a/epgrec/Smarty.v2/plugins/function.debug.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.debug.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,35 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {debug} function plugin
+ *
+ * Type:     function<br>
+ * Name:     debug<br>
+ * Date:     July 1, 2002<br>
+ * Purpose:  popup debug window
+ * @link http://smarty.php.net/manual/en/language.function.debug.php {debug}
+ *       (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @version  1.0
+ * @param array
+ * @param Smarty
+ * @return string output from {@link Smarty::_generate_debug_output()}
+ */
+function smarty_function_debug($params, &$smarty)
+{
+    if (isset($params['output'])) {
+        $smarty->assign('_smarty_debug_output', $params['output']);
+    }
+    require_once(SMARTY_CORE_DIR . 'core.display_debug_console.php');
+    return smarty_core_display_debug_console(null, $smarty);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.eval.php b/epgrec/Smarty.v2/plugins/function.eval.php
--- a/epgrec/Smarty.v2/plugins/function.eval.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.eval.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,49 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {eval} function plugin
+ *
+ * Type:     function<br>
+ * Name:     eval<br>
+ * Purpose:  evaluate a template variable as a template<br>
+ * @link http://smarty.php.net/manual/en/language.function.eval.php {eval}
+ *       (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @param array
+ * @param Smarty
+ */
+function smarty_function_eval($params, &$smarty)
+{
+
+    if (!isset($params['var'])) {
+        $smarty->trigger_error("eval: missing 'var' parameter");
+        return;
+    }
+
+    if($params['var'] == '') {
+        return;
+    }
+
+    $smarty->_compile_source('evaluated template', $params['var'], $_var_compiled);
+
+    ob_start();
+    $smarty->_eval('?>' . $_var_compiled);
+    $_contents = ob_get_contents();
+    ob_end_clean();
+
+    if (!empty($params['assign'])) {
+        $smarty->assign($params['assign'], $_contents);
+    } else {
+        return $_contents;
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.fetch.php b/epgrec/Smarty.v2/plugins/function.fetch.php
--- a/epgrec/Smarty.v2/plugins/function.fetch.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.fetch.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,221 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {fetch} plugin
+ *
+ * Type:     function<br>
+ * Name:     fetch<br>
+ * Purpose:  fetch file, web or ftp data and display results
+ * @link http://smarty.php.net/manual/en/language.function.fetch.php {fetch}
+ *       (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @param array
+ * @param Smarty
+ * @return string|null if the assign parameter is passed, Smarty assigns the
+ *                     result to a template variable
+ */
+function smarty_function_fetch($params, &$smarty)
+{
+    if (empty($params['file'])) {
+        $smarty->_trigger_fatal_error("[plugin] parameter 'file' cannot be empty");
+        return;
+    }
+
+    $content = '';
+    if ($smarty->security && !preg_match('!^(http|ftp)://!i', $params['file'])) {
+        $_params = array('resource_type' => 'file', 'resource_name' => $params['file']);
+        require_once(SMARTY_CORE_DIR . 'core.is_secure.php');
+        if(!smarty_core_is_secure($_params, $smarty)) {
+            $smarty->_trigger_fatal_error('[plugin] (secure mode) fetch \'' . $params['file'] . '\' is not allowed');
+            return;
+        }
+        
+        // fetch the file
+        if($fp = @fopen($params['file'],'r')) {
+            while(!feof($fp)) {
+                $content .= fgets ($fp,4096);
+            }
+            fclose($fp);
+        } else {
+            $smarty->_trigger_fatal_error('[plugin] fetch cannot read file \'' . $params['file'] . '\'');
+            return;
+        }
+    } else {
+        // not a local file
+        if(preg_match('!^http://!i',$params['file'])) {
+            // http fetch
+            if($uri_parts = parse_url($params['file'])) {
+                // set defaults
+                $host = $server_name = $uri_parts['host'];
+                $timeout = 30;
+                $accept = "image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*";
+                $agent = "Smarty Template Engine ".$smarty->_version;
+                $referer = "";
+                $uri = !empty($uri_parts['path']) ? $uri_parts['path'] : '/';
+                $uri .= !empty($uri_parts['query']) ? '?' . $uri_parts['query'] : '';
+                $_is_proxy = false;
+                if(empty($uri_parts['port'])) {
+                    $port = 80;
+                } else {
+                    $port = $uri_parts['port'];
+                }
+                if(!empty($uri_parts['user'])) {
+                    $user = $uri_parts['user'];
+                }
+                if(!empty($uri_parts['pass'])) {
+                    $pass = $uri_parts['pass'];
+                }
+                // loop through parameters, setup headers
+                foreach($params as $param_key => $param_value) {
+                    switch($param_key) {
+                        case "file":
+                        case "assign":
+                        case "assign_headers":
+                            break;
+                        case "user":
+                            if(!empty($param_value)) {
+                                $user = $param_value;
+                            }
+                            break;
+                        case "pass":
+                            if(!empty($param_value)) {
+                                $pass = $param_value;
+                            }
+                            break;
+                        case "accept":
+                            if(!empty($param_value)) {
+                                $accept = $param_value;
+                            }
+                            break;
+                        case "header":
+                            if(!empty($param_value)) {
+                                if(!preg_match('![\w\d-]+: .+!',$param_value)) {
+                                    $smarty->_trigger_fatal_error("[plugin] invalid header format '".$param_value."'");
+                                    return;
+                                } else {
+                                    $extra_headers[] = $param_value;
+                                }
+                            }
+                            break;
+                        case "proxy_host":
+                            if(!empty($param_value)) {
+                                $proxy_host = $param_value;
+                            }
+                            break;
+                        case "proxy_port":
+                            if(!preg_match('!\D!', $param_value)) {
+                                $proxy_port = (int) $param_value;
+                            } else {
+                                $smarty->_trigger_fatal_error("[plugin] invalid value for attribute '".$param_key."'");
+                                return;
+                            }
+                            break;
+                        case "agent":
+                            if(!empty($param_value)) {
+                                $agent = $param_value;
+                            }
+                            break;
+                        case "referer":
+                            if(!empty($param_value)) {
+                                $referer = $param_value;
+                            }
+                            break;
+                        case "timeout":
+                            if(!preg_match('!\D!', $param_value)) {
+                                $timeout = (int) $param_value;
+                            } else {
+                                $smarty->_trigger_fatal_error("[plugin] invalid value for attribute '".$param_key."'");
+                                return;
+                            }
+                            break;
+                        default:
+                            $smarty->_trigger_fatal_error("[plugin] unrecognized attribute '".$param_key."'");
+                            return;
+                    }
+                }
+                if(!empty($proxy_host) && !empty($proxy_port)) {
+                    $_is_proxy = true;
+                    $fp = fsockopen($proxy_host,$proxy_port,$errno,$errstr,$timeout);
+                } else {
+                    $fp = fsockopen($server_name,$port,$errno,$errstr,$timeout);
+                }
+
+                if(!$fp) {
+                    $smarty->_trigger_fatal_error("[plugin] unable to fetch: $errstr ($errno)");
+                    return;
+                } else {
+                    if($_is_proxy) {
+                        fputs($fp, 'GET ' . $params['file'] . " HTTP/1.0\r\n");
+                    } else {
+                        fputs($fp, "GET $uri HTTP/1.0\r\n");
+                    }
+                    if(!empty($host)) {
+                        fputs($fp, "Host: $host\r\n");
+                    }
+                    if(!empty($accept)) {
+                        fputs($fp, "Accept: $accept\r\n");
+                    }
+                    if(!empty($agent)) {
+                        fputs($fp, "User-Agent: $agent\r\n");
+                    }
+                    if(!empty($referer)) {
+                        fputs($fp, "Referer: $referer\r\n");
+                    }
+                    if(isset($extra_headers) && is_array($extra_headers)) {
+                        foreach($extra_headers as $curr_header) {
+                            fputs($fp, $curr_header."\r\n");
+                        }
+                    }
+                    if(!empty($user) && !empty($pass)) {
+                        fputs($fp, "Authorization: BASIC ".base64_encode("$user:$pass")."\r\n");
+                    }
+
+                    fputs($fp, "\r\n");
+                    while(!feof($fp)) {
+                        $content .= fgets($fp,4096);
+                    }
+                    fclose($fp);
+                    $csplit = preg_split("!\r\n\r\n!",$content,2);
+
+                    $content = $csplit[1];
+
+                    if(!empty($params['assign_headers'])) {
+                        $smarty->assign($params['assign_headers'],preg_split("!\r\n!",$csplit[0]));
+                    }
+                }
+            } else {
+                $smarty->_trigger_fatal_error("[plugin] unable to parse URL, check syntax");
+                return;
+            }
+        } else {
+            // ftp fetch
+            if($fp = @fopen($params['file'],'r')) {
+                while(!feof($fp)) {
+                    $content .= fgets ($fp,4096);
+                }
+                fclose($fp);
+            } else {
+                $smarty->_trigger_fatal_error('[plugin] fetch cannot read file \'' . $params['file'] .'\'');
+                return;
+            }
+        }
+
+    }
+
+
+    if (!empty($params['assign'])) {
+        $smarty->assign($params['assign'],$content);
+    } else {
+        return $content;
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.html_checkboxes.php b/epgrec/Smarty.v2/plugins/function.html_checkboxes.php
--- a/epgrec/Smarty.v2/plugins/function.html_checkboxes.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.html_checkboxes.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,143 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {html_checkboxes} function plugin
+ *
+ * File:       function.html_checkboxes.php<br>
+ * Type:       function<br>
+ * Name:       html_checkboxes<br>
+ * Date:       24.Feb.2003<br>
+ * Purpose:    Prints out a list of checkbox input types<br>
+ * Input:<br>
+ *           - name       (optional) - string default "checkbox"
+ *           - values     (required) - array
+ *           - options    (optional) - associative array
+ *           - checked    (optional) - array default not set
+ *           - separator  (optional) - ie <br> or &nbsp;
+ *           - output     (optional) - the output next to each checkbox
+ *           - assign     (optional) - assign the output as an array to this variable
+ * Examples:
+ * <pre>
+ * {html_checkboxes values=$ids output=$names}
+ * {html_checkboxes values=$ids name='box' separator='<br>' output=$names}
+ * {html_checkboxes values=$ids checked=$checked separator='<br>' output=$names}
+ * </pre>
+ * @link http://smarty.php.net/manual/en/language.function.html.checkboxes.php {html_checkboxes}
+ *      (Smarty online manual)
+ * @author     Christopher Kvarme <christopher.kvarme@flashjab.com>
+ * @author credits to Monte Ohrt <monte at ohrt dot com>
+ * @version    1.0
+ * @param array
+ * @param Smarty
+ * @return string
+ * @uses smarty_function_escape_special_chars()
+ */
+function smarty_function_html_checkboxes($params, &$smarty)
+{
+    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
+
+    $name = 'checkbox';
+    $values = null;
+    $options = null;
+    $selected = null;
+    $separator = '';
+    $labels = true;
+    $output = null;
+
+    $extra = '';
+
+    foreach($params as $_key => $_val) {
+        switch($_key) {
+            case 'name':
+            case 'separator':
+                $$_key = $_val;
+                break;
+
+            case 'labels':
+                $$_key = (bool)$_val;
+                break;
+
+            case 'options':
+                $$_key = (array)$_val;
+                break;
+
+            case 'values':
+            case 'output':
+                $$_key = array_values((array)$_val);
+                break;
+
+            case 'checked':
+            case 'selected':
+                $selected = array_map('strval', array_values((array)$_val));
+                break;
+
+            case 'checkboxes':
+                $smarty->trigger_error('html_checkboxes: the use of the "checkboxes" attribute is deprecated, use "options" instead', E_USER_WARNING);
+                $options = (array)$_val;
+                break;
+
+            case 'assign':
+                break;
+
+            default:
+                if(!is_array($_val)) {
+                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                } else {
+                    $smarty->trigger_error("html_checkboxes: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                }
+                break;
+        }
+    }
+
+    if (!isset($options) && !isset($values))
+        return ''; /* raise error here? */
+
+    settype($selected, 'array');
+    $_html_result = array();
+
+    if (isset($options)) {
+
+        foreach ($options as $_key=>$_val)
+            $_html_result[] = smarty_function_html_checkboxes_output($name, $_key, $_val, $selected, $extra, $separator, $labels);
+
+
+    } else {
+        foreach ($values as $_i=>$_key) {
+            $_val = isset($output[$_i]) ? $output[$_i] : '';
+            $_html_result[] = smarty_function_html_checkboxes_output($name, $_key, $_val, $selected, $extra, $separator, $labels);
+        }
+
+    }
+
+    if(!empty($params['assign'])) {
+        $smarty->assign($params['assign'], $_html_result);
+    } else {
+        return implode("\n",$_html_result);
+    }
+
+}
+
+function smarty_function_html_checkboxes_output($name, $value, $output, $selected, $extra, $separator, $labels) {
+    $_output = '';
+    if ($labels) $_output .= '<label>';
+    $_output .= '<input type="checkbox" name="'
+        . smarty_function_escape_special_chars($name) . '[]" value="'
+        . smarty_function_escape_special_chars($value) . '"';
+
+    if (in_array((string)$value, $selected)) {
+        $_output .= ' checked="checked"';
+    }
+    $_output .= $extra . ' />' . $output;
+    if ($labels) $_output .= '</label>';
+    $_output .=  $separator;
+
+    return $_output;
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.html_image.php b/epgrec/Smarty.v2/plugins/function.html_image.php
--- a/epgrec/Smarty.v2/plugins/function.html_image.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.html_image.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,142 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {html_image} function plugin
+ *
+ * Type:     function<br>
+ * Name:     html_image<br>
+ * Date:     Feb 24, 2003<br>
+ * Purpose:  format HTML tags for the image<br>
+ * Input:<br>
+ *         - file = file (and path) of image (required)
+ *         - height = image height (optional, default actual height)
+ *         - width = image width (optional, default actual width)
+ *         - basedir = base directory for absolute paths, default
+ *                     is environment variable DOCUMENT_ROOT
+ *         - path_prefix = prefix for path output (optional, default empty)
+ *
+ * Examples: {html_image file="/images/masthead.gif"}
+ * Output:   <img src="/images/masthead.gif" width=400 height=23>
+ * @link http://smarty.php.net/manual/en/language.function.html.image.php {html_image}
+ *      (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @author credits to Duda <duda@big.hu> - wrote first image function
+ *           in repository, helped with lots of functionality
+ * @version  1.0
+ * @param array
+ * @param Smarty
+ * @return string
+ * @uses smarty_function_escape_special_chars()
+ */
+function smarty_function_html_image($params, &$smarty)
+{
+    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
+    
+    $alt = '';
+    $file = '';
+    $height = '';
+    $width = '';
+    $extra = '';
+    $prefix = '';
+    $suffix = '';
+    $path_prefix = '';
+    $server_vars = ($smarty->request_use_auto_globals) ? $_SERVER : $GLOBALS['HTTP_SERVER_VARS'];
+    $basedir = isset($server_vars['DOCUMENT_ROOT']) ? $server_vars['DOCUMENT_ROOT'] : '';
+    foreach($params as $_key => $_val) {
+        switch($_key) {
+            case 'file':
+            case 'height':
+            case 'width':
+            case 'dpi':
+            case 'path_prefix':
+            case 'basedir':
+                $$_key = $_val;
+                break;
+
+            case 'alt':
+                if(!is_array($_val)) {
+                    $$_key = smarty_function_escape_special_chars($_val);
+                } else {
+                    $smarty->trigger_error("html_image: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                }
+                break;
+
+            case 'link':
+            case 'href':
+                $prefix = '<a href="' . $_val . '">';
+                $suffix = '</a>';
+                break;
+
+            default:
+                if(!is_array($_val)) {
+                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                } else {
+                    $smarty->trigger_error("html_image: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                }
+                break;
+        }
+    }
+
+    if (empty($file)) {
+        $smarty->trigger_error("html_image: missing 'file' parameter", E_USER_NOTICE);
+        return;
+    }
+
+    if (substr($file,0,1) == '/') {
+        $_image_path = $basedir . $file;
+    } else {
+        $_image_path = $file;
+    }
+    
+    if(!isset($params['width']) || !isset($params['height'])) {
+        if(!$_image_data = @getimagesize($_image_path)) {
+            if(!file_exists($_image_path)) {
+                $smarty->trigger_error("html_image: unable to find '$_image_path'", E_USER_NOTICE);
+                return;
+            } else if(!is_readable($_image_path)) {
+                $smarty->trigger_error("html_image: unable to read '$_image_path'", E_USER_NOTICE);
+                return;
+            } else {
+                $smarty->trigger_error("html_image: '$_image_path' is not a valid image file", E_USER_NOTICE);
+                return;
+            }
+        }
+        if ($smarty->security &&
+            ($_params = array('resource_type' => 'file', 'resource_name' => $_image_path)) &&
+            (require_once(SMARTY_CORE_DIR . 'core.is_secure.php')) &&
+            (!smarty_core_is_secure($_params, $smarty)) ) {
+            $smarty->trigger_error("html_image: (secure) '$_image_path' not in secure directory", E_USER_NOTICE);
+        }        
+        
+        if(!isset($params['width'])) {
+            $width = $_image_data[0];
+        }
+        if(!isset($params['height'])) {
+            $height = $_image_data[1];
+        }
+
+    }
+
+    if(isset($params['dpi'])) {
+        if(strstr($server_vars['HTTP_USER_AGENT'], 'Mac')) {
+            $dpi_default = 72;
+        } else {
+            $dpi_default = 96;
+        }
+        $_resize = $dpi_default/$params['dpi'];
+        $width = round($width * $_resize);
+        $height = round($height * $_resize);
+    }
+
+    return $prefix . '<img src="'.$path_prefix.$file.'" alt="'.$alt.'" width="'.$width.'" height="'.$height.'"'.$extra.' />' . $suffix;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.html_options.php b/epgrec/Smarty.v2/plugins/function.html_options.php
--- a/epgrec/Smarty.v2/plugins/function.html_options.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.html_options.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,122 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {html_options} function plugin
+ *
+ * Type:     function<br>
+ * Name:     html_options<br>
+ * Input:<br>
+ *           - name       (optional) - string default "select"
+ *           - values     (required if no options supplied) - array
+ *           - options    (required if no values supplied) - associative array
+ *           - selected   (optional) - string default not set
+ *           - output     (required if not options supplied) - array
+ * Purpose:  Prints the list of <option> tags generated from
+ *           the passed parameters
+ * @link http://smarty.php.net/manual/en/language.function.html.options.php {html_image}
+ *      (Smarty online manual)
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @param array
+ * @param Smarty
+ * @return string
+ * @uses smarty_function_escape_special_chars()
+ */
+function smarty_function_html_options($params, &$smarty)
+{
+    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
+    
+    $name = null;
+    $values = null;
+    $options = null;
+    $selected = array();
+    $output = null;
+    
+    $extra = '';
+    
+    foreach($params as $_key => $_val) {
+        switch($_key) {
+            case 'name':
+                $$_key = (string)$_val;
+                break;
+            
+            case 'options':
+                $$_key = (array)$_val;
+                break;
+                
+            case 'values':
+            case 'output':
+                $$_key = array_values((array)$_val);
+                break;
+
+            case 'selected':
+                $$_key = array_map('strval', array_values((array)$_val));
+                break;
+                
+            default:
+                if(!is_array($_val)) {
+                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                } else {
+                    $smarty->trigger_error("html_options: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                }
+                break;
+        }
+    }
+
+    if (!isset($options) && !isset($values))
+        return ''; /* raise error here? */
+
+    $_html_result = '';
+
+    if (isset($options)) {
+        
+        foreach ($options as $_key=>$_val)
+            $_html_result .= smarty_function_html_options_optoutput($_key, $_val, $selected);
+
+    } else {
+        
+        foreach ($values as $_i=>$_key) {
+            $_val = isset($output[$_i]) ? $output[$_i] : '';
+            $_html_result .= smarty_function_html_options_optoutput($_key, $_val, $selected);
+        }
+
+    }
+
+    if(!empty($name)) {
+        $_html_result = '<select name="' . $name . '"' . $extra . '>' . "\n" . $_html_result . '</select>' . "\n";
+    }
+
+    return $_html_result;
+
+}
+
+function smarty_function_html_options_optoutput($key, $value, $selected) {
+    if(!is_array($value)) {
+        $_html_result = '<option label="' . smarty_function_escape_special_chars($value) . '" value="' .
+            smarty_function_escape_special_chars($key) . '"';
+        if (in_array((string)$key, $selected))
+            $_html_result .= ' selected="selected"';
+        $_html_result .= '>' . smarty_function_escape_special_chars($value) . '</option>' . "\n";
+    } else {
+        $_html_result = smarty_function_html_options_optgroup($key, $value, $selected);
+    }
+    return $_html_result;
+}
+
+function smarty_function_html_options_optgroup($key, $values, $selected) {
+    $optgroup_html = '<optgroup label="' . smarty_function_escape_special_chars($key) . '">' . "\n";
+    foreach ($values as $key => $value) {
+        $optgroup_html .= smarty_function_html_options_optoutput($key, $value, $selected);
+    }
+    $optgroup_html .= "</optgroup>\n";
+    return $optgroup_html;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.html_radios.php b/epgrec/Smarty.v2/plugins/function.html_radios.php
--- a/epgrec/Smarty.v2/plugins/function.html_radios.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.html_radios.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,156 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {html_radios} function plugin
+ *
+ * File:       function.html_radios.php<br>
+ * Type:       function<br>
+ * Name:       html_radios<br>
+ * Date:       24.Feb.2003<br>
+ * Purpose:    Prints out a list of radio input types<br>
+ * Input:<br>
+ *           - name       (optional) - string default "radio"
+ *           - values     (required) - array
+ *           - options    (optional) - associative array
+ *           - checked    (optional) - array default not set
+ *           - separator  (optional) - ie <br> or &nbsp;
+ *           - output     (optional) - the output next to each radio button
+ *           - assign     (optional) - assign the output as an array to this variable
+ * Examples:
+ * <pre>
+ * {html_radios values=$ids output=$names}
+ * {html_radios values=$ids name='box' separator='<br>' output=$names}
+ * {html_radios values=$ids checked=$checked separator='<br>' output=$names}
+ * </pre>
+ * @link http://smarty.php.net/manual/en/language.function.html.radios.php {html_radios}
+ *      (Smarty online manual)
+ * @author     Christopher Kvarme <christopher.kvarme@flashjab.com>
+ * @author credits to Monte Ohrt <monte at ohrt dot com>
+ * @version    1.0
+ * @param array
+ * @param Smarty
+ * @return string
+ * @uses smarty_function_escape_special_chars()
+ */
+function smarty_function_html_radios($params, &$smarty)
+{
+    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
+   
+    $name = 'radio';
+    $values = null;
+    $options = null;
+    $selected = null;
+    $separator = '';
+    $labels = true;
+    $label_ids = false;
+    $output = null;
+    $extra = '';
+
+    foreach($params as $_key => $_val) {
+        switch($_key) {
+            case 'name':
+            case 'separator':
+                $$_key = (string)$_val;
+                break;
+
+            case 'checked':
+            case 'selected':
+                if(is_array($_val)) {
+                    $smarty->trigger_error('html_radios: the "' . $_key . '" attribute cannot be an array', E_USER_WARNING);
+                } else {
+                    $selected = (string)$_val;
+                }
+                break;
+
+            case 'labels':
+            case 'label_ids':
+                $$_key = (bool)$_val;
+                break;
+
+            case 'options':
+                $$_key = (array)$_val;
+                break;
+
+            case 'values':
+            case 'output':
+                $$_key = array_values((array)$_val);
+                break;
+
+            case 'radios':
+                $smarty->trigger_error('html_radios: the use of the "radios" attribute is deprecated, use "options" instead', E_USER_WARNING);
+                $options = (array)$_val;
+                break;
+
+            case 'assign':
+                break;
+
+            default:
+                if(!is_array($_val)) {
+                    $extra .= ' '.$_key.'="'.smarty_function_escape_special_chars($_val).'"';
+                } else {
+                    $smarty->trigger_error("html_radios: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                }
+                break;
+        }
+    }
+
+    if (!isset($options) && !isset($values))
+        return ''; /* raise error here? */
+
+    $_html_result = array();
+
+    if (isset($options)) {
+
+        foreach ($options as $_key=>$_val)
+            $_html_result[] = smarty_function_html_radios_output($name, $_key, $_val, $selected, $extra, $separator, $labels, $label_ids);
+
+    } else {
+
+        foreach ($values as $_i=>$_key) {
+            $_val = isset($output[$_i]) ? $output[$_i] : '';
+            $_html_result[] = smarty_function_html_radios_output($name, $_key, $_val, $selected, $extra, $separator, $labels, $label_ids);
+        }
+
+    }
+
+    if(!empty($params['assign'])) {
+        $smarty->assign($params['assign'], $_html_result);
+    } else {
+        return implode("\n",$_html_result);
+    }
+
+}
+
+function smarty_function_html_radios_output($name, $value, $output, $selected, $extra, $separator, $labels, $label_ids) {
+    $_output = '';
+    if ($labels) {
+      if($label_ids) {
+          $_id = smarty_function_escape_special_chars(preg_replace('![^\w\-\.]!', '_', $name . '_' . $value));
+          $_output .= '<label for="' . $_id . '">';
+      } else {
+          $_output .= '<label>';           
+      }
+   }
+   $_output .= '<input type="radio" name="'
+        . smarty_function_escape_special_chars($name) . '" value="'
+        . smarty_function_escape_special_chars($value) . '"';
+
+   if ($labels && $label_ids) $_output .= ' id="' . $_id . '"';
+
+    if ((string)$value==$selected) {
+        $_output .= ' checked="checked"';
+    }
+    $_output .= $extra . ' />' . $output;
+    if ($labels) $_output .= '</label>';
+    $_output .=  $separator;
+
+    return $_output;
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.html_select_date.php b/epgrec/Smarty.v2/plugins/function.html_select_date.php
--- a/epgrec/Smarty.v2/plugins/function.html_select_date.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.html_select_date.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,331 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty {html_select_date} plugin
+ *
+ * Type:     function<br>
+ * Name:     html_select_date<br>
+ * Purpose:  Prints the dropdowns for date selection.
+ *
+ * ChangeLog:<br>
+ *           - 1.0 initial release
+ *           - 1.1 added support for +/- N syntax for begin
+ *                and end year values. (Monte)
+ *           - 1.2 added support for yyyy-mm-dd syntax for
+ *                time value. (Jan Rosier)
+ *           - 1.3 added support for choosing format for
+ *                month values (Gary Loescher)
+ *           - 1.3.1 added support for choosing format for
+ *                day values (Marcus Bointon)
+ *           - 1.3.2 support negative timestamps, force year
+ *             dropdown to include given date unless explicitly set (Monte)
+ *           - 1.3.4 fix behaviour of 0000-00-00 00:00:00 dates to match that
+ *             of 0000-00-00 dates (cybot, boots)
+ * @link http://smarty.php.net/manual/en/language.function.html.select.date.php {html_select_date}
+ *      (Smarty online manual)
+ * @version 1.3.4
+ * @author Andrei Zmievski
+ * @author Monte Ohrt <monte at ohrt dot com>
+ * @param array
+ * @param Smarty
+ * @return string
+ */
+function smarty_function_html_select_date($params, &$smarty)
+{
+    require_once $smarty->_get_plugin_filepath('shared','escape_special_chars');
+    require_once $smarty->_get_plugin_filepath('shared','make_timestamp');
+    require_once $smarty->_get_plugin_filepath('function','html_options');
+    /* Default values. */
+    $prefix          = "Date_";
+    $start_year      = strftime("%Y");
+    $end_year        = $start_year;
+    $display_days    = true;
+    $display_months  = true;
+    $display_years   = true;
+    $month_format    = "%B";
+    /* Write months as numbers by default  GL */
+    $month_value_format = "%m";
+    $day_format      = "%02d";
+    /* Write day values using this format MB */
+    $day_value_format = "%d";
+    $year_as_text    = false;
+    /* Display years in reverse order? Ie. 2000,1999,.... */
+    $reverse_years   = false;
+    /* Should the select boxes be part of an array when returned from PHP?
+       e.g. setting it to "birthday", would create "birthday[Day]",
+       "birthday[Month]" & "birthday[Year]". Can be combined with prefix */
+    $field_array     = null;
+    /* <select size>'s of the different <select> tags.
+       If not set, uses default dropdown. */
+    $day_size        = null;
+    $month_size      = null;
+    $year_size       = null;
+    /* Unparsed attributes common to *ALL* the <select>/<input> tags.
+       An example might be in the template: all_extra ='class ="foo"'. */
+    $all_extra       = null;
+    /* Separate attributes for the tags. */
+    $day_extra       = null;
+    $month_extra     = null;
+    $year_extra      = null;
+    /* Order in which to display the fields.
+       "D" -> day, "M" -> month, "Y" -> year. */
+    $field_order     = 'MDY';
+    /* String printed between the different fields. */
+    $field_separator = "\n";
+    $time = time();
+    $all_empty       = null;
+    $day_empty       = null;
+    $month_empty     = null;
+    $year_empty      = null;
+    $extra_attrs     = '';
+
+    foreach ($params as $_key=>$_value) {
+        switch ($_key) {
+            case 'prefix':
+            case 'time':
+            case 'start_year':
+            case 'end_year':
+            case 'month_format':
+            case 'day_format':
+            case 'day_value_format':
+            case 'field_array':
+            case 'day_size':
+            case 'month_size':
+            case 'year_size':
+            case 'all_extra':
+            case 'day_extra':
+            case 'month_extra':
+            case 'year_extra':
+            case 'field_order':
+            case 'field_separator':
+            case 'month_value_format':
+            case 'month_empty':
+            case 'day_empty':
+            case 'year_empty':
+                $$_key = (string)$_value;
+                break;
+
+            case 'all_empty':
+                $$_key = (string)$_value;
+                $day_empty = $month_empty = $year_empty = $all_empty;
+                break;
+
+            case 'display_days':
+            case 'display_months':
+            case 'display_years':
+            case 'year_as_text':
+            case 'reverse_years':
+                $$_key = (bool)$_value;
+                break;
+
+            default:
+                if(!is_array($_value)) {
+                    $extra_attrs .= ' '.$_key.'="'.smarty_function_escape_special_chars($_value).'"';
+                } else {
+                    $smarty->trigger_error("html_select_date: extra attribute '$_key' cannot be an array", E_USER_NOTICE);
+                }
+                break;
+        }
+    }
+
+    if (preg_match('!^-\d+$!', $time)) {
+        // negative timestamp, use date()
+        $time = date('Y-m-d', $time);
+    }
+    // If $time is not in format yyyy-mm-dd
+    if (preg_match('/^(\d{0,4}-\d{0,2}-\d{0,2})/', $time, $found)) {
+        $time = $found[1];
+    } else {
+        // use smarty_make_timestamp to get an unix timestamp and
+        // strftime to make yyyy-mm-dd
+        $time = strftime('%Y-%m-%d', smarty_make_timestamp($time));
+    }
+    // Now split this in pieces, which later can be used to set the select
+    $time = explode("-", $time);
+
+    // make syntax "+N" or "-N" work with start_year and end_year
+    if (preg_match('!^(\+|\-)\s*(\d+)$!', $end_year, $match)) {
+        if ($match[1] == '+') {
+            $end_year = strftime('%Y') + $match[2];
+        } else {
+            $end_year = strftime('%Y') - $match[2];
+        }
+    }
+    if (preg_match('!^(\+|\-)\s*(\d+)$!', $start_year, $match)) {
+        if ($match[1] == '+') {
+            $start_year = strftime('%Y') + $match[2];
+        } else {
+            $start_year = strftime('%Y') - $match[2];
+        }
+    }
+    if (strlen($time[0]) > 0) {
+        if ($start_year > $time[0] && !isset($params['start_year'])) {
+            // force start year to include given date if not explicitly set
+            $start_year = $time[0];
+        }
+        if($end_year < $time[0] && !isset($params['end_year'])) {
+            // force end year to include given date if not explicitly set
+            $end_year = $time[0];
+        }
+    }
+
+    $field_order = strtoupper($field_order);
+
+    $html_result = $month_result = $day_result = $year_result = "";
+
+    $field_separator_count = -1;
+    if ($display_months) {
+    	$field_separator_count++;
+        $month_names = array();
+        $month_values = array();
+        if(isset($month_empty)) {
+            $month_names[''] = $month_empty;
+            $month_values[''] = '';
+        }
+        for ($i = 1; $i <= 12; $i++) {
+            $month_names[$i] = strftime($month_format, mktime(0, 0, 0, $i, 1, 2000));
+            $month_values[$i] = strftime($month_value_format, mktime(0, 0, 0, $i, 1, 2000));
+        }
+
+        $month_result .= '<select name=';
+        if (null !== $field_array){
+            $month_result .= '"' . $field_array . '[' . $prefix . 'Month]"';
+        } else {
+            $month_result .= '"' . $prefix . 'Month"';
+        }
+        if (null !== $month_size){
+            $month_result .= ' size="' . $month_size . '"';
+        }
+        if (null !== $month_extra){
+            $month_result .= ' ' . $month_extra;
+        }
+        if (null !== $all_extra){
+            $month_result .= ' ' . $all_extra;
+        }
+        $month_result .= $extra_attrs . '>'."\n";
+
+        $month_result .= smarty_function_html_options(array('output'     => $month_names,
+                                                            'values'     => $month_values,
+                                                            'selected'   => (int)$time[1] ? strftime($month_value_format, mktime(0, 0, 0, (int)$time[1], 1, 2000)) : '',
+                                                            'print_result' => false),
+                                                      $smarty);
+        $month_result .= '</select>';
+    }
+
+    if ($display_days) {
+    	$field_separator_count++;
+        $days = array();
+        if (isset($day_empty)) {
+            $days[''] = $day_empty;
+            $day_values[''] = '';
+        }
+        for ($i = 1; $i <= 31; $i++) {
+            $days[] = sprintf($day_format, $i);
+            $day_values[] = sprintf($day_value_format, $i);
+        }
+
+        $day_result .= '<select name=';
+        if (null !== $field_array){
+            $day_result .= '"' . $field_array . '[' . $prefix . 'Day]"';
+        } else {
+            $day_result .= '"' . $prefix . 'Day"';
+        }
+        if (null !== $day_size){
+            $day_result .= ' size="' . $day_size . '"';
+        }
+        if (null !== $all_extra){
+            $day_result .= ' ' . $all_extra;
+        }
+        if (null !== $day_extra){
+            $day_result .= ' ' . $day_extra;
+        }
+        $day_result .= $extra_attrs . '>'."\n";
+        $day_result .= smarty_function_html_options(array('output'     => $days,
+                                                          'values'     => $day_values,
+                                                          'selected'   => $time[2],
+                                                          'print_result' => false),
+                                                    $smarty);
+        $day_result .= '</select>';
+    }
+
+    if ($display_years) {
+    	$field_separator_count++;
+        if (null !== $field_array){
+            $year_name = $field_array . '[' . $prefix . 'Year]';
+        } else {
+            $year_name = $prefix . 'Year';
+        }
+        if ($year_as_text) {
+            $year_result .= '<input type="text" name="' . $year_name . '" value="' . $time[0] . '" size="4" maxlength="4"';
+            if (null !== $all_extra){
+                $year_result .= ' ' . $all_extra;
+            }
+            if (null !== $year_extra){
+                $year_result .= ' ' . $year_extra;
+            }
+            $year_result .= ' />';
+        } else {
+            $years = range((int)$start_year, (int)$end_year);
+            if ($reverse_years) {
+                rsort($years, SORT_NUMERIC);
+            } else {
+                sort($years, SORT_NUMERIC);
+            }
+            $yearvals = $years;
+            if(isset($year_empty)) {
+                array_unshift($years, $year_empty);
+                array_unshift($yearvals, '');
+            }
+            $year_result .= '<select name="' . $year_name . '"';
+            if (null !== $year_size){
+                $year_result .= ' size="' . $year_size . '"';
+            }
+            if (null !== $all_extra){
+                $year_result .= ' ' . $all_extra;
+            }
+            if (null !== $year_extra){
+                $year_result .= ' ' . $year_extra;
+            }
+            $year_result .= $extra_attrs . '>'."\n";
+            $year_result .= smarty_function_html_options(array('output' => $years,
+                                                               'values' => $yearvals,
+                                                               'selected'   => $time[0],
+                                                               'print_result' => false),
+                                                         $smarty);
+            $year_result .= '</select>';
+        }
+    }
+
+    // Loop thru the field_order field
+    for ($i = 0; $i <= 2; $i++){
+        $c = substr($field_order, $i, 1);
+        switch ($c){
+            case 'D':
+                $html_result .= $day_result;
+                break;
+
+            case 'M':
+                $html_result .= $month_result;
+                break;
+
+            case 'Y':
+                $html_result .= $year_result;
+                break;
+        }
+        // Add the field seperator
+        if($i < $field_separator_count) {
+            $html_result .= $field_separator;
+        }
+    }
+
+    return $html_result;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.html_select_time.php b/epgrec/Smarty.v2/plugins/function.html_select_time.php
--- a/epgrec/Smarty.v2/plugins/function.html_select_time.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.html_select_time.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,194 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {html_select_time} function plugin
+ *
+ * Type:     function<br>
+ * Name:     html_select_time<br>
+ * Purpose:  Prints the dropdowns for time selection
+ * @link http://smarty.php.net/manual/en/language.function.html.select.time.php {html_select_time}
+ *          (Smarty online manual)
+ * @author Roberto Berto <roberto@berto.net>
+ * @credits Monte Ohrt <monte AT ohrt DOT com>
+ * @param array
+ * @param Smarty
+ * @return string
+ * @uses smarty_make_timestamp()
+ */
+function smarty_function_html_select_time($params, &$smarty)
+{
+    require_once $smarty->_get_plugin_filepath('shared','make_timestamp');
+    require_once $smarty->_get_plugin_filepath('function','html_options');
+    /* Default values. */
+    $prefix             = "Time_";
+    $time               = time();
+    $display_hours      = true;
+    $display_minutes    = true;
+    $display_seconds    = true;
+    $display_meridian   = true;
+    $use_24_hours       = true;
+    $minute_interval    = 1;
+    $second_interval    = 1;
+    /* Should the select boxes be part of an array when returned from PHP?
+       e.g. setting it to "birthday", would create "birthday[Hour]",
+       "birthday[Minute]", "birthday[Seconds]" & "birthday[Meridian]".
+       Can be combined with prefix. */
+    $field_array        = null;
+    $all_extra          = null;
+    $hour_extra         = null;
+    $minute_extra       = null;
+    $second_extra       = null;
+    $meridian_extra     = null;
+
+    foreach ($params as $_key=>$_value) {
+        switch ($_key) {
+            case 'prefix':
+            case 'time':
+            case 'field_array':
+            case 'all_extra':
+            case 'hour_extra':
+            case 'minute_extra':
+            case 'second_extra':
+            case 'meridian_extra':
+                $$_key = (string)$_value;
+                break;
+
+            case 'display_hours':
+            case 'display_minutes':
+            case 'display_seconds':
+            case 'display_meridian':
+            case 'use_24_hours':
+                $$_key = (bool)$_value;
+                break;
+
+            case 'minute_interval':
+            case 'second_interval':
+                $$_key = (int)$_value;
+                break;
+
+            default:
+                $smarty->trigger_error("[html_select_time] unknown parameter $_key", E_USER_WARNING);
+        }
+    }
+
+    $time = smarty_make_timestamp($time);
+
+    $html_result = '';
+
+    if ($display_hours) {
+        $hours       = $use_24_hours ? range(0, 23) : range(1, 12);
+        $hour_fmt = $use_24_hours ? '%H' : '%I';
+        for ($i = 0, $for_max = count($hours); $i < $for_max; $i++)
+            $hours[$i] = sprintf('%02d', $hours[$i]);
+        $html_result .= '<select name=';
+        if (null !== $field_array) {
+            $html_result .= '"' . $field_array . '[' . $prefix . 'Hour]"';
+        } else {
+            $html_result .= '"' . $prefix . 'Hour"';
+        }
+        if (null !== $hour_extra){
+            $html_result .= ' ' . $hour_extra;
+        }
+        if (null !== $all_extra){
+            $html_result .= ' ' . $all_extra;
+        }
+        $html_result .= '>'."\n";
+        $html_result .= smarty_function_html_options(array('output'          => $hours,
+                                                           'values'          => $hours,
+                                                           'selected'      => strftime($hour_fmt, $time),
+                                                           'print_result' => false),
+                                                     $smarty);
+        $html_result .= "</select>\n";
+    }
+
+    if ($display_minutes) {
+        $all_minutes = range(0, 59);
+        for ($i = 0, $for_max = count($all_minutes); $i < $for_max; $i+= $minute_interval)
+            $minutes[] = sprintf('%02d', $all_minutes[$i]);
+        $selected = intval(floor(strftime('%M', $time) / $minute_interval) * $minute_interval);
+        $html_result .= '<select name=';
+        if (null !== $field_array) {
+            $html_result .= '"' . $field_array . '[' . $prefix . 'Minute]"';
+        } else {
+            $html_result .= '"' . $prefix . 'Minute"';
+        }
+        if (null !== $minute_extra){
+            $html_result .= ' ' . $minute_extra;
+        }
+        if (null !== $all_extra){
+            $html_result .= ' ' . $all_extra;
+        }
+        $html_result .= '>'."\n";
+        
+        $html_result .= smarty_function_html_options(array('output'          => $minutes,
+                                                           'values'          => $minutes,
+                                                           'selected'      => $selected,
+                                                           'print_result' => false),
+                                                     $smarty);
+        $html_result .= "</select>\n";
+    }
+
+    if ($display_seconds) {
+        $all_seconds = range(0, 59);
+        for ($i = 0, $for_max = count($all_seconds); $i < $for_max; $i+= $second_interval)
+            $seconds[] = sprintf('%02d', $all_seconds[$i]);
+        $selected = intval(floor(strftime('%S', $time) / $second_interval) * $second_interval);
+        $html_result .= '<select name=';
+        if (null !== $field_array) {
+            $html_result .= '"' . $field_array . '[' . $prefix . 'Second]"';
+        } else {
+            $html_result .= '"' . $prefix . 'Second"';
+        }
+        
+        if (null !== $second_extra){
+            $html_result .= ' ' . $second_extra;
+        }
+        if (null !== $all_extra){
+            $html_result .= ' ' . $all_extra;
+        }
+        $html_result .= '>'."\n";
+        
+        $html_result .= smarty_function_html_options(array('output'          => $seconds,
+                                                           'values'          => $seconds,
+                                                           'selected'      => $selected,
+                                                           'print_result' => false),
+                                                     $smarty);
+        $html_result .= "</select>\n";
+    }
+
+    if ($display_meridian && !$use_24_hours) {
+        $html_result .= '<select name=';
+        if (null !== $field_array) {
+            $html_result .= '"' . $field_array . '[' . $prefix . 'Meridian]"';
+        } else {
+            $html_result .= '"' . $prefix . 'Meridian"';
+        }
+        
+        if (null !== $meridian_extra){
+            $html_result .= ' ' . $meridian_extra;
+        }
+        if (null !== $all_extra){
+            $html_result .= ' ' . $all_extra;
+        }
+        $html_result .= '>'."\n";
+        
+        $html_result .= smarty_function_html_options(array('output'          => array('AM', 'PM'),
+                                                           'values'          => array('am', 'pm'),
+                                                           'selected'      => strtolower(strftime('%p', $time)),
+                                                           'print_result' => false),
+                                                     $smarty);
+        $html_result .= "</select>\n";
+    }
+
+    return $html_result;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.html_table.php b/epgrec/Smarty.v2/plugins/function.html_table.php
--- a/epgrec/Smarty.v2/plugins/function.html_table.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.html_table.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,177 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {html_table} function plugin
+ *
+ * Type:     function<br>
+ * Name:     html_table<br>
+ * Date:     Feb 17, 2003<br>
+ * Purpose:  make an html table from an array of data<br>
+ * Input:<br>
+ *         - loop = array to loop through
+ *         - cols = number of columns, comma separated list of column names
+ *                  or array of column names
+ *         - rows = number of rows
+ *         - table_attr = table attributes
+ *         - th_attr = table heading attributes (arrays are cycled)
+ *         - tr_attr = table row attributes (arrays are cycled)
+ *         - td_attr = table cell attributes (arrays are cycled)
+ *         - trailpad = value to pad trailing cells with
+ *         - caption = text for caption element 
+ *         - vdir = vertical direction (default: "down", means top-to-bottom)
+ *         - hdir = horizontal direction (default: "right", means left-to-right)
+ *         - inner = inner loop (default "cols": print $loop line by line,
+ *                   $loop will be printed column by column otherwise)
+ *
+ *
+ * Examples:
+ * <pre>
+ * {table loop=$data}
+ * {table loop=$data cols=4 tr_attr='"bgcolor=red"'}
+ * {table loop=$data cols="first,second,third" tr_attr=$colors}
+ * </pre>
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @author credit to Messju Mohr <messju at lammfellpuschen dot de>
+ * @author credit to boots <boots dot smarty at yahoo dot com>
+ * @version  1.1
+ * @link http://smarty.php.net/manual/en/language.function.html.table.php {html_table}
+ *          (Smarty online manual)
+ * @param array
+ * @param Smarty
+ * @return string
+ */
+function smarty_function_html_table($params, &$smarty)
+{
+    $table_attr = 'border="1"';
+    $tr_attr = '';
+    $th_attr = '';
+    $td_attr = '';
+    $cols = $cols_count = 3;
+    $rows = 3;
+    $trailpad = '&nbsp;';
+    $vdir = 'down';
+    $hdir = 'right';
+    $inner = 'cols';
+    $caption = '';
+
+    if (!isset($params['loop'])) {
+        $smarty->trigger_error("html_table: missing 'loop' parameter");
+        return;
+    }
+
+    foreach ($params as $_key=>$_value) {
+        switch ($_key) {
+            case 'loop':
+                $$_key = (array)$_value;
+                break;
+
+            case 'cols':
+                if (is_array($_value) && !empty($_value)) {
+                    $cols = $_value;
+                    $cols_count = count($_value);
+                } elseif (!is_numeric($_value) && is_string($_value) && !empty($_value)) {
+                    $cols = explode(',', $_value);
+                    $cols_count = count($cols);
+                } elseif (!empty($_value)) {
+                    $cols_count = (int)$_value;
+                } else {
+                    $cols_count = $cols;
+                }
+                break;
+
+            case 'rows':
+                $$_key = (int)$_value;
+                break;
+
+            case 'table_attr':
+            case 'trailpad':
+            case 'hdir':
+            case 'vdir':
+            case 'inner':
+            case 'caption':
+                $$_key = (string)$_value;
+                break;
+
+            case 'tr_attr':
+            case 'td_attr':
+            case 'th_attr':
+                $$_key = $_value;
+                break;
+        }
+    }
+
+    $loop_count = count($loop);
+    if (empty($params['rows'])) {
+        /* no rows specified */
+        $rows = ceil($loop_count/$cols_count);
+    } elseif (empty($params['cols'])) {
+        if (!empty($params['rows'])) {
+            /* no cols specified, but rows */
+            $cols_count = ceil($loop_count/$rows);
+        }
+    }
+
+    $output = "<table $table_attr>\n";
+
+    if (!empty($caption)) {
+        $output .= '<caption>' . $caption . "</caption>\n";
+    }
+
+    if (is_array($cols)) {
+        $cols = ($hdir == 'right') ? $cols : array_reverse($cols);
+        $output .= "<thead><tr>\n";
+
+        for ($r=0; $r<$cols_count; $r++) {
+            $output .= '<th' . smarty_function_html_table_cycle('th', $th_attr, $r) . '>';
+            $output .= $cols[$r];
+            $output .= "</th>\n";
+        }
+        $output .= "</tr></thead>\n";
+    }
+
+    $output .= "<tbody>\n";
+    for ($r=0; $r<$rows; $r++) {
+        $output .= "<tr" . smarty_function_html_table_cycle('tr', $tr_attr, $r) . ">\n";
+        $rx =  ($vdir == 'down') ? $r*$cols_count : ($rows-1-$r)*$cols_count;
+
+        for ($c=0; $c<$cols_count; $c++) {
+            $x =  ($hdir == 'right') ? $rx+$c : $rx+$cols_count-1-$c;
+            if ($inner!='cols') {
+                /* shuffle x to loop over rows*/
+                $x = floor($x/$cols_count) + ($x%$cols_count)*$rows;
+            }
+
+            if ($x<$loop_count) {
+                $output .= "<td" . smarty_function_html_table_cycle('td', $td_attr, $c) . ">" . $loop[$x] . "</td>\n";
+            } else {
+                $output .= "<td" . smarty_function_html_table_cycle('td', $td_attr, $c) . ">$trailpad</td>\n";
+            }
+        }
+        $output .= "</tr>\n";
+    }
+    $output .= "</tbody>\n";
+    $output .= "</table>\n";
+    
+    return $output;
+}
+
+function smarty_function_html_table_cycle($name, $var, $no) {
+    if(!is_array($var)) {
+        $ret = $var;
+    } else {
+        $ret = $var[$no % count($var)];
+    }
+    
+    return ($ret) ? ' '.$ret : '';
+}
+
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.mailto.php b/epgrec/Smarty.v2/plugins/function.mailto.php
--- a/epgrec/Smarty.v2/plugins/function.mailto.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.mailto.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,165 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {mailto} function plugin
+ *
+ * Type:     function<br>
+ * Name:     mailto<br>
+ * Date:     May 21, 2002
+ * Purpose:  automate mailto address link creation, and optionally
+ *           encode them.<br>
+ * Input:<br>
+ *         - address = e-mail address
+ *         - text = (optional) text to display, default is address
+ *         - encode = (optional) can be one of:
+ *                * none : no encoding (default)
+ *                * javascript : encode with javascript
+ *                * javascript_charcode : encode with javascript charcode
+ *                * hex : encode with hexidecimal (no javascript)
+ *         - cc = (optional) address(es) to carbon copy
+ *         - bcc = (optional) address(es) to blind carbon copy
+ *         - subject = (optional) e-mail subject
+ *         - newsgroups = (optional) newsgroup(s) to post to
+ *         - followupto = (optional) address(es) to follow up to
+ *         - extra = (optional) extra tags for the href link
+ *
+ * Examples:
+ * <pre>
+ * {mailto address="me@domain.com"}
+ * {mailto address="me@domain.com" encode="javascript"}
+ * {mailto address="me@domain.com" encode="hex"}
+ * {mailto address="me@domain.com" subject="Hello to you!"}
+ * {mailto address="me@domain.com" cc="you@domain.com,they@domain.com"}
+ * {mailto address="me@domain.com" extra='class="mailto"'}
+ * </pre>
+ * @link http://smarty.php.net/manual/en/language.function.mailto.php {mailto}
+ *          (Smarty online manual)
+ * @version  1.2
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @author   credits to Jason Sweat (added cc, bcc and subject functionality)
+ * @param    array
+ * @param    Smarty
+ * @return   string
+ */
+function smarty_function_mailto($params, &$smarty)
+{
+    $extra = '';
+
+    if (empty($params['address'])) {
+        $smarty->trigger_error("mailto: missing 'address' parameter");
+        return;
+    } else {
+        $address = $params['address'];
+    }
+
+    $text = $address;
+
+    // netscape and mozilla do not decode %40 (@) in BCC field (bug?)
+    // so, don't encode it.
+    $search = array('%40', '%2C');
+    $replace  = array('@', ',');
+    $mail_parms = array();
+    foreach ($params as $var=>$value) {
+        switch ($var) {
+            case 'cc':
+            case 'bcc':
+            case 'followupto':
+                if (!empty($value))
+                    $mail_parms[] = $var.'='.str_replace($search,$replace,rawurlencode($value));
+                break;
+                
+            case 'subject':
+            case 'newsgroups':
+                $mail_parms[] = $var.'='.rawurlencode($value);
+                break;
+
+            case 'extra':
+            case 'text':
+                $$var = $value;
+
+            default:
+        }
+    }
+
+    $mail_parm_vals = '';
+    for ($i=0; $i<count($mail_parms); $i++) {
+        $mail_parm_vals .= (0==$i) ? '?' : '&';
+        $mail_parm_vals .= $mail_parms[$i];
+    }
+    $address .= $mail_parm_vals;
+
+    $encode = (empty($params['encode'])) ? 'none' : $params['encode'];
+    if (!in_array($encode,array('javascript','javascript_charcode','hex','none')) ) {
+        $smarty->trigger_error("mailto: 'encode' parameter must be none, javascript or hex");
+        return;
+    }
+
+    if ($encode == 'javascript' ) {
+        $string = 'document.write(\'<a href="mailto:'.$address.'" '.$extra.'>'.$text.'</a>\');';
+
+        $js_encode = '';
+        for ($x=0; $x < strlen($string); $x++) {
+            $js_encode .= '%' . bin2hex($string[$x]);
+        }
+
+        return '<script type="text/javascript">eval(unescape(\''.$js_encode.'\'))</script>';
+
+    } elseif ($encode == 'javascript_charcode' ) {
+        $string = '<a href="mailto:'.$address.'" '.$extra.'>'.$text.'</a>';
+
+        for($x = 0, $y = strlen($string); $x < $y; $x++ ) {
+            $ord[] = ord($string[$x]);   
+        }
+
+        $_ret = "<script type=\"text/javascript\" language=\"javascript\">\n";
+        $_ret .= "<!--\n";
+        $_ret .= "{document.write(String.fromCharCode(";
+        $_ret .= implode(',',$ord);
+        $_ret .= "))";
+        $_ret .= "}\n";
+        $_ret .= "//-->\n";
+        $_ret .= "</script>\n";
+        
+        return $_ret;
+        
+        
+    } elseif ($encode == 'hex') {
+
+        preg_match('!^(.*)(\?.*)$!',$address,$match);
+        if(!empty($match[2])) {
+            $smarty->trigger_error("mailto: hex encoding does not work with extra attributes. Try javascript.");
+            return;
+        }
+        $address_encode = '';
+        for ($x=0; $x < strlen($address); $x++) {
+            if(preg_match('!\w!',$address[$x])) {
+                $address_encode .= '%' . bin2hex($address[$x]);
+            } else {
+                $address_encode .= $address[$x];
+            }
+        }
+        $text_encode = '';
+        for ($x=0; $x < strlen($text); $x++) {
+            $text_encode .= '&#x' . bin2hex($text[$x]).';';
+        }
+
+        $mailto = "&#109;&#97;&#105;&#108;&#116;&#111;&#58;";
+        return '<a href="'.$mailto.$address_encode.'" '.$extra.'>'.$text_encode.'</a>';
+
+    } else {
+        // no encoding
+        return '<a href="mailto:'.$address.'" '.$extra.'>'.$text.'</a>';
+
+    }
+
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.math.php b/epgrec/Smarty.v2/plugins/function.math.php
--- a/epgrec/Smarty.v2/plugins/function.math.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.math.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,85 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {math} function plugin
+ *
+ * Type:     function<br>
+ * Name:     math<br>
+ * Purpose:  handle math computations in template<br>
+ * @link http://smarty.php.net/manual/en/language.function.math.php {math}
+ *          (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param array
+ * @param Smarty
+ * @return string
+ */
+function smarty_function_math($params, &$smarty)
+{
+    // be sure equation parameter is present
+    if (empty($params['equation'])) {
+        $smarty->trigger_error("math: missing equation parameter");
+        return;
+    }
+
+    // strip out backticks, not necessary for math
+    $equation = str_replace('`','',$params['equation']);
+
+    // make sure parenthesis are balanced
+    if (substr_count($equation,"(") != substr_count($equation,")")) {
+        $smarty->trigger_error("math: unbalanced parenthesis");
+        return;
+    }
+
+    // match all vars in equation, make sure all are passed
+    preg_match_all("!(?:0x[a-fA-F0-9]+)|([a-zA-Z][a-zA-Z0-9_]*)!",$equation, $match);
+    $allowed_funcs = array('int','abs','ceil','cos','exp','floor','log','log10',
+                           'max','min','pi','pow','rand','round','sin','sqrt','srand','tan');
+    
+    foreach($match[1] as $curr_var) {
+        if ($curr_var && !in_array($curr_var, array_keys($params)) && !in_array($curr_var, $allowed_funcs)) {
+            $smarty->trigger_error("math: function call $curr_var not allowed");
+            return;
+        }
+    }
+
+    foreach($params as $key => $val) {
+        if ($key != "equation" && $key != "format" && $key != "assign") {
+            // make sure value is not empty
+            if (strlen($val)==0) {
+                $smarty->trigger_error("math: parameter $key is empty");
+                return;
+            }
+            if (!is_numeric($val)) {
+                $smarty->trigger_error("math: parameter $key: is not numeric");
+                return;
+            }
+            $equation = preg_replace("/\b$key\b/", " \$params['$key'] ", $equation);
+        }
+    }
+
+    eval("\$smarty_math_result = ".$equation.";");
+
+    if (empty($params['format'])) {
+        if (empty($params['assign'])) {
+            return $smarty_math_result;
+        } else {
+            $smarty->assign($params['assign'],$smarty_math_result);
+        }
+    } else {
+        if (empty($params['assign'])){
+            printf($params['format'],$smarty_math_result);
+        } else {
+            $smarty->assign($params['assign'],sprintf($params['format'],$smarty_math_result));
+        }
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
\ 
diff -urN a/epgrec/Smarty.v2/plugins/function.popup.php b/epgrec/Smarty.v2/plugins/function.popup.php
--- a/epgrec/Smarty.v2/plugins/function.popup.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.popup.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,119 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {popup} function plugin
+ *
+ * Type:     function<br>
+ * Name:     popup<br>
+ * Purpose:  make text pop up in windows via overlib
+ * @link http://smarty.php.net/manual/en/language.function.popup.php {popup}
+ *          (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param array
+ * @param Smarty
+ * @return string
+ */
+function smarty_function_popup($params, &$smarty)
+{
+    $append = '';
+    foreach ($params as $_key=>$_value) {
+        switch ($_key) {
+            case 'text':
+            case 'trigger':
+            case 'function':
+            case 'inarray':
+                $$_key = (string)$_value;
+                if ($_key == 'function' || $_key == 'inarray')
+                    $append .= ',' . strtoupper($_key) . ",'$_value'";
+                break;
+
+            case 'caption':
+            case 'closetext':
+            case 'status':
+                $append .= ',' . strtoupper($_key) . ",'" . str_replace("'","\'",$_value) . "'";
+                break;
+
+            case 'fgcolor':
+            case 'bgcolor':
+            case 'textcolor':
+            case 'capcolor':
+            case 'closecolor':
+            case 'textfont':
+            case 'captionfont':
+            case 'closefont':
+            case 'fgbackground':
+            case 'bgbackground':
+            case 'caparray':
+            case 'capicon':
+            case 'background':
+            case 'frame':
+                $append .= ',' . strtoupper($_key) . ",'$_value'";
+                break;
+
+            case 'textsize':
+            case 'captionsize':
+            case 'closesize':
+            case 'width':
+            case 'height':
+            case 'border':
+            case 'offsetx':
+            case 'offsety':
+            case 'snapx':
+            case 'snapy':
+            case 'fixx':
+            case 'fixy':
+            case 'padx':
+            case 'pady':
+            case 'timeout':
+            case 'delay':
+                $append .= ',' . strtoupper($_key) . ",$_value";
+                break;
+
+            case 'sticky':
+            case 'left':
+            case 'right':
+            case 'center':
+            case 'above':
+            case 'below':
+            case 'noclose':
+            case 'autostatus':
+            case 'autostatuscap':
+            case 'fullhtml':
+            case 'hauto':
+            case 'vauto':
+            case 'mouseoff':
+            case 'followmouse':
+            case 'closeclick':
+                if ($_value) $append .= ',' . strtoupper($_key);
+                break;
+
+            default:
+                $smarty->trigger_error("[popup] unknown parameter $_key", E_USER_WARNING);
+        }
+    }
+
+    if (empty($text) && !isset($inarray) && empty($function)) {
+        $smarty->trigger_error("overlib: attribute 'text' or 'inarray' or 'function' required");
+        return false;
+    }
+
+    if (empty($trigger)) { $trigger = "onmouseover"; }
+
+    $retval = $trigger . '="return overlib(\''.preg_replace(array("!'!","![\r\n]!"),array("\'",'\r'),$text).'\'';
+    $retval .= $append . ');"';
+    if ($trigger == 'onmouseover')
+       $retval .= ' onmouseout="nd();"';
+
+
+    return $retval;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/function.popup_init.php b/epgrec/Smarty.v2/plugins/function.popup_init.php
--- a/epgrec/Smarty.v2/plugins/function.popup_init.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/function.popup_init.php	2022-12-13 18:30:29.452561000 +0900
@@ -0,0 +1,40 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty {popup_init} function plugin
+ *
+ * Type:     function<br>
+ * Name:     popup_init<br>
+ * Purpose:  initialize overlib
+ * @link http://smarty.php.net/manual/en/language.function.popup.init.php {popup_init}
+ *          (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param array
+ * @param Smarty
+ * @return string
+ */
+function smarty_function_popup_init($params, &$smarty)
+{
+    $zindex = 1000;
+    
+    if (!empty($params['zindex'])) {
+        $zindex = $params['zindex'];
+    }
+    
+    if (!empty($params['src'])) {
+        return '<div id="overDiv" style="position:absolute; visibility:hidden; z-index:'.$zindex.';"></div>' . "\n"
+         . '<script type="text/javascript" language="JavaScript" src="'.$params['src'].'"></script>' . "\n";
+    } else {
+        $smarty->trigger_error("popup_init: missing src parameter");
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.capitalize.php b/epgrec/Smarty.v2/plugins/modifier.capitalize.php
--- a/epgrec/Smarty.v2/plugins/modifier.capitalize.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.capitalize.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,43 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty capitalize modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     capitalize<br>
+ * Purpose:  capitalize words in the string
+ * @link http://smarty.php.net/manual/en/language.modifiers.php#LANGUAGE.MODIFIER.CAPITALIZE
+ *      capitalize (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return string
+ */
+function smarty_modifier_capitalize($string, $uc_digits = false)
+{
+    smarty_modifier_capitalize_ucfirst(null, $uc_digits);
+    return preg_replace_callback('!\'?\b\w(\w|\')*\b!', 'smarty_modifier_capitalize_ucfirst', $string);
+}
+
+function smarty_modifier_capitalize_ucfirst($string, $uc_digits = null)
+{
+    static $_uc_digits = false;
+    
+    if(isset($uc_digits)) {
+        $_uc_digits = $uc_digits;
+        return;
+    }
+    
+    if(substr($string[0],0,1) != "'" && !preg_match("!\d!",$string[0]) || $_uc_digits)
+        return ucfirst($string[0]);
+    else
+        return $string[0];
+}
+
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.cat.php b/epgrec/Smarty.v2/plugins/modifier.cat.php
--- a/epgrec/Smarty.v2/plugins/modifier.cat.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.cat.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,33 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty cat modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     cat<br>
+ * Date:     Feb 24, 2003
+ * Purpose:  catenate a value to a variable
+ * Input:    string to catenate
+ * Example:  {$var|cat:"foo"}
+ * @link http://smarty.php.net/manual/en/language.modifier.cat.php cat
+ *          (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @version 1.0
+ * @param string
+ * @param string
+ * @return string
+ */
+function smarty_modifier_cat($string, $cat)
+{
+    return $string . $cat;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.count_characters.php b/epgrec/Smarty.v2/plugins/modifier.count_characters.php
--- a/epgrec/Smarty.v2/plugins/modifier.count_characters.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.count_characters.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,32 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty count_characters modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     count_characteres<br>
+ * Purpose:  count the number of characters in a text
+ * @link http://smarty.php.net/manual/en/language.modifier.count.characters.php
+ *          count_characters (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param boolean include whitespace in the character count
+ * @return integer
+ */
+function smarty_modifier_count_characters($string, $include_spaces = false)
+{
+    if ($include_spaces)
+       return(strlen($string));
+
+    return preg_match_all("/[^\s]/",$string, $match);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.count_paragraphs.php b/epgrec/Smarty.v2/plugins/modifier.count_paragraphs.php
--- a/epgrec/Smarty.v2/plugins/modifier.count_paragraphs.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.count_paragraphs.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,29 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty count_paragraphs modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     count_paragraphs<br>
+ * Purpose:  count the number of paragraphs in a text
+ * @link http://smarty.php.net/manual/en/language.modifier.count.paragraphs.php
+ *          count_paragraphs (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return integer
+ */
+function smarty_modifier_count_paragraphs($string)
+{
+    // count \r or \n characters
+    return count(preg_split('/[\r\n]+/', $string));
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.count_sentences.php b/epgrec/Smarty.v2/plugins/modifier.count_sentences.php
--- a/epgrec/Smarty.v2/plugins/modifier.count_sentences.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.count_sentences.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,29 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty count_sentences modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     count_sentences
+ * Purpose:  count the number of sentences in a text
+ * @link http://smarty.php.net/manual/en/language.modifier.count.paragraphs.php
+ *          count_sentences (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return integer
+ */
+function smarty_modifier_count_sentences($string)
+{
+    // find periods with a word before but not after.
+    return preg_match_all('/[^\s]\.(?!\w)/', $string, $match);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.count_words.php b/epgrec/Smarty.v2/plugins/modifier.count_words.php
--- a/epgrec/Smarty.v2/plugins/modifier.count_words.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.count_words.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,33 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty count_words modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     count_words<br>
+ * Purpose:  count the number of words in a text
+ * @link http://smarty.php.net/manual/en/language.modifier.count.words.php
+ *          count_words (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return integer
+ */
+function smarty_modifier_count_words($string)
+{
+    // split text by ' ',\r,\n,\f,\t
+    $split_array = preg_split('/\s+/',$string);
+    // count matches that contain alphanumerics
+    $word_count = preg_grep('/[a-zA-Z0-9\\x80-\\xff]/', $split_array);
+
+    return count($word_count);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.date_format.php b/epgrec/Smarty.v2/plugins/modifier.date_format.php
--- a/epgrec/Smarty.v2/plugins/modifier.date_format.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.date_format.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,58 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Include the {@link shared.make_timestamp.php} plugin
+ */
+require_once $smarty->_get_plugin_filepath('shared', 'make_timestamp');
+/**
+ * Smarty date_format modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     date_format<br>
+ * Purpose:  format datestamps via strftime<br>
+ * Input:<br>
+ *         - string: input date string
+ *         - format: strftime format for output
+ *         - default_date: default date if $string is empty
+ * @link http://smarty.php.net/manual/en/language.modifier.date.format.php
+ *          date_format (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param string
+ * @param string
+ * @return string|void
+ * @uses smarty_make_timestamp()
+ */
+function smarty_modifier_date_format($string, $format = '%b %e, %Y', $default_date = '')
+{
+    if ($string != '') {
+        $timestamp = smarty_make_timestamp($string);
+    } elseif ($default_date != '') {
+        $timestamp = smarty_make_timestamp($default_date);
+    } else {
+        return;
+    }
+    if (DIRECTORY_SEPARATOR == '\\') {
+        $_win_from = array('%D',       '%h', '%n', '%r',          '%R',    '%t', '%T');
+        $_win_to   = array('%m/%d/%y', '%b', "\n", '%I:%M:%S %p', '%H:%M', "\t", '%H:%M:%S');
+        if (strpos($format, '%e') !== false) {
+            $_win_from[] = '%e';
+            $_win_to[]   = sprintf('%\' 2d', date('j', $timestamp));
+        }
+        if (strpos($format, '%l') !== false) {
+            $_win_from[] = '%l';
+            $_win_to[]   = sprintf('%\' 2d', date('h', $timestamp));
+        }
+        $format = str_replace($_win_from, $_win_to, $format);
+    }
+    return strftime($format, $timestamp);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.debug_print_var.php b/epgrec/Smarty.v2/plugins/modifier.debug_print_var.php
--- a/epgrec/Smarty.v2/plugins/modifier.debug_print_var.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.debug_print_var.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,90 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty debug_print_var modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     debug_print_var<br>
+ * Purpose:  formats variable contents for display in the console
+ * @link http://smarty.php.net/manual/en/language.modifier.debug.print.var.php
+ *          debug_print_var (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param array|object
+ * @param integer
+ * @param integer
+ * @return string
+ */
+function smarty_modifier_debug_print_var($var, $depth = 0, $length = 40)
+{
+    $_replace = array(
+        "\n" => '<i>\n</i>',
+        "\r" => '<i>\r</i>',
+        "\t" => '<i>\t</i>'
+    );
+
+    switch (gettype($var)) {
+        case 'array' :
+            $results = '<b>Array (' . count($var) . ')</b>';
+            foreach ($var as $curr_key => $curr_val) {
+                $results .= '<br>' . str_repeat('&nbsp;', $depth * 2)
+                    . '<b>' . strtr($curr_key, $_replace) . '</b> =&gt; '
+                    . smarty_modifier_debug_print_var($curr_val, ++$depth, $length);
+                    $depth--;
+            }
+            break;
+        case 'object' :
+            $object_vars = get_object_vars($var);
+            $results = '<b>' . get_class($var) . ' Object (' . count($object_vars) . ')</b>';
+            foreach ($object_vars as $curr_key => $curr_val) {
+                $results .= '<br>' . str_repeat('&nbsp;', $depth * 2)
+                    . '<b> -&gt;' . strtr($curr_key, $_replace) . '</b> = '
+                    . smarty_modifier_debug_print_var($curr_val, ++$depth, $length);
+                    $depth--;
+            }
+            break;
+        case 'boolean' :
+        case 'NULL' :
+        case 'resource' :
+            if (true === $var) {
+                $results = 'true';
+            } elseif (false === $var) {
+                $results = 'false';
+            } elseif (null === $var) {
+                $results = 'null';
+            } else {
+                $results = htmlspecialchars((string) $var);
+            }
+            $results = '<i>' . $results . '</i>';
+            break;
+        case 'integer' :
+        case 'float' :
+            $results = htmlspecialchars((string) $var);
+            break;
+        case 'string' :
+            $results = strtr($var, $_replace);
+            if (strlen($var) > $length ) {
+                $results = substr($var, 0, $length - 3) . '...';
+            }
+            $results = htmlspecialchars('"' . $results . '"');
+            break;
+        case 'unknown type' :
+        default :
+            $results = strtr((string) $var, $_replace);
+            if (strlen($results) > $length ) {
+                $results = substr($results, 0, $length - 3) . '...';
+            }
+            $results = htmlspecialchars($results);
+    }
+
+    return $results;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.default.php b/epgrec/Smarty.v2/plugins/modifier.default.php
--- a/epgrec/Smarty.v2/plugins/modifier.default.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.default.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,32 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty default modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     default<br>
+ * Purpose:  designate default value for empty variables
+ * @link http://smarty.php.net/manual/en/language.modifier.default.php
+ *          default (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param string
+ * @return string
+ */
+function smarty_modifier_default($string, $default = '')
+{
+    if (!isset($string) || $string === '')
+        return $default;
+    else
+        return $string;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.escape.php b/epgrec/Smarty.v2/plugins/modifier.escape.php
--- a/epgrec/Smarty.v2/plugins/modifier.escape.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.escape.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,93 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty escape modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     escape<br>
+ * Purpose:  Escape the string according to escapement type
+ * @link http://smarty.php.net/manual/en/language.modifier.escape.php
+ *          escape (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param html|htmlall|url|quotes|hex|hexentity|javascript
+ * @return string
+ */
+function smarty_modifier_escape($string, $esc_type = 'html', $char_set = 'ISO-8859-1')
+{
+    switch ($esc_type) {
+        case 'html':
+            return htmlspecialchars($string, ENT_QUOTES, $char_set);
+
+        case 'htmlall':
+            return htmlentities($string, ENT_QUOTES, $char_set);
+
+        case 'url':
+            return rawurlencode($string);
+
+        case 'urlpathinfo':
+            return str_replace('%2F','/',rawurlencode($string));
+            
+        case 'quotes':
+            // escape unescaped single quotes
+            return preg_replace("%(?<!\\\\)'%", "\\'", $string);
+
+        case 'hex':
+            // escape every character into hex
+            $return = '';
+            for ($x=0; $x < strlen($string); $x++) {
+                $return .= '%' . bin2hex($string[$x]);
+            }
+            return $return;
+            
+        case 'hexentity':
+            $return = '';
+            for ($x=0; $x < strlen($string); $x++) {
+                $return .= '&#x' . bin2hex($string[$x]) . ';';
+            }
+            return $return;
+
+        case 'decentity':
+            $return = '';
+            for ($x=0; $x < strlen($string); $x++) {
+                $return .= '&#' . ord($string[$x]) . ';';
+            }
+            return $return;
+
+        case 'javascript':
+            // escape quotes and backslashes, newlines, etc.
+            return strtr($string, array('\\'=>'\\\\',"'"=>"\\'",'"'=>'\\"',"\r"=>'\\r',"\n"=>'\\n','</'=>'<\/'));
+            
+        case 'mail':
+            // safe way to display e-mail address on a web page
+            return str_replace(array('@', '.'),array(' [AT] ', ' [DOT] '), $string);
+            
+        case 'nonstd':
+           // escape non-standard chars, such as ms document quotes
+           $_res = '';
+           for($_i = 0, $_len = strlen($string); $_i < $_len; $_i++) {
+               $_ord = ord(substr($string, $_i, 1));
+               // non-standard char, escape it
+               if($_ord >= 126){
+                   $_res .= '&#' . $_ord . ';';
+               }
+               else {
+                   $_res .= substr($string, $_i, 1);
+               }
+           }
+           return $_res;
+
+        default:
+            return $string;
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.indent.php b/epgrec/Smarty.v2/plugins/modifier.indent.php
--- a/epgrec/Smarty.v2/plugins/modifier.indent.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.indent.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,28 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty indent modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     indent<br>
+ * Purpose:  indent lines of text
+ * @link http://smarty.php.net/manual/en/language.modifier.indent.php
+ *          indent (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param integer
+ * @param string
+ * @return string
+ */
+function smarty_modifier_indent($string,$chars=4,$char=" ")
+{
+    return preg_replace('!^!m',str_repeat($char,$chars),$string);
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.lower.php b/epgrec/Smarty.v2/plugins/modifier.lower.php
--- a/epgrec/Smarty.v2/plugins/modifier.lower.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.lower.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,26 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty lower modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     lower<br>
+ * Purpose:  convert string to lowercase
+ * @link http://smarty.php.net/manual/en/language.modifier.lower.php
+ *          lower (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return string
+ */
+function smarty_modifier_lower($string)
+{
+    return strtolower($string);
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.nl2br.php b/epgrec/Smarty.v2/plugins/modifier.nl2br.php
--- a/epgrec/Smarty.v2/plugins/modifier.nl2br.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.nl2br.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,35 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty plugin
+ *
+ * Type:     modifier<br>
+ * Name:     nl2br<br>
+ * Date:     Feb 26, 2003
+ * Purpose:  convert \r\n, \r or \n to <<br>>
+ * Input:<br>
+ *         - contents = contents to replace
+ *         - preceed_test = if true, includes preceeding break tags
+ *           in replacement
+ * Example:  {$text|nl2br}
+ * @link http://smarty.php.net/manual/en/language.modifier.nl2br.php
+ *          nl2br (Smarty online manual)
+ * @version  1.0
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return string
+ */
+function smarty_modifier_nl2br($string)
+{
+    return nl2br($string);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.regex_replace.php b/epgrec/Smarty.v2/plugins/modifier.regex_replace.php
--- a/epgrec/Smarty.v2/plugins/modifier.regex_replace.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.regex_replace.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,48 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty regex_replace modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     regex_replace<br>
+ * Purpose:  regular expression search/replace
+ * @link http://smarty.php.net/manual/en/language.modifier.regex.replace.php
+ *          regex_replace (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param string|array
+ * @param string|array
+ * @return string
+ */
+function smarty_modifier_regex_replace($string, $search, $replace)
+{
+    if(is_array($search)) {
+      foreach($search as $idx => $s)
+        $search[$idx] = _smarty_regex_replace_check($s);
+    } else {
+      $search = _smarty_regex_replace_check($search);
+    }       
+
+    return preg_replace($search, $replace, $string);
+}
+
+function _smarty_regex_replace_check($search)
+{
+    if (($pos = strpos($search,"\0")) !== false)
+      $search = substr($search,0,$pos);
+    if (preg_match('!([a-zA-Z\s]+)$!s', $search, $match) && (strpos($match[1], 'e') !== false)) {
+        /* remove eval-modifier from $search */
+        $search = substr($search, 0, -strlen($match[1])) . preg_replace('![e\s]+!', '', $match[1]);
+    }
+    return $search;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.replace.php b/epgrec/Smarty.v2/plugins/modifier.replace.php
--- a/epgrec/Smarty.v2/plugins/modifier.replace.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.replace.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,30 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty replace modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     replace<br>
+ * Purpose:  simple search/replace
+ * @link http://smarty.php.net/manual/en/language.modifier.replace.php
+ *          replace (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param string
+ * @param string
+ * @return string
+ */
+function smarty_modifier_replace($string, $search, $replace)
+{
+    return str_replace($search, $replace, $string);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.spacify.php b/epgrec/Smarty.v2/plugins/modifier.spacify.php
--- a/epgrec/Smarty.v2/plugins/modifier.spacify.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.spacify.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,30 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty spacify modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     spacify<br>
+ * Purpose:  add spaces between characters in a string
+ * @link http://smarty.php.net/manual/en/language.modifier.spacify.php
+ *          spacify (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param string
+ * @return string
+ */
+function smarty_modifier_spacify($string, $spacify_char = ' ')
+{
+    return implode($spacify_char,
+                   preg_split('//', $string, -1, PREG_SPLIT_NO_EMPTY));
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.string_format.php b/epgrec/Smarty.v2/plugins/modifier.string_format.php
--- a/epgrec/Smarty.v2/plugins/modifier.string_format.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.string_format.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,29 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty string_format modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     string_format<br>
+ * Purpose:  format strings via sprintf
+ * @link http://smarty.php.net/manual/en/language.modifier.string.format.php
+ *          string_format (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param string
+ * @return string
+ */
+function smarty_modifier_string_format($string, $format)
+{
+    return sprintf($format, $string);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.strip.php b/epgrec/Smarty.v2/plugins/modifier.strip.php
--- a/epgrec/Smarty.v2/plugins/modifier.strip.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.strip.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,33 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty strip modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     strip<br>
+ * Purpose:  Replace all repeated spaces, newlines, tabs
+ *           with a single space or supplied replacement string.<br>
+ * Example:  {$var|strip} {$var|strip:"&nbsp;"}
+ * Date:     September 25th, 2002
+ * @link http://smarty.php.net/manual/en/language.modifier.strip.php
+ *          strip (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @version  1.0
+ * @param string
+ * @param string
+ * @return string
+ */
+function smarty_modifier_strip($text, $replace = ' ')
+{
+    return preg_replace('!\s+!', $replace, $text);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.strip_tags.php b/epgrec/Smarty.v2/plugins/modifier.strip_tags.php
--- a/epgrec/Smarty.v2/plugins/modifier.strip_tags.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.strip_tags.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,32 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty strip_tags modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     strip_tags<br>
+ * Purpose:  strip html tags from text
+ * @link http://smarty.php.net/manual/en/language.modifier.strip.tags.php
+ *          strip_tags (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param boolean
+ * @return string
+ */
+function smarty_modifier_strip_tags($string, $replace_with_space = true)
+{
+    if ($replace_with_space)
+        return preg_replace('!<[^>]*?>!', ' ', $string);
+    else
+        return strip_tags($string);
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.truncate.php b/epgrec/Smarty.v2/plugins/modifier.truncate.php
--- a/epgrec/Smarty.v2/plugins/modifier.truncate.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.truncate.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,50 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty truncate modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     truncate<br>
+ * Purpose:  Truncate a string to a certain length if necessary,
+ *           optionally splitting in the middle of a word, and
+ *           appending the $etc string or inserting $etc into the middle.
+ * @link http://smarty.php.net/manual/en/language.modifier.truncate.php
+ *          truncate (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param integer
+ * @param string
+ * @param boolean
+ * @param boolean
+ * @return string
+ */
+function smarty_modifier_truncate($string, $length = 80, $etc = '...',
+                                  $break_words = false, $middle = false)
+{
+    if ($length == 0)
+        return '';
+
+    if (strlen($string) > $length) {
+        $length -= min($length, strlen($etc));
+        if (!$break_words && !$middle) {
+            $string = preg_replace('/\s+?(\S+)?$/', '', substr($string, 0, $length+1));
+        }
+        if(!$middle) {
+            return substr($string, 0, $length) . $etc;
+        } else {
+            return substr($string, 0, $length/2) . $etc . substr($string, -$length/2);
+        }
+    } else {
+        return $string;
+    }
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.upper.php b/epgrec/Smarty.v2/plugins/modifier.upper.php
--- a/epgrec/Smarty.v2/plugins/modifier.upper.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.upper.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,26 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty upper modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     upper<br>
+ * Purpose:  convert string to uppercase
+ * @link http://smarty.php.net/manual/en/language.modifier.upper.php
+ *          upper (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return string
+ */
+function smarty_modifier_upper($string)
+{
+    return strtoupper($string);
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/modifier.wordwrap.php b/epgrec/Smarty.v2/plugins/modifier.wordwrap.php
--- a/epgrec/Smarty.v2/plugins/modifier.wordwrap.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/modifier.wordwrap.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,29 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Smarty wordwrap modifier plugin
+ *
+ * Type:     modifier<br>
+ * Name:     wordwrap<br>
+ * Purpose:  wrap a string of text at a given length
+ * @link http://smarty.php.net/manual/en/language.modifier.wordwrap.php
+ *          wordwrap (Smarty online manual)
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @param integer
+ * @param string
+ * @param boolean
+ * @return string
+ */
+function smarty_modifier_wordwrap($string,$length=80,$break="\n",$cut=false)
+{
+    return wordwrap($string,$length,$break,$cut);
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/outputfilter.trimwhitespace.php b/epgrec/Smarty.v2/plugins/outputfilter.trimwhitespace.php
--- a/epgrec/Smarty.v2/plugins/outputfilter.trimwhitespace.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/outputfilter.trimwhitespace.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,75 @@
+<?php
+/**
+ * Smarty plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+/**
+ * Smarty trimwhitespace outputfilter plugin
+ *
+ * File:     outputfilter.trimwhitespace.php<br>
+ * Type:     outputfilter<br>
+ * Name:     trimwhitespace<br>
+ * Date:     Jan 25, 2003<br>
+ * Purpose:  trim leading white space and blank lines from
+ *           template source after it gets interpreted, cleaning
+ *           up code and saving bandwidth. Does not affect
+ *           <<PRE>></PRE> and <SCRIPT></SCRIPT> blocks.<br>
+ * Install:  Drop into the plugin directory, call
+ *           <code>$smarty->load_filter('output','trimwhitespace');</code>
+ *           from application.
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @author Contributions from Lars Noschinski <lars@usenet.noschinski.de>
+ * @version  1.3
+ * @param string
+ * @param Smarty
+ */
+function smarty_outputfilter_trimwhitespace($source, &$smarty)
+{
+    // Pull out the script blocks
+    preg_match_all("!<script[^>]*?>.*?</script>!is", $source, $match);
+    $_script_blocks = $match[0];
+    $source = preg_replace("!<script[^>]*?>.*?</script>!is",
+                           '@@@SMARTY:TRIM:SCRIPT@@@', $source);
+
+    // Pull out the pre blocks
+    preg_match_all("!<pre[^>]*?>.*?</pre>!is", $source, $match);
+    $_pre_blocks = $match[0];
+    $source = preg_replace("!<pre[^>]*?>.*?</pre>!is",
+                           '@@@SMARTY:TRIM:PRE@@@', $source);
+    
+    // Pull out the textarea blocks
+    preg_match_all("!<textarea[^>]*?>.*?</textarea>!is", $source, $match);
+    $_textarea_blocks = $match[0];
+    $source = preg_replace("!<textarea[^>]*?>.*?</textarea>!is",
+                           '@@@SMARTY:TRIM:TEXTAREA@@@', $source);
+
+    // remove all leading spaces, tabs and carriage returns NOT
+    // preceeded by a php close tag.
+    $source = trim(preg_replace('/((?<!\?>)\n)[\s]+/m', '\1', $source));
+
+    // replace textarea blocks
+    smarty_outputfilter_trimwhitespace_replace("@@@SMARTY:TRIM:TEXTAREA@@@",$_textarea_blocks, $source);
+
+    // replace pre blocks
+    smarty_outputfilter_trimwhitespace_replace("@@@SMARTY:TRIM:PRE@@@",$_pre_blocks, $source);
+
+    // replace script blocks
+    smarty_outputfilter_trimwhitespace_replace("@@@SMARTY:TRIM:SCRIPT@@@",$_script_blocks, $source);
+
+    return $source;
+}
+
+function smarty_outputfilter_trimwhitespace_replace($search_str, $replace, &$subject) {
+    $_len = strlen($search_str);
+    $_pos = 0;
+    for ($_i=0, $_count=count($replace); $_i<$_count; $_i++)
+        if (($_pos=strpos($subject, $search_str, $_pos))!==false)
+            $subject = substr_replace($subject, $replace[$_i], $_pos, $_len);
+        else
+            break;
+
+}
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/shared.escape_special_chars.php b/epgrec/Smarty.v2/plugins/shared.escape_special_chars.php
--- a/epgrec/Smarty.v2/plugins/shared.escape_special_chars.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/shared.escape_special_chars.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,31 @@
+<?php
+/**
+ * Smarty shared plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * escape_special_chars common function
+ *
+ * Function: smarty_function_escape_special_chars<br>
+ * Purpose:  used by other smarty functions to escape
+ *           special chars except for already escaped ones
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return string
+ */
+function smarty_function_escape_special_chars($string)
+{
+    if(!is_array($string)) {
+        $string = preg_replace('!&(#?\w+);!', '%%%SMARTY_START%%%\\1%%%SMARTY_END%%%', $string);
+        $string = htmlspecialchars($string);
+        $string = str_replace(array('%%%SMARTY_START%%%','%%%SMARTY_END%%%'), array('&',';'), $string);
+    }
+    return $string;
+}
+
+/* vim: set expandtab: */
+
+?>
diff -urN a/epgrec/Smarty.v2/plugins/shared.make_timestamp.php b/epgrec/Smarty.v2/plugins/shared.make_timestamp.php
--- a/epgrec/Smarty.v2/plugins/shared.make_timestamp.php	1970-01-01 09:00:00.000000000 +0900
+++ b/epgrec/Smarty.v2/plugins/shared.make_timestamp.php	2022-12-13 18:30:29.456561000 +0900
@@ -0,0 +1,46 @@
+<?php
+/**
+ * Smarty shared plugin
+ * @package Smarty
+ * @subpackage plugins
+ */
+
+
+/**
+ * Function: smarty_make_timestamp<br>
+ * Purpose:  used by other smarty functions to make a timestamp
+ *           from a string.
+ * @author   Monte Ohrt <monte at ohrt dot com>
+ * @param string
+ * @return string
+ */
+function smarty_make_timestamp($string)
+{
+    if(empty($string)) {
+        // use "now":
+        $time = time();
+
+    } elseif (preg_match('/^\d{14}$/', $string)) {
+        // it is mysql timestamp format of YYYYMMDDHHMMSS?            
+        $time = mktime(substr($string, 8, 2),substr($string, 10, 2),substr($string, 12, 2),
+                       substr($string, 4, 2),substr($string, 6, 2),substr($string, 0, 4));
+        
+    } elseif (is_numeric($string)) {
+        // it is a numeric string, we handle it as timestamp
+        $time = (int)$string;
+        
+    } else {
+        // strtotime should handle it
+        $time = strtotime($string);
+        if ($time == -1 || $time === false) {
+            // strtotime() was not able to parse $string, use "now":
+            $time = time();
+        }
+    }
+    return $time;
+
+}
+
+/* vim: set expandtab: */
+
+?>
